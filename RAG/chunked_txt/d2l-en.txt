Dive into Deep Learning
ASTON ZHANG, ZACHARY C. LIPTON, MU LI, AND ALEXANDER J. SMOLA
Contents 
Preface Installation Notation 1 Introduction 1.1 A Motivating Example 1.2 Key Components 1.3 Kinds of Machine Learning Problems 1.4 Roots 1.5 The Road to Deep Learning 1.6 Success Stories 1.7 The Essence of Deep Learning 1.8 Summary 1.9 Exercises 2 Preliminaries 2.1 Data Manipulation 2.1.1 Getting Started 2.1.2 Indexing and Slicing 2.1.3 Operations 2.1.4 Broadcasting 2.1.5 Saving Memory 2.1.6 Conversion to Other Python Objects 2.1.7 Summary 2.1.8 Exercises 2.2 Data Preprocessing 2.2.1 Reading the Dataset 2.2.2 Data Preparation 2.2.3 Conversion to the Tensor Format 2.2.4 Discussion 2.2.5 Exercises 2.3 Linear Algebra 2.3.1 Scalars page xxv xxxiv xxxvii 1 2 4 7 20 22 25 27 29 29 30 30 30 33 34 35 36 37 37 38 38 38 39 40 40 40 41 41
iii
2.3.2 Vectors 2.3.3 Matrices 2.3.4 Tensors 2.3.5 Basic Properties of Tensor Arithmetic 2.3.6 Reduction 2.3.7 Non-Reduction Sum 2.3.8 Dot Products 2.3.9 Matrix‚ÄìVector Products 2.3.10 Matrix‚ÄìMatrix Multiplication 2.3.11 Norms 2.3.12 Discussion 2.3.13 Exercises 2.4 Calculus 2.4.1 Derivatives and Differentiation 2.4.2 Visualization Utilities 2.4.3 Partial Derivatives and Gradients 2.4.4 Chain Rule 2.4.5 Discussion 2.4.6 Exercises 2.5 Automatic Differentiation 2.5.1 A Simple Function 2.5.2 Backward for Non-Scalar Variables 2.5.3 Detaching Computation 2.5.4 Gradients and Python Control Flow 2.5.5 Discussion 2.5.6 Exercises 2.6 Probability and Statistics 2.6.1 A Simple Example: Tossing Coins 2.6.2 A More Formal Treatment 2.6.3 Random Variables 2.6.4 Multiple Random Variables 2.6.5 An Example 2.6.6 Expectations 2.6.7 Discussion 2.6.8 Exercises 2.7 Documentation 2.7.1 Functions and Classes in a Module 2.7.2 Specific Functions and Classes 42 43 44 45 46 47 48 48 49 50 52 53 54 54 56 58 58 59 59 60 60 61 62 63 64 64 65 66 68 69 70 73 74 76 77 78 78 79 82
3 Linear Neural Networks for Regression
3.1
Linear Regression
3.1.1
Basics
3.1.2
Vectorization for Speed
3.1.3 The Normal Distribution and Squared Loss
3.1.4 Linear Regression as a Neural Network
iv
82
83
88
88
90
3.1.5 Summary 3.1.6 Exercises 3.2 Object-Oriented Design for Implementation 3.2.1 Utilities 3.2.2 Models 3.2.3 Data 3.2.4 Training 3.2.5 Summary 3.2.6 Exercises 3.3 Synthetic Regression Data 3.3.1 Generating the Dataset 3.3.2 Reading the Dataset 3.3.3 Concise Implementation of the Data Loader 3.3.4 Summary 3.3.5 Exercises 3.4 Linear Regression Implementation from Scratch 3.4.1 Defining the Model 3.4.2 Defining the Loss Function 3.4.3 Defining the Optimization Algorithm 3.4.4 Training 3.4.5 Summary 3.4.6 Exercises 3.5 Concise Implementation of Linear Regression 3.5.1 Defining the Model 3.5.2 Defining the Loss Function 3.5.3 Defining the Optimization Algorithm 3.5.4 Training 3.5.5 Summary 3.5.6 Exercises 3.6 Generalization 3.6.1 Training Error and Generalization Error 3.6.2 Underfitting or Overfitting? 3.6.3 Model Selection 3.6.4 Summary 3.6.5 Exercises 3.7 Weight Decay 3.7.1 Norms and Weight Decay 3.7.2 High-Dimensional Linear Regression 3.7.3 Implementation from Scratch 3.7.4 Concise Implementation 3.7.5 Summary 3.7.6 Exercises 91 92 93 94 96 97 97 98 98 99 99 100 101 102 102 103 103 104 104 105 107 107 108 109 109 110 110 111 111 112 113 115 116 117 117 118 119 120 121 122 124 124
4 Linear Neural Networks for ClassiÔ¨Åcation
4.1
Softmax Regression
v
125
125
4.1.1 Classification 4.1.2 Loss Function 4.1.3 Information Theory Basics 4.1.4 Summary and Discussion 4.1.5 Exercises 4.2 The Image Classification Dataset 4.2.1 Loading the Dataset 4.2.2 Reading a Minibatch 4.2.3 Visualization 4.2.4 Summary 4.2.5 Exercises 4.3 The Base Classification Model 4.3.1 The Classifier Class 4.3.2 Accuracy 4.3.3 Summary 4.3.4 Exercises 4.4 Softmax Regression Implementation from Scratch 4.4.1 The Softmax 4.4.2 The Model 4.4.3 The Cross-Entropy Loss 4.4.4 Training 4.4.5 Prediction 4.4.6 Summary 4.4.7 Exercises 4.5 Concise Implementation of Softmax Regression 4.5.1 Defining the Model 4.5.2 Softmax Revisited 4.5.3 Training 4.5.4 Summary 4.5.5 Exercises 4.6 Generalization in Classification 4.6.1 The Test Set 4.6.2 Test Set Reuse 4.6.3 Statistical Learning Theory 4.6.4 Summary 4.6.5 Exercises 4.7 Environment and Distribution Shift 4.7.1 Types of Distribution Shift 4.7.2 Examples of Distribution Shift 4.7.3 Correction of Distribution Shift 4.7.4 A Taxonomy of Learning Problems 4.7.5 Fairness, Accountability, and Transparency in Machine Learning 126 129 130 131 132 134 134 135 136 137 137 138 138 138 139 139 140 140 141 141 142 143 143 144 144 145 145 146 146 147 147 148 150 151 153 154 154 155 157 159 163 164
4.7.6
Summary
4.7.7
Exercises
vi
165
166
5.1 Multilayer Perceptrons 5.1.1 Hidden Layers 5.1.2 Activation Functions 5.1.3 Summary and Discussion 5.1.4 Exercises 5.2 Implementation of Multilayer Perceptrons 5.2.1 Implementation from Scratch 5.2.2 Concise Implementation 5.2.3 Summary 5.2.4 Exercises 5.3 Forward Propagation, Backward Propagation, and Computational Graphs 5.3.1 Forward Propagation 5.3.2 Computational Graph of Forward Propagation 5.3.3 Backpropagation 5.3.4 Training Neural Networks 5.3.5 Summary 5.3.6 Exercises 5.4 Numerical Stability and Initialization 5.4.1 Vanishing and Exploding Gradients 5.4.2 Parameter Initialization 5.4.3 Summary 5.4.4 Exercises 5.5 Generalization in Deep Learning 5.5.1 Revisiting Overfitting and Regularization 5.5.2 Inspiration from Nonparametrics 5.5.3 Early Stopping 5.5.4 Classical Regularization Methods for Deep Networks 5.5.5 Summary 5.5.6 Exercises 5.6 Dropout 5.6.1 Dropout in Practice 5.6.2 Implementation from Scratch 5.6.3 Concise Implementation 5.6.4 Summary 5.6.5 Exercises 5.7 Predicting House Prices on Kaggle 5.7.1 Downloading Data 5.7.2 Kaggle 5.7.3 Accessing and Reading the Dataset 5.7.4 Data Preprocessing 5.7.5 Error Measure 5.7.6 ùêæ-Fold Cross-Validation 167 167 167 171 174 175 176 176 177 178 179 180 180 181 181 183 183 183 184 184 187 188 189 189 190 191 192 193 193 194 194 195 196 197 198 198 199 199 200 201 201 203 204
5 Multilayer Perceptrons
5.7.7
Model Selection
5.7.8
Submitting Predictions on Kaggle
vii
204
205
5.7.9 Summary and Discussion 5.7.10 Exercises 6.1 Layers and Modules 6.1.1 A Custom Module 6.1.2 The Sequential Module 6.1.3 Executing Code in the Forward Propagation Method 6.1.4 Summary 6.1.5 Exercises 6.2 Parameter Management 6.2.1 Parameter Access 6.2.2 Tied Parameters 6.2.3 Summary 6.2.4 Exercises 6.3 Parameter Initialization 6.3.1 Built-in Initialization 6.3.2 Summary 6.3.3 Exercises 6.4 Lazy Initialization 6.4.1 Summary 6.4.2 Exercises 6.5 Custom Layers 6.5.1 Layers without Parameters 6.5.2 Layers with Parameters 6.5.3 Summary 6.5.4 Exercises 6.6 File I/O 6.6.1 Loading and Saving Tensors 6.6.2 Loading and Saving Model Parameters 6.6.3 Summary 6.6.4 Exercises 6.7 GPUs 6.7.1 Computing Devices 6.7.2 Tensors and GPUs 6.7.3 Neural Networks and GPUs 6.7.4 Summary 6.7.5 Exercises 7.1 From Fully Connected Layers to Convolutions 7.1.1 Invariance 206 206 207 207 209 211 211 213 213 213 214 215 216 216 216 217 219 219 219 220 221 221 221 222 223 223 223 224 225 226 226 226 227 228 230 231 231 233 234 234
6 Builders‚Äô Guide
7 Convolutional Neural Networks
7.1.2
Constraining the MLP
7.1.3
Convolutions
7.1.4
Channels
viii
235
237
238
7.5 Summary and Discussion 7.1.6 Exercises 7.2. Convolutions for Images 7.21 The Cross-Correlation Operation 7.2.2 Convolutional Layers 7.2.3 Object Edge Detection in Images 7.24 Learning a Kernel 7.2.5 Cross-Correlation and Convolution 7.2.6 Feature Map and Receptive Field 727 Summary 7.2.8 Exercises 7.3.bubuPadding and Stride 7.3.1 Padding 7.3.2 Stride 7.3.3 Summary and Discussion 7.3.4 Exercises 7.4 Multiple Input and Multiple Output Channels TAL Multiple Input Channels TA2 Multiple Output Channels 743 1 x 1 Convolutional Layer TAA Discussion TAS Exercises 7.5 Pooling 7.5.1 Maximum Pooling and Average Pooling 75.2 Padding and Stride 7.5.3 Multiple Channels 75.4 Summary 7.5.5 Exercises 7.6 Convolutional Neural Networks (LeNet) 7.6.1 LeNet 7.6.2 Training 7.6.3 Summary 7.6.4 Exercises Modern Convolutional Neural Networks 8.1 Deep Convolutional Neural Networks (AlexNet) 8.1.1 Representation Learning 8.1.2 AlexNet 8.1.3 Training 8.1.4 Discussion 8.1.5 Exercises 8.2 Networks Using Blocks (VGG) 8.2.1 VGG Blocks 239 239 240 240 242 242 244 245 245 246 247 247 248 250 251 251 252 252 253 255 256 256 257 258 260 261 261 262 262 263 265 266 266 268 269 270 273 276 276 277 278 279
8 Modern Convolutional Neural Networks
8.2.2
VGG Network
8.2.3
Training
ix
279
281
8.2.4 Summary 8.2.5 Exercises 8.3 Network in Network (NiN) 8.3.1 NiN Blocks 8.3.2 NiN Model 8.3.3 Training 8.3.4 Summary 8.3.5 Exercises 8.4 Multi-Branch Networks (GoogLeNet) 8.4.1 Inception Blocks 8.4.2 GoogLeNet Model 8.4.3 Training 8.4.4 Discussion 8.4.5 Exercises 8.5 Batch Normalization 8.5.1 Training Deep Networks 8.5.2 Batch Normalization Layers 8.5.3 Implementation from Scratch 8.5.4 LeNet with Batch Normalization 8.5.5 Concise Implementation 8.5.6 Discussion 8.5.7 Exercises 8.6 Residual Networks (ResNet) and ResNeXt 8.6.1 Function Classes 8.6.2 Residual Blocks 8.6.3 ResNet Model 8.6.4 Training 8.6.5 ResNeXt 8.6.6 Summary and Discussion 8.6.7 Exercises 8.7 Densely Connected Networks (DenseNet) 8.7.1 From ResNet to DenseNet 8.7.2 Dense Blocks 8.7.3 Transition Layers 8.7.4 DenseNet Model 8.7.5 Training 8.7.6 Summary and Discussion 8.7.7 Exercises 8.8 Designing Convolution Network Architectures 8.8.1 The AnyNet Design Space 8.8.2 Distributions and Parameters of Design Spaces 8.8.3 RegNet 282 282 283 283 284 285 286 286 287 287 288 291 291 292 292 293 295 297 298 299 300 301 302 302 304 306 308 308 310 311 312 312 313 314 315 315 316 316 317 318 320 322
8.8.4
Training
8.8.5
Discussion
8.8.6
Exercises
x
323
323
324
9.1 Working with Sequences 9.1.1 Autoregressive Models 9.1.2 Sequence Models 9.1.3 Training 9.1.4 Prediction 9.1.5 Summary 9.1.6 Exercises 9.2 Converting Raw Text into Sequence Data 9.2.1 Reading the Dataset 9.2.2 Tokenization 9.2.3 Vocabulary 9.2.4 Putting It All Together 9.2.5 Exploratory Language Statistics 9.2.6 Summary 9.2.7 Exercises 9.3 Language Models 9.3.1 Learning Language Models 9.3.2 Perplexity 9.3.3 Partitioning Sequences 9.3.4 Summary and Discussion 9.3.5 Exercises 9.4 Recurrent Neural Networks 9.4.1 Neural Networks without Hidden States 9.4.2 Recurrent Neural Networks with Hidden States 9.4.3 RNN-Based Character-Level Language Models 9.4.4 Summary 9.4.5 Exercises 9.5 Recurrent Neural Network Implementation from Scratch 9.5.1 RNN Model 9.5.2 RNN-Based Language Model 9.5.3 Gradient Clipping 9.5.4 Training 9.5.5 Decoding 9.5.6 Summary 9.5.7 Exercises 9.6 Concise Implementation of Recurrent Neural Networks 9.6.1 Defining the Model 9.6.2 Training and Predicting 9.6.3 Summary 9.6.4 Exercises 9.7 Backpropagation Through Time 9.7.1 Analysis of Gradients in RNNs 325 327 328 330 331 333 335 335 336 336 337 337 338 339 341 342 342 343 345 346 347 348 348 349 349 351 352 352 352 353 354 356 357 358 359 359 360 360 361 362 362 362 362
9 Recurrent Neural Networks
9.7.2
Backpropagation Through Time in Detail
9.7.3
Summary
xi
365
368
9.7.4
Exercises
10 Modern Recurrent Neural Networks 10.1 Long Short-Term Memory (LSTM) 0.1.1 Gated Memory Cell 0.1.2 Implementation from Scratch 0.1.3 Concise Implementation 0.1.4 Summary 0.1.5 Exercises 10.2 Gated Recurrent Units (GRU) 0.2.1 Reset Gate and Update Gate 0.2.2 Candidate Hidden State 0.2.3 Hidden State 0.2.4 Implementation from Scratch 0.2.5 Concise Implementation 0.2.6 Summary 0.2.7 Exercises 10.3. Deep Recurrent Neural Networks 0.3.1 Implementation from Scratch 0.3.2 Concise Implementation 0.3.3 Summary 0.3.4 Exercises 10.4 Bidirectional Recurrent Neural Networks 0.4.1 Implementation from Scratch 0.4.2 Concise Implementation 0.4.3 Summary 0.4.4 Exercises 10.5 Machine Translation and the Dataset 0.5.1 Downloading and Preprocessing the Dataset 0.5.2 Tokenization 0.5.3 Loading Sequences of Fixed Length 0.5.4 Reading the Dataset 0.5.5 Summary 0.5.6 Exercises 10.6 The Encoder‚ÄîDecoder Architecture 0.6.1 Encoder 0.6.2 Decoder 0.6.3 Putting the Encoder and Decoder Together 0.6.4 Summary 0.6.5 Exercises 10.7 Sequence-to-Sequence Learning for Machine Translation 0.7.1 Teacher Forcing 0.7.2 Encoder 0.7.3 Decoder 0.7.4 Encoder‚ÄîDecoder for Sequence-to-Sequence Learning 369 370 370 373 375 376 376 376 377 378 378 379 380 381 381 382 383 384 385 385 385 387 387 388 388 388 389 390 391 392 393 394 394 394 395 395 396 396 396 397 397 399 400
10 Modern Recurrent Neural Networks
xii
368
10.7.5 Loss Function with Masking 10.7.6 Training 10.7.7 Prediction 10.7.8 Evaluation of Predicted Sequences 10.7.9 Summary 10.7.10 Exercises 10.8 Beam Search 10.8.1 Greedy Search 10.8.2 Exhaustive Search 10.8.3 Beam Search 10.8.4 Summary 10.8.5 Exercises 11.1 Queries, Keys, and Values 11.1.1 Visualization 11.1.2 Summary 11.1.3 Exercises 11.2 Attention Pooling by Similarity 11.2.1 Kernels and Data 11.2.2 Attention Pooling via Nadaraya‚ÄìWatson Regression 11.2.3 Adapting Attention Pooling 11.2.4 Summary 11.2.5 Exercises 11.3 Attention Scoring Functions 11.3.1 Dot Product Attention 11.3.2 Convenience Functions 11.3.3 Scaled Dot Product Attention 11.3.4 Additive Attention 11.3.5 Summary 11.3.6 Exercises 11.4 The Bahdanau Attention Mechanism 11.4.1 Model 11.4.2 Defining the Decoder with Attention 11.4.3 Training 11.4.4 Summary 11.4.5 Exercises 11.5 Multi-Head Attention 11.5.1 Model 11.5.2 Implementation 11.5.3 Summary 11.5.4 Exercises 11.6 Self-Attention and Positional Encoding 401 401 402 403 404 404 405 405 407 407 408 408 409 411 413 414 414 415 415 417 418 419 420 420 421 421 423 424 426 426 427 428 428 430 431 432 432 433 433 435 435 435
11 Attention Mechanisms and Transformers
11.6.1
Self-Attention
11.6.2
Comparing CNNs, RNNs, and Self-Attention
xiii
436
436
11.6.3 Positional Encoding 11.6.4 Summary 11.6.5 Exercises 11.7 The Transformer Architecture 11.7.1 Model 11.7.2 Positionwise Feed-Forward Networks 11.7.3 Residual Connection and Layer Normalization 11.7.4 Encoder 11.7.5 Decoder 11.7.6 Training 11.7.7 Summary 11.7.8 Exercises 11.8 Transformers for Vision 11.8.1 Model 11.8.2 Patch Embedding 11.8.3 Vision Transformer Encoder 11.8.4 Putting It All Together 11.8.5 Training 11.8.6 Summary and Discussion 11.8.7 Exercises 11.9 Large-Scale Pretraining with Transformers 11.9.1 Encoder-Only 11.9.2 Encoder‚ÄìDecoder 11.9.3 Decoder-Only 11.9.4 Scalability 11.9.5 Large Language Models 11.9.6 Summary and Discussion 11.9.7 Exercises 12.1 Optimization and Deep Learning 12.1.1 Goal of Optimization 12.1.2 Optimization Challenges in Deep Learning 12.1.3 Summary 12.1.4 Exercises 12.2 Convexity 12.2.1 Definitions 12.2.2 Properties 12.2.3 Constraints 12.2.4 Summary 12.2.5 Exercises 12.3 Gradient Descent 12.3.1 One-Dimensional Gradient Descent 12.3.2 Multivariate Gradient Descent 437 440 440 440 441 442 443 444 445 447 451 451 451 452 453 453 454 455 455 456 456 457 459 461 463 465 466 467 468 468 469 469 473 473 474 474 476 479 481 482 482 482 486
12 Optimization Algorithms
12.3.3
Adaptive Methods
xiv
488
12.3.4 Summary 12.3.5 Exercises 12.4 Stochastic Gradient Descent 12.4.1 Stochastic Gradient Updates 12.4.2 Dynamic Learning Rate 12.4.3 Convergence Analysis for Convex Objectives 12.4.4 Stochastic Gradients and Finite Samples 12.4.5 Summary 12.4.6 Exercises 12.5 Minibatch Stochastic Gradient Descent 12.5.1 Vectorization and Caches 12.5.2 Minibatches 12.5.3 Reading the Dataset 12.5.4 Implementation from Scratch 12.5.5 Concise Implementation 12.5.6 Summary 12.5.7 Exercises 12.6 Momentum 12.6.1 Basics 12.6.2 Practical Experiments 12.6.3 Theoretical Analysis 12.6.4 Summary 12.6.5 Exercises 12.7 Adagrad 12.7.1 Sparse Features and Learning Rates 12.7.2 Preconditioning 12.7.3 The Algorithm 12.7.4 Implementation from Scratch 12.7.5 Concise Implementation 12.7.6 Summary 12.7.7 Exercises 12.8 RMSProp 12.8.1 The Algorithm 12.8.2 Implementation from Scratch 12.8.3 Concise Implementation 12.8.4 Summary 12.8.5 Exercises 12.9 Adadelta 12.9.1 The Algorithm 12.9.2 Implementation 12.9.3 Summary 12.9.4 Exercises 492 492 493 493 495 496 498 499 499 500 500 503 504 504 507 509 509 510 510 514 516 518 519 519 519 520 521 523 524 524 525 525 526 526 528 528 529 529 529 530 531 532
12.10 Adam
12.10.1
The Algorithm
12.10.2 Implementation 533
xv
532
532
12.10.3 Yogi 12.10.4 Summary 12.10.5 Exercises 12.11 Learning Rate Scheduling 12.11.1 Toy Problem 12.11.2 Schedulers 12.11.3 Policies 12.11.4 Summary 12.11.5 Exercises 13.1 Compilers and Interpreters 13.1.1 Symbolic Programming 13.1.2 Hybrid Programming 13.1.3 Hybridizing the Sequential Class 13.1.4 Summary 13.1.5 Exercises 13.2 Asynchronous Computation 13.2.1 Asynchrony via Backend 13.2.2 Barriers and Blockers 13.2.3 Improving Computation 13.2.4 Summary 13.2.5 Exercises 13.3 Automatic Parallelism 13.3.1 Parallel Computation on GPUs 13.3.2 Parallel Computation and Communication 13.3.3 Summary 13.3.4 Exercises 13.4 Hardware 13.4.1 Computers 13.4.2 Memory 13.4.3 Storage 13.4.4 CPUs 13.4.5 GPUs and other Accelerators 13.4.6 Networks and Buses 13.4.7 More Latency Numbers 13.4.8 Summary 13.4.9 Exercises 13.5 Training on Multiple GPUs 13.5.1 Splitting the Problem 13.5.2 Data Parallelism 13.5.3 A Toy Network 13.5.4 Data Synchronization 534 535 536 536 537 539 540 545 545 547 547 548 549 550 552 552 552 553 554 555 555 555 555 556 557 558 559 559 560 561 562 563 566 569 570 571 571 572 573 574 575 576
13 Computational Performance
13.5.5
Distributing Data
13.5.6
Training
xvi
577
578
13.5.7 Summary 13.5.8 Exercises 13.6 Concise Implementation for Multiple GPUs 13.6.1 A Toy Network 13.6.2 Network Initialization 13.6.3 Training 13.6.4 Summary 13.6.5 Exercises 13.7.1 Data-Parallel Training 13.7.2 Ring Synchronization 13.7.3 Multi-Machine Training 13.7.4 Key‚ÄìValue Stores 13.7.5 Summary 13.7.6 Exercises 14.1.1 Common Image Augmentation Methods 14.1.2 Training with Image Augmentation 14.1.3 Summary 14.1.4 Exercises 14.2.1 Steps 14.2.2 Hot Dog Recognition 14.2.3 Summary 14.2.4 Exercises 14.3 Object Detection and Bounding Boxes 14.3.1 Bounding Boxes 14.3.2 Summary 14.3.3 Exercises 14.4.1 Generating Multiple Anchor Boxes 14.4.2 Intersection over Union (IoU) 14.4.3 Labeling Anchor Boxes in Training Data 14.4.4 Predicting Bounding Boxes with Non-Maximum Suppression 14.4.5 Summary 14.4.6 Exercises 14.5.1 Multiscale Anchor Boxes 14.5.2 Multiscale Detection 14.5.3 Summary 14.5.4 Exercises 14.6.1 Downloading the Dataset 580 580 581 581 582 582 583 584 584 584 586 588 589 591 591 592 592 593 596 599 599 600 600 601 605 606 606 607 609 609 609 610 612 613 619 622 623 623 623 625 626 626 627 627
13.7 Parameter Servers
14 Computer Vision
14.1 Image Augmentation
14.2 Fine-Tuning
14.4 Anchor Boxes
14.5 Multiscale Object Detection
14.6 The Object Detection Dataset
xvii
14.6.2 Reading the Dataset 14.6.3 Demonstration 14.6.4 Summary 14.6.5 Exercises 14.7 Single Shot Multibox Detection 14.7.1 Model 14.7.2 Training 14.7.3 Prediction 14.7.4 Summary 14.7.5 Exercises 14.8 Region-based CNNs (R-CNNs) 14.8.1 R-CNNs 14.8.2 Fast R-CNN 14.8.3 Faster R-CNN 14.8.4 Mask R-CNN 14.8.5 Summary 14.8.6 Exercises 14.9 Semantic Segmentation and the Dataset 14.9.1 Image Segmentation and Instance Segmentation 14.9.2 The Pascal VOC2012 Semantic Segmentation Dataset 14.9.3 Summary 14.9.4 Exercises 14.10.1 Basic Operation 14.10.2 Padding, Strides, and Multiple Channels 14.10.3 Connection to Matrix Transposition 14.10.4 Summary 14.10.5 Exercises 14.11 Fully Convolutional Networks 14.11.1 The Model 14.11.2 Initializing Transposed Convolutional Layers 14.11.3 Reading the Dataset 14.11.4 Training 14.11.5 Prediction 14.11.6 Summary 14.11.7 Exercises 14.12.1 Method 14.12.2 Reading the Content and Style Images 14.12.3 Preprocessing and Postprocessing 14.12.4 Extracting Features 14.12.5 Defining the Loss Function 14.12.6 Initializing the Synthesized Image 14.12.7 Training 627 629 629 630 630 630 636 638 639 640 642 642 643 645 646 647 647 648 648 648 654 654 654 654 656 657 659 659 659 660 662 663 664 664 666 666 666 666 668 668 669 670 672 673
14.10 Transposed Convolution
14.12 Neural Style Transfer
14.12.8
Summary
xviii
674
14.12.9 Exercises 14.13.1 Obtaining and Organizing the Dataset 14.13.2 Image Augmentation 14.13.3 Reading the Dataset 14.13.4 Defining the Model 14.13.5 Defining the Training Function 14.13.6 Training and Validating the Model 14.13.7 Classifying the Testing Set and Submitting Results on Kaggle 14.13.8 Summary 14.13.9 Exercises 14.14.1 Obtaining and Organizing the Dataset 14.14.2 Image Augmentation 14.14.3 Reading the Dataset 14.14.4 Fine-Tuning a Pretrained Model 14.14.5 Defining the Training Function 14.14.6 Training and Validating the Model 14.14.7 Classifying the Testing Set and Submitting Results on Kaggle 14.14.8 Summary 14.14.9 Exercises 15.1.1 One-Hot Vectors Are a Bad Choice 15.1.2 Self-Supervised word2vec 15.1.3 The Skip-Gram Model 15.1.4 The Continuous Bag of Words (CBOW) Model 15.1.5 Summary 15.1.6 Exercises 15.2.1 Negative Sampling 15.2.2 Hierarchical Softmax 15.2.3 Summary 15.2.4 Exercises 15.3.1 Reading the Dataset 15.3.2 Subsampling 15.3.3 Extracting Center Words and Context Words 15.3.4 Negative Sampling 15.3.5 Loading Training Examples in Minibatches 15.3.6 Putting It All Together 15.3.7 Summary 674 674 675 678 678 679 679 680 680 681 682 682 682 684 685 685 686 687 688 688 689 690 691 691 691 692 694 695 695 696 696 698 699 699 699 699 700 702 703 704 705 706
14.13 Image Classification (CIFAR-10) on Kaggle
14.14 Dog Breed Identification (ImageNet Dogs) on Kaggle
15 Natural Language Processing: Pretraining
15.1 Word Embedding (word2vec)
15.2 Approximate Training
15.3 The Dataset for Pretraining Word Embeddings
15.3.8
Exercises
15.4 Pretraining word2vec
xix
706
707
15.4.1 The Skip-Gram Model 15.4.2 Training 15.4.3 Applying Word Embeddings 15.4.4 Summary 15.4.5 Exercises 15.5 Word Embedding with Global Vectors (GloVe) 15.5.1 Skip-Gram with Global Corpus Statistics 15.5.2 The GloVe Model 15.5.3 Interpreting GloVe from the Ratio of Co-occurrence Probabilities 15.5.4 Summary 15.5.5 Exercises 15.6.1 The fastText Model 15.6.2 Byte Pair Encoding 15.6.3 Summary 15.6.4 Exercises 15.7 Word Similarity and Analogy 15.7.1 Loading Pretrained Word Vectors 15.7.2 Applying Pretrained Word Vectors 15.7.3 Summary 15.7.4 Exercises 15.8 Bidirectional Encoder Representations from Transformers (BERT) 15.8.1 From Context-Independent to Context-Sensitive 15.8.2 From Task-Specific to Task-Agnostic 15.8.3 BERT: Combining the Best of Both Worlds 15.8.4 Input Representation 15.8.5 Pretraining Tasks 15.8.6 Putting It All Together 15.8.7 Summary 15.8.8 Exercises 15.9 The Dataset for Pretraining BERT 15.9.1 Defining Helper Functions for Pretraining Tasks 15.9.2 Transforming Text into the Pretraining Dataset 15.9.3 Summary 15.9.4 Exercises 15.10.1 Pretraining BERT 15.10.2 Representing Text with BERT 15.10.3 Summary 15.10.4 Exercises 707 708 711 711 711 711 712 713 713 715 715 715 715 716 719 719 720 720 722 724 724 724 724 725 725 726 728 731 732 733 733 734 736 738 739 739 739 741 742 743
15.6 Subword Embedding
15.10 Pretraining BERT
16 Natural Language Processing: Applications
16.1 Sentiment Analysis and the Dataset 745
16.1.1 Reading the Dataset 745
xx
744
16.1.2 Preprocessing the Dataset 16.1.3 Creating Data Iterators 16.1.4 Putting It All Together 16.1.5 Summary 16.1.6 Exercises 16.2.1 Representing Single Text with RNNs 16.2.2 Loading Pretrained Word Vectors 16.2.3 Training and Evaluating the Model 16.2.4 Summary 16.2.5 Exercises 16.3.1 One-Dimensional Convolutions 16.3.2 Max-Over-Time Pooling 16.3.3 The textCNN Model 16.3.4 Summary 16.3.5 Exercises 16.4.1 Natural Language Inference 16.4.2 The Stanford Natural Language Inference (SNLI) Dataset 16.4.3 Summary 16.4.4 Exercises 16.5.1 The Model 16.5.2 Training and Evaluating the Model 16.5.3 Summary 16.5.4 Exercises 16.6 Fine-Tuning BERT for Sequence-Level and Token-Level Applications 16.6.1 Single Text Classification 16.6.2 Text Pair Classification or Regression 16.6.3 Text Tagging 16.6.4 Question Answering 16.6.5 Summary 16.6.6 Exercises 16.7.1 Loading Pretrained BERT 16.7.2 The Dataset for Fine-Tuning BERT 16.7.3 Fine-Tuning BERT 16.7.4 Summary 16.7.5 Exercises 746 747 747 748 748 748 749 750 751 751 752 752 753 754 755 758 758 759 759 760 763 763 763 764 768 770 770 771 771 772 773 773 774 774 775 775 776 778 779 779
16.2 Sentiment Analysis: Using Recurrent Neural Networks
16.3 Sentiment Analysis: Using Convolutional Neural Networks
16.4 Natural Language Inference and the Dataset
16.5 Natural Language Inference: Using Attention
16.7 Natural Language Inference: Fine-Tuning BERT
17 Reinforcement Learning
17.1 Markov Decision Process (MDP)
17.1.1
Definition of an MDP
17.1.2
Return and Discount Factor
xxi
781
782
782
783
17.1.3 Discussion of the Markov Assumption 17.1.4 Summary 17.1.5 Exercises 17.2.1 Stochastic Policy 17.2.2 Value Function 17.2.3 Action-Value Function 17.2.4 Optimal Stochastic Policy 17.2.5 Principle of Dynamic Programming 17.2.6 Value Iteration 17.2.7 Policy Evaluation 17.2.8 Implementation of Value Iteration 17.2.9 Summary 17.2.10 Exercises 17.3.1 The Q-Learning Algorithm 17.3.2 An Optimization Problem Underlying Q-Learning 17.3.3 Exploration in Q-Learning 17.3.4 The ‚ÄúSelf-correcting‚Äù Property of Q-Learning 17.3.5 Implementation of Q-Learning 17.3.6 Summary 17.3.7 Exercises 18.1.1 Summary 18.1.2 Exercises 18.2.1 Definition 18.2.2 A Simple Gaussian Process 18.2.3 From Weight Space to Function Space 18.2.4 The Radial Basis Function (RBF) Kernel 18.2.5 The Neural Network Kernel 18.2.6 Summary 18.2.7 Exercises 18.3.1 Posterior Inference for Regression 18.3.2 Equations for Making Predictions and Learning Kernel Hyperparameters in GP Regression 18.3.3 Interpreting Equations for Learning and Predictions 18.3.4 Worked Example from Scratch 18.3.5 Making Life Easy with GPyTorch 784 785 785 785 785 786 786 787 787 788 788 789 790 791 791 791 791 793 793 794 795 796 797 798 807 808 809 809 810 811 811 813 814 814 815 815 817 817 818 822
17.2 Value Iteration
17.3 Q-Learning
18 Gaussian Processes
18.1 Introduction to Gaussian Processes
18.2 Gaussian Process Priors
18.3 Gaussian Process Inference
18.3.6
Summary
18.3.7
Exercises
xxii
825
826
19.1 What Is Hyperparameter Optimization? 19.1.1 The Optimization Problem 19.1.2 Random Search 19.1.3 Summary 19.1.4 Exercises 19.2 Hyperparameter Optimization API 19.2.1 Searcher 19.2.2 Scheduler 19.2.3 Tuner 19.2.4 Bookkeeping the Performance of HPO Algorithms 19.2.5 Example: Optimizing the Hyperparameters of a Convolu- tional Neural Network 19.2.6 Comparing HPO Algorithms 19.2.7 Summary 19.2.8 Exercises 19.3 Asynchronous Random Search 19.3.1 Objective Function 19.3.2 Asynchronous Scheduler 19.3.3 Visualize the Asynchronous Optimization Process 19.3.4 Summary 19.3.5 Exercises 19.4 Multi-Fidelity Hyperparameter Optimization 19.4.1 Successive Halving 19.4.2 Summary 19.5 Asynchronous Successive Halving 19.5.1 Objective Function 19.5.2 Asynchronous Scheduler 19.5.3 Visualize the Optimization Process 19.5.4 Summary 20.1 Generative Adversarial Networks 20.1.1 Generate Some ‚ÄúReal‚Äù Data 20.1.2 Generator 20.1.3 Discriminator 20.1.4 Training 20.1.5 Summary 20.1.6 Exercises 20.2 Deep Convolutional Generative Adversarial Networks 20.2.1 The Pokemon Dataset 20.2.2 The Generator 828 828 829 832 834 835 836 836 837 837 838 839 841 842 842 843 844 845 851 852 853 853 855 866 867 869 870 879 879 880 880 882 883 883 883 885 885 886 886 887
19 Hyperparameter Optimization
20 Generative Adversarial Networks
20.2.3
Discriminator
20.2.4
Training
20.2.5
Summary
xxiii
889
891
892
xxiv

20.2.6 Exercises 21.1 Overview of Recommender Systems 21.1.1 Collaborative Filtering 21.1.2 Explicit Feedback and Implicit Feedback 21.1.3 Recommendation Tasks 21.1.4 Summary 21.1.5 Exercises Appendix A Mathematics for Deep Learning Appendix B Tools for Deep Learning 892 893 893 894 895 895 895 895 897 1035 1089
21 Recommender Systems
References
Contents
Preface
Just a few years ago, there were no legions of deep learning scientists developing intelli- gent products and services at major companies and startups. When we entered the field, machine learning did not command headlines in daily newspapers.bubuOur parents had no idea what machine learning was, let alone why we might prefer it to a career in medicine or law. Machine learning was a blue skies academic discipline whose industrial significance was limited to a narrow set of real-world applications, including speech recognition and com- puter vision. Moreover, many of these applications required so much domain knowledge that they were often regarded as entirely separate areas for which machine learning was one small component. At that time, neural networks‚Äîthe predecessors of the deep learn- ing methods that we focus on in this book‚Äîwere generally regarded as outmoded. Yet in just few years, deep learning has taken the world by surprise, driving rapid progress in such diverse fields as computer vision, natural language processing, automatic speech recognition, reinforcement learning, and biomedical informatics. Moreover, the success of deep learning in so many tasks of practical interest has even catalyzed developments in theoretical machine learning and statistics. With these advances in hand, we can now build cars that drive themselves with more autonomy than ever before (though less autonomy than some companies might have you believe), dialogue systems that debug code by asking clarifying questions, and software agents beating the best human players in the world at board games such as Go, a feat once thought to be decades away. Already, these tools exert ever-wider influence on industry and society, changing the way movies are made, diseases are diagnosed, and playing a growing role in basic sciences‚Äîfrom astrophysics, to climate modeling, to weather prediction, to biomedicine. About This Book
eee
This book represents our attempt to make deep learning approachable, teaching you the concepts, the context, and the code. One Medium Combining Code, Math, and HTML
For any computing technology to reach its full impact, it must be well understood, well documented, and supported by mature, well-maintained tools. The key ideas should be clearly distilled, minimizing the onboarding time needed to bring new practitioners up to
xxv
xxvi

date. Mature libraries should automate common tasks, and exemplar code should make it easy for practitioners to modify, apply, and extend common applications to suit their needs. As an example, take dynamic web applications. Despite a large number of companies, such as Amazon, developing successful database-driven web applications in the 1990s, the potential of this technology to aid creative entrepreneurs was realized to a far greater degree only in the past ten years, owing in part to the development of powerful, well-documented frameworks. Testing the potential of deep learning presents unique challenges because any single appli- cation brings together various disciplines. Applying deep learning requires simultaneously understanding (i) the motivations for casting a problem in a particular way; (ii) the math- ematical form of a given model; (iii) the optimization algorithms for fitting the models to data; (iv) the statistical principles that tell us when we should expect our models to general- ize to unseen data and practical methods for certifying that they have, in fact, generalized; and (v) the engineering techniques required to train models efficiently, navigating the pit- falls of numerical computing and getting the most out of available hardware. Teaching the critical thinking skills required to formulate problems, the mathematics to solve them, and the software tools to implement those solutions all in one place presents formidable chal- lenges. Our goal in this book is to present a unified resource to bring would-be practitioners up to speed. Whenwestartedthisbookproject, therewerenoresourcesthatsimultaneously(i)remained
up to date; (ii) covered the breadth of modern machine learning practices with sufficient technical depth; and (iii) interleaved exposition of the quality one expects of a textbook with the clean runnable code that one expects of a hands-on tutorial. We found plenty of code examples illustrating how to use a given deep learning framework (e.g., how to do basic numerical computing with matrices in TensorFlow) or for implementing particular techniques (e.g., code snippets for LeNet, AlexNet, ResNet, etc.) scattered across various blog posts and GitHub repositories. However, these examples typically focused on how to implement a given approach, but left out the discussion of why certain algorithmic deci- sions are made. While some interactive resources have popped up sporadically to address a particular topic, e.g., the engaging blog posts published on the website Distill1, or personal blogs, they only covered selected topics in deep learning, and often lacked associated code. On the other hand, while several deep learning textbooks have emerged‚Äîe.g., Goodfellow et al. (2016), which offers a comprehensive survey on the basics of deep learning‚Äîthese resources do not marry the descriptions to realizations of the concepts in code, sometimes leaving readers clueless as to how to implement them. Moreover, too many resources are hidden behind the paywalls of commercial course providers. 1
We set out to create a resource that could (i) be freely available for everyone; (ii) offer suffi- cient technical depth to provide a starting point on the path to actually becoming an applied machine learning scientist; (iii) include runnable code, showing readers how to solve prob- lems in practice; (iv) allow for rapid updates, both by us and also by the community at large; and (v) be complemented by a forum2 for interactive discussion of technical details and to answer questions. Bem 5 A ree
2
Preface
xxvii

These goals wereoften in conflict. Equations, theorems, and citations are bestmanagedand laid out in LaTeX. Code is best described in Python. And webpages are native in HTML and JavaScript. Furthermore, we want the content to be accessible both as executable code, as a physical book, as a downloadable PDF, and on the Internet as a website. No workflows seemed suited to these demands, so we decided to assemble our own (Section B.6). We settled on GitHub to share the source and to facilitate community contributions; Jupyter notebooksformixingcode, equationsandtext; Sphinxasarenderingengine; andDiscourse asadiscussionplatform. Whileoursystemisnotperfect, thesechoicesstrikeacompromise among the competing concerns. We believe that Dive into Deep Learning might be the first book published using such an integrated workflow. Learning by Doing
Many textbooks present concepts in succession, covering each in exhaustive detail. For example, the excellent textbook of Bishop (2006), teaches each topic so thoroughly that getting to the chapter on linear regression requires a nontrivial amount of work. While experts love this book precisely for its thoroughness, for true beginners, this property limits its usefulness as an introductory text. In this book, we teach most concepts just in time. In other words, you will learn concepts at the very moment that they are needed to accomplish some practical end. While we take some time at the outset to teach fundamental preliminaries, like linear algebra and probability, wewantyoutotastethesatisfactionoftrainingyourfirstmodelbeforeworrying about more esoteric concepts. Aside from a few preliminary notebooks that provide a crash course in the basic mathe- matical background, each subsequent chapter both introduces a reasonable number of new concepts and provides several self-contained working examples, using real datasets. This presented an organizational challenge. Some models might logically be grouped together in a single notebook. And some ideas might be best taught by executing several models in succession. By contrast, there is a big advantage to adhering to a policy of one working example, one notebook: This makes it as easy as possible for you to start your own research projects by leveraging our code. Just copy a notebook and start modifying it. Throughout, we interleave the runnable code with background material as needed. In gen- eral, we err on the side of making tools available before explaining them fully (often filling in the background later). For instance, we might use stochastic gradient descent before explaining why it is useful or offering some intuition for why it works. This helps to give practitioners the necessary ammunition to solve problems quickly, at the expense of requir- ing the reader to trust us with some curatorial decisions. This book teaches deep learning concepts from scratch. Sometimes, we delve into fine details about models that would typically be hidden from users by modern deep learning frameworks. This comes up especially in the basic tutorials, where we want you to un- derstand everything that happens in a given layer or optimizer. In these cases, we often present two versions of the example: one where we implement everything from scratch, relying only on NumPy-like functionality and automatic differentiation, and a more prac-
Preface
xxviii

tical example, where we write succinct code using the high-level APIs of deep learning frameworks. After explaining how some component works, we rely on the high-level API in subsequent tutorials. Content and Structure
The book can be divided into roughly three parts, dealing with preliminaries, deep learning techniques, and advanced topics focused on real systems and applications (Fig. 1).bubu1. Introduction ¬• 2.bubuPreliminaries v 3-4. Linear Neural Networks ¬• 5, Multilayer Perceptrons ¬• 6. Builders‚Äô Guide 7. Convolutional Neural 9. Recurrent Neural Networks Networks q 10. Modern Recurrent Neural Networks 8. Modern Convolutional Neural Networks i 11. Attention Mechanisms and Transformers
tFig. 1
Book structure.bubue Part 1: Basics and Preliminaries. Chapter | is an introduction to deep learning. Then, in Chapter 2, we quickly bring you up to speed on the prerequisites required for hands- on deep learning, such as how to store and manipulate data, and how to apply vari- ous numerical operations based on elementary concepts from linear algebra, calculus, and probability. Chapter 3 and Chapter 5 cover the most fundamental concepts and techniques in deep learning, including regression and classification; linear models; multilayer perceptrons; and overfitting and regularization. e Part 2: Modern Deep Learning Techniques. Chapter 6 describes the key computa- tional components of deep learning systems and lays the groundwork for our sub- sequent implementations of more complex models. Next, Chapter 7 and Chapter 8 present convolutional neural networks (CNNs), powerful tools that form the back- bone of most modern computer vision systems. Similarly, Chapter 9 and Chapter 10 introduce recurrent neural networks (RNNs), models that exploit sequential (e.g., tem- poral) structure in data and are commonly used for natural language processing and time series prediction. In Chapter 11, we describe a relatively new class of models, based on so-called attention mechanisms, that has displaced RNNs as the dominant architecture for most natural language processing tasks. These sections will bring you up to speed on the most powerful and general tools that are widely used by deep learning practitioners. Preface
xxix

e Part 3: Scalability, Efficiency, and Applications (available online?). In Chapter 12, we discuss several common optimization algorithms used to train deep learning models. Next, in Chapter 13, we examine several key factors that influence the computational performance of deep learning code. Then, in Chapter 14, we illustrate major applica- tions of deep learning in computer vision. Finally, in Chapter 15 and Chapter 16, we demonstrate how to pretrain language representation models and apply them to natural language processing tasks. 3
Most sections of this book feature executable code. We believe that some intuitions are best developed via trial and error, tweaking the code in small ways and observing the results. Ideally, an elegant mathematical theory might tell us precisely how to tweak our code to achieve a desired result. However, deep learning practitioners today must often tread where no solid theory provides guidance. Despite our best attempts, formal explanations for the efficacy of various techniques are still lacking, for a variety of reasons: the mathematics to characterize these models can be so difficult; the explanation likely depends on properties of the data that currently lack clear definitions; and serious inquiry on these topics has only recently kicked into high gear. We are hopeful that as the theory of deep learning progresses, each future edition of this book will provide insights that eclipse those presently available. To avoid unnecessary repetition, we capture some of our most frequently imported and used functions and classes in the d2l package. Throughout, we mark blocks of code (such as functions, classes, or collection of import statements) with #@save to indicate that they will be accessed later via the d2l package. We offer a detailed overview of these classes and functions in Section B.8. The d2l package is lightweight and only requires the following dependencies:
#@save
import collections import hashlib import inspect import math import os import random import re import shutil import sys import tarfile import time import zipfile from collections import defaultdict import pandas as pd import requests from IPython import display from matplotlib import pyplot as plt from matplotlib_inline import backend_inline
d2l = sys.modules[__name__]
Preface
Code
xxx

Most of the code in this book is based on PyTorch, a popular open-source framework that has been enthusiastically embraced by the deep learning research community. All of the code in this book has passed tests under the latest stable version of PyTorch.bubuHowever, due to the rapid development of deep learning, some code in the print edition may not work properly in future versions of PyTorch. We plan to keep the online version up to date. In case you encounter any problems, please consult Installation (page xxxiv) to update your code and runtime environment. Below lists dependencies in our PyTorch implemen- tation. #@save import numpy as np import torch import torchvision from PIL import Image from scipy.spatial import distance_matrix from torch import nn from torch.nn import functional as F from torchvision import transforms
Target Audience
This book is for students (undergraduate or graduate), engineers, and researchers, who seek a solid grasp of the practical techniques of deep learning. Because we explain every con- ceptfromscratch, nopreviousbackgroundindeeplearningormachinelearningisrequired. Fully explaining the methods of deep learning requires some mathematics and program- ming, but we will only assume that you enter with some basics, including modest amounts of linear algebra, calculus, probability, and Python programming. Just in case you have forgotten anything, the online Appendix4 provides a refresher on most of the mathematics you will find in this book. Usually, we will prioritize intuition and ideas over mathematical rigor. If you would like to extend these foundations beyond the prerequisites to understand our book, we happily recommend some other terrific resources: Linear Analysis by Bol- lob√°s (1999) covers linear algebra and functional analysis in great depth. All of Statistics (Wasserman, 2013) provides a marvelous introduction to statistics. Joe Blitzstein‚Äôs books5 and courses6 on probability and inference are pedagogical gems. And if you have not used Python before, you may want to peruse this Python tutorial7. 4
5
6
Ee
7
[OL
San
8
Notebooks, Website, GitHub, and Forum
9
All of our notebooks are available for download on the D2L.ai website8 and on GitHub9. Associated with this book, we have launched a discussion forum, located at discuss.d2l.ai 10 . Whenever you have questions on any section of the book, you can find a link to the associated discussion page at the end of each notebook. 10
Preface
xxxi

Acknowledgments

We are indebted to the hundreds of contributors for both the English and the Chinese drafts. They helped improve the content and offered valuable feedback. This book was originally implemented with MXNet as the primary framework. We thank Anirudh Dagar and Yuan Tang for adapting a majority part of earlier MXNet code into PyTorch and TensorFlow im- plementations, respectively. Since July 2021, we have redesigned and reimplemented this book in PyTorch, MXNet, and TensorFlow, choosing PyTorch as the primary framework. We thank Anirudh Dagar for adapting a majority part of more recent PyTorch code into JAX implementations. We thank Gaosheng Wu, Liujun Hu, Ge Zhang, and Jiehang Xie from Baidu for adapting a majority part of more recent PyTorch code into PaddlePaddle implementations in the Chinese draft. We thank Shuai Zhang for integrating the LaTeX style from the press into the PDF building. On GitHub, we thank every contributor of this English draft for making it better for ev-
eryone. Their GitHub IDs or names are (in no particular order): alxnorden, avinashingit, bowen0701, brettkoonce, Chaitanya Prakash Bapat, cryptonaut, Davide Fiocco, edgarro- man, gkutiel, John Mitro, Liang Pu, Rahul Agarwal, Mohamed Ali Jamaoui, Michael (Stu) Stewart, Mike M√ºller, NRauschmayr, Prakhar Srivastav, sad-, sfermigier, Sheng Zha, sun- deepteki, topecongiro, tpdi, vermicelli, Vishaal Kapoor, Vishwesh Ravi Shrimali, YaYaB, Yuhong Chen, Evgeniy Smirnov, lgov, Simon Corston-Oliver, Igor Dzreyev, Ha Nguyen, pmuens, Andrei Lukovenko, senorcinco, vfdev-5, dsweet, Mohammad Mahdi Rahimi, Ab- hishek Gupta, uwsd, DomKM, Lisa Oakley, Bowen Li, Aarush Ahuja, Prasanth Bud- dareddygari, brianhendee, mani2106, mtn, lkevinzc, caojilin, Lakshya, Fiete L√ºer, Surbhi Vijayvargeeya, Muhyun Kim, dennismalmgren, adursun, Anirudh Dagar, liqingnz, Pe- dro Larroy, lgov, ati-ozgur, Jun Wu, Matthias Blume, Lin Yuan, geogunow, Josh Gard- ner, Maximilian B√∂ther, Rakib Islam, Leonard Lausen, Abhinav Upadhyay, rongruosong, Steve Sedlmeyer, Ruslan Baratov, Rafael Schlatter, liusy182, Giannis Pappas, ati-ozgur, qbaza, dchoi77, Adam Gerson, Phuc Le, Mark Atwood, christabella, vn09, Haibin Lin, jjangga0214, RichyChen, noelo, hansent, Giel Dops, dvincent1337, WhiteD3vil, Peter Kulits, codypenta, joseppinilla, ahmaurya, karolszk, heytitle, Peter Goetz, rigtorp, Tiep Vu, sfilip, mlxd, Kale-ab Tessera, Sanjar Adilov, MatteoFerrara, hsneto, Katarzyna Biesial- ska, Gregory Bruss, Duy‚ÄìThanh Doan, paulaurel, graytowne, Duc Pham, sl7423, Jaedong Hwang, Yida Wang, cys4, clhm, Jean Kaddour, austinmw, trebeljahr, tbaums, Cuong V. Nguyen, pavelkomarov, vzlamal, NotAnotherSystem, J-Arun-Mani, jancio, eldarkurtic, the-great-shazbot, doctorcolossus, gducharme, cclauss, Daniel-Mietchen, hoonose, bia- giom, abhinavsp0730, jonathanhrandall, ysraell, Nodar Okroshiashvili, UgurKap, Jiyang Kang, StevenJokes, Tomer Kaftan, liweiwp, netyster, ypandya, NishantTharani, heiligerl, SportsTHU,HoaNguyen,manuel-arno-korfmann-webentwicklung,aterzis-personal,nxby, Xiaoting He, Josiah Yoder, mathresearch, mzz2017, jroberayalas, iluu, ghejc, BSharmi, vkramdev,simonwardjones,LakshKD,TalNeoran,djliden,Nikhil95,OrenBarkan,guoweis, haozhu233, pratikhack, Yue Ying, tayfununal, steinsag, charleybeller, Andrew Lumsdaine, Jiekui Zhang, Deepak Pathak, Florian Donhauser, Tim Gates, Adriaan Tijsseling, Ron
Preface
XXxii
xxxii

Medina, Gaurav Saha, Murat Semerci, Lei Mao, Levi McClenny, Joshua Broyde, jake221, jonbally, zyhazwraith, Brian Pulfer, Nick Tomasino, Lefan Zhang, Hongshen Yang, Vin- ney Cavallo, yuntai, Yuanxiang Zhu, amarazov, pasricha, Ben Greenawald, Shivam Upad- hyay, Quanshangze Du, Biswajit Sahoo, Parthe Pandit, Ishan Kumar, HomunculusK, Lane Schwartz,varadgunjal,JasonWiener,ArminGholampoor,Shreshtha13,eigen-arnav,Hyeong- gyu Kim, EmilyOng, B√°lint Mucs√°nyi, Chase DuBois, Juntian Tao, Wenxiang Xu, Lifu Huang, filevich, quake2005, nils-werner, Yiming Li, Marsel Khisamutdinov, Francesco ‚ÄúFuma‚Äù Fumagalli, Peilin Sun, Vincent Gurgul, qingfengtommy, Janmey Shukla, Mo Shan, KaanSancak, regob, AlexSauer, GopalakrishnaRamachandra, TobiasUelwer, ChaoWang, TianCao,NicolasCorthorn,akash5474,kxxt,zxydi1992,JacobBritton,ShuangchiHe,zh- mou, krahets, Jie-Han Chen, Atishay Garg, Marcel Flygare, adtygan, Nik Vaessen, bolded, LouisSchlessinger,BalajiVaratharajan,atgctg,KaixinLi,VictorBarbaros,RiccardoMusto, Elizabeth Ho, azimjonn, Guilherme Miotto, Alessandro Finamore, Joji Joseph, Anthony Biel, Zeming Zhao, shjustinbaek, gab-chen, nantekoto, Yutaro Nishiyama, Oren Amsalem, Tian-MaoMao, Amin Allahyar, Gijs van Tulder, Mikhail Berkov, iamorphen, Matthew Caseres, Andrew Walsh, pggPL, RohanKarthikeyan, Ryan Choi, and Likun Lei. We thank Amazon Web Services, especially Wen-Ming Ye, George Karypis, Swami Siva- subramanian, Peter DeSantis, Adam Selipsky, and Andrew Jassy for their generous support in writing this book.bubuWithout the available time, resources, discussions with colleagues, and continuous encouragement, this book would not have happened. During the prepara- tion of the book for publication, Cambridge University Press has offered excellent support.bubuWe thank our commissioning editor David Tranah for his help and professionalism. Summary
es
Deep learning has revolutionized pattern recognition, introducing technology that now powers a wide range of technologies, in such diverse fields as computer vision, natural language processing, and automatic speech recognition. To successfully apply deep learn- ing, you must understand how to cast a problem, the basic mathematics of modeling, the algorithms for fitting your models to data, and the engineering techniques to implement it all. This book presents a comprehensive resource, including prose, figures, mathematics, and code, all in one place. Exercises
ES
11 1. Register an account on the discussion forum of this book discuss.d2l.ai11. 2. Install Python on your computer. Preface
XXXili
xxxiii

3. Follow the links at the bottom of the section to the forum, where you will be able to seek out help and discuss the book and find answers to your questions by engaging the authors and broader community. Discussions12. q
12
Preface
Installation
In order to get up and running, we will need an environment for running Python, the Jupyter Notebook, the relevant libraries, and the code needed to run the book itself. Installing Miniconda

Your simplest option is to install Miniconda13. Note that the Python 3.x version is required. You can skip the following steps if your machine already has conda installed. 13
Visit the Miniconda website and determine the appropriate version for your system based on your Python 3.x version and machine architecture. Suppose that your Python version is 3.9(ourtestedversion). IfyouareusingmacOS,youwoulddownloadthebashscriptwhose name contains the strings ‚ÄúMacOSX‚Äù, navigate to the download location, and execute the installation as follows (taking Intel Macs as an example):
# The file name is subject to changes sh Miniconda3-py39_4.12.0-MacOSX-x86_64.sh -b
ALinuxuserwoulddownloadthe filewhose namecontains the strings‚ÄúLinux‚Äùandexecute the following at the download location:
# The file name is subject to changes sh Miniconda3-py39_4.12.0-Linux-x86_64.sh -b
A Windows user would download and install Miniconda by following its online instructions 14. On Windows, you may search for cmd to open the Command Prompt (command-line interpreter) for running commands.bubu14
Next, initialize the shell so we can run conda directly. ~/miniconda3/bin/conda init
Then close and reopen your current shell. You should be able to create a new environment as follows:
xxxiv
xxxv

conda create --name d2l python=3.9 -y
Now we can activate the d2l environment:
conda activate d2l
Installing the Deep Learning Framework and the d2l Package

Before installing any deep learning framework, please first check whether or not you have proper GPUs on your machine (the GPUs that power the display on a standard laptop are not relevant for our purposes). For example, if your computer has NVIDIA GPUs and has installed CUDA 15 , then you are all set.bubuIf your machine does not house any GPU, there is no need to worry just yet. Your CPU provides more than enough horsepower to get you through the first few chapters. Just remember that you will want to access GPUs before running larger models. 15
You can install PyTorch (the specified versions are tested at the time of writing) with either CPU or GPU support as follows:
pip install torch==2.0.0 torchvision==0.15.1
Our next step is to install the d2l package that we developed in order to encapsulate fre- quently used functions and classes found throughout this book:
pip install d2l==1.0.3
Downloading and Running the Code
es
Next, you will want to download the notebooks so that you can run each of the book‚Äôs code blocks. Simply click on the ‚ÄúNotebooks‚Äù tab at the top of any HTML page on the D2L.ai website16 to download the code and then unzip it. Alternatively, you can fetch the notebooks from the command line as follows:
16
mkdir d2l-en && cd d2l-en curl https://d2l.ai/d2l-en-1.0.3.zip -o d2l-en.zip unzip d2l-en.zip && rm d2l-en.zip cd pytorch
Installation
xxxvi

If you do not already have unzip installed, first run sudo apt-get install unzip. Now we can start the Jupyter Notebook server by running:
jupyter notebook
Atthispoint, youcanopenhttp://localhost:8888(itmayhavealreadyopenedautomatically) in your web browser. Then we can run the code for each section of the book. Whenever you open a new command line window, you will need to execute conda activate d2l to activate the runtime environment before running the D2L notebooks, or updating your packages (either the deep learning framework or the d2l package). To exit the environment, run conda deactivate. Discussions17. 17
Installation
Notation
Throughout this book, we adhere to the following notational conventions. Note that some of these symbols are placeholders, while others refer to specific objects. As a general rule of thumb, the indefinite article ‚Äúa‚Äù often indicates that the symbol is a placeholder and that similarly formatted symbols can denote other objects of the same type. For example, ‚Äúùë•: a scalar‚Äù means that lowercased letters generally represent scalar values, but ‚ÄúZ: the set of integers‚Äù refers specifically to the symbol Z. Numerical Objects
ee
e x: ascalar
e x: a vector
e X: a matrix
X: a general tensor
I: the identity matrix (of some given dimension), i.e., a square matrix with | on all
diagonal entries and 0 on all off-diagonals
xj, [x];: the i‚Äù element of vector x
xij, Xi,j,[X]ij, [X]i,;: the element of matrix X at row i and column j. Set Theory
ee
e X: aset
e Z: the set of integers
e Z*: the set of positive integers
R: the set of real numbers
R": the set of n-dimensional vectors of real numbers
xxxvii
xxxviii

R¬¢*>: The set of matrices of real numbers with a rows and b columns
|X|: cardinality (number of elements) of set X
e AUB: union of sets A and B
e AN B: intersection of sets A and B
A \ B: set subtraction of B from A (contains only those elements of A that do not
belong to B)
Functions and Operators
|
e f(-): a function
e log(-): the natural logarithm (base e)
e log,(-):
logarithm to base 2
e exp(-): the exponential function
e 1(.): the indicator function; evaluates to 1 if the boolean argument is true, and 0 other-
wise
e 1,x(z): the set-membership indicator function; evaluates to 1 if the element z belongs to
the set X and 0 otherwise
e (-)":
: transpose of a vector or a matrix
e X7!: inverse of matrix X
e ¬©: Hadamard (elementwise) product
e [-,-]: concatenation
¬© {I+ llp: ‚Ç¨ norm
e ||- |]: & norm
e (x,y): inner (dot) product of vectors x and y
Àù
e
: summation over a collection of elements
>):
Àõ
e
: product over a collection of elements
|]:
o &
=: an equality asserted as a definition of the symbol on the left-hand side
Notation
xxxix

Calculus
ae
dy. ùëëùë•: derivative of ùë¶ with respect to ùë•
e %.bubuùúïùë•: partial derivative of ùë¶ with respect to ùë•
e Vxy: gradient of y with respect to x
Ô¨Ç ùëè
ih f
e
ùëì ‚Äûùë•‚Äù ùëëùë•: definite integral of ùëì from ùëé to ùëè with respect to ùë•
Ô¨Ç
e
ùëì ‚Äûùë•‚Äù ùëëùë•: indefinite integral of ùëì with respect to ùë•
Probability and Information Theory
|
e X: arandom variable
e P: a probability distribution
e X ~ P: the random variable X follows distribution P
e P(X =x): the probability assigned to the event where random variable X takes value x
e P(X | Y): the conditional probability distribution of X given Y
e p(-): a probability density function (PDF) associated with distribution P
e E[X]: expectation of a random variable X
e X 1 Y: random variables X and Y are independent
e X 1 Y | Z: random variables X and Y are conditionally independent given Z
e ox: standard deviation of random variable X
e Var(X): variance of random variable X, equal to oX
ùëã
¬© Cov(X, Y): covariance of random variables X and Y
Cov(X,¬•) e p(X,Y): the Pearson correlation coefficient between X and Y, equals TxOY
e H(X): entropy of random variable X
e Dx (P||Q): the KL-divergence (or relative entropy) from distribution Q to distribution
ùëÉ
Discussions18. 18
Notation
ùúéùëãùúéùëå
1
Introduction
Untilrecently, nearlyeverycomputerprogramthatyoumighthaveinteractedwithduringan ordinary day was coded up as a rigid set of rules specifying precisely how it should behave.bubuSay that we wanted to write an application to manage an e-commerce platform. After huddling around a whiteboard for a few hours to ponder the problem, we might settle on the broad strokes of a working solution, for example: (i) users interact with the application through an interface running in a web browser or mobile application; (ii) our application interacts with a commercial-grade database engine to keep track of each user‚Äôs state and maintain records of historical transactions; and (iii) at the heart of our application, the business logic (you might say, the brains) of our application spells out a set of rules that map every conceivable circumstance to the corresponding action that our program should take. To build the brains of our application, we might enumerate all the common events that our program should handle. For example, whenever a customer clicks to add an item to their shopping cart, our program should add an entry to the shopping cart database table, associ- ating that user‚Äôs ID with the requested product‚Äôs ID. We might then attempt to step through every possible corner case, testing the appropriateness of our rules and making any neces- sary modifications. What happens if a user initiates a purchase with an empty cart? While few developers ever get it completely right the first time (it might take some test runs to work out the kinks), for the most part we can write such programs and confidently launch them before ever seeing a real customer. Our ability to manually design automated sys- tems that drive functioning products and systems, often in novel situations, is a remarkable cognitive feat. And when you are able to devise solutions that work 100% of the time, you typically should not be worrying about machine learning. Fortunately for the growing community of machine learning scientists, many tasks that we would like to automate do not bend so easily to human ingenuity. Imagine huddling around the whiteboard with the smartest minds you know, but this time you are tackling one of the following problems:
e Write a program that predicts tomorrow‚Äôs weather given geographic information, satellite
images, and a trailing window of past weather. e Write a program that takes in a factoid question, expressed in free-form text, and answers
it correctly. e Write a program that, given an image, identifies every person depicted in it and draws
outlines around each. 1
2

e Write a program that presents users with products that they are likely to enjoy but un-
likely, in the natural course of browsing, to encounter. For these problems, even elite programmers would struggle to code up solutions from scratch. The reasons can vary. Sometimes the program that we are looking for follows a pattern that changes over time, so there is no fixed right answer! In such cases, any successful solution must adapt gracefully to a changing world. At other times, the rela- tionship (say between pixels, and abstract categories) may be too complicated, requiring thousands or millions of computations and following unknown principles. In the case of image recognition, the precise steps required to perform the task lie beyond our conscious understanding, even though our subconscious cognitive processes execute the task effort- lessly. Machine learning is the study of algorithms that can learn from experience. As a machine learning algorithm accumulates more experience, typically in the form of observational data or interactions with an environment, its performance improves. Contrast this with our deterministic e-commerce platform, which follows the same business logic, no matter how much experience accrues, until the developers themselves learn and decide that it is time to update the software. In this book, we will teach you the fundamentals of machine learning, focusing in particular on deep learning, a powerful set of techniques driving in- novations in areas as diverse as computer vision, natural language processing, healthcare, and genomics. 1.1 A Motivating Example
a
Before beginning writing, the authors of this book, like much of the work force, had to becomecaffeinated.bubuWehoppedinthecarandstarteddriving. UsinganiPhone, Alexcalled out ‚ÄúHey Siri‚Äù, awakening the phone‚Äôs voice recognition system. Then Mu commanded ‚Äúdirections to Blue Bottle coffee shop‚Äù. The phone quickly displayed the transcription of his command. It also recognized that we were asking for directions and launched the Maps application (app) to fulfill our request. Once launched, the Maps app identified a number of routes. Next to each route, the phone displayed a predicted transit time. While this story was fabricated for pedagogical convenience, it demonstrates that in the span of just a few seconds, our everyday interactions with a smart phone can engage several machine learning models. Imagine just writing a program to respond to a wake word such as ‚ÄúAlexa‚Äù, ‚ÄúOK Google‚Äù, and ‚ÄúHey Siri‚Äù. Try coding it up in a room by yourself with nothing but a computer and a code editor, as illustrated in Fig. 1.1.1. How would you write such a program from first principles? Think about it‚Ä¶ the problem is hard. Every second, the microphone will col- lect roughly 44,000 samples. Each sample is a measurement of the amplitude of the sound wave. What rule could map reliably from a snippet of raw audio to confident predictions fyes,nog about whether the snippet contains the wake word? If you are stuck, do not worry.bubuIntroduction
A Motivating Example
3

We do not know how to write such a program from scratch either. That is why we use ma- chine learning. ¬© ‚Äù) & ‚Äî | Wake word model | ‚Äî> {yes, no}
tFig. 1.1.1
Identify a wake word. Here is the trick.bubuOften, even when we do not know how to tell a computer explicitly how to map from inputs to outputs, we are nonetheless capable of performing the cognitive feat ourselves. In other words, even if you do not know how to program a computer to rec- ognize the word ‚ÄúAlexa‚Äù, you yourself are able to recognize it. Armed with this ability, we can collect a huge dataset containing examples of audio snippets and associated labels, indicating which snippets contain the wake word. In the currently dominant approach to machine learning, we do not attempt to design a system explicitly to recognize wake words. Instead, we define a flexible program whose behavior is determined by a number of pa- rameters. Then we use the dataset to determine the best possible parameter values, i.e., those that improve the performance of our program with respect to a chosen performance measure. You can think of the parameters as knobs that we can turn, manipulating the behavior of the program. Once the parameters are fixed, we call the program a model. The set of all distinct programs (input‚Äìoutput mappings) that we can produce just by manipulating the parameters is called a family of models. And the ‚Äúmeta-program‚Äù that uses our dataset to choose the parameters is called a learning algorithm. Before we can go ahead and engage the learning algorithm, we have to define the problem precisely, pinning down the exact nature of the inputs and outputs, and choosing an ap- propriate model family. In this case, our model receives a snippet of audio as input, and the model generates a selection among fyes,nog as output. If all goes according to plan the model‚Äôs guesses will typically be correct as to whether the snippet contains the wake word. If we choose the right family of models, there should exist one setting of the knobs such that the model fires ‚Äúyes‚Äù every time it hears the word ‚ÄúAlexa‚Äù. Because the exact choice of the wake word is arbitrary, we will probably need a model family sufficiently rich that, via another setting of the knobs, it could fire ‚Äúyes‚Äù only upon hearing the word ‚ÄúApricot‚Äù. We expect that the same model family should be suitable for ‚ÄúAlexa‚Äù recognition and ‚ÄúApricot‚Äù recognition because they seem, intuitively, to be similar tasks. However, we might need a different family of models entirely if we want to deal with fundamentally different inputs or outputs, say if we wanted to map from images to captions, or from English sentences to Chinese sentences. As you might guess, if we just set all of the knobs randomly, it is unlikely that our model will recognize ‚ÄúAlexa‚Äù, ‚ÄúApricot‚Äù, or any other English word. In machine learning, the learning is the process by which we discover the right setting of the knobs for coercing the
4

desired behavior from our model. In other words, we train our model with data. As shown in Fig. 1.1.2, the training process usually looks like the following:
1. Start off with a randomly initialized model that cannot do anything useful. 2. Grab some of your data (e.g., audio snippets and corresponding fyes,nog labels). 3. Tweak the knobs to make the model perform better as assessed on those examples. 4. Repeat Steps 2 and 3 until the model is awesome. Update the ( model Design a model }‚Äî‚Äî‚Äî>| Grab new data | ee
tFig. 1.1.2
A typical training process. To summarize, rather than code up a wake word recognizer, we code up a program that can learn to recognize wake words, if presented with a large labeled dataset. You can think of this act of determining a program‚Äôs behavior by presenting it with a dataset as programming withdata. Thatistosay, wecan‚Äúprogram‚Äùacatdetectorbyprovidingourmachinelearning system with many examples of cats and dogs. This way the detector will eventually learn to emit a very large positive number if it is a cat, a very large negative number if it is a dog, and something closer to zero if it is not sure. This barely scratches the surface of what machine learning can do. Deep learning, which we will explain in greater detail later, is just one among many popular methods for solving machine learning problems. 1.2 Key Components
|
In our wake word example, we described a dataset consisting of audio snippets and binary labels, and we gave a hand-wavy sense of how we might train a model to approximate a mapping from snippets to classifications. This sort of problem, where we try to predict a designated unknown label based on known inputs given a dataset consisting of examples for which the labels are known, is called supervised learning. This is just one among many kinds of machine learning problems. Before we explore other varieties, we would like to shed more light on some core components that will follow us around, no matter what kind of machine learning problem we tackle:
1. The data that we can learn from. 2. A model of how to transform the data. 3. An objective function that quantifies how well (or badly) the model is doing. 4. An algorithm to adjust the model‚Äôs parameters to optimize the objective function. Introduction
Key Components
5

It might go without saying that you cannot do data science without data. We could lose hundreds of pages pondering what precisely data is, but for now, we will focus on the key properties of the datasets that we will be concerned with. Generally, we are concerned with a collection of examples. In order to work with data usefully, we typically need to come up with a suitable numerical representation. Each example (or data point, data instance, sample) typically consists of a set of attributes called features (sometimes called covariates or inputs), based on which the model must make its predictions. In supervised learning problems, our goal is to predict the value of a special attribute, called the label (or target), that is not part of the model‚Äôs input. If we were working with image data, each example might consist of an individual photo- graph (the features) and a number indicating the category to which the photograph belongs (the label). The photograph would be represented numerically as three grids of numerical values representing the brightness of red, green, and blue light at each pixel location. For example, a 200 x 200 pixel color photograph would consist of 200 x 200 x 3 = 120000 numerical values. Alternatively, we might work with electronic health record data and tackle the task of pre- dicting the likelihood that a given patient will survive the next 30 days. Here, our features might consist of a collection of readily available attributes and frequently recorded mea- surements, including age, vital signs, comorbidities, current medications, and recent pro- cedures. The label available for training would be a binary value indicating whether each patient in the historical data survived within the 30-day window. In such cases, when every example is characterized by the same number of numerical fea- tures, we say that the inputs are fixed-length vectors and we call the (constant) length of the vectors the dimensionality of the data. As you might imagine, fixed-length inputs can be convenient, giving us one less complication to worry about. However, not all data can easily be represented as fixed-length vectors. While we might expect microscope images to comefromstandardequipment,wecannotexpectimagesminedfromtheInternetalltohave the same resolution or shape. For images, we might consider cropping them to a standard size, but that strategy only gets us so far. We risk losing information in the cropped-out portions. Moreover, text data resists fixed-length representations even more stubbornly. Consider the customer reviews left on e-commerce sites such as Amazon, IMDb, and Tri- pAdvisor. Some are short: ‚Äúit stinks!‚Äù.bubuOthers ramble for pages. One major advantage of deep learning over traditional methods is the comparative grace with which modern models can handle varying-length data. Generally, the more data we have, the easier our job becomes. When we have more data, we can train more powerful models and rely less heavily on preconceived assumptions. The regime change from (comparatively) small to big data is a major contributor to the success of modern deep learning. To drive the point home, many of the most exciting models in deep learning do not work without large datasets. Some others might work in the small data regime, but are no better than traditional approaches. Finally, it is not enough to have lots of data and to process it cleverly. We need the right
1.2.1 Data
6

data. If the data is full of mistakes, or if the chosen features are not predictive of the target quantity of interest, learning is going to fail. The situation is captured well by the clich√©: garbage in, garbage out. Moreover, poor predictive performance is not the only poten- tial consequence. In sensitive applications of machine learning, like predictive policing, resume screening, and risk models used for lending, we must be especially alert to the con- sequences of garbage data. One commonly occurring failure mode concerns datasets where some groups of people are unrepresented in the training data. Imagine applying a skin can- cer recognition system that had never seen black skin before. Failure can also occur when the data does not only under-represent some groups but reflects societal prejudices. For ex- ample, ifpasthiringdecisionsareusedtotrainapredictivemodelthatwillbeusedtoscreen resumes then machine learning models could inadvertently capture and automate historical injustices. Note that this can all happen without the data scientist actively conspiring, or even being aware. 1.2.2 Models
Most machine learning involves transforming the data in some sense. We might want to build a system that ingests photos and predicts smiley-ness. Alternatively, we might want to ingest a set of sensor readings and predict how normal vs. anomalous the readings are. By model, we denote the computational machinery for ingesting data of one type, and spitting out predictions of a possibly different type. In particular, we are interested in statistical models that can be estimated from data. While simple models are perfectly capable of ad- dressing appropriately simple problems, the problems that we focus on in this book stretch the limits of classical methods. Deep learning is differentiated from classical approaches principally by the set of powerful models that it focuses on. These models consist of many successive transformations of the data that are chained together top to bottom, thus the name deep learning. On our way to discussing deep models, we will also discuss some more traditional methods. 1.2.3 Objective Functions
Earlier, we introduced machine learning as learning from experience. By learning here, we meanimprovingatsometaskovertime.bubuButwhoistosaywhatconstitutesanimprovement? You might imagine that we could propose updating our model, and some people might disagree on whether our proposal constituted an improvement or not. In order to develop a formal mathematical system of learning machines, we need to have formal measures of how good (or bad) our models are. In machine learning, and optimiza- tion more generally, we call these objective functions. By convention, we usually define objective functions so that lower is better. This is merely a convention. You can take any function for which higher is better, and turn it into a new function that is qualitatively iden- tical but for which lower is better by flipping the sign. Because we choose lower to be better, these functions are sometimes called loss functions. When trying to predict numerical values, the most common loss function is squared error, i.e., the square of the difference between the prediction and the ground truth target. For classification, the most common objective is to minimize error rate, i.e., the fraction of
Introduction
Kinds of Machine Learning Problems
7

examples on which our predictions disagree with the ground truth. Some objectives (e.g., squared error) are easy to optimize, while others (e.g., error rate) are difficult to optimize directly, owing to non-differentiability or other complications. In these cases, it is common instead to optimize a surrogate objective. During optimization, we think of the loss as a function of the model‚Äôs parameters, and treat the training dataset as a constant. We learn the best values of our model‚Äôs parameters by minimizing the loss incurred on a set consisting of some number of examples collected for training. However, doing well on the training data does not guarantee that we will do well on unseen data. So we will typically want to split the available data into two partitions: the training dataset (or training set), for learning model parameters; and the test dataset (or test set), which is held out for evaluation. At the end of the day, we typically report how our models perform on both partitions. You could think of training performance as analogous to the scores that a student achieves on the practice exams used to prepare for some real final exam. Even if the results are encouraging, that does not guarantee success on the final exam. Over the course of studying, the student might begin to memorize the practice questions, appearing to master the topic but faltering when faced with previously unseen questions on the actual final exam. When a model performs well on the training set but fails to generalize to unseen data, we say that it is overfitting to the training data. 1.2.4 Optimization Algorithms
Once we have got some data source and representation, a model, and a well-defined objec- tive function, we need an algorithm capable of searching for the best possible parameters for minimizing the loss function. Popular optimization algorithms for deep learning are based on an approach called gradient descent. In brief, at each step, this method checks to see, for each parameter, how that training set loss would change if you perturbed that parameter by just a small amount. It would then update the parameter in the direction that lowers the loss. 1.3 Kinds of Machine Learning Problems
|
The wake word problem in our motivating example is just one among many that machine learning can tackle. To motivate the reader further and provide us with some common language that will follow us throughout the book, we now provide a broad overview of the landscape of machine learning problems. 1.3.1 Supervised Learning
Supervised learning describes tasks where we are given a dataset containing both features and labels and asked to produce a model that predicts the labels when given input features. Each feature‚Äìlabel pair is called an example. Sometimes, when the context is clear, we may use the term examples to refer to a collection of inputs, even when the corresponding
8

labels are unknown. The supervision comes into play because, for choosing the parame- ters, we (the supervisors) provide the model with a dataset consisting of labeled examples. In probabilistic terms, we typically are interested in estimating the conditional probability of a label given input features. While it is just one among several paradigms, supervised learning accounts for the majority of successful applications of machine learning in indus- try. Partly that is because many important tasks can be described crisply as estimating the probability of something unknown given a particular set of available data:
e Predict cancer vs. not cancer, given a computer tomography image. e Predict the correct translation in French, given a sentence in English. e Predict the price of a stock next month based on this month‚Äôs financial reporting data. While all supervised learning problems are captured by the simple description ‚Äúpredicting thelabelsgiveninputfeatures‚Äù, supervisedlearningitselfcantakediverseformsandrequire tons of modeling decisions, depending on (among other considerations) the type, size, and quantity of the inputs and outputs. For example, we use different models for processing sequences of arbitrary lengths and fixed-length vector representations. We will visit many of these problems in depth throughout this book. Informally, the learning process looks something like the following. First, grab a big col- lection of examples for which the features are known and select from them a random subset, acquiring the ground truth labels for each. Sometimes these labels might be available data that have already been collected (e.g., did a patient die within the following year?) and other times we might need to employ human annotators to label the data, (e.g., assigning images to categories). Together, these inputs and corresponding labels comprise the train- ing set. We feed the training dataset into a supervised learning algorithm, a function that takes as input a dataset and outputs another function: the learned model. Finally, we can feed previously unseen inputs to the learned model, using its outputs as predictions of the corresponding label. The full process is drawn in Fig.bubu1.3.1. Training inputs | | }-‚Äî+] See |<‚Äî Training labels i ire | --H oust
tFig. 1.3.1
Supervised learning. Perhaps the simplest supervised learning task to wrap your head around is regression. Con- sider, for example, a set of data harvested from a database of home sales. We might con- struct a table, in which each row corresponds to a different house, and each column cor- responds to some relevant attribute, such as the square footage of a house, the number of bedrooms, the number of bathrooms, and the number of minutes (walking) to the center of town. In this dataset, each example would be a specific house, and the corresponding
Introduction
Regression
Kinds of Machine Learning Problems
9

feature vector would be one row in the table. If you live in New York or San Francisco, and you are not the CEO of Amazon, Google, Microsoft, or Facebook, the (sq.bubufootage, no.bubuof bedrooms, no. of bathrooms, walking distance) feature vector for your home might look something like: ¬ª600,1,1,60‚Ä¶. However, if you live in Pittsburgh, it might look more like ¬ª3000,4,3,10‚Ä¶. Fixed-length feature vectors like this are essential for most classic machine learning algorithms. What makes a problem a regression is actually the form of the target. Say that you are in the market for a new home. You might want to estimate the fair market value of a house, given some features such as above. The data here might consist of historical home listings and the labels might be the observed sales prices. When labels take on arbitrary numerical values (even within some interval), we call this a regression problem. The goal is to produce a model whose predictions closely approximate the actual label values. Lotsofpracticalproblemsareeasilydescribedasregressionproblems. Predictingtherating that a user will assign to a movie can be thought of as a regression problem and if you designed a great algorithm to accomplish this feat in 2009, you might have won the 1- million-dollar Netflix prize19. Predicting the length of stay for patients in the hospital is also a regression problem. A good rule of thumb is that any how much? or how many? problem is likely to be regression. For example:
19
e How many hours will this surgery take? e How much rainfall will this town have in the next six hours? Even if you have never worked with machine learning before, you have probably worked througharegressionprobleminformally. Imagine, forexample, thatyouhadyourdrainsre- paired and that your contractor spent 3 hours removing gunk from your sewage pipes. Then they sent you a bill of 350 dollars. Now imagine that your friend hired the same contractor for 2 hours and received a bill of 250 dollars. If someone then asked you how much to expect on their upcoming gunk-removal invoice you might make some reasonable assump- tions, such as more hours worked costs more dollars. You might also assume that there is some base charge and that the contractor then charges per hour. If these assumptions held true, then given these two data examples, you could already identify the contractor‚Äôs pricing structure: 100 dollars per hour plus 50 dollars to show up at your house. If you followed that much, then you already understand the high-level idea behind linear regression. In this case, we could produce the parameters that exactly matched the contractor‚Äôs prices. Sometimes this is not possible, e.g., if some of the variation arises from factors beyond your two features. In these cases, we will try to learn models that minimize the distance between our predictions and the observed values. In most of our chapters, we will focus on minimizing the squared error loss function. As we will see later, this loss corresponds to the assumption that our data were corrupted by Gaussian noise. Classification
Whileregressionmodelsaregreatforaddressinghowmany?bubuquestions, lotsofproblemsdo not fit comfortably in this template. Consider, for example, a bank that wants to develop a
Introduction
10

check scanning feature for its mobile app. Ideally, the customer would simply snap a photo of a check and the app would automatically recognize the text from the image. Assuming that we had some ability to segment out image patches corresponding to each handwritten character, then the primary remaining task would be to determine which character among some known set is depicted in each image patch. These kinds of which one? problems are called classification and require a different set of tools from those used for regression, although many techniques will carry over. In classification, we want our model to look at features, e.g., the pixel values in an image, and then predict to which category (sometimes called a class) among some discrete set of options, an example belongs. For handwritten digits, we might have ten classes, corre- sponding to the digits 0 through 9. The simplest form of classification is when there are only two classes, a problem which we call binary classification. For example, our dataset could consist of images of animals and our labels might be the classes {cat, dog}. Whereas in regression we sought a regressor to output a numerical value, in classification we seek a classifier, whose output is the predicted class assignment. For reasons that we will get into as the book gets more technical, it can be difficult to opti- mize a model that can only output a firm categorical assignment, e.g., either ‚Äúcat‚Äù or ‚Äúdog‚Äù. In these cases, it is usually much easier to express our model in the language of probabili- ties. Given features of an example, our model assigns a probability to each possible class. Returning to our animal classification example where the classes are {cat, dog}, a classi- fier might see an image and output the probability that the image is a cat as 0.9. We can interpret this number by saying that the classifier is 90% sure that the image depicts a cat. The magnitude of the probability for the predicted class conveys a notion of uncertainty. It is not the only one available and we will discuss others in chapters dealing with more advanced topics. Whenwehavemorethantwopossibleclasses, wecalltheproblemmulticlassclassification. Commonexamplesincludehandwrittencharacterrecognition{0, 1, 2, ...bubu9, a, b, c, ...}. While we attacked regression problems by trying to minimize the squared error loss function, the common loss function for classification problems is called cross-entropy, whose name will be demystified when we introduce information theory in later chapters. Note that the most likely class is not necessarily the one that you are going to use for your decision.bubuAssume that you find a beautiful mushroom in your backyard as shown in Fig. 1.3.2. Now, assume that you built a classifier and trained it to predict whether a mushroom is poi- sonous based on a photograph. Say our poison-detection classifier outputs that the proba- bility that Fig. 1.3.2 shows a death cap is 0.2. In other words, the classifier is 80% sure that our mushroom is not a death cap. Still, you would have to be a fool to eat it. That is because the certain benefit of a delicious dinner is not worth a 20% risk of dying from it. In other words, the effect of the uncertain risk outweighs the benefit by far. Thus, in order to make a decision about whether to eat the mushroom, we need to compute the expected detriment associated with each action which depends both on the likely outcomes and the benefits or harms associated with each. In this case, the detriment incurred by eating the mushroom
Kinds of Machine Learning Problems
11


tFig. 1.3.2
Death cap - do not eat! might be 0.2 x co + 0.8 x 0 = oo, whereas the loss of discarding it is 0.2 x 0+0.8 x 1 = 0.8. Our caution was justified: as any mycologist would tell us, the mushroom in Fig. 1.3.2 is actually a death cap. Classification can get much more complicated than just binary or multiclass classification. For instance, there are some variants of classification addressing hierarchically structured classes. Insuchcasesnotallerrorsareequal‚Äîifwemusterr, wemightprefertomisclassify to a related class rather than a distant class. Usually, this is referred to as hierarchical classification. For inspiration, you might think of Linnaeus20, who organized fauna in a hierarchy. 20
Inthecaseofanimalclassification,itmightnotbesobadtomistakeapoodleforaschnauzer, but our model would pay a huge penalty if it confused a poodle with a dinosaur. Which hierarchy is relevant might depend on how you plan to use the model. For example, rat- tlesnakes and garter snakes might be close on the phylogenetic tree, but mistaking a rattler for a garter could have fatal consequences. Some classification problems fit neatly into the binary or multiclass classification setups. For example, we could train a normal binary classifier to distinguish cats from dogs. Given thecurrentstateofcomputervision, wecandothiseasily, withoff-the-shelftools. Nonethe- less, no matter how accurate our model gets, we might find ourselves in trouble when the classifier encounters an image of the Town Musicians of Bremen, a popular German fairy tale featuring four animals (Fig. 1.3.3). As you can see, the photo features a cat, a rooster, a dog, and a donkey, with some trees in the background. If we anticipate encountering such images, multiclass classification might not be the right problem formulation. Instead, we might want to give the model the option of saying the image depicts a cat, a dog, a donkey, and a rooster. Tagging
12


tFig. 1.3.3
A donkey, a dog, a cat, and a rooster. The problem of learning to predict classes that are not mutually exclusive is called multi- label classification. Auto-tagging problems are typically best described in terms of multi- label classification. Think of the tags people might apply to posts on a technical blog, e.g., ‚Äúmachine learning‚Äù, ‚Äútechnology‚Äù, ‚Äúgadgets‚Äù, ‚Äúprogramming languages‚Äù, ‚ÄúLinux‚Äù, ‚Äúcloud computing‚Äù, ‚ÄúAWS‚Äù. A typical article might have 5‚Äì10 tags applied. Typically, tags will exhibit some correlation structure. Posts about ‚Äúcloud computing‚Äù are likely to mention ‚ÄúAWS‚Äù and posts about ‚Äúmachine learning‚Äù are likely to mention ‚ÄúGPUs‚Äù. Sometimes such tagging problems draw on enormous label sets. The National Library of Medicine employs many professional annotators who associate each article to be indexed in PubMed with a set of tags drawn from the Medical Subject Headings (MeSH) ontology, a collection of roughly 28,000 tags. Correctly tagging articles is important because it allows researchers to conduct exhaustive reviews of the literature. This is a time-consuming pro- cess and typically there is a one-year lag between archiving and tagging. Machine learning can provide provisional tags until each article has a proper manual review. Indeed, for several years, the BioASQ organization has hosted competitions21 for this task. =
21
FS
Introduction
Kinds of Machine Learning Problems
13

In the field of information retrieval, we often impose ranks on sets of items. Take web search for example. The goal is less to determine whether a particular page is relevant for a query, but rather which, among a set of relevant results, should be shown most prominently to a particular user. One way of doing this might be to first assign a score to every element in the set and then to retrieve the top-rated elements. PageRank 22 , the original secret sauce behind the Google search engine, was an early example of such a scoring system. Weirdly, the scoring provided by PageRank did not depend on the actual query. Instead, they relied on a simple relevance filter to identify the set of relevant candidates and then used PageRank to prioritize the more authoritative pages. Nowadays, search engines use machinelearningandbehavioralmodelstoobtainquery-dependentrelevancescores. There are entire academic conferences devoted to this subject. 22
Recommender Systems
Recommender systems are another problem setting that is related to search and ranking. The problems are similar insofar as the goal is to display a set of items relevant to the user. The main difference is the emphasis on personalization to specific users in the context of recommender systems. For instance, for movie recommendations, the results page for a science fiction fan and the results page for a connoisseur of Peter Sellers comedies might differ significantly. Similar problems pop up in other recommendation settings, e.g., for retail products, music, and news recommendation. In some cases, customers provide explicit feedback, communicating how much they liked a particular product (e.g., the product ratings and reviews on Amazon, IMDb, or Goodreads). In other cases, they provide implicit feedback, e.g., by skipping titles on a playlist, which might indicate dissatisfaction or maybe just indicate that the song was inappropriate in context. In the simplest formulations, these systems are trained to estimate some score, such as an expected star rating or the probability that a given user will purchase a particular item. Given such a model, for any given user, we could retrieve the set of objects with the largest scores, which could then be recommended to the user. Production systems are consider- ably more advanced and take detailed user activity and item characteristics into account when computing such scores. Fig. 1.3.4 displays the deep learning books recommended by Amazon based on personalization algorithms tuned to capture Aston‚Äôs preferences. Despite their tremendous economic value, recommender systems naively built on top of predictive models suffer some serious conceptual flaws. To start, we only observe censored feedback: users preferentially rate movies that they feel strongly about. For example, on a five-point scale, you might notice that items receive many one- and five-star ratings but that there are conspicuously few three-star ratings. Moreover, current purchase habits are often a result of the recommendation algorithm currently in place, but learning algorithms do not always take this detail into account. Thus it is possible for feedback loops to form where a recommender system preferentially pushes an item that is then taken to be better (due to greater purchases) and in turn is recommended even more frequently. Many of
Search
14

Deep Learning (Adaptive Fundamentals of Deep Hands-On Machine Learning Deep Learning: A Practitioners Deep Learning with Keras: Computation and Machine Learning: Designing Next- ‚Äòwith Sekit-Leam and ‚ÄòApproach Aug 20,2017 Introduction to Deep Learning Learning series) Nov 18,2016 Generation Machine TensorFlow Concepts, Tools, ik Seaniion with Keras Jus, 2017 seios.trecolaaas Intelligence Algorithms sun29, and Techniques to Build Paperback $0.00 - $14.55 prime Hardcover, Kindle Eon 2017 $2499.bubu$5157 Paperback, Kindle ation Hiefet: + $2249 - $5460 Sore | FREE One-Day re ia = = Some | FREE One-Day Paperback, Kindle Elton bt e Paperback, Kindle Eton Peeehns deiewtrnr +5 * NING salute Beginner Deep Learning Python Deep ‚Äòsaat Bestmes with Keras Learning Deep Learning with Keras Apr Python Deep Learning Apr 29, Deep Learning with Python Neural Networks and Deep Machine Learning for Absolute 25,2017 2017 or, 2017 Leaming Ape 15,2017 Beginners: A Plain English $52.49 - $48.99 prime $5859 - $49.49 vonime $4748 spre $009 - $15.75 prime Introduction Apr 3, 2017 Paperback, Kinde Eton Paperback Kindle Edition Paperback Paperback, Kindle Eaton $0.00 - $989 prime Pew wetey +12 Setetetet 2 eerie +20 Paperback, Kindle Edition RHR +33
tFig. 1.3.4
Deep learning books recommended by Amazon.bubuthese problems‚Äîabout how to deal with censoring, incentives, and feedback loops‚Äîare important open research questions. Sequence Learning
Sofar, wehavelooked at problemswhere wehavesomefixed numberofinputsandproduce a fixed number of outputs. For example, we considered predicting house prices given a fixed set of features: square footage, number of bedrooms, number of bathrooms, and the transit time to downtown. We also discussed mapping from an image (of fixed dimension) to the predicted probabilities that it belongs to each among a fixed number of classes and predicting star ratings associated with purchases based on the user ID and product ID alone. In these cases, once our model is trained, after each test example is fed into our model, it is immediately forgotten. We assumed that successive observations were independent and thus there was no need to hold on to this context. But how should we deal with video snippets? In this case, each snippet might consist of a different number of frames. And our guess of what is going on in each frame might be much stronger if we take into account the previous or succeeding frames. The same goes for language. For example, one popular deep learning problem is machine translation: the task of ingesting sentences in some source language and predicting their translations in another language. Such problems also occur in medicine. We might want a model to monitor patients in the intensive care unit and to fire off alerts whenever their risk of dying in the next 24 hours exceeds some threshold. Here, we would not throw away everything that we know about
Introduction
Kinds of Machine Learning Problems
15

the patient history every hour, because we might not want to make predictions based only on the most recent measurements. Questions like these are among the most exciting applications of machine learning and they are instances of sequence learning. They require a model either to ingest sequences of inputs or to emit sequences of outputs (or both). Specifically, sequence-to-sequence learning considers problems where both inputs and outputs consist of variable-length se- quences. Examples include machine translation and speech-to-text transcription. While it is impossible to consider all types of sequence transformations, the following special cases are worth mentioning. Tagging and Parsing. This involves annotating a text sequence with attributes. Here, the inputs and outputs are aligned, i.e., they are of the same number and occur in a corre- sponding order. For instance, in part-of-speech (PoS) tagging, we annotate every word in a sentence with the corresponding part of speech, i.e., ‚Äúnoun‚Äù or ‚Äúdirect object‚Äù. Alterna- tively, we might want to know which groups of contiguous words refer to named entities, like people, places, or organizations. In the cartoonishly simple example below, we might just want to indicate whether or not any word in the sentence is part of a named entity (tagged as ‚ÄúEnt‚Äù). Tom has dinner in Washington with Sally Ent - - - Ent - Ent
Automatic Speech Recognition. With speech recognition, the input sequence is an audio recording of a speaker (Fig. 1.3.5), and the output is a transcript of what the speaker said. The challenge is that there are many more audio frames (sound is typically sampled at 8kHz or 16kHz) than text, i.e., there is no 1:1 correspondence between audio and text, since thousands of samples may correspond to a single spoken word. These are sequence- to-sequence learning problems, where the output is much shorter than the input. While humans are remarkably good at recognizing speech, even from low-quality audio, getting computers to perform the same feat is a formidable challenge. {obo np li | bin
tFig.bubu1.3.5
-D-e-e-p- L-ea-r-ni-ng- in an audio recording. Text to Speech. This is the inverse of automatic speech recognition. Here, the input is text and the output is an audio file. In this case, the output is much longer than the input. Machine Translation. Unlike the case of speech recognition, where corresponding inputs and outputs occur in the same order, in machine translation, unaligned data poses a new challenge. Here the input and output sequences can have different lengths, and the corre-
16

sponding regions of the respective sequences may appear in a different order. Consider the following illustrative example of the peculiar tendency of Germans to place the verbs at the end of sentences:
German: Haben Sie sich schon dieses grossartige Lehrwerk angeschaut? English: Have you already looked at this excellent textbook?bubuWrong alignment: Have you yourself already this excellent textbook looked at? Many related problems pop up in other learning tasks. For instance, determining the order in which a user reads a webpage is a two-dimensional layout analysis problem. Dialogue problems exhibit all kinds of additional complications, where determining what to say next requires taking into account real-world knowledge and the prior state of the conversation across long temporal distances. Such topics are active areas of research. 1.3.2 Unsupervised and Self-Supervised Learning
The previous examples focused on supervised learning, where we feed the model a giant dataset containing both the features and corresponding label values. You could think of the supervised learner as having an extremely specialized job and an extremely dictatorial boss. The boss stands over the learner‚Äôs shoulder and tells them exactly what to do in every situation until they learn to map from situations to actions. Working for such a boss sounds pretty lame. On the other hand, pleasing such a boss is pretty easy. You just recognize the pattern as quickly as possible and imitate the boss‚Äôs actions. Considering the opposite situation, it could be frustrating to work for a boss who has no idea what they want you to do. However, if you plan to be a data scientist, you had better get used to it. The boss might just hand you a giant dump of data and tell you to do some data science with it! This sounds vague because it is vague. We call this class of problems unsupervised learning, and the type and number of questions we can ask is limited only by our creativity. We will address unsupervised learning techniques in later chapters. To whet your appetite for now, we describe a few of the following questions you might ask. e Can we find a small number of prototypes that accurately summarize the data? Given a
set of photos, can we group them into landscape photos, pictures of dogs, babies, cats, and mountain peaks? Likewise, given a collection of users‚Äô browsing activities, can we group them into users with similar behavior? This problem is typically known as clustering.bubue Can we find a small number of parameters that accurately capture the relevant properties of the data? The trajectories of a ball are well described by velocity, diameter, and mass of the ball. Tailors have developed a small number of parameters that describe human body shape fairly accurately for the purpose of fitting clothes. These problems are referred to as subspace estimation. If the dependence is linear, it is called principal component analysis. e Is there a representation of (arbitrarily structured) objects in Euclidean space such that
e Is there a representation of (arbitrarily structured) objects in Euclidean space such that symbolic properties can be well matched? This can be used to describe entities and their relations, such as ‚ÄúRome‚Äù ‚Äî ‚ÄúItaly‚Äù + ‚ÄúFrance‚Äù = ‚ÄúParis‚Äù. Introduction
Kinds of Machine Learning Problems
17

e Is there a description of the root causes of much of the data that we observe? For instance,
if we have demographic data about house prices, pollution, crime, location, education, and salaries, can we discover how they are related simply based on empirical data? The fields concerned with causality and probabilistic graphical models tackle such questions. e Another important and exciting recent development in unsupervised learning is the ad- vent of deep generative models. These models estimate the density of the data, either explicitly or implicitly. Once trained, we can use a generative model either to score examples according to how likely they are, or to sample synthetic examples from the learned distribution. Early deep learning breakthroughs in generative modeling came with the invention of variational autoencoders (Kingma and Welling, 2014, Rezende et al., 2014) and continued with the development of generative adversarial networks (Goodfellow et al., 2014). More recent advances include normalizing flows (Dinh et al., 2014, Dinh er al., 2017) and diffusion models (Ho et al., 2020, Sohl-Dickstein et al., 2015, Song and Ermon, 2019, Song ef al., 2021). A further development in unsupervised learning has been the rise of self-supervised learn- ing, techniques that leverage some aspect of the unlabeled data to provide supervision. For text, we can train models to ‚Äúfill in the blanks‚Äù by predicting randomly masked words us- ing their surrounding words (contexts) in big corpora without any labeling effort (Devlin et al., 2018)! For images, we may train models to tell the relative position between two cropped regions of the same image (Doersch et al., 2015), to predict an occluded part of an image based on the remaining portions of the image, or to predict whether two examples are perturbed versions of the same underlying image. Self-supervised models often learn representations that are subsequently leveraged by fine-tuning the resulting models on some downstream task of interest. 1.3.3 Interacting with an Environment
So far, we have not discussed where data actually comes from, or what actually happens when a machine learning model generates an output. That is because supervised learning and unsupervised learning do not address these issues in a very sophisticated way. In each case, we grab a big pile of data upfront, then set our pattern recognition machines in motion without ever interacting with the environment again. Because all the learning takes place after the algorithm is disconnected from the environment, this is sometimes called offline learning. For example, supervised learning assumes the simple interaction pattern depicted in Fig. 1.3.6. This simplicity of offline learning has its charms. The upside is that we can worry about pattern recognition in isolation, with no concern about complications arising from interac- tions with a dynamic environment. But this problem formulation is limiting. If you grew up reading Asimov‚Äôs Robot novels, then you probably picture artificially intelligent agents capable not only of making predictions, but also of taking actions in the world. We want to think about intelligent agents, not just predictive models. This means that we need to think about choosing actions, not just making predictions. In contrast to mere predictions, actions actually impact the environment. If we want to train an intelligent agent, we must
18

Environment Training inputs | |}-¬ª| Supervised [| learning i Input [‚Äî>} Model [‚Äî+ Output Training labels
tFig. 1.3.6
Collecting data for supervised learning from an environment. account for the way its actions might impact the future observations of the agent, and so offline learning is inappropriate. Considering the interaction with an environment opens a whole set of new modeling ques- tions. The following are just a few examples. e Does the environment remember what we did previously? e Does the environment want to help us, e.g., a user reading text into a speech recognizer? e Does the environment want to beat us, e.g., spammers adapting their emails to evade
spam filters? e Does the environment have shifting dynamics? For example, would future data always
resemble the past or would the patterns change over time, either naturally or in re- sponse to our automated tools? These questions raise the problem of distribution shift, where training and test data are different. An example of this, that many of us may have met, is when taking exams written by a lecturer, while the homework was composed by their teaching assistants. Next, we briefly describe reinforcement learning, a rich framework for posing learning problems in which an agent interacts with an environment. 1.3.4 Reinforcement Learning
If you are interested in using machine learning to develop an agent that interacts with an environment and takes actions, then you are probably going to wind up focusing on re- inforcement learning. This might include applications to robotics, to dialogue systems, and even to developing artificial intelligence (AI) for video games. Deep reinforcement learning, which applies deep learning to reinforcement learning problems, has surged in popularity. The breakthrough deep Q-network, that beat humans at Atari games using only the visual input (Mnih et al., 2015), and the AlphaGo program, which dethroned the world champion at the board game Go (Silver et al., 2016), are two prominent examples. Reinforcement learning gives a very general statement of a problem in which an agent inter- acts with an environment over a series of time steps. At each time step, the agent receives some observation from the environment and must choose an action that is subsequently transmitted back to the environment via some mechanism (sometimes called an actuator), when, after each loop, the agent receives a reward from the environment. This process is
Introduction
Kinds of Machine Learning Problems
19

illustrated in Fig. 1.3.7. The agent then receives a subsequent observation, and chooses a subsequent action, and so on. The behavior of a reinforcement learning agent is governed by a policy. In brief, a policy is just a function that maps from observations of the environ- ment to actions. The goal of reinforcement learning is to produce good policies. ( Action P| Ly Observation _ |
tFig. 1.3.7
The interaction between reinforcement learning and an environment. It is hard to overstate the generality of the reinforcement learning framework. For example, supervised learning can be recast as reinforcement learning. Say we had a classification problem. We could create a reinforcement learning agent with one action corresponding to each class. We could then create an environment which gave a reward that was exactly equal to the loss function from the original supervised learning problem. Further, reinforcement learning can also address many problems that supervised learning cannot. Forexample, in supervised learning, we alwaysexpect thatthe training inputcomes associated with the correct label. But in reinforcement learning, we do not assume that, for each observation the environment tells us the optimal action. In general, we just get some reward. Moreover, the environment may not even tell us which actions led to the reward. Consider the game of chess. The only real reward signal comes at the end of the game when we either win, earning a reward of, say, 1, or when we lose, receiving a reward of, say, ‚Äî1. So reinforcement learners must deal with the credit assignment problem: determining which actions to credit or blame for an outcome. The same goes for an employee who gets a promotion on October 11. That promotion likely reflects a number of well-chosen actions over the previous year. Getting promoted in the future requires figuring out which actions along the way led to the earlier promotions. Reinforcement learners may also have to deal with the problem of partial observability. That is, the current observation might not tell you everything about your current state. Say your cleaning robot found itself trapped in one of many identical closets in your house. Rescuing the robot involves inferring its precise location which might require considering earlier observations prior to it entering the closet. Finally, at any given point, reinforcement learners might know of one good policy, but there might be many other better policies that the agent has never tried. The reinforcement learner must constantly choose whether to exploit the best (currently) known strategy as a policy, or to explore the space of strategies, potentially giving up some short-term reward in exchange for knowledge. The general reinforcement learning problem has a very general setting. Actions affect sub-
20

sequent observations. Rewards are only observed when they correspond to the chosen ac- tions. The environment may be either fully or partially observed. Accounting for all this complexity at once may be asking too much. Moreover, not every practical problem ex- hibits all this complexity. As a result, researchers have studied a number of special cases of reinforcement learning problems. When the environment is fully observed, we call the reinforcement learning problem a Markov decision process. When the state does not depend on the previous actions, we call it a contextual bandit problem. When there is no state, just a set of available actions with initially unknown rewards, we have the classic multi-armed bandit problem. 1.4 Roots
eC
We have just reviewed a small subset of problems that machine learning can address. For a diverse set of machine learning problems, deep learning provides powerful tools for their solution. Although many deep learning methods are recent inventions, the core ideas be- hind learning from data have been studied for centuries. In fact, humans have held the desire to analyze data and to predict future outcomes for ages, and it is this desire that is at the root of much of natural science and mathematics. Two examples are the Bernoulli distribution, named after Jacob Bernoulli (1655‚Äì1705) 23 , and the Gaussian distribution discovered by Carl Friedrich Gauss (1777‚Äì1855)24. Gauss invented, for instance, the least mean squares algorithm, which is still used today for a multitude of problems from insur- ance calculations to medical diagnostics. Such tools enhanced the experimental approach in the natural sciences‚Äîfor instance, Ohm‚Äôs law relating current and voltage in a resistor is perfectly described by a linear model. 23
24
Even in the middle ages, mathematicians had a keen intuition of estimates. For instance, the geometry book of Jacob K√∂bel (1460‚Äì1533) 25 illustrates averaging the length of 16 adult men‚Äôs feet to estimate the typical foot length in the population (Fig. 1.4.1). 25
;
As a group of individuals exited a church, 16 adult men were asked to line up in a row and have their feet measured. The sum of these measurements was then divided by 16 to obtain an estimate for what now is called one foot. This ‚Äúalgorithm‚Äù was later improved to deal with misshapen feet; The two men with the shortest and longest feet were sent away, averaging only over the remainder. This is among the earliest examples of a trimmed mean estimate. Statistics really took off with the availability and collection of data. One of its pioneers, Ronald Fisher (1890‚Äì1962)26, contributed significantly to its theory and also its applica- tions in genetics. Many of his algorithms (such as linear discriminant analysis) and con- cepts (such as the Fisher information matrix) still hold a prominent place in the founda- tions of modern statistics. Even his data resources had a lasting impact. The Iris dataset that Fisher released in 1936 is still sometimes used to demonstrate machine learning algo- rithms. Fisher was also a proponent of eugenics, which should remind us that the morally
26
Introduction
21

ry a al Rin
tFig. 1.4.1
Estimating the length of a foot. dubious use of data science has as long and enduring a history as its productive use in industry and the natural sciences. Other influences for machine learning came from the information theory of Claude Shan- non (1916‚Äì2001)27 and the theory of computation proposed by Alan Turing (1912‚Äì1954) 28. Turing posed the question ‚Äúcan machines think?‚Äù in his famous paper Computing Ma- chinery and Intelligence (Turing, 1950). Describing what is now known as the Turing test, he proposed that a machine can be considered intelligent if it is difficult for a human evalu- ator to distinguish between the replies from a machine and those of a human, based purely on textual interactions. 27
28
Further influences came from neuroscience and psychology. After all, humans clearly ex- hibit intelligent behavior. Many scholars have asked whether one could explain and pos- sibly reverse engineer this capacity. One of the first biologically inspired algorithms was formulated by Donald Hebb (1904‚Äì1985)29. In his groundbreaking book The Organiza- tion of Behavior (Hebb, 1949), he posited that neurons learn by positive reinforcement. This became known as the Hebbian learning rule. These ideas inspired later work, such as Rosenblatt‚Äôs perceptron learning algorithm, and laid the foundations of many stochastic gradient descent algorithms that underpin deep learning today: reinforce desirable behav- ior and diminish undesirable behavior to obtain good settings of the parameters in a neural network. 29
Roots
22

Biological inspiration is what gave neural networks their name. For over a century (dating back to the models of Alexander Bain, 1873, and James Sherrington, 1890), researchers havetriedtoassemblecomputationalcircuitsthatresemblenetworksofinteractingneurons. Over time, the interpretation of biology has become less literal, but the name stuck. At its heart lie a few key principles that can be found in most networks today:
e The alternation of linear and nonlinear processing units, often referred to as layers. e The use of the chain rule (also known as backpropagation) for adjusting parameters in
the entire network at once. After initial rapid progress, research in neural networks languished from around 1995 until 2005. This was mainly due to two reasons. First, training a network is computationally very expensive. While random-access memory was plentiful at the end of the past century, computational power was scarce. Second, datasets were relatively small. In fact, Fisher‚Äôs Iris dataset from 1936 was still a popular tool for testing the efficacy of algorithms. The MNIST dataset with its 60,000 handwritten digits was considered huge. Given the scarcity of data and computation, strong statistical tools such as kernel methods, decision trees, and graphical models proved empirically superior in many applications. Moreover, unlike neural networks, they did not require weeks to train and provided pre- dictable results with strong theoretical guarantees. 1.5 The Road to Deep Learning

Much of this changed with the availability of massive amounts of data, thanks to the World Wide Web, the advent of companies serving hundreds of millions of users online, a dis- semination of low-cost, high-quality sensors, inexpensive data storage (Kryder‚Äôs law), and cheap computation (Moore‚Äôs law). In particular, the landscape of computation in deep learning was revolutionized by advances in GPUs that were originally engineered for com- puter gaming. Suddenly algorithms and models that seemed computationally infeasible were within reach. This is best illustrated in tab_intro_decade.bubu:Dataset vs. computer memory and computational power
Table 1.5.1: label:tab_intro_decade
Introduction
The Road to Deep Learning
23

Decade Dataset Mem- Floating point calculations per ory second 1970 100 (Iris) 1 KB 100 KF (Intel 8080) 1980 1 K (house prices in Boston) 100 1 MF (Intel 80186) KB 1990 10 K (optical character recog- 10 MB 10 MF (Intel 80486) nition) 2000 10 M (web pages) 100 1 GF (Intel Core) MB 2010 10 G (advertising) 1 GB 1 TF (NVIDIA C2050) 2020 1 T (social network) 100 1 PF (NVIDIA DGX-2) GB
Note that random-access memory has not kept pace with the growth in data. At the same time, increases in computational power have outpaced the growth in datasets. This means that statistical models need to become more memory efficient, and so they are free to spend more computer cycles optimizing parameters, thanks to the increased compute budget. Consequently, the sweet spot in machine learning and statistics moved from (generalized) linear models and kernel methods to deep neural networks. This is also one of the rea- sons why many of the mainstays of deep learning, such as multilayer perceptrons (McCul- loch and Pitts, 1943), convolutional neural networks (LeCun et al., 1998), long short-term memory(HochreiterandSchmidhuber, 1997), andQ-Learning(WatkinsandDayan, 1992), were essentially ‚Äúrediscovered‚Äù in the past decade, after lying comparatively dormant for considerable time. The recent progress in statistical models, applications, and algorithms has sometimes been likened to the Cambrian explosion: a moment of rapid progress in the evolution of species. Indeed, the state of the art is not just a mere consequence of available resources applied to decades-old algorithms. Note that the list of ideas below barely scratches the surface of what has helped researchers achieve tremendous progress over the past decade. e Novel methods for capacity control, such as dropout (Srivastava et al., 2014), have helped
to mitigate overfitting. Here, noise is injected (Bishop, 1995) throughout the neural network during training. e Attention mechanisms solved a second problem that had plagued statistics for over a century: how to increase the memory and complexity of a system without increasing the number of learnable parameters. Researchers found an elegant solution by using what can only be viewed as a learnable pointer structure (Bahdanau et al., 2014). Rather than having to remember an entire text sequence, e.g., for machine translation in a fixed-dimensional representation, all that needed to be stored was a pointer to the intermediate state of the translation process. This allowed for significantly increased accuracy for long sequences, since the model no longer needed to remember the entire sequence before commencing the generation of a new one. e Built solely on attention mechanisms, the Transformer architecture (Vaswani et al., 2017)
24

has demonstrated superior scaling behavior: it performs better with an increase in dataset size, model size, and amount of training compute (Kaplan et al., 2020). This architecture has demonstrated compelling success in a wide range of areas, such as natural language processing (Brown et al., 2020, Devlin et al., 2018), computer vision (Dosovitskiy et al., 2021, Liu et al., 2021), speech recognition (Gulati et al., 2020), reinforcement learning (Chen et al., 2021), and graph neural networks (Dwivedi and Bresson, 2020). For example, a single Transformer pretrained on modalities as diverse as text, images, joint torques, and button presses can play Atari, caption images, chat, and control a robot (Reed et al., 2022). e Modeling probabilities of text sequences, Janguage models can predict text given other text. Scaling up the data, model, and compute has unlocked a growing number of capabilities of language models to perform desired tasks via human-like text genera- tion based on input text (Anil et al., 2023, Brown et al., 2020, Chowdhery et al., 2022, Hoffmann et al., 2022, OpenAL, 2023, Rae et al., 2021, Touvron et al., 2023a, Touvron et al., 2023b). For instance, aligning language models with human intent (Ouyang et al., 2022), OpenAI‚Äôs ChatGPT 30 allows users to interact with it in a conversational way to solve problems, such as code debugging and creative writing. 30
e Multi-stage designs, e.g., via the memory networks (Sukhbaatar et al., 2015) and the neu- ral programmer-interpreter (Reed and De Freitas, 2015) permitted statistical modelers to describe iterative approaches to reasoning. These tools allow for an internal state of the deep neural network to be modified repeatedly, thus carrying out subsequent steps in a chain of reasoning, just as a processor can modify memory for a computation. e A key development in deep generative modeling was the invention of generative adver- sarial networks (Goodfellow et al., 2014). Traditionally, statistical methods for density estimation and generative models focused on finding proper probability distributions and (often approximate) algorithms for sampling from them. As a result, these algo- rithms were largely limited by the lack of flexibility inherent in the statistical models. The crucial innovation in generative adversarial networks was to replace the sampler by an arbitrary algorithm with differentiable parameters. These are then adjusted in such a way that the discriminator (effectively a two-sample test) cannot distinguish fake from real data. Through the ability to use arbitrary algorithms to generate data, density estimation was opened up to a wide variety of techniques. Examples of gal- loping zebras (Zhu ef al., 2017) and of fake celebrity faces (Karras et al., 2017) are each testimony to this progress. Even amateur doodlers can produce photorealistic images just based on sketches describing the layout of a scene (Park et al., 2019). e Furthermore, while the diffusion process gradually adds random noise to data samples, diffusion models (Ho et al., 2020, Sohl-Dickstein et al., 2015) learn the denoising pro- cess to gradually construct data samples from random noise, reversing the diffusion process. They have started to replace generative adversarial networks in more recent deep generative models, such as in DALL-E 2 (Ramesh et al., 2022) and Imagen (Sa- haria et al., 2022) for creative art and image generation based on text descriptions. e In many cases, a single GPU is insufficient for processing the large amounts of data
Introduction
Success Stories
25

available for training. Over the past decade the ability to build parallel and distributed training algorithms has improved significantly. One of the key challenges in designing scalable algorithms is that the workhorse of deep learning optimization, stochastic gradient descent, relies on relatively small minibatches of data to be processed. At the same time, small batches limit the efficiency of GPUs. Hence, training on 1,024 GPUs with a minibatch size of, say, 32 images per batch amounts to an aggregate minibatch of about 32,000 images. Work, first by Li (2017) and subsequently by You et al.bubu(2017) and Jia et al. (2018) pushed the size up to 64,000 observations, reducing training time for the ResNet-50 model on the ImageNet dataset to less than 7 minutes. By comparison, training times were initially of the order of days. ic
=
31
io
SE
@ The ability to parallelize computation has also contributed to progress in reinforcement
32
learning. This has led to significant progress in computers achieving superhuman performance on tasks like Go, Atari games, Starcraft, and in physics simulations (e.g., 33 using MuJoCo) where environment simulators are available. See, e.g., Silver et al.bubu(2016)foradescriptionofsuchachievementsinAlphaGo. Inanutshell, reinforcement learning works best if plenty of (state, action, reward) tuples are available. Simulation provides such an avenue.bubu34
e Deep learning frameworks have played a crucial role in disseminating ideas. The first generation of open-source frameworks for neural network modeling consisted of Caffe eae 31 Torch 32, and Theano**. Many seminal papers were written using these tools. ie These have now been superseded by TensorFlow** (often used via its high-level API Keras ¬∞¬∞ ), CNTK ¬∞¬∞ , Caffe 23‚Äù, and Apache MXNet *¬Æ. The third generation of Ree frameworks consists of so-called imperative tools for deep learning, a trend that was i arguably ignited by Chainer ¬∞¬∞ , which used a syntax similar to Python NumPy to describe models. This idea was adopted by both PyTorch*¬∞ , the Gluon API‚Äò! of MXNet, and JAX*?. 35
36
MXNet, and JAX42. 37
The division of labor between system researchers building better tools and statistical mod- elers building better neural networks has greatly simplified things. For instance, training a linear logistic regression model used to be a nontrivial homework problem, worthy to give to new machine learning Ph.D. students at Carnegie Mellon University in 2014. By now, this task can be accomplished with under 10 lines of code, putting it firmly within the reach of any programmer. 38
39
1.6 Success Stories
40

41
Artificial intelligence has a long history of delivering results that would be difficult to ac- complish otherwise. For instance, mail sorting systems using optical character recognition have been deployed since the 1990s. This is, after all, the source of the famous MNIST dataset of handwritten digits. The same applies to reading checks for bank deposits and scoring creditworthiness of applicants. Financial transactions are checked for fraud auto-
42
26

matically. This forms the backbone of many e-commerce payment systems, such as PayPal, Stripe, AliPay, WeChat, Apple, Visa, and MasterCard. Computer programs for chess have been competitive for decades. Machine learning feeds search, recommendation, personal- ization, and ranking on the Internet. In other words, machine learning is pervasive, albeit often hidden from sight. It is only recently that AI has been in the limelight, mostly due to solutions to problems that were considered intractable previously and that are directly related to consumers. Many of such advances are attributed to deep learning. e Intelligent assistants, such as Apple‚Äôs Siri, Amazon‚Äôs Alexa, and Google‚Äôs assistant, are able to respond to spoken requests with a reasonable degree of accuracy. This in- cludes menial jobs, like turning on light switches, and more complex tasks, such as arranging barber‚Äôs appointments and offering phone support dialog. This is likely the most noticeable sign that Al is affecting our lives. e A key ingredient in digital assistants is their ability to recognize speech accurately. The
accuracy of such systems has gradually increased to the point of achieving parity with humans for certain applications (Xiong et al., 2018). e Object recognition has likewise come a long way. Identifying the object in a picture was a fairly challenging task in 2010. On the ImageNet benchmark researchers from NEC Labs and University of Illinois at Urbana-Champaign achieved a top-five error rate of 28% (Lin et al., 2010). By 2017, this error rate was reduced to 2.25% (Hu et al., 2018). Similarly, stunning results have been achieved for identifying birdsong and for diagnosing skin cancer. e Prowess in games used to provide a measuring stick for human ability. Starting from TD-Gammon, a program for playing backgammon using temporal difference rein- forcement learning, algorithmic and computational progress has led to algorithms for a wide range of applications. Compared with backgammon, chess has a much more complex state space and set of actions. DeepBlue beat Garry Kasparov using mas- sive parallelism, special-purpose hardware and efficient search through the game tree (Campbell et al., 2002). Go is more difficult still, due to its huge state space. AlphaGo reached human parity in 2015, using deep learning combined with Monte Carlo tree sampling (Silver et al., 2016). The challenge in Poker was that the state space is large and only partially observed (we do not know the opponents‚Äô cards). Libratus exceeded human performance in Poker using efficiently structured strategies (Brown and Sand- holm, 2017). e Another indication of progress in AI is the advent of self-driving vehicles. While full autonomy is not yet within reach, excellent progress has been made in this direction, with companies such as Tesla, NVIDIA, and Waymo shipping products that enable partial autonomy. What makes full autonomy so challenging is that proper driving requires the ability to perceive, to reason and to incorporate rules into a system. At present, deep learning is used primarily in the visual aspect of these problems. The rest is heavily tuned by engineers. Introduction
The Essence of Deep Learning
27

This barely scratches the surface of significant applications of machine learning. For in- stance, robotics, logistics, computational biology, particle physics, and astronomy owe some of their most impressive recent advances at least in parts to machine learning, which is thus becoming a ubiquitous tool for engineers and scientists. Frequently, questions about a coming AI apocalypse and the plausibility of a singularity have been raised in non-technical articles. The fear is that somehow machine learning systems will become sentient and make decisions, independently of their programmers, that directly impact the lives of humans. To some extent, AI already affects the livelihood of humans in direct ways: creditworthiness is assessed automatically, autopilots mostly navigate vehicles, decisions about whether to grant bail use statistical data as input. More frivolously, we can ask Alexa to switch on the coffee machine. Fortunately, we are far from a sentient AI system that could deliberately manipulate its human creators. First, AI systems are engineered, trained, and deployed in a specific, goal- oriented manner. While their behavior might give the illusion of general intelligence, it is a combination of rules, heuristics and statistical models that underlie the design. Second, at present, there are simply no tools for artificial general intelligence that are able to improve themselves, reason about themselves, and that are able to modify, extend, and improve their own architecture while trying to solve general tasks. A much more pressing concern is how AI is being used in our daily lives. It is likely that many routine tasks, currently fulfilled by humans, can and will be automated. Farm robots will likely reduce the costs for organic farmers but they will also automate harvesting op- erations. This phase of the industrial revolution may have profound consequences for large swaths of society, since menial jobs provide much employment in many countries. Fur- thermore, statistical models, when applied without care, can lead to racial, gender, or age bias and raise reasonable concerns about procedural fairness if automated to drive conse- quential decisions. It is important to ensure that these algorithms are used with care. With what we know today, this strikes us as a much more pressing concern than the potential of malevolent superintelligence for destroying humanity. 1.7 The Essence of Deep Learning
|
Thus far, we have talked in broad terms about machine learning. Deep learning is the subset of machine learning concerned with models based on many-layered neural networks. It is deep in precisely the sense that its models learn many layers of transformations. While this might sound narrow, deep learning has given rise to a dizzying array of models, techniques, problem formulations, and applications. Many intuitions have been developed to explain the benefits of depth. Arguably, all machine learning has many layers of computation, the first consisting of feature processing steps. What differentiates deep learning is that the operations learned at each of the many layers of representations are learned jointly from data. 28

The problems that we have discussed so far, such as learning from the raw audio signal, the raw pixel values of images, or mapping between sentences of arbitrary lengths and their counterparts in foreign languages, are those where deep learning excels and traditional methods falter. It turns out that these many-layered models are capable of addressing low- level perceptual data in a way that previous tools could not. Arguably the most significant commonality in deep learning methods is end-to-end training. That is, rather than assem- bling a system based on components that are individually tuned, one builds the system and then tunes their performance jointly. For instance, in computer vision scientists used to separate the process of feature engineering from the process of building machine learn- ing models. The Canny edge detector (Canny, 1987) and Lowe‚Äôs SIFT feature extractor (Lowe, 2004) reigned supreme for over a decade as algorithms for mapping images into feature vectors. In bygone days, the crucial part of applying machine learning to these problems consisted of coming up with manually-engineered ways of transforming the data into some form amenable to shallow models. Unfortunately, there is only so much that humans can accomplish by ingenuity in comparison with a consistent evaluation over mil- lions of choices carried out automatically by an algorithm. When deep learning took over, these feature extractors were replaced by automatically tuned filters that yielded superior accuracy. Thus, one key advantage of deep learning is that it replaces not only the shallow models at the end of traditional learning pipelines, but also the labor-intensive process of feature engi- neering. Moreover, by replacing much of the domain-specific preprocessing, deep learning has eliminated many of the boundaries that previously separated computer vision, speech recognition, natural language processing, medical informatics, and other application areas, thereby offering a unified set of tools for tackling diverse problems. Beyond end-to-end training, we are experiencing a transition from parametric statistical descriptions to fully nonparametric models. When data is scarce, one needs to rely on sim- plifying assumptions about reality in order to obtain useful models. When data is abundant, these can be replaced by nonparametric models that better fit the data. To some extent, this mirrors the progress that physics experienced in the middle of the previous century with the availability of computers. Rather than solving by hand parametric approximations of how electrons behave, one can now resort to numerical simulations of the associated par- tial differential equations. This has led to much more accurate models, albeit often at the expense of interpretation. Another difference from previous work is the acceptance of suboptimal solutions, dealing with nonconvex nonlinear optimization problems, and the willingness to try things before proving them. This new-found empiricism in dealing with statistical problems, combined with a rapid influx of talent has led to rapid progress in the development of practical algo- rithms, albeit in many cases at the expense of modifying and re-inventing tools that existed for decades. In the end, the deep learning community prides itself on sharing tools across academic and corporate boundaries, releasing many excellent libraries, statistical models, and trained networks as open source. It is in this spirit that the notebooks forming this book are freely available for distribution and use. We have worked hard to lower the barriers of access for
Introduction
29

anyone wishing to learn about deep learning and we hope that our readers will benefit from this. 1.8 Summary
es
Machine learning studies how computer systems can leverage experience (often data) to
improve performance at specific tasks. It combines ideas from statistics, data mining, and optimization. Often, it is used as a means of implementing AI solutions. As a class of machine learning, representational learning focuses on how to automatically find the ap- propriate way to represent data. Considered as multi-level representation learning through learning many layers of transformations, deep learning replaces not only the shallow mod- els at the end of traditional machine learning pipelines, but also the labor-intensive process of feature engineering. Much of the recent progress in deep learning has been triggered by an abundance of data arising from cheap sensors and Internet-scale applications, and by significant progress in computation, mostly through GPUs. Furthermore, the availabil- ity of efficient deep learning frameworks has made design and implementation of whole system optimization significantly easier, and this is a key component in obtaining high performance. 1.9 Exercises
a
1. Which parts of code that you are currently writing could be ‚Äúlearned‚Äù, i.e., improved by learning and automatically determining design choices that are made in your code? Does your code include heuristic design choices? What data might you need to learn the desired behavior? 2. Which problems that you encounter have many examples for their solution, yet no spe- cific way for automating them? These may be prime candidates for using deep learning. 3. Describe the relationships between algorithms, data, and computation. How do char- acteristics of the data and the current available computational resources influence the appropriateness of various algorithms? 4. Name some settings where end-to-end training is not currently the default approach but where it might be useful. Discussions43. 43
Summary
2
Preliminaries
To prepare for your dive into deep learning, you will need a few survival skills: (i) tech- niques for storing and manipulating data; (ii) libraries for ingesting and preprocessing data from a variety of sources; (iii) knowledge of the basic linear algebraic operations that we apply to high-dimensional data elements; (iv) just enough calculus to determine which di- rection to adjust each parameter in order to decrease the loss function; (v) the ability to automatically compute derivatives so that you can forget much of the calculus you just learned; (vi) some basic fluency in probability, our primary language for reasoning under uncertainty; and (vii) some aptitude for finding answers in the official documentation when you get stuck. In short, this chapter provides a rapid introduction to the basics that you will need to follow most of the technical content in this book. 2.1 Data Manipulation
ee
In order to get anything done, we need some way to store and manipulate data. Generally, there are two important things we need to do with data: (i) acquire them; and (ii) process them once they are inside the computer. There is no point in acquiring data without some way to store it, so to start, let‚Äôs get our hands dirty with ùëõ-dimensional arrays, which we also call tensors. If you already know the NumPy scientific computing package, this will be a breeze. For all modern deep learning frameworks, the tensor class (ndarray in MXNet, Tensor in PyTorch and TensorFlow) resembles NumPy‚Äôs ndarray, with a few killer fea- tures added. First, the tensor class supports automatic differentiation. Second, it leverages GPUs to accelerate numerical computation, whereas NumPy only runs on CPUs. These properties make neural networks both easy to code and fast to run. 2.1.1 Getting Started
To start, we import the PyTorch library. Note that the package name is torch. import torch
A tensor represents a (possibly multidimensional) array of numerical values. In the one- dimensional case, i.e., when only one axis is needed for the data, a tensor is called a vector. 30
Data Manipulation
31

With two axes, a tensor is called a matrix. With ùëò > 2 axes, we drop the specialized names
and just refer to the object as a ùëòth-order tensor. PyTorch provides a variety of functions for creating new tensors prepopulated with values. For example, by invoking arange(n), we can create a vector of evenly spaced values, start- ing at 0 (included) and ending at n (not included). By default, the interval size is 1. Unless otherwise specified, new tensors are stored in main memory and designated for CPU-based computation. x = torch.arange(12, dtype=torch.float32)
x
tensor([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11.])
Each of these values is called an element of the tensor. The tensor x contains 12 elements. We can inspect the total number of elements in a tensor via its numel method. x.numel()
12
Wecanaccessatensor‚Äôsshape(thelengthalongeachaxis)byinspectingitsshapeattribute. Because we are dealing with a vector here, the shape contains just a single element and is identical to the size. x.shape
torch.Size([12])
Wecanchangetheshapeofatensorwithoutalteringitssizeorvalues,byinvokingreshape. For example, we can transform our vector x whose shape is (12,) to a matrix X with shape (3, 4). This new tensor retains all elements but reconfigures them into a matrix. Notice that the elements of our vector are laid out one row at a time and thus x[3] == X[0, 3]. X = x.reshape(3, 4) X
tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.]])
Note that specifying every shape component to reshape is redundant. Because we already know our tensor‚Äôs size, we can work out one component of the shape given the rest. For example, given a tensor of size n and target shape (h, w), we know that w = n/h. To
32

automatically infer one component of the shape, we can place a -1 for the shape component that should be inferred automatically. In our case, instead of calling x.reshape(3, 4), we could have equivalently called x.reshape(-1, 4) or x.reshape(3, -1). Practitioners often need to work with tensors initialized to contain all 0s or 1s. We can construct a tensor with all elements set to 0 and a shape of (2, 3, 4) via the zeros func- tion. torch.zeros((2, 3, 4))
tensor([[[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]], [[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]])
Similarly, we can create a tensor with all 1s by invoking ones. torch.ones((2, 3, 4))
tensor([[[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]], [[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]])
We often wish to sample each element randomly (and independently) from a given prob- ability distribution. For example, the parameters of neural networks are often initialized randomly. The following snippet creates a tensor with elements drawn from a standard Gaussian (normal) distribution with mean 0 and standard deviation 1. torch.randn(3, 4)
tensor([[ 0.1351, -0.9099, -0.2028, 2.1937], [-0.3200, -0.7545, 0.8086, -1.8730], [ 0.3929, 0.4931, 0.9114, -0.7072]])
Finally, we can construct tensors by supplying the exact values for each element by sup- plying (possibly nested) Python list(s) containing numerical literals. Here, we construct a matrix with a list of lists, where the outermost list corresponds to axis 0, and the inner list corresponds to axis 1. Preliminaries
Data Manipulation
33

torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
2.1.2 Indexing and Slicing
As with Python lists, we can access tensor elements by indexing (starting with 0). To access an element based on its position relative to the end of the list, we can use negative indexing. Finally, we can access whole ranges of indices via slicing (e.g., X[start:stop]), where the returned value includes the first index (start) but not the last (stop). Finally, when only one index (or slice) is specified for a ùëòth-order tensor, it is applied along axis 0. Thus, in the following code, [-1] selects the last row and [1:3] selects the second and third rows. X[-1], X[1:3]
(tensor([ 8., 9., 10., 11.]), tensor([[ 4., 5., 6., 7.], [ 8., 9., 10., 11.]]))
Beyond reading them, we can also write elements of a matrix by specifying indices. X[1, 2] = 17 X
tensor([[ 0., 1., 2., 3.], [ 4., 5., 17., 7.], [ 8., 9., 10., 11.]])
If we want to assign multiple elements the same value, we apply the indexing on the left- hand side of the assignment operation. For instance, [:2, :] accesses the first and second rows, where : takes all the elements along axis 1 (column). While we discussed indexing formatrices, thisalsoworksforvectorsandfortensorsofmorethantwodimensions. X[:2, :] = 12 X
tensor([[12., 12., 12., 12.], [12., 12., 12., 12.], [ 8., 9., 10., 11.]])
34

2.1.3 Operations
Now that we know how to construct tensors and how to read from and write to their ele- ments, we can begin to manipulate them with various mathematical operations. Among the most useful of these are the elementwise operations. These apply a standard scalar opera- tion to each element of a tensor. For functions that take two tensors as inputs, elementwise operations apply some standard binary operator on each pair of corresponding elements. We can create an elementwise function from any function that maps from a scalar to a scalar. In mathematical notation, we denote such unary scalar operators (taking one input) by the signature ùëì : R ! R. This just means that the function maps from any real number onto some other real number. Most standard operators, including unary ones like ùëíùë•, can be applied elementwise. torch.exp(x)
tensor([162754.7969, 162754.7969, 162754.7969, 162754.7969, 162754.7969, 162754.7969, 162754.7969, 162754.7969, 2980.9580, 8103.0840, 22026.4648, 59874.1406])
Likewise, we denote binary scalar operators, which map pairs of real numbers to a (single) real number via the signature ùëì : R,R ! R. Given any two vectors u and v of the same shape, and a binary operator ùëì, we can produce a vector c = ùêπ‚Äûu,v‚Äù by setting ùëêùëñ ùëì ‚Äûùë¢ùëñ,ùë£ùëñ‚Äù for all ùëñ, where ùëêùëñ,ùë¢ùëñ, and ùë£ùëñ are the ùëñth elements of vectors c,u, and v. Here, we produced the vector-valued ùêπ : Rùëë,Rùëë ! Rùëë by lifting the scalar function to an elementwise vector operation. The common standard arithmetic operators for addition (+), subtraction (-), multiplication (*), division (/), and exponentiation (**) have all been lifted to elementwise operations for identically-shaped tensors of arbitrary shape. x = torch.tensor([1.0, 2, 4, 8]) y = torch.tensor([2, 2, 2, 2]) x + y, x - y, x * y, x / y, x ** y
(tensor([ 3., 4., 6., 10.]), tensor([-1., 0., 2., 6.]), tensor([ 2., 4., 8., 16.]), tensor([0.5000, 1.0000, 2.0000, 4.0000]), tensor([ 1., 4., 16., 64.]))
In addition to elementwise computations, we can also perform linear algebraic operations, such as dot products and matrix multiplications. We will elaborate on these in Section 2.3. We can also concatenate multiple tensors, stacking them end-to-end to form a larger one. We just need to provide a list of tensors and tell the system along which axis to concatenate. The example below shows what happens when we concatenate two matrices along rows
Preliminaries
Data Manipulation
35

(axis 0) instead of columns (axis 1). We can see that the first output‚Äôs axis-0 length (6) is the sum of the two input tensors‚Äô axis-0 lengths (3 ‚Äö 3); while the second output‚Äôs axis-1 length (8) is the sum of the two input tensors‚Äô axis-1 lengths (4 ‚Äö 4). X = torch.arange(12, dtype=torch.float32).reshape((3,4)) Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)
(tensor([[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [ 2., 1., 4., 3.], [ 1., 2., 3., 4.], [ 4., 3., 2., 1.]]), tensor([[ 0., 1., 2., 3., 2., 1., 4., 3.], [ 4., 5., 6., 7., 1., 2., 3., 4.], [ 8., 9., 10., 11., 4., 3., 2., 1.]]))
Sometimes, we want to construct a binary tensor via logical statements. Take X == Y as an example. For each position i, j, if X[i, j] and Y[i, j] are equal, then the corresponding entry in the result takes value 1, otherwise it takes value 0. X == Y
tensor([[False, True, False, True], [False, False, False, False], [False, False, False, False]])
Summing all the elements in the tensor yields a tensor with only one element. X.sum()
tensor(66.)
2.1.4 Broadcasting
By now, you know how to perform elementwise binary operations on two tensors of the same shape. Under certain conditions, even when shapes differ, we can still perform ele- mentwise binary operations by invoking the broadcasting mechanism. Broadcasting works according to the following two-step procedure: (i) expand one or both arrays by copying elements along axes with length 1 so that after this transformation, the two tensors have the same shape; (ii) perform an elementwise operation on the resulting arrays. a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))
a, b
36

(tensor([[0], [1], [2]]), tensor([[0, 1]]))
Since a and b are 3 x | and | x 2 matrices, respectively, their shapes do not match up. Since a and b are 3 x | and | x 2 matrices, respectively, their shapes do not match up. Broadcasting produces a larger 3 x 2 matrix by replicating matrix a along the columns and matrix b along the rows before adding them elementwise. a + b
tensor([[0, 1], [1, 2], [2, 3]])
2.1.5 Saving Memory
Running operations can cause new memory to be allocated to host results. For example, if we write Y = X + Y, we dereference the tensor that Y used to point to and instead point Y at the newly allocated memory. We can demonstrate this issue with Python‚Äôs id() function, which gives us the exact address of the referenced object in memory. Note that after we run Y = Y + X, id(Y) points to a different location. That is because Python first evaluates Y + X, allocating new memory for the result and then points Y to this new location in memory. before = id(Y) Y = Y + X id(Y) == before
False
This might be undesirable for two reasons. First, we do not want to run around allocat- ing memory unnecessarily all the time. In machine learning, we often have hundreds of megabytes of parameters and update all of them multiple times per second. Whenever possible, we want to perform these updates in place. Second, we might point at the same parameters from multiple variables. If we do not update in place, we must be careful to update all of these references, lest we spring a memory leak or inadvertently refer to stale parameters. Fortunately, performing in-place operations is easy. We can assign the result of an oper- ation to a previously allocated array Y by using slice notation: Y[:] = <expression>. To illustrate this concept, we overwrite the values of tensor Z, after initializing it, using zeros_like, to have the same shape as Y. Preliminaries
Data Manipulation
37

Z = torch.zeros_like(Y) print('id(Z):', id(Z)) Z[:] = X + Y print('id(Z):', id(Z))
id(Z): 140381179266448 id(Z): 140381179266448
If the value of X is not reused in subsequent computations, we can also use X[:] = X + Y or X += Y to reduce the memory overhead of the operation. before = id(X) X += Y id(X) == before
True
2.1.6 Conversion to Other Python Objects
Converting to a NumPy tensor (ndarray), or vice versa, is easy. The torch tensor and
NumPy array will share their underlying memory, and changing one through an in-place operation will also change the other. A = X.numpy() B = torch.from_numpy(A) type(A), type(B)
(numpy.ndarray, torch.Tensor)
To convert a size-1 tensor to a Python scalar, we can invoke the item function or Python‚Äôs built-in functions. a = torch.tensor([3.5]) a, a.item(), float(a), int(a)
(tensor([3.5000]), 3.5, 3.5, 3)
2.1.7 Summary
The tensor class is the main interface for storing and manipulating data in deep learning li- braries. Tensors provide a variety of functionalities including construction routines; index- ing and slicing; basic mathematics operations; broadcasting; memory-efficient assignment; and conversion to and from other Python objects. 38

2.1.8 Exercises
1.bubuRun the code in this section. Change the conditional statement X == Y to X < Y or X > Y, and then see what kind of tensor you can get. 2. Replace the two tensors that operate by element in the broadcasting mechanism with other shapes, e.g., 3-dimensional tensors. Is the result the same as expected?bubuDiscussions44. 44
2.2 Data Preprocessing
|
So far, we have been working with synthetic data that arrived in ready-made tensors. How- ever, to apply deep learning in the wild we must extract messy data stored in arbitrary formats, and preprocess it to suit our needs. Fortunately, the pandas library45 can do much of the heavy lifting. This section, while no substitute for a proper pandas tutorial46, will give you a crash course on some of the most common routines. @32@ pale
45

46
2.2.1 Reading the Dataset
Comma-separated values (CSV) files are ubiquitous for the storing of tabular (spreadsheet- like) data. In them, each line corresponds to one record and consists of several (comma- separated)fields,e.g.,‚ÄúAlbertEinstein,March141879,Ulm,Federalpolytechnicschool,field of gravitational physics‚Äù. To demonstrate how to load CSV files with pandas, we create a CSV file below ../data/house_tiny.csv. This file represents a dataset of homes, where each row corresponds to a distinct home and the columns correspond to the number of rooms (NumRooms), the roof type (RoofType), and the price (Price). import os
os.makedirs(os.path.join('..', 'data'), exist_ok=True) data_file = os.path.join('..', 'data', 'house_tiny.csv') with open(data_file, 'w') as f: f.write('''NumRooms,RoofType,Price NA,NA,127500 2,NA,106000 4,Slate,178100 NA,NA,140000''')
Now let‚Äôs import pandas and load the dataset with read_csv. import pandas as pd
data = pd.read_csv(data_file) print(data)
Preliminaries
Data Preprocessing
39

NumRooms RoofType
Price
0 NaN NaN 127500 1 2.0 NaN 106000 2 4.0 Slate 178100 3 NaN NaN 140000
2.2.2 Data Preparation
In supervised learning, we train models to predict a designated target value, given some set of input values. Our first step in processing the dataset is to separate out columns cor- responding to input versus target values. We can select columns either by name or via integer-location based indexing (iloc). You might have noticed that pandas replaced all CSV entries with value NA with a spe- cial NaN (not a number) value. This can also happen whenever an entry is empty, e.g., ‚Äú3‚Äû,270000‚Äù. These are called missing values and they are the ‚Äúbed bugs‚Äù of data science, a persistent menace that you will confront throughout your career. Depending upon the context, missing values might be handled either via imputation or deletion. Imputation re- places missing values with estimates of their values while deletion simply discards either those rows or those columns that contain missing values. Here are some common imputation heuristics. For categorical input fields, we can treat NaN as a category. Since the RoofType column takes values Slate and NaN, pandas can convert thiscolumnintotwocolumnsRoofType_SlateandRoofType_nan. Arowwhoserooftype is Slate will set values of RoofType_Slate and RoofType_nan to 1 and 0, respectively. The converse holds for a row with a missing RoofType value. inputs, targets = data.iloc[:, 0:2], data.iloc[:, 2] inputs = pd.get_dummies(inputs, dummy_na=True) print(inputs)
NumRooms RoofType_Slate RoofType_nan 0 NaN False True 1 2.0 False True 2 4.0 True False 3 NaN False True
For missing numerical values, one common heuristic is to replace the NaN entries with the mean value of the corresponding column. inputs = inputs.fillna(inputs.mean()) print(inputs)
NumRooms RoofType_Slate RoofType_nan 0 3.0 False True 1 2.0 False True
(continues on next page)
40

2
4.0
True
3 3.0 False True
2.2.3 Conversion to the Tensor Format
Now that all the entries in inputs and targets are numerical, we can load them into a tensor (recall Section 2.1). import torch
X = torch.tensor(inputs.to_numpy(dtype=float)) y = torch.tensor(targets.to_numpy(dtype=float)) X, y
(tensor([[3., 0., 1.], [2., 0., 1.], [4., 1., 0.], [3., 0., 1.]], dtype=torch.float64), tensor([127500., 106000., 178100., 140000.], dtype=torch.float64))
2.2.4 Discussion
You now know how to partition data columns, impute missing variables, and load pan- das data into tensors. In Section 5.7, you will pick up some more data processing skills.bubuWhile this crash course kept things simple, data processing can get hairy. For example, rather than arriving in a single CSV file, our dataset might be spread across multiple files extracted from a relational database. For instance, in an e-commerce application, customer addresses might live in one table and purchase data in another. Moreover, practitioners face myriad data types beyond categorical and numeric, for example, text strings, images, audio data, and point clouds. Oftentimes, advanced tools and efficient algorithms are required in order to prevent data processing from becoming the biggest bottleneck in the machine learning pipeline. These problems will arise when we get to computer vision and natural language processing. Finally, we must pay attention to data quality. Real-world datasets are often plagued by outliers, faulty measurements from sensors, and recording errors, which must be addressed before feeding the data into any model. Data visualization tools such as seaborn47, Bokeh48, or matplotlib49 can help you to manually inspect the data and develop intuitions about the type of problems you may need to address. 47
ig
GE) al
48
nem 3
49
2.2.5 Exercises
50 1. Try loading datasets, e.g., Abalone from the UCI Machine Learning Repository50 and inspect their properties. What fraction of them has missing values? What fraction of the variables is numerical, categorical, or text? 51 2. Try indexing and selecting data columns by name rather than by column number. The pandas documentation on indexing51 has further details on how to do this. Preliminaries
(continued from previous page)
False
Linear Algebra
41

3. How large a dataset do you think you could load this way? What might be the limita- tions? Hint: consider the time to read the data, representation, processing, and memory footprint. Try this out on your laptop. What happens if you try it out on a server?bubu4. How would you deal with data that has a very large number of categories? What if the category labels are all unique? Should you include the latter?bubu5. What alternatives to pandas can you think of? How about loading NumPy tensors from a file52? Check out Pillow53, the Python Imaging Library. Baasall
52
Discussions54. ae
4
gee met
53
2.3 Linear Algebra

54
By now, we can load datasets into tensors and manipulate these tensors with basic math- ematical operations. To start building sophisticated models, we will also need a few tools from linear algebra. This section offers a gentle introduction to the most essential concepts, starting from scalar arithmetic and ramping up to matrix multiplication. import torch
2.3.1 Scalars
Most everyday mathematics consists of manipulating numbers one at a time. Formally, we call these values scalars. For example, the temperature in Palo Alto is a balmy 72 degrees Fahrenheit. If you wanted to convert the temperature to Celsius you would evaluate the expression c = af ‚Äî 32), setting f to 72. In this equation, the values 5, 9, and 32 are constant scalars. The variables c and f in general represent unknown scalars. We denote scalars by ordinary lower-cased letters (e.g., ùë•, ùë¶, and ùëß) and the space of all
(continuous) real-valued scalars by R. For expedience, we will skip past rigorous defini- tions of spaces: just remember that the expression ùë• 2 R is a formal way to say that ùë• is a real-valued scalar. The symbol 2 (pronounced ‚Äúin‚Äù) denotes membership in a set. For example, ùë•, ùë¶ 2 f0,1g indicates that ùë• and ùë¶ are variables that can only take values 0 or 1. Scalars are implemented as tensors that contain only one element. Below, we assign two scalars and perform the familiar addition, multiplication, division, and exponentiation op- erations. x = torch.tensor(3.0)
y = torch.tensor(2.0)
x + y, x * y, x / y, x**y
42

(tensor(5.), tensor(6.), tensor(1.5000), tensor(9.))
2.3.2 Vectors
For current purposes, you can think of a vector as a fixed-length array of scalars. As with their code counterparts, we call these scalars the elements of the vector (synonyms include entries and components). When vectors represent examples from real-world datasets, their values hold some real-world significance. For example, if we were training a model to predict the risk of a loan defaulting, we might associate each applicant with a vector whose componentscorrespondtoquantitiesliketheirincome, lengthofemployment, ornumberof previous defaults. If we were studying the risk of heart attack, each vector might represent a patient and its components might correspond to their most recent vital signs, cholesterol levels, minutes of exercise per day, etc. We denote vectors by bold lowercase letters, (e.g., x, y, and z). Vectors are implemented as 1st-order tensors. In general, such tensors can have arbitrary lengths, subject to memory limitations. Caution: in Python, as in most programming lan- guages, vector indices start at 0, also known as zero-based indexing, whereas in linear algebra subscripts begin at 1 (one-based indexing). x = torch.arange(3)
x
tensor([0, 1, 2])
We can refer to an element of a vector by using a subscript. For example, ùë•2 denotes the
second element of x. Since ùë•2 is a scalar, we do not bold it. By default, we visualize vectors by stacking their elements vertically. Here ùë•1, . . .,ùë•ùëõ are elements of the vector. Later on, we will distinguish between such
column vectors and row vectors whose elements are stacked horizontally. Recall that we access a tensor‚Äôs elements via indexing. x[2]
tensor(2)
To indicate that a vector contains ùëõ elements, we write x 2 Rùëõ. Formally, we call ùëõ the
dimensionality of the vector. In code, this corresponds to the tensor‚Äôs length, accessible via Python‚Äôs built-in len function. Preliminaries
2
3
x = 6 6 6 6 6 4 ùë•1 ... ùë•ùëõ 7 7 7 7 7 5 , (2.3.1)
Linear Algebra
43

len(x)
3
We can also access the length via the shape attribute. The shape is a tuple that indicates a tensor‚Äôs length along each axis. Tensors with just one axis have shapes with just one element. x.shape
torch.Size([3])
Oftentimes, the word ‚Äúdimension‚Äù gets overloaded to mean both the number of axes and the length along a particular axis. To avoid this confusion, we use order to refer to the number of axes and dimensionality exclusively to refer to the number of components. 2.3.3 Matrices
Just as scalars are 0"*-order tensors and vectors are 1‚Äòt-order tensors, matrices are 2"'-order tensors. We denote matrices by bold capital letters (e.g., X, Y, and Z), and represent them in code by tensors with two axes. The expression A ‚Ç¨ R‚Äù‚Ñ¢‚Äù indicates that a matrix A contains m Xx n real-valued scalars, arranged as m rows and n columns. When m = n, we say that a matrix is square. Visually, we can illustrate any matrix as a table. To refer to an individual element, we subscript both the row and column indices, e.g., a;; is the value that belongs to A‚Äôs i‚Äù row and j"* column:
2
ait ai2 sts Ain a2 a22 sts In A=|. 2.bubut. (2.3.2) Ami Gm2 *** Gmn
In code, we represent a matrix A ‚Ç¨ R‚Äù*‚Äù by a 2"‚Ñ¢-order tensor with shape (m, n). We can
In code, we represent a matrix A ‚Ç¨ R‚Äù*‚Äù by a 2"‚Ñ¢-order tensor with shape (m, n). We can convert any appropriately sized m x n tensor into an m X n matrix by passing the desired shape to reshape:
A = torch.arange(6).reshape(3, 2) A
tensor([[0, 1], [2, 3], [4, 5]])
Sometimes we want to flip the axes. When we exchange a matrix‚Äôs rows and columns, the result is called its transpose. Formally, we signify a matrix A‚Äôs transpose by A> and if
3
44

B= A", then bj; = aj; for alli and j. Thus, the transpose of an m x n matrix is ann X m
matrix:
2
A> = 6 6 6 6 6 6 6 4 ùëé11 ùëé12 ... ùëé1ùëõ ùëé21 ùëé22 ...bubuùëé2ùëõ . .bubu. . . . ... . .bubu. ùëéùëö1 ùëéùëö2 ...bubuùëéùëöùëõ 7 7 7 7 7 7 7 5 . (2.3.3)
In code, we can access any matrix‚Äôs transpose as follows:
A.T
tensor([[0, 2, 4], [1, 3, 5]])
Symmetric matrices are the subset of square matrices that are equal to their own transposes: A = A>. The following matrix is symmetric:
A = torch.tensor([[1, 2, 3], [2, 0, 4], [3, 4, 5]]) A == A.T
tensor([[True, True, True], [True, True, True], [True, True, True]])
Matrices are useful for representing datasets. Typically, rows correspond to individual records and columns correspond to distinct attributes. 2.3.4 Tensors
While you can go far in your machine learning journey with only scalars, vectors, and matrices, eventually you may need to work with higher-order tensors. Tensors give us a generic way of describing extensions to n'"-order arrays. We call software objects of the tensor class ‚Äútensors‚Äù precisely because they too can have arbitrary numbers of axes. While it may be confusing to use the word tensor for both the mathematical object and its realization in code, our meaning should usually be clear from context. We denote general tensors by capital letters with a special font face (e.g., X, Y, and Z) and their indexing mechanism (e.g., x;;, and [X]1,2;-1,3) follows naturally from that of matrices. Tensors will become more important when we start working with images. Each image arrives as a 3rd-order tensor with axes corresponding to the height, width, and channel. At eachspatiallocation,theintensitiesofeachcolor(red,green,andblue)arestackedalongthe channel. Furthermore, a collection of images is represented in code by a 4th-order tensor, where distinct images are indexed along the first axis. Higher-order tensors are constructed, as were vectors and matrices, by growing the number of shape components. Preliminaries
3
Linear Algebra
45

torch.arange(24).reshape(2, 3, 4)
tensor([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])
2.3.5 Basic Properties of Tensor Arithmetic
Scalars, vectors, matrices, and higher-order tensors all have some handy properties. For ex-
ample,elementwiseoperationsproduceoutputsthathavethesameshapeastheiroperands. A = torch.arange(6, dtype=torch.float32).reshape(2, 3) B = A.clone() # Assign a copy of A to B by allocating new memory A, A + B
(tensor([[0., 1., 2.], [3., 4., 5.]]), tensor([[ 0., 2., 4.], [ 6., 8., 10.]]))
The elementwise product of two matrices is called their Hadamard product (denoted ¬©). The elementwise product of two matrices is called their Hadamard product (denoted ¬©). We can spell out the entries of the Hadamard product of two matrices A, B ‚Ç¨ R"‚Ñ¢‚Äù:
2
aby abi... AinBin azibx, ‚Äî axnb27¬´. Aan ban AoB=|_.bubua a |. (2.3.4) Ami Pmt Am2bm2--- AmnBmn
A * B
tensor([[ 0., 1., 4.], [ 9., 16., 25.]])
Adding or multiplying a scalar and a tensor produces a result with the same shape as the original tensor. Here, each element of the tensor is added to (or multiplied by) the scalar. a = 2
X = torch.arange(24).reshape(2, 3, 4)
a + X, (a * X).shape
3
46

(tensor([[[ 2, 3, 4, 5], [ 6, 7, 8, 9], [10, 11, 12, 13]], [[14, 15, 16, 17], [18, 19, 20, 21], [22, 23, 24, 25]]]), torch.Size([2, 3, 4]))
2.3.6 Reduction
Often, we wish to calculate the sum of a tensor‚Äôs elements. To express the sum of the Àùùëõ elementsinavectorxoflength ùëõ, wewrite ùë•ùëñ. Thereisasimplefunctionforit: ùëñ=1
x = torch.arange(3, dtype=torch.float32) x, x.sum()
(tensor([0., 1., 2.]), tensor(3.))
To express sums over the elements of tensors of arbitrary shape, we simply sum over all its axes. For example, the sum of the elements of an m X n matrix A could be written m sn ja Lj=1 ij:
A.shape, A.sum()
(torch.Size([2, 3]), tensor(15.))
By default, invoking the sum function reduces a tensor along all of its axes, eventually producing a scalar. Our libraries also allow us to specify the axes along which the tensor should be reduced. To sum over all elements along the rows (axis 0), we specify axis=0 in sum. Since the input matrix reduces along axis 0 to generate the output vector, this axis is missing from the shape of the output. A.shape, A.sum(axis=0).shape
(torch.Size([2, 3]), torch.Size([3]))
Specifying axis=1 will reduce the column dimension (axis 1) by summing up elements of all the columns. A.shape, A.sum(axis=1).shape
(torch.Size([2, 3]), torch.Size([2]))
Preliminaries
Linear Algebra
47

Reducing a matrix along both rows and columns via summation is equivalent to summing up all the elements of the matrix. A.sum(axis=[0, 1]) == A.sum() # Same as A.sum()
tensor(True)
A related quantity is the mean, also called the average. We calculate the mean by dividing the sum by the total number of elements. Because computing the mean is so common, it gets a dedicated library function that works analogously to sum. A.mean(), A.sum() / A.numel()
(tensor(2.5000), tensor(2.5000))
Likewise, the function for calculating the mean can also reduce a tensor along specific axes. A.mean(axis=0), A.sum(axis=0) / A.shape[0]
(tensor([1.5000, 2.5000, 3.5000]), tensor([1.5000, 2.5000, 3.5000]))
2.3.7 Non-Reduction Sum
Sometimes it can be useful to keep the number of axes unchanged when invoking the func- tion for calculating the sum or mean. This matters when we want to use the broadcast mechanism. sum_A = A.sum(axis=1, keepdims=True) sum_A, sum_A.shape
(tensor([[ 3.], [12.]]), torch.Size([2, 1]))
For instance, since sum_A keeps its two axes after summing each row, we can divide A by sum_A with broadcasting to create a matrix where each row sums up to 1. A / sum_A
tensor([[0.0000, 0.3333, 0.6667], [0.2500, 0.3333, 0.4167]])
48

If we want to calculate the cumulative sum of elements of A along some axis, say axis=0 (row by row), we can call the cumsum function. By design, this function does not reduce the input tensor along any axis. A.cumsum(axis=0)
tensor([[0., 1., 2.], [3., 5., 7.]])
2.3.8 Dot Products
Sofar,wehaveonlyperformedelementwiseoperations,sums,andaverages. Andifthiswas all we could do, linear algebra would not deserve its own section. Fortunately, this is where things get more interesting. One of the most fundamental operations is the dot product. Given two vectors x,y 2 Rùëë, their dot product x>y (also known as inner product, hx,yi) Àùùëë is a sum over the products of the elements at the same position: x>y = ùë•ùëñùë¶ùëñ. y = torch.ones(3, dtype = torch.float32) x, y, torch.dot(x, y)
(tensor([0., 1., 2.]), tensor([1., 1., 1.]), tensor(3.))
Equivalently, we can calculate the dot product of two vectors by performing an elementwise multiplication followed by a sum:
torch.sum(x * y)
tensor(3.)
Dot products are useful in a wide range of contexts. For example, given some set of val- ues, denoted by a vector x ‚Ç¨ R‚Äù, and a set of weights, denoted by w ‚Ç¨ R"‚Äù, the weighted sum of the values in x according to the weights w could be expressed as the dot product x'w. When the weights are nonnegative and sum to 1, i-e., (1, wi = 1), the dot prod- uct expresses a weighted average. After normalizing two vectors to have unit length, the dot products express the cosine of the angle between them. Later in this section, we will formally introduce this notion of length. 2.3.9 Matrix‚ÄìVector Products
Now that we know how to calculate dot products, we can begin to understand the product between an m X n matrix A and an n-dimensional vector x. To start off, we visualize our
Preliminaries
ùëñ=1
Linear Algebra
49

matrix in terms of its row vectors
where each a>
ùëñ 2 Rùëõ is a row vector representing the ùëñth row of the matrix A. The matrix‚Äìvector product Ax is simply a column vector of length ùëö, whose ùëñth element
is the dot product a> ùëñ x:
Ax = 6 6 6 6 6 6 6 4 a> 1 a> 2... a> ùëö 7 7 7 7 7 7 7 5 x = 6 6 6 6 6 6 6 4 a> 1 x a> 2 x ... a> ùëöx 7 7 7 7 7 7 7 5 . (2.3.6)
We can think of multiplication with a matrix A ‚Ç¨ R‚Äù‚Äù‚Äù as a transformation that projects
vectors from Rùëõ to Rùëö. These transformations are remarkably useful. For example, we can represent rotations as multiplications by certain square matrices. Matrix‚Äìvector products also describe the key calculation involved in computing the outputs of each layer in a neural network given the outputs from the previous layer. To express a matrix‚Äìvector product in code, we use the mv function. Note that the column dimension of A (its length along axis 1) must be the same as the dimension of x (its length). Pythonhasaconvenienceoperator@thatcanexecutebothmatrix‚Äìvectorandmatrix‚Äìmatrix products (depending on its arguments). Thus we can write A@x. A.shape, x.shape, torch.mv(A, x), A@x
(torch.Size([2, 3]), torch.Size([3]), tensor([ 5., 14.]), tensor([ 5., 14.]))
2.3.10 Matrix‚ÄìMatrix Multiplication
Once you have gotten the hang of dot products and matrix‚Äìvector products, then matrix‚Äì matrix multiplication should be straightforward. Say that we have two matrices A ‚Ç¨ R‚Äù** and B ‚Ç¨ R&*":
3
2
a1 a2 +++ Aik by big +++ Dim a1 422, + AK bo, ba +++ bom A=].bubu.bubu.|, B=]. .bubu. (2.3.7) GQn\ An2 ++" Ank bey bea +++ Dkm
Let a>
ùëñ 2 Rùëò denote the row vector representing the ùëñth row of the matrix A and let bùëó 2 Rùëò
2
3
a>
A = 6 6 6 6 6 6 6 4 1 a> 2... a> ùëö 7 7 7 7 7 7 7 5 , (2.3.5)
2
3
2
3
2
3
50

denote the column vector from the ùëóth column of the matrix B:
2
3
a>
ay ay A=| "|, B= [bi by --- bal. (2.3.8) ay
To form the matrix product C ‚Ç¨ R‚Äô*", we simply compute each element c;; as the dot
product between the ùëñth row of A and the ùëóth column of B, i.e., a> ùëñ bùëó:
al afb; ajfbz --- ajbm al alb; albo -:- alb C=AB=|7/[b) by bal=} 77 ae (2.3.9) ay anby ajb2 + a;bm
Wecanthinkofthematrix‚ÄìmatrixmultiplicationABasperforming ùëö matrix‚Äìvectorprod-
We can think of the matrix‚Äîmatrix multiplication AB as performing m matrix‚Äîvector prod- ucts or m Xx n dot products and stitching the results together to form an n x m matrix. In the following snippet, we perform matrix multiplication on A and B. Here, A is a matrix with two rows and three columns, and B is a matrix with three rows and four columns. After multiplication, we obtain a matrix with two rows and four columns. B = torch.ones(3, 4) torch.mm(A, B), A@B
(tensor([[ 3., 3., 3., 3.], [12., 12., 12., 12.]]), tensor([[ 3., 3., 3., 3.], [12., 12., 12., 12.]]))
The term matrix‚Äìmatrix multiplication is often simplified to matrix multiplication, and should not be confused with the Hadamard product. 2.3.11 Norms
Some of the most useful operators in linear algebra are norms. Informally, the norm of a vector tells us how big it is. For instance, the ‚Ñì2 norm measures the (Euclidean) length of a vector. Here, we are employing a notion of size that concerns the magnitude of a vector‚Äôs components (not its dimensionality). A norm is a function || - || that maps a vector to a scalar and satisfies the following three
properties:
1. Given any vector x, if we scale (all elements of) the vector by a scalar ùõº 2 R, its norm
scales accordingly:
Preliminaries
kùõºxk = jùõºjkxk. (2.3.10)
Linear Algebra
51

2. For any vectors x and y: norms satisfy the triangle inequality:
lx + yll < Ilxll + lly. (2.3.11)
3. The norm of a vector is nonnegative and it only vanishes if the vector is zero:
kxk > 0 for all x ‚â† 0. (2.3.12)
Many functions are valid norms and different norms encode different notions of size. The Euclidean norm that we all learned in elementary school geometry when calculating the hypotenuse of a right triangle is the square root of the sum of squares of a vector‚Äôs elements. Formally, this is called the ‚Ñì2 norm and expressed as
kxk2 = ùë•2 ùëñ . ùëñ=1 (2.3.13)
The method norm calculates the ‚Ñì2 norm. u = torch.tensor([3.0, -4.0]) torch.norm(u)
tensor(5.)
The ‚Ñì1 norm is also common and the associated measure is called the Manhattan distance. By definition, the ‚Ñì1 norm sums the absolute values of a vector‚Äôs elements:
kxk1 = jùë•ùëñj . ùëñ=1 (2.3.14)
Compared to the ‚Ñì2 norm, it is less sensitive to outliers. To compute the ‚Ñì1 norm, we
compose the absolute value with the sum operation. torch.abs(u).sum()
tensor(7.)
Both the ‚Ñì2 and ‚Ñì1 norms are special cases of the more general ‚Ñìùëù norms:
n 1/p IIxIp = (> | ; (2.3.15) i=l
In the case of matrices, matters are more complicated. After all, matrices can be viewed bothascollectionsofindividualentriesand asobjectsthat operateon vectorsandtransform them into other vectors. For instance, we can ask by how much longer the matrix‚Äìvector product Xv could be relative to v. This line of thought leads to what is called the spectral
vt
n
! 1/p
52

norm. For now, we introduce the Frobenius norm, which is much easier to compute and defined as the square root of the sum of the squares of a matrix‚Äôs elements:
Xlle = (2.3.16)
The Frobenius norm behaves as if it were an ‚Ñì2 norm of a matrix-shaped vector. Invoking
the following function will calculate the Frobenius norm of a matrix. torch.norm(torch.ones((4, 9)))
tensor(6.)
While we do not want to get too far ahead of ourselves, we already can plant some intu- ition about why these concepts are useful. In deep learning, we are often trying to solve optimization problems: maximize the probability assigned to observed data; maximize the revenue associated with a recommender model; minimize the distance between predictions and the ground truth observations; minimize the distance between representations of photos of the same person while maximizing the distance between representations of photos of dif- ferent people. These distances, which constitute the objectives of deep learning algorithms, are often expressed as norms. 2.3.12 Discussion
In this section, we have reviewed all the linear algebra that you will need to understand a significant chunk of modern deep learning. There is a lot more to linear algebra, though, and much of it is useful for machine learning. For example, matrices can be decomposed into factors, and these decompositions can reveal low-dimensional structure in real-world datasets. There are entire subfields of machine learning that focus on using matrix decom- positions and their generalizations to high-order tensors to discover structure in datasets and solve prediction problems. But this book focuses on deep learning. And we believe you will be more inclined to learn more mathematics once you have gotten your hands dirty applying machine learning to real datasets. So while we reserve the right to introduce more mathematics later on, we wrap up this section here. If you are eager to learn more linear algebra, there are many excellent books and online resources. For a more advanced crash course, consider checking out Strang (1993), Kolter (2008), and Petersen and Pedersen (2008). To recap:
e Scalars, vectors, matrices, and tensors are the basic mathematical objects used in linear
algebra and have zero, one, two, and an arbitrary number of axes, respectively. e Tensors can be sliced or reduced along specified axes via indexing, or operations such
as sum and mean, respectively. Preliminaries
Linear Algebra
53

Elementwise products are called Hadamard products. By contrast, dot products, matrix‚Äî
vector products, and matrix‚Äìmatrix products are not elementwise operations and in general return objects having shapes that are different from the the operands. Compared to Hadamard products, matrix‚Äîmatrix products take considerably longer to
compute (cubic rather than quadratic time). Norms capture various notions of the magnitude of a vector (or matrix), and are com-
monly applied to the difference of two vectors to measure their distance apart. Common vector norms include the ¬¢; and &) norms, and common matrix norms include
the spectral and Frobenius norms. 2.3.13 Exercises
1. Prove that the transpose of the transpose of a matrix is the matrix itself: ‚ÄûA>‚Äù> = A. 2. Given two matrices A and B, show that sum and transposition commute: A> ‚Äö B> =
‚ÄûA ‚Äö B‚Äù>. 3. Given any square matrix A, is A ‚Äö A> always symmetric? Can you prove the result by
using only the results of the previous two exercises?bubu4. We defined the tensor X of shape (2, 3, 4) in this section. What is the output of len(X)? Write your answer without implementing any code, then check your answer using code. 5. For a tensor X of arbitrary shape, does len(X) always correspond to the length of a certain axis of X? What is that axis?bubu6. Run A / A.sum(axis=1) and see what happens. Can you analyze the results?bubu7. When traveling between two points in downtown Manhattan, what is the distance that you need to cover in terms of the coordinates, i.e., in terms of avenues and streets? Can you travel diagonally?bubu8. Consider a tensor of shape (2, 3, 4). What are the shapes of the summation outputs along axes 0, 1, and 2? 9. Feed a tensor with three or more axes to the linalg.norm function and observe its output. What does this function compute for tensors of arbitrary shape? 10. Consider three large matrices, say A ‚Ç¨ ReOx216 | Be R?¬∞x? and C ‚Ç¨ RP" ini- tialized with Gaussian random variables. You want to compute the product ABC. Is there any difference in memory footprint and speed, depending on whether you compute (AB)C or A(BC). Why? 11. Consider three large matrices, say A ‚Ç¨ R2¬∞*2" Be R2¬∞x?‚Äô and C ‚Ç¨ R?*2"", Is there any difference in speed depending on whether you compute AB or ACT? Why? What changes if you initialize C = B‚Äò without cloning memory? Why?bubu12. Consider three matrices, say A, B, C ‚Ç¨ R!0x200 | Construct a tensor with three axes by
54

stacking ¬ªA,B,C‚Ä¶. What is the dimensionality? Slice out the second coordinate of the
third axis to recover B. Check that your answer is correct.bubuDiscussions55. 55
2.4 Calculus
ae
For a long time, how to calculate the area of a circle remained a mystery. Then, in Ancient Greece, the mathematician Archimedes came up with the clever idea to inscribe a series of polygons with increasing numbers of vertices on the inside of a circle (Fig. 2.4.1). For a polygon with n vertices, we obtain n triangles. The height of each triangle approaches the radius r as we partition the circle more finely. At the same time, its base approaches 2zr/n, since the ratio between arc and secant approaches | for a large number of vertices. Thus, the area of the polygon approaches n- r - 3(2nr/n) =ar. tFig. 2.4.1
Finding the area of a circle as a limit procedure. Thislimitingprocedureisatthe rootof both differentialcalculus andintegralcalculus. The former can tell us how to increase or decrease a function‚Äôs value by manipulating its argu- ments. This comes in handy for the optimization problems that we face in deep learning, where we repeatedly update our parameters in order to decrease the loss function. Opti- mizationaddresseshowtofitourmodelstotrainingdata, andcalculusisitskeyprerequisite. However, do not forget that our ultimate goal is to perform well on previously unseen data.bubuThat problem is called generalization and will be a key focus of other chapters. %matplotlib inline import numpy as np from matplotlib_inline import backend_inline from d2l import torch as d2l
2.4.1 Derivatives and Differentiation
Put simply, a derivative is the rate of change in a function with respect to changes in its arguments. Derivatives can tell us how rapidly a loss function would increase or decrease were we to increase or decrease each parameter by an infinitesimally small amount. For- mally, for functions ùëì : R ! R, that map from scalars to scalars, the derivative of ùëì at a point ùë• is defined as
ùëì 0‚Äûùë•‚Äù = lim ‚Ñé!0 ‚Ñé . (2.4.1)
Preliminaries
2
55

This term on the right hand side is called a /imit and it tells us what happens to the value of an expression as a specified variable approaches a particular value. This limit tells us what the ratio between a perturbation h and the change in the function value f(x + h) ‚Äî f(x) converges to as we shrink its size to zero. When ùëì 0‚Äûùë•‚Äù exists, ùëì is said to be differentiable at ùë•; and when ùëì 0‚Äûùë•‚Äù exists for all ùë• on a
set, e.g., the interval ¬ªùëé, ùëè‚Ä¶, we say that ùëì is differentiable on this set. Not all functions are differentiable, includingmanythatwewishtooptimize, suchasaccuracyandtheareaunder the receiving operating characteristic (AUC). However, because computing the derivative of the loss is a crucial step in nearly all algorithms for training deep neural networks, we often optimize a differentiable surrogate instead. We can interpret the derivative ùëì 0‚Äûùë•‚Äù as the instantaneous rate of change of ùëì ‚Äûùë•‚Äù with
We can interpret the derivative f‚Äô(x) as the instantaneous rate of change of f(x) with respect to x. Let‚Äôs develop some intuition with an example. Define u = f(x) = 3x? - Ax. def f(x): return 3 * x ** 2 - 4 * x
Setting ùë• = 1, we see that
‚Ñé periment lacks the rigor of a mathematical proof, we can quickly see that indeed ùëì 0‚Äû1‚Äù = 2. for h in 10.0**np.arange(-1, -6, -1): print(f'h={h:.5f}, numerical limit={(f(1+h)-f(1))/h:.5f}')
h=0.10000, numerical limit=2.30000 h=0.01000, numerical limit=2.03000 h=0.00100, numerical limit=2.00300 h=0.00010, numerical limit=2.00030 h=0.00001, numerical limit=2.00003
There are several equivalent notational conventions for derivatives. Given ùë¶ = ùëì ‚Äûùë•‚Äù, the
following expressions are equivalent:
ùëì 0‚Äûùë•‚Äù = ùë¶0 = ùëëùë¶ ùëëùë• = ùëëùëì ùëëùë• = ùëë ùëëùë• ùëì ‚Äûùë•‚Äù = ùê∑ ùëì ‚Äûùë•‚Äù = ùê∑ùë• ùëì ‚Äûùë•‚Äù, (2.4.2)
where the symbols ùëë
ùëëùë• and ùê∑ are differentiation operators. Below, we present the deriva-
tives of some common functions:
ùëë
Lo =0 for any constant C dx d x =nx""! forn #0 * (2.4.3) 4 x =e* dx ‚ÄîInx =x. Calculus
approaches 2 as ‚Ñé approaches 0. While this ex-
Preliminaries
56

Functions composed from differentiable functions are often themselves differentiable. The following rules come in handy for working with compositions of any differentiable func- tions ùëì and ùëî, and constant ùê∂. ùëë
ùëë
d d ah [Cf (x)] = oratGs) Constant multiple rule d d d ‚Äî (f(x) + 8(x)] = = f(x) + 8a) Sum rule dx dx dx d d d (2.4.4) ak [f(xg(x)] = f(x) Re) + g(x) Rt Product rule a _ a < a = a) & ne ax8(%) Quotient rule
Using this, we can apply the rules to find the derivative of 3x? ‚Äî 4x via
ùëë
d d d qe ‚Äî 4x] = 3a ~ 4x = 6x = 4. (2.4.5) x Xx
Plugging in ùë• = 1 shows that, indeed, the derivative equals 2 at this location. Note that
derivatives tell us the slope of a function at a particular location. 2.4.2 Visualization Utilities
We can visualize the slopes of functions using the matplotlib library. We need to de- fine a few functions. As its name indicates, use_svg_display tells matplotlib to output graphics in SVG format for crisper images. The comment #@save is a special modifier that allows us to save any function, class, or other code block to the d2l package so that we can invoke it later without repeating the code, e.g., via d2l.use_svg_display(). def use_svg_display(): #@save """Use the svg format to display a plot in Jupyter.""" backend_inline.set_matplotlib_formats('svg')
Conveniently, we can set figure sizes with set_figsize. Since the import statement from matplotlib import pyplot as plt was marked via #@save in the d2l package, we can call d2l.plt. def set_figsize(figsize=(3.5, 2.5)): #@save """Set the figure size for matplotlib.""" use_svg_display() d2l.plt.rcParams['figure.figsize'] = figsize
The set_axes function can associate axes with properties, including labels, ranges, and scales. #@save def set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend): """Set the axes for matplotlib.""" axes.set_xlabel(xlabel), axes.set_ylabel(ylabel)
ùëë
ùëë
(continues on next page)
57

axes.set_xscale(xscale), axes.set_yscale(yscale) axes.set_xlim(xlim), axes.set_ylim(ylim) if legend: axes.legend(legend) axes.grid()
With these three functions, we can define a plot function to overlay multiple curves. Much of the code here is just ensuring that the sizes and shapes of inputs match. #@save def plot(X, Y=None, xlabel=None, ylabel=None, legend=[], xlim=None, ylim=None, xscale='linear', yscale='linear', fmts=('-', 'm--', 'g-.', 'r:'), figsize=(3.5, 2.5), axes=None): """Plot data points.""" def has_one_axis(X): # True if X (tensor or list) has 1 axis return (hasattr(X, "ndim") and X.ndim == 1 or isinstance(X, list) and not hasattr(X[0], "__len__")) if has_one_axis(X): X = [X] if Y is None: X, Y = [[]] * len(X), X elif has_one_axis(Y): Y = [Y] if len(X) != len(Y): X = X * len(Y) set_figsize(figsize) if axes is None: axes = d2l.plt.gca() axes.cla() for x, y, fmt in zip(X, Y, fmts): axes.plot(x,y,fmt) if len(x) else axes.plot(y,fmt) set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend)
Now we can plot the function u = f(x) and its tangent line y = 2x ‚Äî 3 at x = 1, where the
coefficient 2 is the slope of the tangent line. x = np.arange(0, 3, 0.1) plot(x, [f(x), 2 * x - 3], 'x', 'f(x)', legend=['f(x)', 'Tangent line (x=1)'])
‚Äî f(x) 10 {777 Tangent line (x=1) zs 0
Calculus
(continued from previous page)
58

2.4.3 Partial Derivatives and Gradients
Thus far, we have been differentiating functions of just one variable. In deep learning, we also need to work with functions of many variables. We briefly introduce notions of the derivative that apply to such multivariate functions. Let ùë¶ = ùëì ‚Äûùë•1,ùë•2, .bubu. .,ùë•ùëõ‚Äù be a function with ùëõ variables. The partial derivative of ùë¶ with
respect to its ùëñth parameter ùë•ùëñ is
Oy | lim SF (1,06. X41 Mi +, Xia, -- Xn) ‚Äî F(X, .- Xi. Xn) (2.4.6) Ox; =ho0 h ; _
ùúïùë¶
Q we can treat x1,...,%j‚Äî-1,Xi+1,...,%Xn, as constants and calculate the deriva- i
Tocalculate tive of ùë¶ with respect to ùë•ùëñ. The following notational conventions for partial derivatives are all common and all mean the same thing:
ùúïùë¶
ùúï ùëì
ùúïùë•ùëñ = ùúïùë•ùëñ = ùúïùë•ùëñ ùëì = ùúïùëñ ùëì = ùëìùë•ùëñ = ùëìùëñ = ùê∑ùëñ ùëì = ùê∑ùë•ùëñ ùëì . (2.4.7)
We can concatenate partial derivatives of a multivariate function with respect to all its variables to obtain a vector that is called the gradient of the function. Suppose that the input of function ùëì : Rùëõ ! R is an ùëõ-dimensional vector x = ¬ªùë•1,ùë•2, . . .,ùë•ùëõ‚Ä¶> and the output is a scalar. The gradient of the function ùëì with respect to x is a vector of ùëõ partial derivatives:
rx ùëì ‚Äûx‚Äù = ùúïùë•1 ùëì ‚Äûx‚Äù, ùúïùë•2 ùëì ‚Äûx‚Äù, . .bubu. ùúïùë•ùëõ ùëì ‚Äûx‚Äù (2.4.8)
When there is no ambiguity, rx ùëì ‚Äûx‚Äù is typically replaced by rùëì ‚Äûx‚Äù. The following rules
come in handy for differentiating multivariate functions:
e Forall A ‚Ç¨ R‚Äù*‚Äù we have V,Ax = AT and V,x'A=A. e For square matrices A ‚Ç¨ R‚Äù*‚Äù we have that V;xx' Ax = (A + A")x and in particular
rxkxk2 = rxx>x = 2x. Similarly, for any matrix X, we have rXkXk2
2.4.4 Chain Rule
In deep learning, the gradients of concern are often difficult to calculate because we are workingwithdeeplynestedfunctions(offunctions(offunctions‚Ä¶)). Fortunately, thechain rule takes care of this. Returning to functions of a single variable, suppose that ùë¶ = ùëì ‚Äûùëî‚Äûùë•‚Äù‚Äù and that the underlying functions ùë¶ = ùëì ‚Äûùë¢‚Äù and ùë¢ = ùëî‚Äûùë•‚Äù are both differentiable. The chain rule states that
ùëëùë• = ùëëùë¢ ùëëùë• . (2.4.9)
Turning back to multivariate functions, suppose that ùë¶ = ùëì ‚Äûu‚Äù has variables ùë¢1,ùë¢2, . . .,ùë¢ùëö,
where each ùë¢ùëñ = ùëîùëñ‚Äûx‚Äù has variables ùë•1,ùë•2, . . .,ùë•ùëõ, i.e., u = ùëî‚Äûx‚Äù. Then the chain rule states that
ùúïùë¶ ùúïùë•ùëñ = ùúïùë¶ ùúïùë¢1 ùúïùë¢1 ùúïùë•ùëñ ‚Äö ùúïùë¶ ùúïùë¢2 ùúïùë¢2 ùúïùë•ùëñ ‚Äö . .bubu. ‚Äö ùúïùë¶ ùúïùë¢ùëö ùúïùë¢ùëö ùúïùë•ùëñ and so rxùë¶ = Aruùë¶, (2.4.10)
Preliminaries

F = 2X. ùëëùë¶
ùëëùë¢
ùëëùë¶
59

where A ‚Ç¨ R‚Äù*‚Äô" is a matrix that contains the derivative of vector u with respect to vector
x. Thus, evaluating the gradient requires computing a vector‚Äìmatrix product. This is one of the key reasons why linear algebra is such an integral building block in building deep learning systems. 2.4.5 Discussion
Whilewehavejustscratchedthesurfaceofadeeptopic, anumberofconceptsalreadycome into focus: first, the composition rules for differentiation can be applied routinely, enabling us to compute gradients automatically. This task requires no creativity and thus we can focus our cognitive powers elsewhere. Second, computing the derivatives of vector-valued functions requires us to multiply matrices as we trace the dependency graph of variables from output to input. In particular, this graph is traversed in a forward direction when we evaluate a function and in a backwards direction when we compute gradients. Later chapters will formally introduce backpropagation, a computational procedure for applying the chain rule. From the viewpoint of optimization, gradients allow us to determine how to move the pa- rameters of a model in order to lower the loss, and each step of the optimization algorithms used throughout this book will require calculating the gradient. 2.4.6 Exercises
1.bubuSo far we took the rules for derivatives for granted. Using the definition and limits prove the properties for (i) ùëì ‚Äûùë•‚Äù = ùëê, (ii) ùëì ‚Äûùë•‚Äù = ùë•ùëõ, (iii) ùëì ‚Äûùë•‚Äù = ùëíùë• and (iv) ùëì ‚Äûùë•‚Äù = logùë•. 2. In the same vein, prove the product, sum, and quotient rule from first principles. 3. Prove that the constant multiple rule follows as a special case of the product rule. 4. Calculate the derivative of ùëì ‚Äûùë•‚Äù = ùë•ùë•. 5. What does it mean that ùëì 0‚Äûùë•‚Äù = 0 for some ùë•? Give an example of a function ùëì and a
location ùë• for which this might hold.bubu6. Plot the function y = f(x) =x¬∞ - + and plot its tangent line at x = 1. 7. Find the gradient of the function ùëì ‚Äûx‚Äù = 3ùë•2
8. What is the gradient of the function ùëì ‚Äûx‚Äù = kxk2? What happens for x = 0? 9. Can you write out the chain rule for the case where ùë¢ = ùëì ‚Äûùë•, ùë¶, ùëß‚Äù and ùë• = ùë•‚Äûùëé, ùëè‚Äù,
ùë¶ = ùë¶‚Äûùëé, ùëè‚Äù, and ùëß = ùëß‚Äûùëé, ùëè‚Äù? 10. Given a function f(x) that is invertible, compute the derivative of its inverse f~! (x). 10. Given a function f(x) that is invertible, compute the derivative of its inverse f~! (x). Here we have that f~!(f(x)) = x and conversely f(f~!(y)) = y. Hint: use these properties in your derivation. 56
Discussions56.bubuCalculus
‚Äö 5ùëíùë•2. 1
60

2.5 Automatic Differentiation

Recall from Section 2.4 that calculating derivatives is the crucial step in all the optimization algorithms that we will use to train deep networks. While the calculations are straightfor- ward, working them out by hand can be tedious and error-prone, and these issues only grow as our models become more complex. Fortunately all modern deep learning frameworks take this work off our plates by offering automatic differentiation (often shortened to autograd). As we pass data through each successivefunction, theframeworkbuildsacomputationalgraphthattrackshoweachvalue depends on others. To calculate derivatives, automatic differentiation works backwards through this graph applying the chain rule. The computational algorithm for applying the chain rule in this fashion is called backpropagation. While autograd libraries have become a hot concern over the past decade, they have a long history. In fact the earliest references to autograd date back over half of a century (Wengert, 1964). The core ideas behind modern backpropagation date to a PhD thesis from 1980 (Speelpenning, 1980) and were further developed in the late 1980s (Griewank, 1989). While backpropagation has become the default method for computing gradients, it is not the only option. For instance, the Julia programming language employs forward propagation (Revels et al., 2016). Before exploring methods, let‚Äôs first master the autograd package. import torch
2.5.1 A Simple Function
Let‚Äôs assume that we are interested in differentiating the function ùë¶ = 2x>x with respect to
the column vector x. To start, we assign x an initial value. x = torch.arange(4.0) x
tensor([0., 1., 2., 3.])
Before we calculate the gradient of ùë¶ with respect to x, we need a place to store it. In
general, we avoid allocating new memory every time we take a derivative because deep learning requires successively computing derivatives with respect to the same parameters a great many times, and we might risk running out of memory. Note that the gradient of a scalar-valued function with respect to a vector x is vector-valued with the same shape as x. Preliminaries
Automatic Differentiation
61

# Can also create x = torch.arange(4.0, requires_grad=True) x.requires_grad_(True) x.grad # The gradient is None by default
We now calculate our function of x and assign the result to y. y = 2 * torch.dot(x, x) y
tensor(28., grad_fn=<MulBackward0>)
We can now take the gradient of y with respect to x by calling its backward method. Next, we can access the gradient via x‚Äôs grad attribute. y.backward()
x.grad
tensor([ 0., 4., 8., 12.])
We already know that the gradient of the function ùë¶ = 2x>x with respect to x should be
4x. We can now verify that the automatic gradient computation and the expected result are identical. x.grad == 4 * x
tensor([True, True, True, True])
Now let‚Äôs calculate another function of x and take its gradient. Note that PyTorch does not automatically reset the gradient buffer when we record a new gradient. Instead, the new gradient is added to the already-stored gradient. This behavior comes in handy when we want to optimize the sum of multiple objective functions. To reset the gradient buffer, we can call x.grad.zero_() as follows:
x.grad.zero_() # Reset the gradient y = x.sum() y.backward() x.grad
tensor([1., 1., 1., 1.])
2.5.2 Backward for Non-Scalar Variables
When y is a vector, the most natural representation of the derivative of y with respect to a vector x is a matrix called the Jacobian that contains the partial derivatives of each
62

component of y with respect to each component of x. Likewise, for higher-order y and x, the result of differentiation could be an even higher-order tensor. While Jacobians do show up in some advanced machine learning techniques, more com- monly we want to sum up the gradients of each component of y with respect to the full vector x, yielding a vector of the same shape as x. For example, we often have a vector representing the value of our loss function calculated separately for each example among a batch of training examples. Here, we just want to sum up the gradients computed individ- ually for each example. Because deep learning frameworks vary in how they interpret gradients of non-scalar ten- sors, PyTorch takes some steps to avoid confusion. Invoking backward on a non-scalar elicits an error unless we tell PyTorch how to reduce the object to a scalar. More formally, we need to provide some vector v such that backward will compute v>ùúïxy rather than ùúïxy. This next part may be confusing, but for reasons that will become clear later, this argument (representing v) is named gradient. For a more detailed description, see Yang Zhang‚Äôs Medium post57. 57
x.grad.zero_() y = x * x y.backward(gradient=torch.ones(len(y))) # Faster: y.sum().backward() x.grad
x.grad.zero_()
tensor([0., 2., 4., 6.])
2.5.3 Detaching Computation
Sometimes, we wish to move some calculations outside of the recorded computational graph. For example, say that we use the input to create some auxiliary intermediate terms for which we do not want to compute a gradient. In this case, we need to detach the re- spective computational graph from the final result. The following toy example makes this clearer: suppose we have z = x * y and y = x * x but we want to focus on the direct influence of x on z rather than the influence conveyed via y. In this case, we can create a new variable u that takes the same value as y but whose provenance (how it was created) has been wiped out. Thus u has no ancestors in the graph and gradients do not flow through u to x. For example, taking the gradient of z = x * u will yield the result u, (not 3 * x * x as you might have expected since z = x * x * x). x.grad.zero_() y = x * x u = y.detach() z = u * x z.sum().backward() x.grad == u
Preliminaries
Automatic Differentiation
63

tensor([True, True, True, True])
Note that while this procedure detaches y‚Äôs ancestors from the graph leading to z, the com- putational graph leading to y persists and thus we can calculate the gradient of y with respect to x. x.grad.zero_()
y.sum().backward()
x.grad == 2 * x
tensor([True, True, True, True])
2.5.4 Gradients and Python Control Flow
So far we reviewed cases where the path from input to output was well defined via a func- tion such as z = x * x * x. Programming offers us a lot more freedom in how we compute results.bubuFor instance, we can make them depend on auxiliary variables or condi- tion choices on intermediate results. One benefit of using automatic differentiation is that even if building the computational graph of a function required passing through a maze of Python control flow (e.g., conditionals, loops, and arbitrary function calls), we can still calculate the gradient of the resulting variable. To illustrate this, consider the following code snippet where the number of iterations of the while loop and the evaluation of the if statement both depend on the value of the input a. def f(a): b = a * 2 while b.norm() < 1000: b = b * 2 if b.sum() > 0: c = b else: c = 100 * b return c
Below, we call this function, passing in a random value, as input. Since the input is a random variable, we do not know what form the computational graph will take. However, whenever we execute f(a) on a specific input, we realize a specific computational graph and can subsequently run backward. a = torch.randn(size=(), requires_grad=True) d = f(a) d.backward()
Even though our function f is, for demonstration purposes, a bit contrived, its dependence on the input is quite simple: it is a linear function of a with piecewise defined scale. As
Preliminaries
64

such, f(a) / a is a vector of constant entries and, moreover, f(a) / a needs to match the gradient of f(a) with respect to a. a.grad == d / a
tensor(True)
Dynamic control flow is very common in deep learning. For instance, when processing text, the computational graph depends on the length of the input. In these cases, automatic differentiation becomes vital for statistical modeling since it is impossible to compute the gradient a priori. 2.5.5 Discussion
You have now gotten a taste of the power of automatic differentiation. The development of libraries for calculating derivatives both automatically and efficiently has been a massive productivity booster for deep learning practitioners, liberating them so they can focus on less menial. Moreover, autograd lets us design massive models for which pen and paper gradient computations would be prohibitively time consuming. Interestingly, while we use autograd to optimize models (in a statistical sense) the optimization of autograd libraries themselves (in a computational sense) is a rich subject of vital interest to framework design- ers. Here, tools from compilers and graph manipulation are leveraged to compute results in the most expedient and memory-efficient manner. For now, try to remember these basics: (i) attach gradients to those variables with respect to which we desire derivatives; (ii) record the computation of the target value; (iii) execute the backpropagation function; and (iv) access the resulting gradient. 2.5.6 Exercises
1. Why is the second derivative much more expensive to compute than the first derivative? 2. After running the function for backpropagation, immediately run it again and see what happens. Investigate.bubu3. In the control flow example where we calculate the derivative of d with respect to a, what would happen if we changed the variable a to a random vector or a matrix? At this point, the result of the calculation f(a) is no longer a scalar. What happens to the result? How do we analyze this? 4. Let ùëì ‚Äûùë•‚Äù = sin‚Äûùë•‚Äù. Plot the graph of ùëì and of its derivative ùëì 0. Do not exploit the fact
that ùëì 0‚Äûùë•‚Äù = cos‚Äûùë•‚Äù but rather use automatic differentiation to get the result. 5. Let f(x) = ((log x‚Äù) - sinx) +.x7!. Write out a dependency graph tracing results from
ùë• to ùëì ‚Äûùë•‚Äù. 6. Use the chain rule to compute the derivative ùëëùë• of the aforementioned function, placing each term on the dependency graph that you constructed previously. ùëë ùëì
Probability and Statistics
65

7. Given the graph and the intermediate derivative results, you have a number of options when computing the gradient. Evaluate the result once starting from ùë• to ùëì and once from ùëì tracing back to ùë•. The path from ùë• to ùëì is commonly known as forward differ- entiation, whereas the path from ùëì to ùë• is known as backward differentiation. 8.bubuWhen might you want to use forward, and when backward, differentiation? Hint: con- sider the amount of intermediate data needed, the ability to parallelize steps, and the size of matrices and vectors involved. Discussions58. 58
2.6 Probability and Statistics
a
One way or another, machine learning is all about uncertainty. In supervised learning, we want to predict something unknown (the target) given something known (the features). De- pending on our objective, we might attempt to predict the most likely value of the target. Or we might predict the value with the smallest expected distance from the target. And sometimes we wish not only to predict a specific value but to quantify our uncertainty. For example, given some features describing a patient, we might want to know how likely they are to suffer a heart attack in the next year. In unsupervised learning, we often care about uncertainty. To determine whether a set of measurements are anomalous, it helps to know how likely one is to observe values in a population of interest. Furthermore, in reinforce- ment learning, we wish to develop agents that act intelligently in various environments. This requires reasoning about how an environment might be expected to change and what rewards one might expect to encounter in response to each of the available actions. Probability is the mathematical field concerned with reasoning under uncertainty. Given a probabilistic model of some process, we can reason about the likelihood of various events. The use of probabilities to describe the frequencies of repeatable events (like coin tosses) is fairly uncontroversial. In fact, frequentist scholars adhere to an interpretation of probability that applies only to such repeatable events. By contrast Bayesian scholars use the language of probability more broadly to formalize reasoning under uncertainty. Bayesian probability is characterized by two unique features: (i) assigning degrees of belief to non-repeatable events, e.g., what is the probability that a dam will collapse?; and (ii) subjectivity. While Bayesian probability provides unambiguous rules for how one should update their beliefs in light of new evidence, it allows for different individuals to start off with different prior be- liefs. Statistics helps us to reason backwards, starting off with collection and organization of data and backing out to what inferences we might draw about the process that generated the data. Whenever we analyze a dataset, hunting for patterns that we hope might charac- terize a broader population, we are employing statistical thinking. Many courses, majors, theses, careers, departments, companies, and institutions have been devoted to the study of probability and statistics. While this section only scratches the surface, we will provide the foundation that you need to begin building models. 66

%matplotlib inline import random import torch from torch.distributions.multinomial import Multinomial from d2l import torch as d2l
2.6.1 A Simple Example: Tossing Coins
Imagine that we plan to toss a coin and want to quantify how likely we are to see heads (vs. tails).bubuIf the coin is fair, then both outcomes (heads and tails), are equally likely. Moreover if we plan to toss the coin n times then the fraction of heads that we expect to see should exactly match the expected fraction of tails. One intuitive way to see this is by symmetry: for every possible outcome with np, heads and n, = (n ‚Äî np) tails, there is an equally likely outcome with m, heads and ny, tails. Note that this is only possible if on average we expect to see 1/2 of tosses come up heads and 1/2 come up tails. Of course, if you conduct this experiment many times with n = 1000000 tosses each, you might never see a trial where np, = m exactly. Formally, the quantity 1/2 is called a probability and here it captures the certainty with
Formally, the quantity 1/2 is called a probability and here it captures the certainty with which any given toss will come up heads. Probabilities assign scores between 0 and | to outcomes of interest, called events. Here the event of interest is heads and we denote the corresponding probability P(heads). A probability of 1 indicates absolute certainty (imag- ine a trick coin where both sides were heads) and a probability of 0 indicates impossibility (e.g., if both sides were tails). The frequencies n,/n and n,/n are not probabilities but rather statistics. Probabilities are theoretical quantities that underly the data generating process. Here, the probability 1/2 is a property of the coin itself. By contrast, statistics are empirical quantities that are computed as functions of the observed data. Our interests in probabilis- tic and statistical quantities are inextricably intertwined. We often design special statistics called estimators that, given a dataset, produce estimates of model parameters such as prob- abilities. Moreover, when those estimators satisfy a nice property called consistency, our estimates will converge to the corresponding probability. In turn, these inferred probabili- ties tell about the likely statistical properties of data from the same population that we might encounter in the future. Suppose that we stumbled upon a real coin for which we did not know the true ùëÉ‚Äûheads‚Äù. To investigate this quantity with statistical methods, we need to (i) collect some data; and (ii) design an estimator. Data acquisition here is easy; we can toss the coin many times and record all the outcomes. Formally, drawing realizations from some underlying random process is called sampling. As you might have guessed, one natural estimator is the ratio of the number of observed heads to the total number of tosses. Now, suppose that the coin was in fact fair, i.e., ùëÉ‚Äûheads‚Äù = 0.5. To simulate tosses of a
Now, suppose that the coin was in fact fair, i.e, P(heads) = 0.5. To simulate tosses of a fair coin, we can invoke any random number generator. There are some easy ways to draw samples of an event with probability 0.5. For example Python‚Äôs random. random yields numbers in the interval [0, 1] where the probability of lying in any sub-interval [a,b] ¬¢
Preliminaries
Probability and Statistics
67

[0, 1] is equal to b ‚Äî a. Thus we can get out @ and 1 with probability @.5 each by testing
whether the returned float number is greater than 0.5:
num_tosses = 100 heads = sum([random.random() > 0.5 for _ in range(num_tosses)]) tails = num_tosses - heads print("heads, tails: ", [heads, tails])
heads, tails: [44, 56]
More generally, we can simulate multiple draws from any variable with a finite number of possible outcomes (like the toss of a coin or roll of a die) by calling the multinomial function, setting the first argument to the number of draws and the second as a list of prob- abilities associated with each of the possible outcomes. To simulate ten tosses of a fair coin, we assign probability vector [0.5, 0.5], interpreting index 0 as heads and index 1 as tails. The function returns a vector with length equal to the number of possible outcomes (here, 2), where the first component tells us the number of occurrences of heads and the second component tells us the number of occurrences of tails. fair_probs = torch.tensor([0.5, 0.5]) Multinomial(100, fair_probs).sample()
tensor([50., 50.])
Each time you run this sampling process, you will receive a new random value that may differ from the previous outcome. Dividing by the number of tosses gives us the frequency of each outcome in our data. Note that these frequencies, just like the probabilities that they are intended to estimate, sum to 1. Multinomial(100, fair_probs).sample() / 100
tensor([0.4800, 0.5200])
Here, even though our simulated coin is fair (we ourselves set the probabilities [0.5, Q. 5]), the counts of heads and tails may not be identical. That is because we only drew a relatively small number of samples. If we did not implement the simulation ourselves, and only saw the outcome, how would we know if the coin were slightly unfair or if the possible deviation from 1/2 was just an artifact of the small sample size? Let‚Äôs see what happens when we simulate 10,000 tosses. counts = Multinomial(10000, fair_probs).sample() counts / 10000
68

tensor([0.4966, 0.5034])
In general, for averages of repeated events (like coin tosses), as the number of repetitions grows, our estimates are guaranteed to converge to the true underlying probabilities. The mathematical formulation of this phenomenon is called the law of large numbers and the central limit theorem tells us that in many situations, as the sample size n grows, these errors should go down at a rate of (1/-Vn). Let‚Äôs get some more intuition by studying how our estimate evolves as we grow the number of tosses from 1 to 10,000. counts = Multinomial(1, fair_probs).sample((10000,)) cum_counts = counts.cumsum(dim=0) estimates = cum_counts / cum_counts.sum(dim=1, keepdims=True) estimates = estimates.numpy() d2l.set_figsize((4.5, 3.5)) d2l.plt.plot(estimates[:, 0], label=("P(coin=heads)")) d2l.plt.plot(estimates[:, 1], label=("P(coin=tails)")) d2l.plt.axhline(y=0.5, color='black', linestyle='dashed') d2l.plt.gca().set_xlabel('Samples') d2l.plt.gca().set_ylabel('Estimated probability') d2l.plt.legend();
‚Äî P(coin=heads) ‚Äî‚Äî P(coin=tails) 2 ¬∞ ¬∞ B oa & Estimated probability o N ¬∞ ¬∞ 0 2000 4000 6000 8000 10000 Samples
Each solid curve corresponds to one of the two values of the coin and gives our estimated probability that the coin turns up that value after each group of experiments. The dashed black line gives the true underlying probability. As we get more data by conducting more experiments, the curves converge towards the true probability. You might already begin to see the shape of some of the more advanced questions that preoccupy statisticians: How quickly does this convergence happen? If we had already tested many coins manufactured at the same plant, how might we incorporate this information? 2.6.2 A More Formal Treatment
We have already gotten pretty far: posing a probabilistic model, generating synthetic data, running a statistical estimator, empirically assessing convergence, and reporting error met-
Preliminaries
Probability and Statistics
69

rics (checking the deviation). However, to go much further, we will need to be more pre- cise. When dealing with randomness, we denote the set of possible outcomes S and call it the
sample space or outcome space. Here, each element is a distinct possible outcome. In the case of rolling a single coin, S = fheads,tailsg. For a single die, S = f1,2,3,4,5,6g. Whenflippingtwocoins,possibleoutcomesare f‚Äûheads,heads‚Äù, ‚Äûheads,tails‚Äù, ‚Äûtails,heads‚Äù, ‚Äûtails,tails‚Äùg. Events are subsets of the sample space. For instance, the event ‚Äúthe first coin toss comes up heads‚Äù corresponds to the set f‚Äûheads,heads‚Äù, ‚Äûheads,tails‚Äùg. Whenever the outcome ùëß of a random experiment satisfies ùëß 2 A, then event A has occurred. For a single roll of a die, we could define the events ‚Äúseeing a 5‚Äù (A = f5g) and ‚Äúseeing an odd number‚Äù (B = f1,3,5g). In thiscase, ifthedie cameup 5, wewouldsaythat both A and B occurred. On the other hand, if ùëß = 3, then A did not occur but B did. A probability function maps events onto real values P : A C S = [0,1]. The probabil-
ity, denoted ùëÉ‚ÄûA‚Äù, of an event A in the given sample space S, has the following proper- ties:
e The probability of any event A is a nonnegative real number, i.e., P(A) = 0;
e The probability of the entire sample space is 1, i.e., P(S) = 1;
e For any countable sequence of events Aj, Az, ... that are mutually exclusive (i.e., AiO
Aùëó = ; for all ùëñ ‚â† ùëó), the probability that any of them happens is equal to the sum of ‚Äî1 Àù1 their individual probabilities, i.e., ùëÉ‚Äû Aùëñ‚Äù = ùëÉ‚ÄûAùëñ‚Äù. ùëñ=1 ùëñ=1
These axioms of probability theory, proposed by Kolmogorov (1933), can be applied to rapidly derive a number of important consequences. For instance, it follows immediately that the probability of any event A or its complement A0 occurring is 1 (because A[A0 = S). We can also prove that ùëÉ‚Äû;‚Äù = 0 because 1 = ùëÉ‚ÄûS [S0‚Äù = ùëÉ‚ÄûS [;‚Äù = ùëÉ‚ÄûS‚Äù ‚Äö ùëÉ‚Äû;‚Äù = 1 ‚Äö ùëÉ‚Äû;‚Äù. Consequently, the probability of any event A and its complement A0 occurring simultaneously is ùëÉ‚ÄûA\A0‚Äù = 0. Informally, this tells us that impossible events have zero probability of occurring. 2.6.3 Random Variables
When we spoke about events like the roll of a die coming up odds or the first coin toss coming up heads, we were invoking the idea of a random variable. Formally, random variables are mappings from an underlying sample space to a set of (possibly many) values. You might wonder how a random variable is different from the sample space, since both are collections of outcomes. Importantly, random variables can be much coarser than the raw sample space. We can define a binary random variable like ‚Äúgreater than 0.5‚Äù even when the underlying sample space is infinite, e.g., points on the line segment between 0 and 1. Additionally, multiple random variables can share the same underlying sample space. For example ‚Äúwhether my home alarm goes off‚Äù and ‚Äúwhether my house was burgled‚Äù are both binary random variables that share an underlying sample space. Consequently, knowingthe value taken by one random variable can tell us something about the likely value of another
70

random variable. Knowing that the alarm went off, we might suspect that the house was likely burgled. Every value taken by a random variable corresponds to a subset of the underlying sample space. Thus the occurrence where the random variable X takes value v, denoted by X = v, is an event and P(X = v) denotes its probability. Sometimes this notation can get clunky, and we can abuse notation when the context is clear. For example, we might use P(X) to refer broadly to the distribution of X, i.e., the function that tells us the probability that X takes any given value. Other times we write expressions like P(X, Y) = P(X)P(Y), asa shorthand to express a statement that is true for all of the values that the random variables X and Y can take, ie., for all i, j it holds that P(X =iandY = j) = P(X =i)P(Y = j). Other times, we abuse notation by writing P(v) when the random variable is clear from the context. Since an event in probability theory is a set of outcomes from the sample space, we can specify a range of values for a random variable to take. For example, P(1 < X < 3) denotes the probability of the event {1 < X < 3}. Note that there is a subtle difference between discrete random variables, like flips of a coin or tosses of a die, and continuous ones, like the weight and the height of a person sampled at random from the population. In this case we seldom really care about someone‚Äôs exact height. Moreover, if we took precise enough measurements, we would find that no two people on the planet have the exact same height. In fact, with fine enough measurements, you would never have the same height when you wake up and when you go to sleep. There is little point in asking about the exact probability that someone is 1.801392782910287192 meters tall. Instead, we typically care more about being able to say whether someone‚Äôs height falls into a given interval, say between 1.79 and 1.81 meters. In these cases we work withprobabilitydensities. Theheightofexactly1.80metershasnoprobability, butnonzero density. To work out the probability assigned to an interval, we must take an integral of the density over that interval. 2.6.4 Multiple Random Variables
You might have noticed that we could not even make it through the previous section without makingstatementsinvolvinginteractionsamongmultiplerandomvariables(recall ùëÉ‚Äûùëã,ùëå‚Äù = ùëÉ‚Äûùëã‚ÄùùëÉ‚Äûùëå‚Äù). Mostofmachinelearningisconcernedwithsuchrelationships. Here, thesam- ple space would be the population of interest, say customers who transact with a business, photographs on the Internet, or proteins known to biologists. Each random variable would represent the (unknown) value of a different attribute. Whenever we sample an individual from the population, we observe a realization of each of the random variables. Because the values taken by random variables correspond to subsets of the sample space that could be overlapping, partially overlapping, or entirely disjoint, knowing the value taken by one random variable can cause us to update our beliefs about which values of another random variable are likely. If a patient walks into a hospital and we observe that they are having trouble breathing and have lost their sense of smell, then we believe that they are more likely to have COVID-19 than we might if they had no trouble breathing and a perfectly ordinary sense of smell. When working with multiple random variables, we can construct events corresponding to
Preliminaries
Probability and Statistics
71

every combination of values that the variables can jointly take.bubuThe probability function that assigns probabilities to each of these combinations (e.g. ùê¥ = ùëé and ùêµ = ùëè) is called the joint probability function and simply returns the probability assigned to the intersection of the corresponding subsets of the sample space. The joint probability assigned to the event where random variables ùê¥ and ùêµ take values ùëé and ùëè, respectively, is denoted ùëÉ‚Äûùê¥ = ùëé, ùêµ = ùëè‚Äù, where the comma indicates ‚Äúand‚Äù. Note that for any values ùëé and ùëè, it follows that
P(A =a,B=b) < P(A =a) and P(A =a,B =b) < P(B=)b),
(2.6.1)
since for ùê¥ = ùëé and ùêµ = ùëè to happen, ùê¥ = ùëé has to happen and ùêµ = ùëè also has to
happen. Interestingly, the joint probability tells us all that we can know about these random variables in a probabilistic sense, and can be used to derive many other useful quantities, including recovering the individual distributions ùëÉ‚Äûùê¥‚Äù and ùëÉ‚Äûùêµ‚Äù. To recover ùëÉ‚Äûùê¥ = ùëé‚Äù we simply sum up ùëÉ‚Äûùê¥ = ùëé, ùêµ = ùë£‚Äù over all values ùë£ that the random variable ùêµ can take: Àù ùëÉ‚Äûùê¥ = ùëé‚Äù = ùë£ ùëÉ‚Äûùê¥ = ùëé, ùêµ = ùë£‚Äù. ùëÉ‚Äûùê¥=ùëé,ùêµ=ùëè‚Äù
< | turns out to be extremely important. It is called the conditional
The ratio ùëÉ‚Äûùê¥=ùëé‚Äù probability, and is denoted via the ‚Äúj‚Äù symbol:
P(B=b|A=a)=P(A=a,B=b)/P(A=a). (2.6.2)
It tells us the new probability associated with the event ùêµ = ùëè, once we condition on the fact ùê¥ = ùëé took place. We can think of this conditional probability as restricting attention only to the subset of the sample space associated with ùê¥ = ùëé and then renormalizing so that all probabilities sum to 1. Conditional probabilities are in fact just ordinary probabilities and thus respect all of the axioms, as long as we condition all terms on the same event and thus restrict attention to the same sample space. For instance, for disjoint events B and B0, we have that ùëÉ‚ÄûB [ B0 j ùê¥ = ùëé‚Äù = ùëÉ‚ÄûB j ùê¥ = ùëé‚Äù ‚Äö ùëÉ‚ÄûB0 j ùê¥ = ùëé‚Äù. Using the definition of conditional probabilities, we can derive the famous result called Bayes‚Äô theorem. By construction, we have that ùëÉ‚Äûùê¥, ùêµ‚Äù = ùëÉ‚Äûùêµ j ùê¥‚ÄùùëÉ‚Äûùê¥‚Äù and ùëÉ‚Äûùê¥, ùêµ‚Äù = ùëÉ‚Äûùê¥ j ùêµ‚ÄùùëÉ‚Äûùêµ‚Äù. Combining both equations yields ùëÉ‚Äûùêµ j ùê¥‚ÄùùëÉ‚Äûùê¥‚Äù = ùëÉ‚Äûùê¥ j ùêµ‚ÄùùëÉ‚Äûùêµ‚Äù and hence
ùëÉ‚Äûùê¥ j ùêµ‚Äù = ùëÉ‚Äûùêµ‚Äù . (2.6.3)
This simple equation has profound implications because it allows us to reverse the order of conditioning. If we know how to estimate ùëÉ‚Äûùêµ j ùê¥‚Äù, ùëÉ‚Äûùê¥‚Äù, and ùëÉ‚Äûùêµ‚Äù, then we can estimate ùëÉ‚Äûùê¥ j ùêµ‚Äù. We often find it easier to estimate one term directly but not the other and Bayes‚Äô theorem can come to the rescue here. For instance, if we know the prevalence of symptoms for a given disease, and the overall prevalences of the disease and symptoms, respectively, we can determine how likely someone is to have the disease based on their symptoms. In some cases we might not have direct access to ùëÉ‚Äûùêµ‚Äù, such as the prevalence of symptoms. In this case a simplified version of Bayes‚Äô theorem comes in handy:
ùëÉ‚Äûùê¥ j ùêµ‚Äù / ùëÉ‚Äûùêµ j ùê¥‚ÄùùëÉ‚Äûùê¥‚Äù. (2.6.4)
ùëÉ‚Äûùêµ j ùê¥‚ÄùùëÉ‚Äûùê¥‚Äù
72

Since we know that ùëÉ‚Äûùê¥ j ùêµ‚Äù must be normalized to 1, i.e.,
use it to compute
ùëÉ‚Äûùê¥ j ùêµ‚Äù = Àù ùëé ùëÉ‚Äûùêµ j ùê¥ = ùëé‚ÄùùëÉ‚Äûùê¥ = ùëé‚Äù . (2.6.5)
In Bayesian statistics, we think of an observer as possessing some (subjective) prior be- liefs about the plausibility of the available hypotheses encoded in the prior ùëÉ‚Äûùêª‚Äù, and a likelihood function that says how likely one is to observe any value of the collected evi- dence for each of the hypotheses in the class ùëÉ‚Äûùê∏ j ùêª‚Äù. Bayes‚Äô theorem is then interpreted as telling us how to update the initial prior ùëÉ‚Äûùêª‚Äù in light of the available evidence ùê∏ to ùëÉ‚Äûùê∏jùêª‚ÄùùëÉ‚Äûùêª‚Äù produce posterior beliefs ùëÉ‚Äûùêª j ùê∏‚Äù = . Informally, this can be stated as ‚Äúpos- ùëÉ‚Äûùê∏‚Äù terior equals prior times likelihood, divided by the evidence‚Äù. Now, because the evidence ùëÉ‚Äûùê∏‚Äù is the same for all hypotheses, we can get away with simply normalizing over the hypotheses. Àù
Note that ùëé ùëÉ‚Äûùê¥ = ùëé j ùêµ‚Äù = 1 also allows us to marginalize over random variables. That is, we can drop variables from a joint distribution such as ùëÉ‚Äûùê¥, ùêµ‚Äù. After all, we have that
ùëé ùëÉ‚Äûùêµ j ùê¥ = ùëé‚ÄùùëÉ‚Äûùê¥ = ùëé‚Äù = ùëé ùëÉ‚Äûùêµ, ùê¥ = ùëé‚Äù = ùëÉ‚Äûùêµ‚Äù. (2.6.6)
Independenceisanother fundamentallyimportant concept that formsthebackboneofmany important ideas in statistics. In short, two variables are independent if conditioning on the value of ùê¥ does not cause any change to the probability distribution associated with ùêµ and vice versa. More formally, independence, denoted ùê¥ ? ùêµ, requires that ùëÉ‚Äûùê¥ j ùêµ‚Äù = ùëÉ‚Äûùê¥‚Äù and, consequently, that ùëÉ‚Äûùê¥, ùêµ‚Äù = ùëÉ‚Äûùê¥ j ùêµ‚ÄùùëÉ‚Äûùêµ‚Äù = ùëÉ‚Äûùê¥‚ÄùùëÉ‚Äûùêµ‚Äù. Independence is often an appropriate assumption. For example, if the random variable ùê¥ represents the outcome from tossing one fair coin and the random variable ùêµ represents the outcome from tossing another, then knowing whether ùê¥ came up heads should not influence the probability of ùêµ coming up heads. Independence is especially useful when it holds among the successive draws of our data from some underlying distribution (allowing us to make strong statistical conclusions) or when it holds among various variables in our data, allowing us to work with simpler models that encode this independence structure. On the other hand, estimating the dependencies among random variables is often the very aim of learning. We care to estimate the probabil- ity of disease given symptoms specifically because we believe that diseases and symptoms are not independent. Note that because conditional probabilities are proper probabilities, the concepts of inde- pendenceanddependencealsoapplytothem. Tworandomvariables ùê¥ and ùêµ arecondition- ally independent given a third variable ùê∂ if and only if ùëÉ‚Äûùê¥, ùêµ j ùê∂‚Äù = ùëÉ‚Äûùê¥ j ùê∂‚ÄùùëÉ‚Äûùêµ j ùê∂‚Äù. Interestingly, two variables can be independent in general but become dependent when conditioning on a third. This often occurs when the two random variables ùê¥ and ùêµ cor- respond to causes of some third variable ùê∂. For example, broken bones and lung cancer might be independent in the general population but if we condition on being in the hospital then we might find that broken bones are negatively correlated with lung cancer. That is
Preliminaries
Àù
ùëé ùëÉ‚Äûùê¥ = ùëé j ùêµ‚Äù = 1, we can
ùëÉ‚Äûùêµ j ùê¥‚ÄùùëÉ‚Äûùê¥‚Äù
Probability and Statistics
73

because the broken bone explains away why some person is in the hospital and thus lowers the probability that they are hospitalized because of having lung cancer. And conversely, two dependent random variables can become independent upon condition- ing on a third. This often happens when two otherwise unrelated events have a common cause. Shoe size and reading level are highly correlated among elementary school students, but this correlation disappears if we condition on age. 2.6.5 An Example
Let‚Äôs put our skills to the test.bubuAssume that a doctor administers an HIV test to a patient. This test is fairly accurate and fails only with 1% probability if the patient is healthy but reported as diseased, i.e., healthy patients test positive in 1% of cases. Moreover, it never fails to detect HIV if the patient actually has it. We use ùê∑1 2 f0,1g to indicate the diagnosis (0 if negative and 1 if positive) and ùêª 2 f0,1g to denote the HIV status. Conditional probability ùêª = 1 ùêª = 0
ùëÉ‚Äûùê∑1 = 1 j ùêª‚Äù 1 0.01 ùëÉ‚Äûùê∑1 = 0 j ùêª‚Äù 0 0.99
Note that the column sums are all 1 (but the row sums do not), since they are conditional probabilities. Let‚Äôs compute the probability of the patient having HIV if the test comes back positive, i.e., ùëÉ‚Äûùêª = 1 j ùê∑1 = 1‚Äù. Intuitively this is going to depend on how common the disease is, since it affects the number of false alarms. Assume that the population is fairly free of the disease, e.g., ùëÉ‚Äûùêª = 1‚Äù = 0.0015. To apply Bayes‚Äô theorem, we need to apply marginalization to determine
ùëÉ‚Äûùê∑1 = 1‚Äù =ùëÉ‚Äûùê∑1 = 1, ùêª = 0‚Äù ‚Äö ùëÉ‚Äûùê∑1 = 1, ùêª = 1‚Äù =ùëÉ‚Äûùê∑1 = 1 j ùêª = 0‚ÄùùëÉ‚Äûùêª = 0‚Äù ‚Äö ùëÉ‚Äûùê∑1 = 1 j ùêª = 1‚ÄùùëÉ‚Äûùêª = 1‚Äù =0.011485. (2.6.7)
This leads us to
ùëÉ‚Äûùêª = 1 j ùê∑1 = 1‚Äù = ùëÉ‚Äûùê∑1 = 1 j ùêª = 1‚ÄùùëÉ‚Äûùêª = 1‚Äù ùëÉ‚Äûùê∑1 = 1‚Äù = 0.1306. (2.6.8)
In other words, there is only a 13.06% chance that the patient actually has HIV, despite the testbeingprettyaccurate. Aswecansee, probabilitycanbecounterintuitive. Whatshoulda patient do upon receiving such terrifying news? Likely, the patient would ask the physician to administer another test to get clarity. The second test has different characteristics and it is not as good as the first one. Conditional probability ùêª = 1 ùêª = 0
ùëÉ‚Äûùê∑2 = 1 j ùêª‚Äù 0.98 0.03 ùëÉ‚Äûùê∑2 = 0 j ùêª‚Äù 0.02 0.97
74

Unfortunately, the second test comes back positive, too. Let‚Äôs calculate the requisite prob- abilities to invoke Bayes‚Äô theorem by assuming conditional independence:
ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1 j ùêª = 0‚Äù = ùëÉ‚Äûùê∑1 = 1 j ùêª = 0‚ÄùùëÉ‚Äûùê∑2 = 1 j ùêª = 0‚Äù = 0.0003, ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1 j ùêª = 1‚Äù = ùëÉ‚Äûùê∑1 = 1 j ùêª = 1‚ÄùùëÉ‚Äûùê∑2 = 1 j ùêª = 1‚Äù = 0.98. (2.6.9)
Now we can apply marginalization to obtain the probability that both tests come back pos- itive:
ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1‚Äù
= ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1, ùêª = 0‚Äù ‚Äö ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1, ùêª = 1‚Äù = ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1 j ùêª = 0‚ÄùùëÉ‚Äûùêª = 0‚Äù ‚Äö ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1 j ùêª = 1‚ÄùùëÉ‚Äûùêª = 1‚Äù = 0.00176955. Finally, the probability of the patient having HIV given that both tests are positive is
ùëÉ‚Äûùêª = 1 j ùê∑1 = 1, ùê∑2 = 1‚Äù = ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1 j ùêª = 1‚ÄùùëÉ‚Äûùêª = 1‚Äù ùëÉ‚Äûùê∑1 = 1, ùê∑2 = 1‚Äù = 0.8307. (2.6.11)
That is, the second test allowed us to gain much higher confidence that not all is well. De- spite the second test being considerably less accurate than the first one, it still significantly improved our estimate. The assumption of both tests being conditionally independent of each other was crucial for our ability to generate a more accurate estimate. Take the ex- treme case where we run the same test twice. In this situation we would expect the same outcome both times, hence no additional insight is gained from running the same test again. The astute reader might have noticed that the diagnosis behaved like a classifier hiding in plain sight where our ability to decide whether a patient is healthy increases as we obtain more features (test outcomes). 2.6.6 Expectations
Often, making decisions requires not just looking at the probabilities assigned to individ- ual events but composing them together into useful aggregates that can provide us with guidance. For example, when random variables take continuous scalar values, we often care about knowing what value to expect on average. This quantity is formally called an expectation. If we are making investments, the first quantity of interest might be the return we can expect, averaging over all the possible outcomes (and weighting by the appropri- ate probabilities). For instance, say that with 50% probability, an investment might fail altogether, with 40% probability it might provide a 2x return, and with 10% probability it might provide a 10x return 10x. To calculate the expected return, we sum over all re- turns, multiplying each by the probability that they will occur. This yields the expectation 0.5-0+0.4-2+40.1- 10 = 1.8. Hence the expected return is 1.8x. In general, the expectation (or average) of the random variable ùëã is defined as
E[X] = Ex-p[x] = SxP(X =x). (2.6.12) x
Preliminaries
(2.6.10)
Probability and Statistics
75

Likewise, for densities we obtain ùê∏¬ªùëã‚Ä¶ = ùë• ùëëùëù‚Äûùë•‚Äù. Sometimes we are interested in the expected value of some function of ùë•. We can calculate these expectations as
Ex-pLf(0)] =) ¬£4) PC) and Ex-rLF0]= ff foyp) de (2.6.13)
for discrete probabilities and densities, respectively. Returning to the investment exam- ple from above, ùëì might be the utility (happiness) associated with the return. Behavior economists have long noted that people associate greater disutility with losing money than the utility gained from earning one dollar relative to their baseline. Moreover, the value of money tends to be sub-linear. Possessing 100k dollars versus zero dollars can make the difference between paying the rent, eating well, and enjoying quality healthcare versus suf- fering through homelessness. On the other hand, the gains due to possessing 200k versus 100k are less dramatic. Reasoning like this motivates the clich√© that ‚Äúthe utility of money is logarithmic‚Äù. If the utility associated with a total loss were ‚Äî1, and the utilities associated with returns of
If the utility associated with a total loss were ‚Äî1, and the utilities associated with returns of 1, 2, and 10 were 1, 2 and 4, respectively, then the expected happiness of investing would be 0.5-(-1) +0.4-2+0.1-4 = 0.7 (an expected loss of utility of 30%). If indeed this were your utility function, you might be best off keeping the money in the bank. For financial decisions, we might also want to measure how risky an investment is. Here, we care not just about the expected value but how much the actual values tend to vary relative to this value. Note that we cannot just take the expectation of the difference between the actual and expected values. This is because the expectation of a difference is the difference of the expectations, ie., E[X ‚Äî E[X]] = E[X] - E[E[X]] = 0. However, we can look at the expectation of any non-negative function of this difference. The variance of a random variable is calculated by looking at the expected value of the squared differences:
Var[X] = E [(X - E[X])¬∞] = E[X*] - E[X]?. (2.6.14)
Here the equality follows by expanding (X ‚Äî E[X])? = X?‚Äî 2XE[X] + E[X]? and taking expectations for each term. The square root of the variance is another useful quantity called the standard deviation. While this and the variance convey the same information (either can be calculated from the other), the standard deviation has the nice property that it is expressed in the same units as the original quantity represented by the random variable. Lastly, the variance of a function of a random variable is defined analogously as
Vary~p[f(x)] = Ex~pLf?Q)] - Ex-p Lf)‚Äô. (2.6.15)
Returning to our investment example, we can now compute the variance of the investment. It is given by 0.5 -0+0.4-2?+0.1 - 10?bubu‚Äî 1.8?bubu= 8.36. For all intents and purposes this is arisky investment. Note that by mathematical convention mean and variance are often referenced as 4 and 0. This is particularly the case whenever we use it to parametrize a Gaussian distribution. In the same way as we introduced expectations and variance for scalar random variables, we can do so for vector-valued ones. Expectations are easy, since we can apply them el- : : def .bubu.bubuementwise. For instance, u = Ex~p[x] has coordinates y; = Ex~p[x;]. Covariances
Ô¨Ç
‚Äû
76

are more complicated. We define them by taking expectations of the outer product of the difference between random variables and their mean:
> ¬© Cova -p[x] = Exep [(x- w)(x- p)"). (2.6.16)
This matrix ùö∫ is referred to as the covariance matrix. An easy way to see its effect is to
consider some vector v of the same size as x. It follows that
viiv=Ex.p [v(x ‚Äî p)(x- n)‚Äòv] = Vary~p[v'x]. (2.6.17)
As such, ùö∫ allows us to compute the variance for any linear function of x by a simple
matrix multiplication. The off-diagonal elements tell us how correlated the coordinates are: a value of 0 means no correlation, where a larger positive value means that they are more strongly correlated. 2.6.7 Discussion
In machine learning, there are many things to be uncertain about! We can be uncertain about the value of a label given an input. We can be uncertain about the estimated value of a parameter. We can even be uncertain about whether data arriving at deployment is even from the same distribution as the training data. By aleatoric uncertainty, we mean uncertainty that is intrinsic to the problem, and due to genuine randomness unaccounted for by the observed variables. By epistemic uncertainty, we mean uncertainty over a model‚Äôs parameters, the sort of uncertainty that we can hope to reduce by collecting more data. We might have epistemic uncertainty concerning the probability that a coin turns up heads, but even once we know this probability, we are left with aleatoric uncertainty about the outcome of any future toss. No matter how long we watch someone tossing a fair coin, we will never be more or less than 50% certain that the next toss will come up heads. These terms come from mechanical modeling, (see e.g., Der Kiureghian and Ditlevsen (2009) for a review on this aspect of uncertainty quantifica- tion59). It is worth noting, however, that these terms constitute a slight abuse of language. The term epistemic refers to anything concerning knowledge and thus, in the philosophical sense, all uncertainty is epistemic. 59
We saw that sampling data from some unknown probability distribution can provide us with information that can be used to estimate the parameters of the data generating distribution.bubuThat said, the rate at which this is possible can be quite slow. In our coin tossing example (and many others) we can do no better than to design estimators that converge at a rate of 1/Vn, where n is the sample size (e.g., the number of tosses). This means that by going from 10 to 1000 observations (usually a very achievable task) we see a tenfold reduction of uncertainty, whereas the next 1000 observations help comparatively little, offering only a 1.41 times reduction. This is a persistent feature of machine learning: while there are often easy gains, it takes a very large amount of data, and often with it an enormous amount of computation, to make further gains. For an empirical review of this fact for large scale language models see Revels et al. (2016).bubuWe also sharpened our language and tools for statistical modeling. In the process of that
Preliminaries
Probability and Statistics
77

we learned about conditional probabilities and about one of the most important equations in statistics‚ÄîBayes‚Äô theorem. It is an effective tool for decoupling information conveyed by data through a likelihood term ùëÉ‚Äûùêµ j ùê¥‚Äù that addresses how well observations ùêµ match a choice of parameters ùê¥, and a prior probability ùëÉ‚Äûùê¥‚Äù which governs how plausible a par- ticular choice of ùê¥ was in the first place. In particular, we saw how this rule can be applied to assign probabilities to diagnoses, based on the efficacy of the test and the prevalence of the disease itself (i.e., our prior). Lastly, we introduced a first set of nontrivial questions about the effect of a specific proba- bility distribution, namely expectations and variances. While there are many more than just linear and quadratic expectations for a probability distribution, these two already provide a good deal of knowledge about the possible behavior of the distribution. For instance, Chebyshev‚Äôs inequality ¬© states that P(|X ‚Äî | > ko) < 1/k?, where p is the expecta- tion, a? is the variance of the distribution, and k > 1 is a confidence parameter of our choosing. It tells us that draws from a distribution lie with at least 50% probability within a [-V2o,, ¬•2c] interval centered on the expectation. 60
2.6.8 Exercises
1.bubuGive an example where observing more data can reduce the amount of uncertainty about the outcome to an arbitrarily low level. 2. Give an example where observing more data will only reduce the amount of uncertainty up to a point and then no further. Explain why this is the case and where you expect this point to occur.bubu3. We empirically demonstrated convergence to the mean for the toss of a coin. Calculate thevarianceoftheestimateoftheprobabilitythatweseeaheadafterdrawing ùëõ samples. 1. How does the variance scale with the number of observations? 2. Use Chebyshev‚Äôs inequality to bound the deviation from the expectation. 3. How does it relate to the central limit theorem? 4. Assume that we draw m samples x; from a probability distribution with zero mean and unit variance. Compute the averages Z,, fin! Dj, xi. Can we apply Chebyshev‚Äôs inequality for every z,, independently? Why not?bubu5. Given two events with probability ùëÉ‚ÄûA‚Äù and ùëÉ‚ÄûB‚Äù, compute upper and lower bounds
on ùëÉ‚ÄûA [ B‚Äù and ùëÉ‚ÄûA \ B‚Äù. Hint: graph the situation using a Venn diagram61. 61
6. Assume that we have a sequence of random variables, say ùê¥, ùêµ, andùê∂, where ùêµ only de-
pendson ùê¥, andùê∂ onlydependson ùêµ, canyousimplifythejointprobability ùëÉ‚Äûùê¥, ùêµ,ùê∂‚Äù? Hint: this is a Markov chain62. 62
7. In Section 2.6.5, assume that the outcomes of the two tests are not independent. In particular assume that either test on its own has a false positive rate of 10% and a false negative rate of 1%. That is, assume that ùëÉ‚Äûùê∑ = 1 j ùêª = 0‚Äù = 0.1 and that ùëÉ‚Äûùê∑ = 0 j ùêª = 1‚Äù = 0.01. Moreover, assume that for ùêª = 1 (infected) the test outcomes are
Preliminaries
78

conditionally independent, i.e., that ùëÉ‚Äûùê∑1, ùê∑2 j ùêª = 1‚Äù = ùëÉ‚Äûùê∑1 j ùêª = 1‚ÄùùëÉ‚Äûùê∑2 j ùêª =
1‚Äù but that for healthy patients the outcomes are coupled via ùëÉ‚Äûùê∑1 = ùê∑2 = 1 j ùêª = 0‚Äù = 0.02. 1. Work out the joint probability table for ùê∑1 and ùê∑2, given ùêª = 0 based on the infor-
mation you have so far. 2. Derive the probability that the patient is diseased (ùêª = 1) after one test returns
positive. You can assume the same baseline probability ùëÉ‚Äûùêª = 1‚Äù = 0.0015 as before. 3. Derive the probability that the patient is diseased (ùêª = 1) after both tests return
positive. 8. Assume that you are an asset manager for an investment bank and you have a choice of stocks s; to invest in. Your portfolio needs to add up to 1 with weights a; for each stock. The stocks have an average return tp = E,~p[s] and covariance X = Covs~p[s]. 1. Compute the expected return for a given portfolio ùú∂. 2. If you wanted to maximize the return of the portfolio, how should you choose your investment? 3. Compute the variance of the portfolio. 4. Formulate an optimization problem of maximizing the return while keeping the vari- anceconstrainedtoanupperbound. ThisistheNobel-PrizewinningMarkovitzport- folio63 (Mangram, 2013). To solve it you will need a quadratic programming solver, something way beyond the scope of this book. 63
Discussions64. 64
2.7 Documentation
ae
While we cannot possibly introduce every single PyTorch function and class (and the infor- mation might become outdated quickly), the API documentation65 and additional tutorials 66 and examples provide such documentation. This section provides some guidance for how to explore the PyTorch API. 65
import torch
66
¬¢
2.7.1 Functions and Classes in a Module
To know which functions and classes can be called in a module, we invoke the dir func- tion. For instance, we can query all properties in the module for generating random num- bers:
Documentation
79

print(dir(torch.distributions))
['AbsTransform', 'AffineTransform', 'Bernoulli', 'Beta', 'Binomial', ‚Ü©!'CatTransform', 'Categorical', 'Cauchy', 'Chi2', 'ComposeTransform', ‚Ü©!'ContinuousBernoulli', 'CorrCholeskyTransform', ‚Ü©!'CumulativeDistributionTransform', 'Dirichlet', 'Distribution', 'ExpTransform ‚Ü©!', 'Exponential', 'ExponentialFamily', 'FisherSnedecor', 'Gamma', 'Geometric ‚Ü©!', 'Gumbel', 'HalfCauchy', 'HalfNormal', 'Independent', 'IndependentTransform ‚Ü©!', 'Kumaraswamy', 'LKJCholesky', 'Laplace', 'LogNormal', 'LogisticNormal', ‚Ü©!'LowRankMultivariateNormal', 'LowerCholeskyTransform', 'MixtureSameFamily', ‚Ü©!'Multinomial', 'MultivariateNormal', 'NegativeBinomial', 'Normal', ‚Ü©!'OneHotCategorical', 'OneHotCategoricalStraightThrough', 'Pareto', 'Poisson', ‚Ü©! 'PositiveDefiniteTransform', 'PowerTransform', 'RelaxedBernoulli', ‚Ü©!'RelaxedOneHotCategorical', 'ReshapeTransform', 'SigmoidTransform', ‚Ü©!'SoftmaxTransform', 'SoftplusTransform', 'StackTransform', ‚Ü©!'StickBreakingTransform', 'StudentT', 'TanhTransform', 'Transform', ‚Ü©!'TransformedDistribution', 'Uniform', 'VonMises', 'Weibull', 'Wishart', '__ ‚Ü©!all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '_ ‚Ü©!_name__', '__package__', '__path__', '__spec__', 'bernoulli', 'beta', ‚Ü©!'biject_to', 'binomial', 'categorical', 'cauchy', 'chi2', 'constraint_ ‚Ü©!registry', 'constraints', 'continuous_bernoulli', 'dirichlet', 'distribution ‚Ü©!', 'exp_family', 'exponential', 'fishersnedecor', 'gamma', 'geometric', ‚Ü©!'gumbel', 'half_cauchy', 'half_normal', 'identity_transform', 'independent', ‚Ü©!'kl', 'kl_divergence', 'kumaraswamy', 'laplace', 'lkj_cholesky', 'log_normal ‚Ü©!', 'logistic_normal', 'lowrank_multivariate_normal', 'mixture_same_family', ‚Ü©!'multinomial', 'multivariate_normal', 'negative_binomial', 'normal', 'one_ ‚Ü©!hot_categorical', 'pareto', 'poisson', 'register_kl', 'relaxed_bernoulli', ‚Ü©!'relaxed_categorical', 'studentT', 'transform_to', 'transformed_distribution ‚Ü©!', 'transforms', 'uniform', 'utils', 'von_mises', 'weibull', 'wishart']
Generally, we can ignore functions that start and end with __ (special objects in Python) or functionsthatstartwithasingle_(usuallyinternalfunctions). Basedontheremainingfunc- tion or attribute names, we might hazard a guess that this module offers various methods for generating random numbers, including sampling from the uniform distribution (uniform), normal distribution (normal), and multinomial distribution (multinomial).bubu2.7.2 Specific Functions and Classes
For specific instructions on how to use a given function or class, we can invoke the help function. Asanexample,let‚Äôsexploretheusageinstructionsfortensors‚Äôonesfunction. help(torch.ones)
Help on built-in function ones in module torch:
ones(...)
ones(*size, *, out=None, dtype=None, layout=torch.strided, device=None, ‚Ü©! requires_grad=False) -> Tensor
Returns a tensor filled with the scalar value 1, with the shape defined
Preliminaries
80

by the variable argument size. Args:
size (int...): a sequence of integers defining the shape of the‚ê£ ‚Ü©!output tensor. Can be a variable number of arguments or a collection like a‚ê£ ‚Ü©!list or tuple. Keyword arguments:
out (Tensor, optional): the output tensor. dtype (torch.dtype, optional): the desired data type of returned‚ê£ ‚Ü©!tensor. Default: if None, uses a global default (see torch.set_default_ ‚Ü©!tensor_type()). layout (torch.layout, optional): the desired layout of returned‚ê£ ‚Ü©!Tensor. Default: torch.strided. device (torch.device, optional): the desired device of returned‚ê£
‚Ü©!tensor. Default: if None, uses the current device for the default tensor‚ê£
‚Ü©!type
(see torch.set_default_tensor_type()). device will be the CPU
for CPU tensor types and the current CUDA device for CUDA tensor‚ê£
‚Ü©!types. requires_grad (bool, optional): If autograd should record operations‚ê£
‚Ü©!on the
returned tensor.bubuDefault: False. Example::
>>> torch.ones(2, 3) tensor([[ 1., 1., 1.], [ 1., 1., 1.]]) >>> torch.ones(5) tensor([ 1., 1., 1., 1.,
From the documentation, we can see that the ones function creates a new tensor with the specified shape and sets all the elements to the value of 1. Whenever possible, you should run a quick test to confirm your interpretation:
torch.ones(4)
tensor([1., 1., 1., 1.])
1.])
Documentation
81

In the Jupyter notebook, we can use ? to display the document in another window. For example, list? will create content that is almost identical to help(list), displaying it in a new browser window. In addition, if we use two question marks, such as list??, the Python code implementing the function will also be displayed. The official documentation provides plenty of descriptions and examples that are beyond this book. We emphasize important use cases that will get you started quickly with prac- tical problems, rather than completeness of coverage. We also encourage you to study the source code of the libraries to see examples of high-quality implementations of production code. By doing this you will become a better engineer in addition to becoming a better scientist.bubuDiscussions67. 67
3
Linear Neural Networks for Regression
Before we worry about making our neural networks deep, it will be helpful to implement some shallow ones, for which the inputs connect directly to the outputs. This will prove im- portant for a few reasons. First, rather than getting distracted by complicated architectures, we can focus on the basics of neural network training, including parametrizing the output layer, handling data, specifying a loss function, and training the model. Second, this class of shallow networks happens to comprise the set of linear models, which subsumes many classical methods of statistical prediction, including linear and softmax regression. Un- derstanding these classical tools is pivotal because they are widely used in many contexts and we will often need to use them as baselines when justifying the use of fancier archi- tectures. This chapter will focus narrowly on linear regression and the next one will extend our modeling repertoire by developing linear neural networks for classification. 3.1 Linear Regression
ee
Regression problems pop up whenever we want to predict a numerical value. Common ex- amples include predicting prices (of homes, stocks, etc.), predicting the length of stay (for patients in the hospital), forecasting demand (for retail sales), among numerous others. Not every prediction problem is one of classical regression. Later on, we will introduce classifi- cation problems, where the goal is to predict membership among a set of categories. As a running example, suppose that we wish to estimate the prices of houses (in dollars) based on their area (in square feet) and age (in years). To develop a model for predicting house prices, we need to get our hands on data, including the sales price, area, and age for each home. In the terminology of machine learning, the dataset is called a training dataset or training set, and each row (containing the data corresponding to one sale) is called an example (or data point, instance, sample). The thing we are trying to predict (price) is called a label (or target). The variables (age and area) upon which the predictions are based are called features (or covariates). %matplotlib inline import math import time import numpy as np
82
(continues on next page)
Linear Regression
83

import torch from d2l import torch as d2l
3.1.1 Basics
Linear regression is both the simplest and most popular among the standard tools for tack- ling regression problems. Dating back to the dawn of the 19th century (Gauss, 1809, Leg- endre, 1805), linear regression flows from a few simple assumptions. First, we assume that the relationship between features x and target ùë¶ is approximately linear, i.e., that the con- ditional mean ùê∏¬ªùëå j ùëã = x‚Ä¶ can be expressed as a weighted sum of the features x. This setup allows that the target value may still deviate from its expected value on account of observation noise. Next, we can impose the assumption that any such noise is well behaved, following a Gaussian distribution. Typically, we will use ùëõ to denote the number of exam- ples in our dataset. We use superscripts to enumerate samples and targets, and subscripts to index coordinates. More concretely, x‚Äûùëñ‚Äù denotes the ùëñth sample and ùë•‚Äûùëñ‚Äù ùëó denotes its ùëóth coordinate. At the heart of every solution is a model that describes how features can be transformed into an estimate of the target. The assumption of linearity means that the expected value of the target (price) can be expressed as a weighted sum of the features (area and age):
price = Warea * area + Wage age + b. (3.1.1)
Here ùë§area and ùë§age are called weights, and ùëè is called a bias (or offset or intercept). The weights determine the influence of each feature on our prediction. The bias determines the value of the estimate when all features are zero. Even though we will never see any newly- built homes with precisely zero area, we still need the bias because it allows us to express all linear functions of our features (rather than restricting us to lines that pass through the origin). Strictly speaking, (3.1.1) is an aÔ¨Äine transformation of input features, which is characterized by a linear transformation of features via a weighted sum, combined with a translation via the added bias. Given a dataset, our goal is to choose the weights w and the bias ùëè that, on average, make our model‚Äôs predictions fit the true prices observed in the data as closely as possible. In disciplines where it is common to focus on datasets with just a few features, explicitly expressing models long-form, as in (3.1.1), is common. In machine learning, we usually work with high-dimensional datasets, where it is more convenient to employ compact lin- ear algebra notation. When our inputs consist of ùëë features, we can assign each an index (between 1 and ùëë) and express our prediction ÀÜùë¶ (in general the ‚Äúhat‚Äù symbol denotes an estimate) as
SSwxpte+++wara tb. (3.1.2)
(continued from previous page)
Model
Linear Neural Networks for Regression
84

Collecting all features into a vector x 2 Rùëë and all weights into a vector w 2 Rùëë, we can express our model compactly via the dot product between w and x:
(3.1.3)
In (3.1.3), the vector x corresponds to the features of a single example. We will often find it convenient to refer to features of our entire dataset of n examples via the design matrix X ‚Ç¨ R"*¬¢, Here, X contains one row for every example and one column for every feature. For a collection of features X, the predictions y ‚Ç¨ R‚Äù can be expressed via the matrix‚Äîvector product:
(3.1.4)
where broadcasting (Section 2.1.4) is applied during the summation. Given features of a training dataset X and corresponding (known) labels y, the goal of linear regression is to find the weight vector w and the bias term ùëè such that, given features of a new data example sampled from the same distribution as X, the new example‚Äôs label will (in expectation) be predicted with the smallest error. Even if we believe that the best model for predicting ùë¶ given x is linear, we would not
Even if we believe that the best model for predicting y given x is linear, we would not expect to find a real-world dataset of n examples where y") exactly equals w‚Ñ¢x + b for all 1 < i < n. For example, whatever instruments we use to observe the features X and labels y, there might be a small amount of measurement error. Thus, even when we are confident that the underlying relationship is linear, we will incorporate a noise term to account for such errors. Before we can go about searching for the best parameters (or model parameters) w and ùëè,
we will need two more things: (i) a measure of the quality of some given model; and (ii) a procedure for updating the model to improve its quality. Loss Function
Naturally, fitting our model to the data requires that we agree on some measure of fitness (or, equivalently, of unfitness). Loss functions quantify the distance between the real and predicted values of the target. The loss will usually be a nonnegative number where smaller values are better and perfect predictions incur a loss of 0. For regression problems, the most common loss function is the squared error. When our prediction for an example ùëñ is ÀÜùë¶‚Äûùëñ‚Äù and the corresponding true label is ùë¶‚Äûùëñ‚Äù, the squared error is given by:
. l/s, \\2 1 (w,b) = 5 (99 -y) (3.1.5)
The constant 1 2 makes no real difference but proves to be notationally convenient, since it cancels out when we take the derivative of the loss. Because the training dataset is given to us, and thus is out of our control, the empirical error is only a function of the model parameters. In Fig. 3.1.1, we visualize the fit of a linear regression model in a problem with one-dimensional inputs. Note that large differences between estimates ÀÜùë¶‚Äûùëñ‚Äù and targets ùë¶‚Äûùëñ‚Äù lead to even larger contri- butions to the loss, due to its quadratic form (this quadraticity can be a double-edge sword;
ÀÜùë¶ = w>x ‚Äö ùëè. ÀÜy = Xw ‚Äö ùëè,
Linear Regression
85


tFig. 3.1.1
Fitting a linear regression model to one-dimensional data. while it encourages the model to avoid large errors it can also lead to excessive sensitivity to anomalous data). To measure the quality of a model on the entire dataset of ùëõ examples, we simply average (or equivalently, sum) the losses on the training set:
an 2 IY rol ; ; L(w, b) = ‚Äî 911 (w,b) = =D) 5 (w'x) +b-y) (3.1.6) i=l i:
When training the model, we seek parameters (w*, b*) that minimize the total loss across
all training examples:
w*,b* = argmin
ùêø‚Äûw, ùëè‚Äù. w,ùëè (3.1.7)
Analytic Solution
Unlike most of the models that we will cover, linear regression presents us with a surpris- ingly easy optimization problem. In particular, we can find the optimal parameters (as assessed on the training data) analytically by applying a simple formula as follows. First, we can subsume the bias b into the parameter w by appending a column to the design ma- trix consisting of all 1s. Then our prediction problem is to minimize ||y ‚Äî Xw||?. As long as the design matrix X has full rank (no feature is linearly dependent on the others), then there will be just one critical point on the loss surface and it corresponds to the minimum of the loss over the entire domain. Taking the derivative of the loss with respect to w and setting it equal to zero yields:
Ow lly ‚Äî Xw]|? = 2X7 (Xw - y) = 0 and hence X'y = X'Xw. (3.1.8)
Solving for w provides us with the optimal solution for the optimization problem. Note that this solution
w* =(X‚Ñ¢X) |! XTy
(3.1.9)
willonlybeuniquewhen thematrix X>X isinvertible, i.e., when thecolumns ofthedesign
matrix are linearly independent (Golub and Van Loan, 1996). While simple problems like linear regression may admit analytic solutions, you should not get used to such good fortune. Although analytic solutions allow for nice mathematical analysis, therequirementofananalyticsolutionissorestrictivethatitwouldexcludealmost all exciting aspects of deep learning. an
Linear Neural Networks for Regression
86

Minibatch Stochastic Gradient Descent
Fortunately, even in cases where we cannot solve the models analytically, we can still of- ten train models effectively in practice. Moreover, for many tasks, those hard-to-optimize models turn out to be so much better that figuring out how to train them ends up being well worth the trouble. The key technique for optimizing nearly every deep learning model, and which we will call upon throughout this book, consists of iteratively reducing the error by updating the parameters in the direction that incrementally lowers the loss function. This algorithm is called gradient descent. The most naive application of gradient descent consists of taking the derivative of the loss function, which is an average of the losses computed on every single example in the dataset. In practice, this can be extremely slow: we must pass over the entire dataset before making a single update, even if the update steps might be very powerful (Liu and Nocedal, 1989). Even worse, if there is a lot of redundancy in the training data, the benefit of a full update is limited. The other extreme is to consider only a single example at a time and to take update steps based on one observation at a time. The resulting algorithm, stochastic gradient descent (SGD) can be an effective strategy (Bottou, 2010), even for large datasets. Unfortunately, SGD has drawbacks, both computational and statistical. One problem arises from the fact that processors are a lot faster multiplying and adding numbers than they are at moving data from main memory to processor cache. It is up to an order of magnitude more efficient to perform a matrix‚Äìvector multiplication than a corresponding number of vector‚Äìvector operations. Thismeansthatitcantakealotlongertoprocessonesampleatatimecompared to a full batch. A second problem is that some of the layers, such as batch normalization (to be described in Section 8.5), only work well when we have access to more than one observation at a time. The solution to both problems is to pick an intermediate strategy: rather than taking a full batch or only a single sample at a time, we take a minibatch of observations (Li et al., 2014). The specific choice of the size of the said minibatch depends on many factors, such as the amount of memory, the number of accelerators, the choice of layers, and the total dataset size. Despite all that, a number between 32 and 256, preferably a multiple of a large power of 2, is a good start. This leads us to minibatch stochastic gradient descent. In its most basic form, in each iteration ùë°, we first randomly sample a minibatch Bùë° consist- ing of a fixed number jBj of training examples. We then compute the derivative (gradient) of the average loss on the minibatch with respect to the model parameters. Finally, we mul- tiply the gradient by a predetermined small positive value ùúÇ, called the learning rate, and subtract the resulting term from the current parameter values. We can express the update as follows:
(w, b) ‚Äî (w, b) - al >) Aeon)!bubuCw, b). (3.1.10) ic B,
In summary, minibatch SGD proceeds as follows: (i) initialize the values of the model
ùúÇ
Linear Regression
87

parameters, typically at random; (ii) iteratively sample random minibatches from the data, updating the parameters in the direction of the negative gradient. For quadratic losses and affine transformations, this has a closed-form expansion:
ùúÇ
wew- ¬ª Owl (wb) =w- a ¬ª x) (wix'? +b- y) S| icB, S| ie B, (3.1.11) 7 @ - 7 Ty) (i b‚Äîb-‚Äî Opl\? (wy b =b-‚Äî wx‚Äô+b-y : ray py LS‚Äô (w, b) ray aI ) )
Since we pick a minibatch B we need to normalize by its size jBj. Frequently minibatch size and learning rate are user-defined. Such tunable parameters that are not updated in the training loop are called hyperparameters. They can be tuned automatically by a number of techniques, such as Bayesian optimization (Frazier, 2018). In the end, the quality of the solution is typically assessed on a separate validation dataset (or validation set). After training for some predetermined number of iterations (or until some other stopping criterionismet), werecordtheestimatedmodelparameters, denoted ÀÜw, ÀÜùëè. Notethatevenif our function is truly linear and noiseless, these parameters will not be the exact minimizers of the loss, nor even deterministic. Although the algorithm converges slowly towards the minimizers it typically will not find them exactly in a finite number of steps. Moreover, the minibatches B used for updating the parameters are chosen at random. This breaks determinism. Linear regression happens to be a learning problem with a global minimum (whenever X is full rank, or equivalently, whenever X>X is invertible). However, the loss surfaces for deep networks contain many saddle points and minima. Fortunately, we typically do not care about finding an exact set of parameters but merely any set of parameters that leads to accurate predictions (and thus low loss). In practice, deep learning practitioners seldom struggle to find parameters that minimize the loss on training sets (Frankle and Carbin, 2018, Izmailov et al., 2018). The more formidable task is to find parameters that lead to accurate predictions on previously unseen data, a challenge called generalization. We return to these topics throughout the book. Given the model ÀÜw>x ‚Äö ÀÜùëè, we can now make predictions for a new example, e.g., pre-
dicting the sales price of a previously unseen house given its area ùë•1 and age ùë•2. Deep learning practitioners have taken to calling the prediction phase inference but this is a bit of a misnomer‚Äîinference refers broadly to any conclusion reached on the basis of evidence, including both the values of the parameters and the likely label for an unseen instance. If anything, in the statistics literature inference more often denotes parameter inference and this overloading of terminology creates unnecessary confusion when deep learning prac- titioners talk to statisticians. In the following we will stick to prediction whenever possi- ble. 3.1.2 Vectorization for Speed
ùúÇ
Predictions
Linear Neural Networks for Regression
88

When training our models, we typically want to process whole minibatches of examples si- multaneously. Doing this efficiently requires that we vectorize the calculations and leverage fast linear algebra libraries rather than writing costly for-loops in Python. To see why this matters so much, let‚Äôs consider two methods for adding vectors. To start, we instantiate two 10,000-dimensional vectors containing all 1s. In the first method, we loop over the vectors with a Python for-loop. In the second, we rely on a single call to +. n = 10000
nou
a = torch.ones(n)
b = torch.ones(n)
Now we can benchmark the workloads. First, we add them, one coordinate at a time, using a for-loop. c = torch.zeros(n) t = time.time() for i in range(n): c[i] = a[i] + b[i] f'{time.time() - t:.5f} sec'
c = torch.zeros(n)
t = time.time()
'0.17802 sec'
Alternatively, we rely on the reloaded + operator to compute the elementwise sum. t = time.time() d = a + b f'{time.time() - t:.5f} sec'
'0.00036 sec'
The second method is dramatically faster than the first. Vectorizing code often yields order- of-magnitude speedups.bubuMoreover, we push more of the mathematics to the library so we do not have to write as many calculations ourselves, reducing the potential for errors and increasing portability of the code. 3.1.3 The Normal Distribution and Squared Loss
Sofarwehavegivenafairlyfunctionalmotivationofthesquaredlossobjective: theoptimal parameters return the conditional expectation ùê∏¬ªùëå j ùëã‚Ä¶ whenever the underlying pattern is truly linear, and the loss assigns large penalties for outliers. We can also provide a more formal motivation for the squared loss objective by making probabilistic assumptions about the distribution of noise. Linear regression was invented at the turn of the 19th century. While it has long been debated whether Gauss or Legendre first thought up the idea, it was Gauss who also dis- covered the normal distribution (also called the Gaussian). It turns out that the normal
Linear Regression
89

distribution and linear regression with squared loss share a deeper connection than com- mon parentage. To begin, recall that a normal distribution with mean ùúá and variance ùúé2 (standard deviation
ùúé) is given as
1 1 P(x) = Vaw? (-s30-w"). (3.1.12) mo? Below we define a function to compute the normal distribution. def normal(x, mu, sigma): p = 1 / math.sqrt(2 * math.pi * sigma**2) return p * np.exp(-0.5 * (x - mu)**2 / sigma**2)
We can now visualize the normal distributions. # Use NumPy again for visualization x = np.arange(-7, 7, 0.01) # Mean and standard deviation pairs params = [(0, 1), (0, 2), (3, 1)] d2l.plot(x, [normal(x, mu, sigma) for mu, sigma in params], xlabel='x', ylabel='p(x)', figsize=(4.5, 2.5), legend=[f'mean {mu}, std {sigma}' for mu, sigma in params])
0.47 mean 0, std 1 ==- mean 0, std 2 ‚Äî-- mean 3, std 1
Note that changing the mean corresponds to a shift along the ùë•-axis, and increasing the
variance spreads the distribution out, lowering its peak. One way to motivate linear regression with squared loss is to assume that observations arise fromnoisymeasurements,wherethenoiseùúñ followsthenormaldistributionN‚Äû0, ùúé2‚Äù:
y =w'x+b+e where ‚Ç¨ ~ N(0,07). (3.1.13)
Thus, we can now write out the likelihood of seeing a particular ùë¶ for a given x via
1 P(y|x)= exp ~ aga (9 wx =)? : (3.1.14) 2no?bubuAs such, the likelihood factorizes. According to the principle of maximum likelihood, the
Linear Neural Networks for Regression
90

best values of parameters w and ùëè are those that maximize the likelihood of the entire
dataset:
ùëÉ‚Äûy j X‚Äù = ùëù‚Äûùë¶‚Äûùëñ‚Äù j x‚Äûùëñ‚Äù‚Äù. (3.1.15) ùëñ=1
The equality follows since all pairs ‚Äûx‚Äûùëñ‚Äù, ùë¶‚Äûùëñ‚Äù‚Äù were drawn independently of each other. Es- timatorschosenaccordingtotheprincipleofmaximumlikelihoodarecalledmaximumlike- lihood estimators. While, maximizing the product of many exponential functions, might look difficult, we can simplify things significantly, without changing the objective, by max- imizing the logarithm of the likelihood instead. For historical reasons, optimizations are moreoftenexpressedas minimizationratherthan maximization. So, withoutchangingany- thing, wecanminimizethenegativelog-likelihood, whichwecanexpressasfollows:
n
n ~log PCy |X) = 9) jlowt2ne?) + a(x ‚Äîw'x!? 5). (8.1.16)
If we assume that ùúé is fixed, we can ignore the first term, because it does not depend on w
or ùëè. The second term is identical to the squared error loss introduced earlier, except for the multiplicative constant 1 ùúé2. Fortunately, the solution does not depend on ùúé either. It follows that minimizing the mean squared error is equivalent to the maximum likelihood estimation of a linear model under the assumption of additive Gaussian noise. 3.1.4 Linear Regression as a Neural Network
While linear models are not sufficiently rich to express the many complicated networks that we will introduce in this book, (artificial) neural networks are rich enough to subsume linear models as networks in which every feature is represented by an input neuron, all of which are connected directly to the output. Fig. 3.1.2 depicts linear regression as a neural network. The diagram highlights the con- nectivity pattern, such as how each input is connected to the output, but not the specific values taken by the weights or biases. Output layer Input layer
tFig. 3.1.2
Linear regression is a single-layer neural network. The inputs are ùë•1, .bubu. .,ùë•ùëë. We refer to ùëë as the number of inputs or the feature dimensional-
ity in the input layer. The output of the network is ùëú1. Because we are just trying to predict a single numerical value, we have only one output neuron. Note that the input values are all given. There is just a single computed neuron. In summary, we can think of linear regres- sion as a single-layer fully connected neural network. We will encounter networks with far more layers in later chapters. Linear Regression
91

Because linear regression predates computational neuroscience, it might seem anachro- nistic to describe linear regression in terms of neural networks. Nonetheless, they were a natural place to start when the cyberneticists and neurophysiologists Warren McCulloch and Walter Pitts began to develop models of artificial neurons. Consider the cartoonish picture of a biological neuron in Fig. 3.1.3, consisting of dendrites (input terminals), the nucleus (CPU), the axon (output wire), and the axon terminals (output terminals), enabling connections to other neurons via synapses. Dendrite Axon Terminal Node of Cell body Ranvier Schwann cell Myelin sheath Nucleus
tFig. 3.1.3
The real neuron (source: ‚ÄúAnatomy and Physiology‚Äù by the US National Cancer Institute‚Äôs Surveillance, Epidemiology and End Results (SEER) Program). Information ùë•ùëñ arriving from other neurons (or environmental sensors) is received in the
dendrites. In particular, that information is weighted by synaptic weights ùë§ùëñ, determining the effect of the inputs, e.g., activation or inhibition via the product ùë•ùëñùë§ùëñ. The weighted inputs arriving from multiple sources are aggregated in the nucleus as a weighted sum ùë¶ = Àù ùëñ ùë•ùëñùë§ùëñ ‚Äö ùëè, possibly subject to some nonlinear postprocessing via a function ùúé‚Äûùë¶‚Äù. This information is then sent via the axon to the axon terminals, where it reaches its destination (e.g., an actuator such as a muscle) or it is fed into another neuron via its dendrites. Certainly, the high-level idea that many such units could be combined, provided they have the correct connectivity and learning algorithm, to produce far more interesting and com- plex behavior than any one neuron alone could express arises from our study of real bi- ological neural systems. At the same time, most research in deep learning today draws inspiration from a much wider source. We invoke Russell and Norvig (2016) who pointed out that although airplanes might have been inspired by birds, ornithology has not been the primary driver of aeronautics innovation for some centuries. Likewise, inspiration in deep learning these days comes in equal or greater measure from mathematics, linguistics, psychology, statistics, computer science, and many other fields. 3.1.5 Summary
In this section, we introduced traditional linear regression, where the parameters of a linear function are chosen to minimize squared loss on the training set. We also motivated this choice of objective both via some practical considerations and through an interpretation of linear regression as maximimum likelihood estimation under an assumption of linearity andGaussiannoise. Afterdiscussingbothcomputationalconsiderationsandconnectionsto
Biology
Linear Neural Networks for Regression
92

statistics, we showed how such linear models could be expressed as simple neural networks where the inputs are directly wired to the output(s). While we will soon move past linear models altogether, they are sufficient to introduce most of the components that all of our models require: parametric forms, differentiable objectives, optimization via minibatch stochastic gradient descent, and ultimately, evaluation on previously unseen data. 3.1.6 Exercises
1.bubuAssume that we have some data ùë•1, . .bubu.,ùë•ùëõ 2 R. Our goal is to find a constant ùëè such
1. Assume that we have some data x;,...,x, ‚Ç¨ R. Our goal is to find a constant b such that 5;(x; ‚Äî )? is minimized. 1. Find an analytic solution for the optimal value of ùëè. 2. How does this problem and its solution relate to the normal distribution? 3. What if we change the loss from ¬•,;(x;‚Äî b)? to 5; |x; ‚Äî b|? Can you find the optimal solution for b? 2. Prove that the affine functions that can be expressed by x>w‚Äöùëè are equivalent to linear
functions on ‚Äûx,1‚Äù. 3. Assume that you want to find quadratic functions of x, ie., f(x) = b+ Dj; wix; + Dij<i WijXiXj;- How would you formulate this in a deep network? 4. Recall that one of the conditions for the linear regression problem to be solvable was that the design matrix X>X has full rank. 1.bubuWhat happens if this is not the case? 2.bubuHow could you fix it? What happens if you add a small amount of coordinate-wise independent Gaussian noise to all entries of X? 3. What is the expected value of the design matrix X>X in this case? 4. What happens with stochastic gradient descent when X>X does not have full rank? 5. Assume that the noise model governing the additive noise ùúñ is the exponential distribu-
5. Assume that the noise model governing the additive noise ‚Ç¨ is the exponential distribu- tion. That is, p(e) = 3 exp(-lel). 1. Write out the negative log-likelihood of the data under the model ‚Äî log P(y | X). 2.bubuCan you find a closed form solution? 3. Suggest a minibatch stochastic gradient descent algorithm to solve this problem. What could possibly go wrong (hint: what happens near the stationary point as we keep on updating the parameters)? Can you fix this?bubu6. Assume that we want to design a neural network with two layers by composing two linear layers. That is, the output of the first layer becomes the input of the second layer. Why would such a naive composition not work?bubu7. What happens if you want to use regression for realistic price estimation of houses or stock prices? Àù
Àù
Àù
ùëì ‚Äûx‚Äù = ùëè ‚Äö
ùëñ ùë§ùëñùë•ùëñ ‚Äö
Object-Oriented Design for Implementation
93

1. Show that the additive Gaussian noise assumption is not appropriate. Hint: can we have negative prices? What about fluctuations? 2. Whywouldregressiontothelogarithmofthepricebemuchbetter,i.e., ùë¶ = logprice? 3. What do you need to worry about when dealing with pennystock, i.e., stock with very low prices? Hint: can you trade at all possible prices?bubuWhy is this a bigger problem for cheap stock? For more information review the celebrated Black‚ÄìScholes model for option pricing (Black and Scholes, 1973). 8. Suppose we want to use regression to estimate the number of apples sold in a grocery store. 1. What are the problems with a Gaussian additive noise model? Hint: you are selling apples, not oil. 2. The Poisson distribution68 captures distributions over counts. It is given by ùëù‚Äûùëò j
2. The Poisson distribution ¬Æ* captures distributions over counts. It is given by p(k | a) = Ake~4/k!. Here A is the rate function and k is the number of events you see. Prove that A is the expected value of counts k. 68
3. Design a loss function associated with the Poisson distribution. 4. Design a loss function for estimating logùúÜ instead. Beso
69
Discussions69. [obs
3.2 Object-Oriented Design for Implementation

In our introduction to linear regression, we walked through various components including the data, the model, the loss function, and the optimization algorithm. Indeed, linear re- gression is one of the simplest machine learning models. Training it, however, uses many of the same components that other models in this book require.bubuTherefore, before diving into the implementation details it is worth designing some of the APIs that we use throughout. Treating components in deep learning as objects, we can start by defining classes for these objects and their interactions. This object-oriented design for implementation will greatly streamline the presentation and you might even want to use it in your projects. 70
Inspired by open-source libraries such as PyTorch Lightning 70 , at a high level we wish to have three classes: (i) Module contains models, losses, and optimization methods; (ii) DataModule provides data loaders for training and validation; (iii) both classes are com- bined using the Trainer class, which allows us to train models on a variety of hardware platforms. Most code in this book adapts Module and DataModule. We will touch upon the Trainer class only when we discuss GPUs, CPUs, parallel training, and optimization algorithms. Linear Neural Networks for Regression
94

import time import numpy as np import torch from torch import nn from d2l import torch as d2l
3.2.1 Utilities
We need a few utilities to simplify object-oriented programming in Jupyter notebooks. One of the challenges is that class definitions tend to be fairly long blocks of code. Notebook readability demands short code fragments, interspersed with explanations, a requirement incompatible with the style of programming common for Python libraries. The first utility functionallowsustoregisterfunctionsasmethodsinaclassafter theclasshasbeencreated. In fact, we can do so even after we have created instances of the class! It allows us to split the implementation of a class into multiple code blocks. def add_to_class(Class): #@save """Register functions as methods in created class.""" def wrapper(obj): setattr(Class, obj.__name__, obj) return wrapper
Let‚Äôs have a quick look at how to use it. We plan to implement a class A with a method do. Instead of having code for both A and do in the same code block, we can first declare the class A and create an instance a. class A: def __init__(self): self.b = 1 a = A()
Next we define the method do as we normally would, but not in class A‚Äôs scope. Instead, we decorate this method by add_to_class with class A as its argument. In doing so, the method is able to access the member variables of A just as we would expect had it been included as part of A‚Äôs definition. Let‚Äôs see what happens when we invoke it for the instance a. @add_to_class(A) def do(self): print('Class attribute "b" is', self.b) a.do()
a.do()
Class attribute "b" is 1
The second one is a utility class that saves all arguments in a class‚Äôs __init__ method
Object-Oriented Design for Implementation
95

as class attributes. This allows us to extend constructor call signatures implicitly without additional code. class HyperParameters: #@save """The base class of hyperparameters.""" def save_hyperparameters(self, ignore=[]): raise NotImplemented
We defer its implementation into Section B.7. To use it, we define our class that inherits fromHyperParametersandcallssave_hyperparametersinthe__init__method. # Call the fully implemented HyperParameters class saved in d2l class B(d2l.HyperParameters): def __init__(self, a, b, c): self.save_hyperparameters(ignore=['c']) print('self.a =', self.a, 'self.b =', self.b) print('There is no self.c =', not hasattr(self, 'c')) b = B(a=1, b=2, c=3)
self.a = 1 self.b = 2 There is no self.c = True
The final utility allows us to plot experiment progress interactively while it is going on. In deference to the much more powerful (and complex) TensorBoard71 we name it Pro- gressBoard.bubuThe implementation is deferred to Section B.7.bubuFor now, let‚Äôs simply see it in action.bubu71
. The draw method plots a point (x, y) in the figure, with label specified in the legend. The optional every_n smooths the line by only showing 1/n points in the figure. Their values are averaged from the n neighbor points in the original figure. class ProgressBoard(d2l.HyperParameters): #@save """The board that plots data points in animation.""" def __init__(self, xlabel=None, ylabel=None, xlim=None, ylim=None, xscale='linear', yscale='linear', ls=['-', '--', '-.', ':'], colors=['C0', 'C1', 'C2', 'C3'], fig=None, axes=None, figsize=(3.5, 2.5), display=True): self.save_hyperparameters() def draw(self, x, y, label, every_n=1): raise NotImplemented
In the following example, we draw sin and cos with a different smoothness. If you run this code block, you will see the lines grow in animation. board = d2l.ProgressBoard('x') for x in np.arange(0, 10, 0.1): board.draw(x, np.sin(x), 'sin', every_n=2) board.draw(x, np.cos(x), 'cos', every_n=10)
Linear Neural Networks for Regression
96

1.0 0.5 0.0 0.5 -1.0
3.2.2 Models
The Module class is the base class of all models we will implement. At the very least we need three methods. The first, __init__, stores the learnable parameters, the train- ing_stepmethodacceptsadatabatchtoreturnthelossvalue,andfinally,configure_optimizers returns the optimization method, or a list of them, that is used to update the learnable pa- rameters. Optionally we can define validation_step to report the evaluation measures. Sometimes we put the code for computing the output into a separate forward method to make it more reusable. class Module(nn.Module, d2l.HyperParameters): #@save """The base class of models.""" def __init__(self, plot_train_per_epoch=2, plot_valid_per_epoch=1): super().__init__() self.save_hyperparameters() self.board = ProgressBoard() def loss(self, y_hat, y): raise NotImplementedError def forward(self, X): assert hasattr(self, 'net'), 'Neural network is defined' return self.net(X) def plot(self, key, value, train): """Plot a point in animation.""" assert hasattr(self, 'trainer'), 'Trainer is not inited' self.board.xlabel = 'epoch' if train: x = self.trainer.train_batch_idx / \ self.trainer.num_train_batches n = self.trainer.num_train_batches / \ self.plot_train_per_epoch else: x = self.trainer.epoch + 1 n = self.trainer.num_val_batches / \ self.plot_valid_per_epoch self.board.draw(x, value.to(d2l.cpu()).detach().numpy(), ('train_' if train else 'val_') + key, every_n=int(n))
(continues on next page)
Object-Oriented Design for Implementation
97

def training_step(self, batch): l = self.loss(self(*batch[:-1]), batch[-1]) self.plot('loss', l, train=True) return l def validation_step(self, batch): l = self.loss(self(*batch[:-1]), batch[-1]) self.plot('loss', l, train=False) def configure_optimizers(self): raise NotImplementedError
You may notice that Module is a subclass of nn.Module, the base class of neural networks in PyTorch. It provides convenient features for handling neural networks.bubuFor example, if we define a forward method, such as forward(self, X), then for an instance a we can invoke this method by a(X). This works since it calls the forward method in the built-in __call__ method. You can find more details and examples about nn.Module in Section 6.1. 3.2.3 Data
The DataModule class is the base class for data. Quite frequently the __init__ method is used to prepare the data. This includes downloading and preprocessing if needed. The train_dataloader returns the data loader for the training dataset. A data loader is a (Python) generator that yields a data batch each time it is used. This batch is then fed into the training_step method of Module to compute the loss. There is an optional val_dataloader to return the validation dataset loader. It behaves in the same manner, except that it yields data batches for the validation_step method in Module. class DataModule(d2l.HyperParameters): #@save """The base class of data.""" def __init__(self, root='../data', num_workers=4): self.save_hyperparameters() def get_dataloader(self, train): raise NotImplementedError def train_dataloader(self): return self.get_dataloader(train=True) def val_dataloader(self): return self.get_dataloader(train=False)
3.2.4 Training
The Trainer class trains the learnable parameters in the Module class with data specified in DataModule. The key method is fit, which accepts two arguments: model, an instance of Module, and data, an instance of DataModule. It then iterates over the entire dataset
(continued from previous page)
Linear Neural Networks for Regression
98

max_epochs times to train the model. As before, we will defer the implementation of this method to later chapters. class Trainer(d2l.HyperParameters): #@save """The base class for training models with data.""" def __init__(self, max_epochs, num_gpus=0, gradient_clip_val=0): self.save_hyperparameters() assert num_gpus == 0, 'No GPU support yet' def prepare_data(self, data): self.train_dataloader = data.train_dataloader() self.val_dataloader = data.val_dataloader() self.num_train_batches = len(self.train_dataloader) self.num_val_batches = (len(self.val_dataloader) if self.val_dataloader is not None else 0) def prepare_model(self, model): model.trainer = self model.board.xlim = [0, self.max_epochs] self.model = model def fit(self, model, data): self.prepare_data(data) self.prepare_model(model) self.optim = model.configure_optimizers() self.epoch = 0 self.train_batch_idx = 0 self.val_batch_idx = 0 for self.epoch in range(self.max_epochs): self.fit_epoch() def fit_epoch(self):
raise NotImplementedError
3.2.5 Summary
To highlight the object-oriented design for our future deep learning implementation, the above classes simply show how their objects store data and interact with each other. We will keep enriching implementations of these classes, such as via @add_to_class, in the rest of the book. Moreover, these fully implemented classes are saved in the D2L library72 , a lightweight toolkit that makes structured modeling for deep learning easy. In particular, it facilitates reusing many components between projects without changing much at all. For instance, we can replace just the optimizer, just the model, just the dataset, etc.; this degree of modularity pays dividends throughout the book in terms of conciseness and simplicity (this is why we added it) and it can do the same for your own projects. 72
3.2.6 Exercises
1. Locate full implementations of the above classes that are saved in the D2L library 73
73 . We strongly recommend that you look at the implementation in detail once you have gained some more familiarity with deep learning modeling. Synthetic Regression Data
99

2. Removethesave_hyperparametersstatementintheBclass. Canyoustillprintself.a and self.b? Optional: if you have dived into the full implementation of the HyperPa- rameters class, can you explain why?bubuDiscussions74. 74 
3.3 Synthetic Regression Data

Machine learning is all about extracting information from data. So you might wonder, what could we possibly learn from synthetic data? While we might not care intrinsically about the patterns that we ourselves baked into an artificial data generating model, such datasets are nevertheless useful for didactic purposes, helping us to evaluate the properties of our learning algorithms and to confirm that our implementations work as expected. For example, if we create data for which the correct parameters are known a priori, then we can check that our model can in fact recover them. %matplotlib inline import random import torch from d2l import torch as d2l
3.3.1 Generating the Dataset
For this example, we will work in low dimension for succinctness. The following code snippet generates 1000 examples with 2-dimensional features drawn from a standard nor- mal distribution. The resulting design matrix X belongs to R!¬∞¬∞%?, We generate each label by applying a ground truth linear function, corrupting them via additive noise ‚Ç¨, drawn in- dependently and identically for each example:
y = Xw ‚Äö ùëè ‚Äö ùùê. (3.3.1)
For convenience we assume that ùùê is drawn from a normal distribution with mean ùúá = 0
and standard deviation ùúé = 0.01. Note that for object-oriented design we add the code to the __init__ method of a subclass of d2l.DataModule (introduced in Section 3.2.3). It is good practice to allow the setting of any additional hyperparameters. We accomplish this with save_hyperparameters(). The batch_size will be determined later. class SyntheticRegressionData(d2l.DataModule): #@save """Synthetic data for linear regression.""" def __init__(self, w, b, noise=0.01, num_train=1000, num_val=1000, batch_size=32): super().__init__() self.save_hyperparameters() n = num_train + num_val
(continues on next page)
Linear Neural Networks for Regression
100

self.X = torch.randn(n, len(w)) noise = torch.randn(n, 1) * noise self.y = torch.matmul(self.X, w.reshape((-1, 1))) + b + noise
Below, we set the true parameters to w = [2,-3.4] " and b = 4.2. Later, we can check our
estimated parameters against these ground truth values. data = SyntheticRegressionData(w=torch.tensor([2, -3.4]), b=4.2)
Each row in features consists of a vector in R2 and each row in labels is a scalar. Let‚Äôs have a look at the first entry. print('features:', data.X[0],'\nlabel:', data.y[0])
features: tensor([0.9026, 1.0264]) label: tensor([2.5148])
3.3.2 Reading the Dataset
Training machine learning models often requires multiple passes over a dataset, grabbing one minibatch of examples at a time. This data is then used to update the model. To illustrate how this works, we implement the get_dataloader method, registering it in the SyntheticRegressionData class via add_to_class (introduced in Section 3.2.1). It takes a batch size, a matrix of features, and a vector of labels, and generates minibatches of size batch_size. As such, each minibatch consists of a tuple of features and labels. Note that we need to be mindful of whether we‚Äôre in training or validation mode: in the former, we will want to read the data in random order, whereas for the latter, being able to read data in a pre-defined order may be important for debugging purposes. @d2l.add_to_class(SyntheticRegressionData) def get_dataloader(self, train): if train: indices = list(range(0, self.num_train)) # The examples are read in random order random.shuffle(indices) else: indices = list(range(self.num_train, self.num_train+self.num_val)) for i in range(0, len(indices), self.batch_size): batch_indices = torch.tensor(indices[i: i+self.batch_size]) yield self.X[batch_indices], self.y[batch_indices]
To build some intuition, let‚Äôs inspect the first minibatch of data. Each minibatch of fea- tures provides us with both its size and the dimensionality of input features. Likewise, our minibatch of labels will have a matching shape given by batch_size. (continued from previous page)
Synthetic Regression Data
101

X, y = next(iter(data.train_dataloader())) print('X shape:', X.shape, '\ny shape:', y.shape)
X shape: torch.Size([32, 2]) y shape: torch.Size([32, 1])
While seemingly innocuous, the invocation of iter(data.train_dataloader()) illus- trates the power of Python‚Äôs object-oriented design. Note that we added a method to the SyntheticRegressionData class after creating the data object. Nonetheless, the object benefits from the ex post facto addition of functionality to the class. Throughout the iteration we obtain distinct minibatches until the entire dataset has been exhausted (try this). While the iteration implemented above is good for didactic purposes, it is inefficient in ways that might get us into trouble with real problems. For example, it requires that we load all the data in memory and that we perform lots of random memory access. The built-in iterators implemented in a deep learning framework are considerably more efficient and they can deal with sources such as data stored in files, data received via a stream, and data generated or processed on the fly. Next let‚Äôs try to implement the same method using built-in iterators. 3.3.3 Concise Implementation of the Data Loader
Rather than writing our own iterator, we can call the existing API in a framework to load data. As before, we need a dataset with features X and labels y. Beyond that, we set batch_size in the built-in data loader and let it take care of shuffling examples effi- ciently. @d2l.add_to_class(d2l.DataModule) #@save def get_tensorloader(self, tensors, train, indices=slice(0, None)): tensors = tuple(a[indices] for a in tensors) dataset = torch.utils.data.TensorDataset(*tensors) return torch.utils.data.DataLoader(dataset, self.batch_size, shuffle=train)
@d2l.add_to_class(SyntheticRegressionData) #@save def get_dataloader(self, train): i = slice(0, self.num_train) if train else slice(self.num_train, None) return self.get_tensorloader((self.X, self.y), train, i)
The new data loader behaves just like the previous one, except that it is more efficient and has some added functionality. X, y = next(iter(data.train_dataloader())) print('X shape:', X.shape, '\ny shape:', y.shape)
Linear Neural Networks for Regression
102

X shape: torch.Size([32, 2]) y shape: torch.Size([32, 1])
For instance, the data loader provided by the framework API supports the built-in __len__ method, so we can query its length, i.e., the number of batches. len(data.train_dataloader())
32
3.3.4 Summary
Data loaders are a convenient way of abstracting out the process of loading and manipu- lating data. This way the same machine learning algorithm is capable of processing many different types and sources of data without the need for modification. One of the nice things about data loaders is that they can be composed. For instance, we might be loading images and then have a postprocessing filter that crops them or modifies them in other ways. As such, data loaders can be used to describe an entire data processing pipeline. As for the model itself, the two-dimensional linear model is about the simplest we might encounter. It lets us test out the accuracy of regression models without worrying about having insufficient amounts of data or an underdetermined system of equations. We will put this to good use in the next section.bubu3.3.5 Exercises
1. What will happen if the number of examples cannot be divided by the batch size. How would you change this behavior by specifying a different argument by using the frame- work‚Äôs API? 2. Suppose that we want to generate a huge dataset, where both the size of the parameter vector w and the number of examples num_examples are large. 1. What happens if we cannot hold all data in memory? 2. How would you shuffle the data if it is held on disk? Your task is to design an eÔ¨Äicient algorithm that does not require too many random reads or writes. Hint: pseudoran- dom permutation generators 75 allow you to design a reshuffle without the need to store the permutation table explicitly (Naor and Reingold, 1999). 75
3. Implement a data generator that produces new data on the fly, every time the iterator is called. 4. How would you design a random data generator that generates the same data each time it is called? 76
Discussions76. Linear Regression Implementation from Scratch
103

3.4 Linear Regression Implementation from Scratch
|
We are now ready to work through a fully functioning implementation of linear regression. In this section, we will implement the entire method from scratch, including (i) the model; (ii) the loss function; (iii) a minibatch stochastic gradient descent optimizer; and (iv) the training function that stitches all of these pieces together. Finally, we will run our synthetic datageneratorfromSection3.3andapplyourmodelontheresultingdataset. Whilemodern deep learning frameworks can automate nearly all of this work, implementing things from scratch is the only way to make sure that you really know what you are doing. Moreover, when it is time to customize models, defining our own layers or loss functions, understand- ing how things work under the hood will prove handy. In this section, we will rely only on tensors and automatic differentiation. Later, we will introduce a more concise imple- mentation, taking advantage of the bells and whistles of deep learning frameworks while retaining the structure of what follows below. %matplotlib inline import torch from d2l import torch as d2l
3.4.1 Defining the Model
Before we can begin optimizing our model‚Äôs parameters by minibatch SGD, we need to have some parameters in the first place. In the following we initialize weights by drawing random numbers from a normal distribution with mean 0 and a standard deviation of 0.01. The magic number 0.01 often works well in practice, but you can specify a different value through the argument sigma. Moreover we set the bias to 0. Note that for object-oriented design we add the code to the __init__ method of a subclass of d2l.Module (introduced in Section 3.2.2). class LinearRegressionScratch(d2l.Module): #@save """The linear regression model implemented from scratch.""" def __init__(self, num_inputs, lr, sigma=0.01): super().__init__() self.save_hyperparameters() self.w = torch.normal(0, sigma, (num_inputs, 1), requires_grad=True) self.b = torch.zeros(1, requires_grad=True)
Next we must define our model, relating its input and parameters to its output. Using the same notation as (3.1.4) for our linear model we simply take the matrix‚Äìvector product of the input features X and the model weights w, and add the offset ùëè to each example. The product Xw is a vector and ùëè is a scalar. Because of the broadcasting mechanism (see Section 2.1.4), when we add a vector and a scalar, the scalar is added to each component of the vector. The resulting forward method is registered in the LinearRegressionScratch class via add_to_class (introduced in Section 3.2.1). Linear Neural Networks for Regression
104

@d2l.add_to_class(LinearRegressionScratch) #@save def forward(self, X): return torch.matmul(X, self.w) + self.b
3.4.2 Defining the Loss Function
Since updating our model requires taking the gradient of our loss function, we ought to define the loss function first. Here we use the squared loss function in (3.1.5). In the implementation, we need to transform the true value y into the predicted value‚Äôs shape y_hat. Theresultreturnedbythefollowingmethodwillalsohavethesameshapeasy_hat. We also return the averaged loss value among all examples in the minibatch. @d2l.add_to_class(LinearRegressionScratch) #@save def loss(self, y_hat, y): l = (y_hat - y) ** 2 / 2 return l.mean()
3.4.3 Defining the Optimization Algorithm
As discussed in Section 3.1, linear regression has a closed-form solution. However, our goal here is to illustrate how to train more general neural networks, and that requires that we teach you how to use minibatch SGD. Hence we will take this opportunity to introduce your first working example of SGD. At each step, using a minibatch randomly drawn from our dataset, we estimate the gradient of the loss with respect to the parameters. Next, we update the parameters in the direction that may reduce the loss. The following code applies the update, given a set of parameters, a learning rate lr. Since our loss is computed as an average over the minibatch, we do not need to adjust the learning rate against the batch size. In later chapters we will investigate how learning rates should be adjusted for very large minibatches as they arise in distributed large-scale learning. For now, we can ignore this dependency. WedefineourSGDclass,asubclassof d2l.HyperParameters(introducedinSection3.2.1), to have a similar API as the built-in SGD optimizer. We update the parameters in the step method. The zero_grad method sets all gradients to 0, which must be run before a back- propagation step. class SGD(d2l.HyperParameters): #@save """Minibatch stochastic gradient descent.""" def __init__(self, params, lr): self.save_hyperparameters() def step(self): for param in self.params: param -= self.lr * param.grad def zero_grad(self):
(continues on next page)
Linear Regression Implementation from Scratch
105

for param in self.params: if param.grad is not None: param.grad.zero_()
We next define the configure_optimizers method, which returns an instance of the SGD class. @d2l.add_to_class(LinearRegressionScratch) #@save def configure_optimizers(self): return SGD([self.w, self.b], self.lr)
3.4.4 Training
Now that we have all of the parts in place (parameters, loss function, model, and optimizer), we are ready to implement the main training loop. It is crucial that you understand this code fully since you will employ similar training loops for every other deep learning model covered in this book. In each epoch, we iterate through the entire training dataset, passing once through every example (assuming that the number of examples is divisible by the batch size). In each iteration, we grab a minibatch of training examples, and compute its loss through the model‚Äôs training_step method. Then we compute the gradients with respect to each parameter. Finally, we will call the optimization algorithm to update the model parameters. In summary, we will execute the following loop:
e Initialize parameters (w, b)
e Repeat until done
‚Äì Compute gradient g ùúï‚Äûw,ùëè‚Äù
jBj
‚Äî Update parameters (w, b) ‚Äî (w, b) ‚Äî ng
RecallthatthesyntheticregressiondatasetthatwegeneratedinSection3.3doesnotprovide a validation dataset. In most cases, however, we will want a validation dataset to measure our model quality. Here we pass the validation dataloader once in each epoch to mea- sure the model performance. Following our object-oriented design, the prepare_batch and fit_epoch methods are registered in the d2l.Trainer class (introduced in Section 3.2.4). @d2l.add_to_class(d2l.Trainer) #@save def prepare_batch(self, batch): return batch
@d2l.add_to_class(d2l.Trainer) #@save def fit_epoch(self): self.model.train() for batch in self.train_dataloader: loss = self.model.training_step(self.prepare_batch(batch))
(continued from previous page)
Àù
ùëñ2B ùëô‚Äûx‚Äûùëñ‚Äù, ùë¶‚Äûùëñ‚Äù,w, ùëè‚Äù
1
(continues on next page)
Linear Neural Networks for Regression
106

self.optim.zero_grad() with torch.no_grad(): loss.backward() if self.gradient_clip_val > 0: # To be discussed later self.clip_gradients(self.gradient_clip_val, self.model) self.optim.step() self.train_batch_idx += 1 if self.val_dataloader is None: return self.model.eval() for batch in self.val_dataloader: with torch.no_grad(): self.model.validation_step(self.prepare_batch(batch)) self.val_batch_idx += 1
We are almost ready to train the model, but first we need some training data. Here we use the SyntheticRegressionData class and pass in some ground truth parameters. Then we train our model with the learning rate lr=0.03 and set max_epochs=3. Note that in general, both the number of epochs and the learning rate are hyperparameters. In general, setting hyperparameters is tricky and we will usually want to use a three-way split, one set for training, a second for hyperparameter selection, and the third reserved for the final evaluation. We elide these details for now but will revise them later. model = LinearRegressionScratch(2, lr=0.03) data = d2l.SyntheticRegressionData(w=torch.tensor([2, -3.4]), b=4.2) trainer = d2l.Trainer(max_epochs=3) trainer.fit(model, data)
lo ‚Äî train_loss =-- val_loss 00 05 #10 415 20 25 3.0 epoch
Because we synthesized the dataset ourselves, we know precisely what the true parameters are. Thus, we can evaluate our success in training by comparing the true parameters with those that we learned through our training loop. Indeed they turn out to be very close to each other. with torch.no_grad():
print(f'error in estimating w: {data.w - model.w.reshape(data.w.shape)}') print(f'error in estimating b: {data.b - model.b}')
(continued from previous page)
Linear Regression Implementation from Scratch
107

error in estimating w: tensor([ 0.1408, -0.1493]) error in estimating b: tensor([0.2130])
We should not take the ability to exactly recover the ground truth parameters for granted. In general, for deep models unique solutions for the parameters do not exist, and even for linear models, exactly recovering the parameters is only possible when no feature is linearlydependentontheothers. However,inmachinelearning, weareoftenlessconcerned with recovering true underlying parameters, but rather with parameters that lead to highly accurate prediction (Vapnik, 1992). Fortunately, even on difficult optimization problems, stochastic gradient descent can often find remarkably good solutions, owing partly to the fact that, for deep networks, there exist many configurations of the parameters that lead to highly accurate prediction. 3.4.5 Summary
In this section, we took a significant step towards designing deep learning systems by im- plementing a fully functional neural network model and training loop. In this process, we built a data loader, a model, a loss function, an optimization procedure, and a visualization and monitoring tool. We did this by composing a Python object that contains all relevant components for training a model. While this is not yet a professional-grade implementation it is perfectly functional and code like this could already help you to solve small problems quickly. In the coming sections, we will see how to do this both more concisely (avoiding boilerplate code) and more eÔ¨Äiciently (using our GPUs to their full potential). 3.4.6 Exercises
1. What would happen if we were to initialize the weights to zero. Would the algorithm still work? What if we initialized the parameters with variance 1000 rather than 0.01? 2. Assume that you are Georg Simon Ohm 77 trying to come up with a model for resis- tance that relates voltage and current. Can you use automatic differentiation to learn the parameters of your model? 77
. Can you use Planck‚Äôs Law‚Äù¬Æ to determine the temperature of an object using spectral energy density? For reference, the spectral density B of radiation emanating from a black body is B(A,T) = 2he* : (exp fs - 1) . Here 2 is the wavelength, T is the temperature, c is the speed of light, h is Planck‚Äôs constant, and k is the Boltzmann constant. You measure the energy for different wavelengths 2 and you now need to fit the spectral density curve to Planck‚Äôs law. 78
4.bubuWhataretheproblemsyoumightencounterifyouwantedtocomputethesecondderiva- tives of the loss? How would you fix them?bubu5. Why is the reshape method needed in the loss function? 6. Experiment using different learning rates to find out how quickly the loss function value drops. Can you reduce the error by increasing the number of epochs of training? Linear Neural Networks for Regression
108

7. Ifthenumberofexamplescannotbedividedbythebatchsize,whathappenstodata_iter at the end of an epoch? 8. Try implementing a different loss function, such as the absolute value loss (y_hat - d2l.reshape(y, y_hat.shape)).abs().sum(). 1.bubuCheck what happens for regular data. 2. Check whether there is a difference in behavior if you actively perturb some entries, such as ùë¶5 = 10000, of y. 3. Can you think of a cheap solution for combining the best aspects of squared loss and absolute value loss? Hint: how can you avoid really large gradient values? 9. Why do we need to reshuffle the dataset? Can you design a case where a maliciously constructed dataset would break the optimization algorithm otherwise? Discussions79. 79
3.5 Concise Implementation of Linear Regression
|
Deep learning has witnessed a sort of Cambrian explosion over the past decade. The sheer number of techniques, applications and algorithms by far surpasses the progress of pre- vious decades. This is due to a fortuitous combination of multiple factors, one of which is the powerful free tools offered by a number of open-source deep learning frameworks. Theano (Bergstra et al., 2010), DistBelief (Dean et al., 2012), and Caffe (Jia et al., 2014) arguably represent the first generation of such models that found widespread adoption. In contrast to earlier (seminal) works like SN2 (Simulateur Neuristique) (Bottou and Le Cun, 1988), which provided a Lisp-like programming experience, modern frameworks of- fer automatic differentiation and the convenience of Python. These frameworks allow us to automate and modularize the repetitive work of implementing gradient-based learning algorithms. In Section 3.4, we relied only on (i) tensors for data storage and linear algebra; and (ii) automatic differentiation for calculating gradients. In practice, because data iterators, loss functions, optimizers, and neural network layers are so common, modern libraries imple- ment these components for us as well. In this section, we will show you how to implement the linear regression model from Section 3.4 concisely by using high-level APIs of deep learning frameworks. import numpy as np import torch from torch import nn from d2l import torch as d2l
Concise Implementation of Linear Regression
109

3.5.1 Defining the Model
When we implemented linear regression from scratch in Section 3.4, we defined our model parameters explicitly and coded up the calculations to produce output using basic linear algebra operations. You should know how to do this.bubuBut once your models get more complex, and once you have to do this nearly every day, you will be glad of the assistance. The situation is similar to coding up your own blog from scratch. Doing it once or twice is rewarding and instructive, but you would be a lousy web developer if you spent a month reinventing the wheel. For standard operations, we can use a framework‚Äôs predefined layers, which allow us to focus on the layers used to construct the model rather than worrying about their implemen- tation. Recall the architecture of a single-layer network as described in Fig. 3.1.2. The layer is called fully connected, since each of its inputs is connected to each of its outputs by means of a matrix‚Äìvector multiplication. In PyTorch, the fully connected layer is defined in Linear and LazyLinear classes (avail- able since version 1.8.0). The latter allows users to specify merely the output dimension, while the former additionally asks for how many inputs go into this layer. Specifying input shapes is inconvenient and may require nontrivial calculations (such as in convolutional layers). Thus, for simplicity, we will use such ‚Äúlazy‚Äù layers whenever we can. class LinearRegression(d2l.Module): #@save """The linear regression model implemented with high-level APIs.""" def __init__(self, lr): super().__init__() self.save_hyperparameters() self.net = nn.LazyLinear(1) self.net.weight.data.normal_(0, 0.01) self.net.bias.data.fill_(0)
In the forward method we just invoke the built-in __call__ method of the predefined layers to compute the outputs. @d2l.add_to_class(LinearRegression) #@save def forward(self, X): return self.net(X)
3.5.2 Defining the Loss Function
The MSELoss class computes the mean squared error (without the 1/2 factor in (3.1.5)). By default, MSELoss returns the average loss over examples. It is faster (and easier to use) than implementing our own. @d2l.add_to_class(LinearRegression) #@save def loss(self, y_hat, y): fn = nn.MSELoss() return fn(y_hat, y)
Linear Neural Networks for Regression
110

3.5.3 Defining the Optimization Algorithm
Minibatch SGD is a standard tool for optimizing neural networks and thus PyTorch sup- ports it alongside a number of variations on this algorithm in the optim module. When we instantiate an SGD instance, we specify the parameters to optimize over, obtainable from our model via self.parameters(), and the learning rate (self.lr) required by our opti- mization algorithm. @d2l.add_to_class(LinearRegression) #@save def configure_optimizers(self): return torch.optim.SGD(self.parameters(), self.lr)
3.5.4 Training
You might have noticed that expressing our model through high-level APIs of a deep learn- ing framework requires fewer lines of code. We did not have to allocate parameters indi- vidually, define our loss function, or implement minibatch SGD. Once we start working with much more complex models, the advantages of the high-level API will grow consid- erably. Now that we have all the basic pieces in place, the training loop itself is the same as the one we implemented from scratch. So we just call the fit method (introduced in Section 3.2.4), which relies on the implementation of the fit_epoch method in Section 3.4, to train our model. model = LinearRegression(lr=0.03) data = d2l.SyntheticRegressionData(w=torch.tensor([2, -3.4]), b=4.2) trainer = d2l.Trainer(max_epochs=3) trainer.fit(model, data)
15 ‚Äî train_loss =-- val_loss 10 00 05 10 415 20 25 3.0 epoch
Below, we compare the model parameters learned by training on finite data and the actual parametersthatgeneratedourdataset. Toaccessparameters, weaccesstheweightsandbias of the layer that we need. As in our implementation from scratch, note that our estimated parameters are close to their true counterparts. @d2l.add_to_class(LinearRegression) #@save
(continues on next page)
Concise Implementation of Linear Regression
111

def get_w_b(self): return (self.net.weight.data, self.net.bias.data) w, b = model.get_w_b()
print(f'error in estimating w: {data.w - w.reshape(data.w.shape)}') print(f'error in estimating b: {data.b - b}')
error in estimating w: tensor([ 0.0094, -0.0030]) error in estimating b: tensor([0.0137])
3.5.5 Summary
This section contains the first implementation of a deep network (in this book) to tap into the conveniences afforded by modern deep learning frameworks, such as MXNet (Chen et al., 2015), JAX (Frostig et al., 2018), PyTorch (Paszke et al., 2019), and Tensorflow (Abadi et al., 2016). We used framework defaults for loading data, defining a layer, a loss function, an optimizer and a training loop. Whenever the framework provides all necessary features, it is generally a good idea to use them, since the library implementations of these components tend to be heavily optimized for performance and properly tested for reliability. At the same time, try not to forget that these modules can be implemented directly. This is especially important for aspiring researchers who wish to live on the leading edge of model development, where you will be inventing new components that cannot possibly exist in any current library. In PyTorch, the data module provides tools for data processing, the nn module defines a large number of neural network layers and common loss functions. We can initialize the pa- rametersbyreplacingtheirvalueswithmethodsendingwith_. Notethatweneedtospecify the input dimensions of the network. While this is trivial for now, it can have significant knock-on effects when we want to design complex networks with many layers. Careful considerations of how to parametrize these networks is needed to allow portability. 3.5.6 Exercises
1. How would you need to change the learning rate if you replace the aggregate loss over the minibatch with an average over the loss on the minibatch? 2.bubuReview the framework documentation to see which loss functions are provided. In par- ticular, replace the squared loss with Huber‚Äôs robust loss function. That is, use the loss function
(
ny _}l-wl-¬¢ ifly-yl>o lony) = 4 nD : (3.5.1) x¬¢(y-y‚Äô) otherwise
3. How do you access the gradient of the weights of the model? (continued from previous page)
Linear Neural Networks for Regression
112

4. What is the effect on the solution if you change the learning rate and the number of epochs? Does it keep on improving? 5. How does the solution change as you vary the amount of data generated? 1. Plot the estimation error for W ‚Äî w and 6 ‚Äî b as a function of the amount of data. Hint: increase the amount of data logarithmically rather than linearly, i.e., 5, 10, 20, 50, ..., 10,000 rather than 1000, 2000, ..., 10,000. 2.bubuWhy is the suggestion in the hint appropriate? Discussions80. 80
3.6 Generalization
ae
Consider two college students diligently preparing for their final exam. Commonly, this preparation will consist of practicing and testing their abilities by taking exams adminis- teredinpreviousyears. Nonetheless, doingwellonpastexamsisnoguaranteethattheywill excel when it matters. For instance, imagine a student, Extraordinary Ellie, whose prepara- tion consisted entirely of memorizing the answers to previous years‚Äô exam questions. Even if Ellie were endowed with an extraordinary memory, and thus could perfectly recall the an- swer to any previously seen question, she might nevertheless freeze when faced with a new (previously unseen) question. By comparison, imagine another student, Inductive Irene, with comparably poor memorization skills, but a knack for picking up patterns. Note that if the exam truly consisted of recycled questions from a previous year, Ellie would handily outperform Irene. Even if Irene‚Äôs inferred patterns yielded 90% accurate predictions, they could never compete with Ellie‚Äôs 100% recall. However, even if the exam consisted entirely of fresh questions, Irene might maintain her 90% average. Asmachinelearning scientists, our goal is to discover patterns. But howcan webe surethat we have truly discovered a general pattern and not simply memorized our data? Most of the time, our predictions are only useful if our model discovers such a pattern. We do not want to predict yesterday‚Äôs stock prices, but tomorrow‚Äôs. We do not need to recognize already diagnosed diseases for previously seen patients, but rather previously undiagnosed ailments in previously unseen patients. This problem‚Äîhow to discover patterns that generalize‚Äîis the fundamental problem of machine learning, and arguably of all of statistics. We might cast this problem as just one slice of a far grander question that engulfs all of science: when are we ever justified in making the leap from particular observations to more general statements? In real life, we must fit our models using a finite collection of data. The typical scales of that data vary wildly across domains. For many important medical problems, we can only access a few thousand data points. When studying rare diseases, we might be lucky to access hundreds. By contrast, the largest public datasets consisting of labeled photographs, e.g., ImageNet (Deng et al., 2009), contain millions of images. And some unlabeled image
Generalization
113

collections such as the Flickr YFC100M dataset can be even larger, containing over 100 million images (Thomee et al., 2016). However, even at this extreme scale, the number of available data points remains infinitesimally small compared to the space of all possible images at a megapixel resolution. Whenever we work with finite samples, we must keep in mind the risk that we might fit our training data, only to discover that we failed to discover a generalizable pattern. The phenomenon of fitting closer to our training data than to the underlying distribution is called overfitting, and techniques for combatting overfitting are often called regularization methods. While it is no substitute for a proper introduction to statistical learning theory (see Boucheron et al. (2005), Vapnik (1998)), we will give you just enough intuition to get going. We will revisit generalization in many chapters throughout the book, exploring both what is known about the principles underlying generalization in various models, and also heuristic techniques that have been found (empirically) to yield improved generalization on tasks of practical interest. 3.6.1 Training Error and Generalization Error
In the standard supervised learning setting, we assume that the training data and the test data are drawn independently from identical distributions. This is commonly called the IID assumption. While this assumption is strong, it is worth noting that, absent any such assumption, we would be dead in the water. Why should we believe that training data sampled from distribution P(X,Y) should tell us how to make predictions on test data generated by a different distribution Q(X, Y)? Making such leaps turns out to require strong assumptions about how P and @ are related. Later on we will discuss some assumptions that allow for shifts in distribution but first we need to understand the IID case, where P() = 0). To begin with, we need to differentiate between the training error ùëÖemp, which is a statistic calculated on the training dataset, and the generalization error ùëÖ, which is an expectation taken with respect to the underlying distribution. You can think of the generalization error as what you would see if you applied your model to an infinite stream of additional data examples drawn from the same underlying data distribution. Formally the training error is expressed as a sum (with the same notation as Section 3.1):
ùëÖemp¬ªX,y, ùëì‚Ä¶ = 1 ùëõ ùëñ=1 ùëô‚Äûx‚Äûùëñ‚Äù, ùë¶‚Äûùëñ‚Äù, ùëì ‚Äûx‚Äûùëñ‚Äù‚Äù‚Äù, (3.6.1)
while the generalization error is expressed as an integral:
Rip. f] = Eveyy-pll,y, F00)] = / / (x,y, F09)p(%,y) dxdy. (3.6.2)
Problematically, we can never calculate the generalization error ùëÖ exactly. Nobody ever
tells us the precise form of the density function ùëù‚Äûx, ùë¶‚Äù. Moreover, we cannot sample an infinite stream of data points. Thus, in practice, we must estimate the generalization error by applying our model to an independent test set constituted of a random selection of examples X0 and labels y0 that were withheld from our training set. This consists of
n
‚Äû ‚Äû
Linear Neural Networks for Regression
114

applying the same formula that was used for calculating the empirical training error but to a test set X0,y0. Crucially, when we evaluate our classifier on the test set, we are working with a fixed classi- fier (it does not depend on the sample of the test set), and thus estimating its error is simply the problem of mean estimation. However the same cannot be said for the training set. Note that the model we wind up with depends explicitly on the selection of the training set and thus the training error will in general be a biased estimate of the true error on the underly- ing population. The central question of generalization is then when should we expect our training error to be close to the population error (and thus the generalization error). Model Complexity
In classical theory, when we have simple models and abundant data, the training and gen- eralization errors tend to be close. However, when we work with more complex models and/or fewer examples, we expect the training error to go down but the generalization gap to grow. This should not be surprising. Imagine a model class so expressive that for any dataset of ùëõ examples, we can find a set of parameters that can perfectly fit arbitrary labels, even if randomly assigned. In this case, even if we fit our training data perfectly, how can we conclude anything about the generalization error? For all we know, our generalization error might be no better than random guessing. In general, absent any restriction on our model class, we cannot conclude, based on fitting the training data alone, that our model has discovered any generalizable pattern (Vapnik et al., 1994). On the other hand, if our model class was not capable of fitting arbitrary labels, then it must have discovered a pattern. Learning-theoretic ideas about model complexity derived some inspiration from the ideas of Karl Popper, an influential philosopher of sci- ence, who formalized the criterion of falsifiability. According to Popper, a theory that can explain any and all observations is not a scientific theory at all! After all, what has it told us about the world if it has not ruled out any possibility? In short, what we want is a hypothesis that could not explain any observations we might conceivably make and yet nevertheless happens to be compatible with those observations that we in fact make. Now what precisely constitutes an appropriate notion of model complexity is a complex matter. Often, models with more parameters are able to fit a greater number of arbitrarily assigned labels. However, this is not necessarily true. For instance, kernel methods operate in spaces with infinite numbers of parameters, yet their complexity is controlled by other means (Sch√∂lkopf and Smola, 2002). One notion of complexity that often proves useful is the range of values that the parameters can take. Here, a model whose parameters are permitted to take arbitrary values would be more complex. We will revisit this idea in the next section, when we introduce weight decay, your first practical regularization technique. Notably, it can be difficult to compare complexity among members of substantiallydifferent model classes (say, decision trees vs. neural networks). At this point, we must stress another important point that we will revisit when introducing deep neural networks. When a model is capable of fitting arbitrary labels, low training error does not necessarily imply low generalization error. However, it does not necessarily
Generalization
115

imply high generalization error either! All we can say with confidence is that low training error alone is not enough to certify low generalization error. Deep neural networks turn out to be just such models: while they generalize well in practice, they are too powerful to allow us to conclude much on the basis of training error alone. In these cases we must rely more heavily on our holdout data to certify generalization after the fact. Error on the holdout data, i.e., validation set, is called the validation error. 3.6.2 Underfitting or Overfitting? When we compare the training and validation errors, we want to be mindful of two com- mon situations. First, we want to watch out for cases when our training error and validation error are both substantial but there is a little gap between them. If the model is unable to reduce the training error, that could mean that our model is too simple (i.e., insufficiently expressive) to capture the pattern that we are trying to model. Moreover, since the gener- alization gap (Remp ‚Äî R) between our training and generalization errors is small, we have reason to believe that we could get away with a more complex model. This phenomenon is known as underfitting. On the other hand, as we discussed above, we want to watch out for the cases when our training error is significantly lower than our validation error, indicating severe overfitting. Note that overfitting is not always a bad thing. In deep learning especially, the best pre- dictive models often perform far better on training data than on holdout data. Ultimately, we usually care about driving the generalization error lower, and only care about the gap insofar as it becomes an obstacle to that end. Note that if the training error is zero, then the generalization gap is precisely equal to the generalization error and we can make progress only by reducing the gap. Polynomial Curve Fitting
To illustrate some classical intuition about overfitting and model complexity, consider the following: given training data consisting of a single feature ùë• and a corresponding real- valued label ùë¶, we try to find the polynomial of degree ùëë
for estimating the label ùë¶. This is just a linear regression problem where our features are
given by the powers of ùë•, the model‚Äôs weights are given by ùë§ùëñ, and the bias is given by ùë§0 since ùë•0 = 1 for all ùë•. Since this is just a linear regression problem, we can use the squared error as our loss function. A higher-order polynomial function is more complex than a lower-order polynomial func- tion, sincethehigher-orderpolynomialhasmoreparametersandthemodelfunction‚Äôsselec- tion range is wider. Fixing the training dataset, higher-order polynomial functions should always achieve lower (at worst, equal) training error relative to lower-degree polynomials. In fact, whenever each data example has a distinct value of ùë•, a polynomial function with degree equal to the number of data examples can fit the training set perfectly. We compare
d
ÀÜùë¶ = ùë•ùëñùë§ùëñ ùëñ=0 (3.6.3)
Linear Neural Networks for Regression
116

the relationship between polynomial degree (model complexity) and both underfitting and overfitting in Fig. 3.6.1. ‚Äî ‚Äî Underfitting Optimum ‚Äî_Overfitting Generalization loss Training loss >
Loss
tFig. 3.6.1
InÔ¨Çuence of model complexity on underÔ¨Åtting and overÔ¨Åtting. Dataset Size
As the above bound already indicates, another big consideration to bear in mind is dataset size. Fixing our model, the fewer samples we have in the training dataset, the more likely (and more severely) we are to encounter overfitting. As we increase the amount of training data, the generalization error typically decreases. Moreover, in general, more data never hurts. For a fixed task and data distribution, model complexity should not increase more rapidly than the amount of data. Given more data, we might attempt to fit a more complex model. Absent sufficient data, simpler models may be more difficult to beat. For many tasks, deep learning only outperforms linear models when many thousands of training ex- amples are available. In part, the current success of deep learning owes considerably to the abundance of massive datasets arising from Internet companies, cheap storage, connected devices, and the broad digitization of the economy. 3.6.3 Model Selection
Typically, we select our final model only after evaluating multiple models that differ in vari- ous ways (different architectures, training objectives, selected features, data preprocessing, learning rates, etc.). Choosing among many models is aptly called model selection. In principle, we should not touch our test set until after we have chosen all our hyperpa- rameters. Were we to use the test data in the model selection process, there is a risk that we might overfit the test data. Then we would be in serious trouble. If we overfit our training data, there is always the evaluation on test data to keep us honest. But if we overfit the test data, how would we ever know? See Ong et al. (2005) for an example of how this can lead to absurd results even for models where the complexity can be tightly controlled. Thus, we should never rely on the test data for model selection. And yet we cannot rely solely on the training data for model selection either because we cannot estimate the gen- eralization error on the very data that we use to train the model. In practical applications, the picture gets muddier. While ideally we would only touch the
Model complexity
Generalization
117

test data once, to assess the very best model or to compare a small number of models with each other, real-world test data is seldom discarded after just one use. We can seldom afford a new test set for each round of experiments. In fact, recycling benchmark data for decades can have a significant impact on the development of algorithms, e.g., for image classification81 and optical character recognition82. 81
The common practice for addressing the problem of training on the test set is to split our data three ways, incorporating a validation set in addition to the training and test datasets. The result is a murky business where the boundaries between validation and test data are worryingly ambiguous. Unless explicitly stated otherwise, in the experiments in this book we are really working with what should rightly be called training data and validation data, with no true test sets. Therefore, the accuracy reported in each experiment of the book is really the validation accuracy and not a true test set accuracy. 82
Cross-Validation
When training data is scarce, we might not even be able to afford to hold out enough data to constitute a proper validation set. One popular solution to this problem is to employ K-fold cross-validation. Here, the original training data is split into K non-overlapping subsets. Then model training and validation are executed K times, each time training on K ‚Äî 1 subsets and validating on a different subset (the one not used for training in that round). Finally, the training and validation errors are estimated by averaging over the results from the K experiments. 3.6.4 Summary
This section explored some of the underpinnings of generalization in machine learning. Some of these ideas become complicated and counterintuitive when we get to deeper mod- els; here, models are capable of overfitting data badly, and the relevant notions of complex- itycanbebothimplicitandcounterintuitive(e.g., largerarchitectureswithmoreparameters generalizing better). We leave you with a few rules of thumb:
1. Use validation sets (or ùêæ-fold cross-validation) for model selection;
2. More complex models often require more data;
3. Relevant notions of complexity include both the number of parameters and the range of values that they are allowed to take;
4. Keeping all else equal, more data almost always leads to better generalization;
5. This entire talk of generalization is all predicated on the IID assumption. If we relax this assumption, allowing for distributions to shift between the train and testing peri- ods, then we cannot say anything about generalization absent a further (perhaps milder) assumption. 3.6.5 Exercises
1. When can you solve the problem of polynomial regression exactly? Linear Neural Networks for Regression
118

2. Giveatleastfiveexampleswheredependentrandomvariablesmaketreatingtheproblem as IID data inadvisable. 3. Can you ever expect to see zero training error? Under which circumstances would you see zero generalization error? 4. Why is ùêæ-fold cross-validation very expensive to compute? 5. Why is the ùêæ-fold cross-validation error estimate biased? 6. The VC dimension is defined as the maximum number of points that can be classified with arbitrary labels {+1} by a function of a class of functions. Why might this not be a good idea for measuring how complex the class of functions is? Hint: consider the magnitude of the functions. 7. Your manager gives you a difficult dataset on which your current algorithm does not perform so well. How would you justify to him that you need more data? Hint: you cannot increase the data but you can decrease it.bubu83
Discussions83. 3.7 Weight Decay

Now that we have characterized the problem of overfitting, we can introduce our first reg- ularization technique. Recall that we can always mitigate overfitting by collecting more training data. However, that can be costly, time consuming, or entirely out of our control, making it impossible in the short run. For now, we can assume that we already have as much high-quality data as our resources permit and focus the tools at our disposal when the dataset is taken as a given. Recallthatinourpolynomialregressionexample(Section3.6.2)wecouldlimitourmodel‚Äôs capacity by tweaking the degree of the fitted polynomial. Indeed, limiting the number of features is a popular technique for mitigating overfitting. However, simply tossing aside features can be too blunt an instrument. Sticking with the polynomial regression example, consider what might happen with high-dimensional input. The natural extensions of poly- nomials to multivariate data are called monomials, which are simply products of powers of variables. The degree of a monomial is the sum of the powers. For example, ùë•2 ùë•3ùë•2 5 are both monomials of degree 3. 1 ùë•2, and
Note that the number of terms with degree ùëë blows up rapidly as ùëë grows larger. Given ùëò
Note that the number of terms with degree d blows up rapidly as d grows larger. Given k variables, the number of monomials of degree d is (84). Even small changes in degree, say from 2 to 3, dramatically increase the complexity of our model.bubuThus we often need a more fine-grained tool for adjusting function complexity. 119

%matplotlib inline import torch from torch import nn from d2l import torch as d2l
3.7.1 Norms and Weight Decay
Rather than directly manipulating the number of parameters, weight decay, operates by restricting the values that the parameters can take. More commonly called ‚Ñì2 regularization outside of deep learning circles when optimized by minibatch stochastic gradient descent, weight decay might be the most widely used technique for regularizing parametric machine learning models. The technique is motivated by the basic intuition that among all functions ùëì, the function ùëì = 0 (assigning the value 0 to all inputs) is in some sense the simplest, and that we can measure the complexity of a function by the distance of its parameters from zero. But how precisely should we measure the distance between a function and zero? There is no single right answer. In fact, entire branches of mathematics, including parts of functional analysis and the theory of Banach spaces, are devoted to addressing such issues. One simple interpretation might be to measure the complexity of a linear function ùëì ‚Äûx‚Äù =
w>x by some norm of its weight vector, e.g., kwk2. Recall that we introduced the ‚Ñì2 norm and ‚Ñì1 norm, which are special cases of the more general ‚Ñìùëù norm, in Section 2.3.11. The most common method for ensuring a small weight vector is to add its norm as a penalty term to the problem of minimizing the loss. Thus we replace our original objective, min- imizing the prediction loss on the training labels, with new objective, minimizing the sum of the prediction loss and the penalty term. Now, if our weight vector grows too large, our learning algorithm might focus on minimizing the weight norm kwk2 rather than minimiz- ing the training error. That is exactly what we want. To illustrate things in code, we revive our previous example from Section 3.1 for linear regression. There, our loss was given by
n
n L(w, b) >) ; (wrx! +b-y0) (3.7.1)
Recall that x‚Äûùëñ‚Äù are the features, ùë¶‚Äûùëñ‚Äù is the label for any data example ùëñ, and ‚Äûw, ùëè‚Äù are
the weight and bias parameters, respectively. To penalize the size of the weight vector, we must somehow add kwk2 to the loss function, but how should the model trade off the standard loss for this new additive penalty? In practice, we characterize this trade-off via the regularization constant ùúÜ, a nonnegative hyperparameter that we fit using validation data:
ùêø‚Äûw, ùëè‚Äù ‚Äö 2 kwk2. (3.7.2)
For ùúÜ = 0, we recover our original loss function. For ùúÜ > 0, we restrict the size of kwk. For A = 0, we recover our original loss function. For 2 > 0, we restrict the size of ||w]. We divide by 2 by convention: when we take the derivative of a quadratic function, the 2 and 1/2 cancel out, ensuring that the expression for the update looks nice and simple. The astute reader might wonder why we work with the squared norm and not the standard
Weight Decay
ùúÜ
Linear Neural Networks for Regression
120

norm(i.e., theEuclideandistance). Wedo this forcomputational convenience. Bysquaring the ‚Ñì2 norm, we remove the square root, leaving the sum of squares of each component of the weight vector. This makes the derivative of the penalty easy to compute: the sum of derivatives equals the derivative of the sum. Moreover, you might ask why we work with the ‚Ñì2 norm in the first place and not, say,
the ‚Ñì1 norm. In fact, other choices are valid and popular throughout statistics. While ‚Ñì2- regularized linear models constitute the classic ridge regression algorithm, ‚Ñì1-regularized linear regression is a similarly fundamental method in statistics, popularly known as lasso regression. One reason to work with the ‚Ñì2 norm is that it places an outsize penalty on large components of the weight vector. This biases our learning algorithm towards models that distribute weight evenly across a larger number of features. In practice, this might make them more robust to measurement error in a single variable. By contrast, ‚Ñì1 penalties lead to models that concentrate weights on a small set of features by clearing the other weights to zero. This gives us an effective method for feature selection, which may be desirable for other reasons. For example, if our model only relies on a few features, then we may not need to collect, store, or transmit data for the other (dropped) features. Using the same notation in (3.1.11), minibatch stochastic gradient descent updates for ‚Ñì2- regularized regression as follows:
we (l- a)w‚Äî ZL x (wi +b- 0). ‚Äù ra 2d, y (3.7.3)
As before, we update w based on the amount by which our estimate differs from the ob- servation. However, we also shrink the size of w towards zero. That is why the method is sometimescalled‚Äúweightdecay‚Äù: giventhepenaltytermalone, ouroptimizationalgorithm decays the weight at each step of training. In contrast to feature selection, weight decay offers us a mechanism for continuously adjusting the complexity of a function. Smaller values of ùúÜ correspond to less constrained w, whereas larger values of ùúÜ constrain w more considerably. Whether we include a corresponding bias penalty ùëè2 can vary across imple- mentations, and may vary across layers of a neural network. Often, we do not regularize the bias term. Besides, although ‚Ñì2 regularization may not be equivalent to weight decay for other optimization algorithms, the idea of regularization through shrinking the size of weights still holds true. 3.7.2 High-Dimensional Linear Regression
We can illustrate the benefits of weight decay through a simple synthetic example. First, we generate some data as before:
d
d y =0.05+ ¬ª 0.01x; + ‚Ç¨ where ‚Ç¨ ~ N(0, 0.017). (3.7.4) i=l
In this synthetic dataset, our label is given by an underlying linear function of our inputs, corrupted by Gaussian noise with zero mean and standard deviation 0.01. For illustrative purposes, we can make the effects of overfitting pronounced, by increasing the dimen-
ùúÇ
Weight Decay
121

sionality of our problem to ùëë = 200 and working with a small training set with only 20
examples. class Data(d2l.DataModule): def __init__(self, num_train, num_val, num_inputs, batch_size): self.save_hyperparameters() n = num_train + num_val self.X = torch.randn(n, num_inputs) noise = torch.randn(n, 1) * 0.01 w, b = torch.ones((num_inputs, 1)) * 0.01, 0.05 self.y = torch.matmul(self.X, w) + b + noise def get_dataloader(self, train): i = slice(0, self.num_train) if train else slice(self.num_train, None) return self.get_tensorloader([self.X, self.y], train, i)
3.7.3 Implementation from Scratch
Now, let‚Äôstryimplementingweightdecayfromscratch. Sinceminibatchstochasticgradient descent is our optimizer, we just need to add the squared ‚Ñì2 penalty to the original loss function. Defining ‚Ñì2 Norm Penalty
Perhaps the most convenient way of implementing this penalty is to square all terms in place and sum them. def l2_penalty(w): return (w ** 2).sum() / 2
Defining the Model
In the final model, the linear regression and the squared loss have not changed since Section 3.4, so we will just define a subclass of d2l.LinearRegressionScratch. The only change here is that our loss now includes the penalty term. class WeightDecayScratch(d2l.LinearRegressionScratch): def __init__(self, num_inputs, lambd, lr, sigma=0.01): super().__init__(num_inputs, lr, sigma) self.save_hyperparameters() def loss(self, y_hat, y): return (super().loss(y_hat, y) + self.lambd * l2_penalty(self.w))
The following code fits our model on the training set with 20 examples and evaluates it on the validation set with 100 examples. Linear Neural Networks for Regression
122

data = Data(num_train=20, num_val=100, num_inputs=200, batch_size=5) trainer = d2l.Trainer(max_epochs=10)
trainer = d2l.Trainer(max_epochs=10) def train_scratch(lambd): model = WeightDecayScratch(num_inputs=200, lambd=lambd, lr=0.01) model.board.yscale='log' trainer.fit(model, data) print('L2 norm of w:', float(l2_penalty(model.w)))
Training without Regularization
We now run this code with lambd = 0, disabling weight decay. Note that we overfit badly, decreasing the training error but not the validation error‚Äîa textbook case of over- fitting. train_scratch(0)
L2 norm of w: 0.009948714636266232
107? 10-3 10-4] ‚Äî train_loss --- val_loss
Using Weight Decay
Below, we run with substantial weight decay. Note that the training error increases but the validation error decreases. This is precisely the effect we expect from regulariza- tion. train_scratch(3)
L2 norm of w: 0.0017270983662456274
3.7.4 Concise Implementation
Because weight decay is ubiquitous in neural network optimization, the deep learning framework makes it especially convenient, integrating weight decay into the optimization
Weight Decay
123

‚Äî train_loss --- val_loss sn, ~. ~ ~, mae, 10-2
algorithm itself for easy use in combination with any loss function. Moreover, this integra- tion serves a computational benefit, allowing implementation tricks to add weight decay to the algorithm, without any additional computational overhead. Since the weight decay portion of the update depends only on the current value of each parameter, the optimizer must touch each parameter once anyway. Below, we specify the weight decay hyperparameter directly through weight_decay when instantiating our optimizer. By default, PyTorch decays both weights and biases simulta- neously, but we can configure the optimizer to handle different parameters according to different policies. Here, we only set weight_decay for the weights (the net.weight pa- rameters), hence the bias (the net.bias parameter) will not decay. class WeightDecay(d2l.LinearRegression): def __init__(self, wd, lr): super().__init__(lr) self.save_hyperparameters() self.wd = wd def configure_optimizers(self): return torch.optim.SGD([ {'params': self.net.weight, 'weight_decay': self.wd}, {'params': self.net.bias}], lr=self.lr)
The plot looks similar to that when we implemented weight decay from scratch. How- ever, this version runs faster and is easier to implement, benefits that will become more pronounced as you address larger problems and this work becomes more routine. model = WeightDecay(wd=3, lr=0.01) model.board.yscale='log' trainer.fit(model, data)
print('L2 norm of w:', float(l2_penalty(model.get_w_b()[0])))
L2 norm of w: 0.013779522851109505
So far, we have touched upon one notion of what constitutes a simple linear function. How- ever, even for simple nonlinear functions, the situation can be much more complex. To see this, the concept of reproducing kernel Hilbert space (RKHS)84 allows one to apply tools
84
Linear Neural Networks for Regression
124

10-1 10-2 ‚Äî‚Äî train_loss --- val_loss 10-3
introduced for linear functions in a nonlinear context. Unfortunately, RKHS-based algo- rithms tend to scale poorly to large, high-dimensional data. In this book we will often adopt the common heuristic whereby weight decay is applied to all layers of a deep net- work. 3.7.5 Summary
Regularization is a common method for dealing with overfitting. Classical regularization techniques add a penalty term to the loss function (when training) to reduce the complexity of the learned model. One particular choice for keeping the model simple is using an ‚Ñì2 penalty. This leads to weight decay in the update steps of the minibatch stochastic gradient descent algorithm. In practice, the weight decay functionality is provided in optimizers from deep learning frameworks. Different sets of parameters can have different update behaviors within the same training loop. 3.7.6 Exercises
1. Experiment with the value of ùúÜ in the estimation problem in this section. Plot training
and validation accuracy as a function of ùúÜ. What do you observe?bubu2. Use a validation set to find the optimal value of ùúÜ. Is it really the optimal value? Does
this matter?bubu3. What would the update equations look like if instead of kwk2 we used
penalty of choice (‚Ñì1 regularization)? 4. We know that kwk2 = w>w. Can you find a similar equation for matrices (see the
Frobenius norm in Section 2.3.11)? 5. Review the relationship between training error and generalization error. In addition to weight decay, increased training, and the use of a model of suitable complexity, what other ways might help us deal with overfitting? 6. In Bayesian statistics we use the product of prior and likelihood to arrive at a posterior via ùëÉ‚Äûùë§ j ùë•‚Äù / ùëÉ‚Äûùë• j ùë§‚ÄùùëÉ‚Äûùë§‚Äù. How can you identify ùëÉ‚Äûùë§‚Äù with regularization?bubuDiscussions85. 85
Àù
ùëñ jùë§ùëñj as our
4
Linear Neural Networks for ClassiÔ¨Åcation
Now that you have worked through all of the mechanics you are ready to apply the skills you have learned to broader kinds of tasks. Even as we pivot towards classification, most of the plumbing remains the same: loading the data, passing it through the model, generat- ing output, calculating the loss, taking gradients with respect to weights, and updating the model. However, the precise form of the targets, the parametrization of the output layer, and the choice of loss function will adapt to suit the classification setting. 4.1 Softmax Regression
ee
In Section 3.1, we introduced linear regression, working through implementations from scratch in Section 3.4 and again using high-level APIs of a deep learning framework in Section 3.5 to do the heavy lifting. Regression is the hammer we reach for when we want to answer how much?bubuor how many?bubuquestions. If you want to predict the number of dollars (price) at which a house will be sold, or the number of wins a baseball team might have, or the number of days that a patient will remain hospitalized before being discharged, then you are probably looking for a regression model. However, even within regression models, there are important distinctions. For instance, the price of a house will never be negative and changes might often be relative to its baseline price. As such, it might be more effective to regress on the logarithm of the price. Likewise, the number of days a patient spends in hospital is a discrete nonnegative random variable. As such, least mean squares might not be an ideal approach either. This sort of time-to-event modeling comes with a host of other complications that are dealt with in a specialized subfield called survival modeling. The point here is not to overwhelm you but just to let you know that there is a lot more to estimation than simply minimizing squared errors. And more broadly, there is a lot more to supervised learning than regression. In this section, we focus on classification problems where we put aside how much? questions and instead focus on which category?bubuquestions. e Does this email belong in the spam folder or the inbox? e Is this customer more likely to sign up or not to sign up for a subscription service? 125
Linear Neural Networks for ClassiÔ¨Åcation
126

e Does this image depict a donkey, a dog, a cat, or a rooster? e Which movie is Aston most likely to watch next?bubue Which section of the book are you going to read next? Colloquially, machine learning practitioners overload the word classification to describe two subtly different problems: (i) those where we are interested only in hard assignments of examples to categories (classes); and (ii) those where we wish to make soft assignments, i.e., toassesstheprobabilitythateachcategory applies. Thedistinctiontendstogetblurred, in part, because often, even when we only care about hard assignments, we still use models that make soft assignments. Even more, there are cases where more than one label might be true. For instance, a news article might simultaneously cover the topics of entertainment, business, and space flight, but not the topics of medicine or sports. Thus, categorizing it into one of the above cate- gories on their own would not be very useful. This problem is commonly known as multi- label classification 86. See Tsoumakas and Katakis (2007) for an overview and Huang et al. (2015) for an effective algorithm when tagging images. 86
4.1.1 Classification
To get our feet wet, let‚Äôs start with a simple image classification problem. Here, each input consists of a 2 x 2 grayscale image. We can represent each pixel value with a single scalar, giving us four features x), x2,x3,x4. Further, let‚Äôs assume that each image belongs to one 99 Ke among the categories ‚Äúcat‚Äù, ‚Äúchicken‚Äù, and ‚Äúdog‚Äù. Next, we have to choose how to represent the labels. We have two obvious choices. Per- hapsthemostnaturalimpulsewouldbetochoose ùë¶ 2 f1,2,3g, wheretheintegersrepresent fdog,cat,chickeng respectively. This is a great way of storing such information on a com- puter. If the categories had some natural ordering among them, say if we were trying to predict fbaby,toddler,adolescent,young adult,adult,geriatricg, then it might even make sense to cast this as an ordinal regression 87 problem and keep the labels in this format. See Moon et al. (2010) for an overview of different types of ranking loss functions and Beutel et al. (2014) for a Bayesian approach that addresses responses with more than one mode. 87
s
In general, classification problems do not come with natural orderings among the classes. Fortunately, statisticians long ago invented a simple way to represent categorical data: the one-hot encoding. A one-hot encoding is a vector with as many components as we have categories. The component corresponding to a particular instance‚Äôs category is set to 1 and all other components are set to 0. In our case, a label ùë¶ would be a three-dimensional vector, with ‚Äû1,0,0‚Äù corresponding to ‚Äúcat‚Äù, ‚Äû0,1,0‚Äù to ‚Äúchicken‚Äù, and ‚Äû0,0,1‚Äù to ‚Äúdog‚Äù:
ùë¶ 2 f‚Äû1,0,0‚Äù, ‚Äû0,1,0‚Äù, ‚Äû0,0,1‚Äùg. (4.1.1)
Softmax Regression
127

Linear Model
In order to estimate the conditional probabilities associated with all the possible classes, we need a model with multiple outputs, one per class. To address classification with lin- ear models, we will need as many affine functions as we have outputs. Strictly speaking, we only need one fewer, since the final category has to be the difference between 1 and the sum of the other categories, but for reasons of symmetry we use a slightly redundant parametrization. Each output corresponds to its own affine function. In our case, since we have 4 features and 3 possible output categories, we need 12 scalars to represent the weights (ùë§ with subscripts), and 3 scalars to represent the biases (ùëè with subscripts). This yields:
ùëú1 = ùë•1ùë§11 ‚Äö ùë•2ùë§12 ‚Äö ùë•3ùë§13 ‚Äö ùë•4ùë§14 ‚Äö ùëè1, ùëú2 = ùë•1ùë§21 ‚Äö ùë•2ùë§22 ‚Äö ùë•3ùë§23 ‚Äö ùë•4ùë§24 ‚Äö ùëè2, ùëú3 = ùë•1ùë§31 ‚Äö ùë•2ùë§32 ‚Äö ùë•3ùë§33 ‚Äö ùë•4ùë§34 ‚Äö ùëè3. (4.1.2)
The corresponding neural network diagram is shown in Fig. 4.1.1. Just as in linear regres- sion, we use a single-layer neural network. And since the calculation of each output, ùëú1, ùëú2, and ùëú3, depends on every input, ùë•1, ùë•2, ùë•3, and ùë•4, the output layer can also be described as a fully connected layer. Output layer Input layer
tFig. 4.1.1
Softmax regression is a single-layer neural network. For a more concise notation we use vectors and matrices: o = Wx‚Äöb is much better suited
For a more concise notation we use vectors and matrices: o = Wx+b is much better suited for mathematics and code. Note that we have gathered all of our weights into a 3 x 4 matrix and all biases b ‚Ç¨ R?bubuin a vector. The Softmax
Assuming a suitable loss function, we could try, directly, to minimize the difference be- tween o and the labels y. While it turns out that treating classification as a vector-valued regressionproblemworkssurprisinglywell, itisnonethelessunsatisfactoryinthefollowing ways:
e There is no guarantee that the outputs 0; sum up to | in the way we expect probabilities
to behave. e There is no guarantee that the outputs 0; are even nonnegative, even if their outputs sum
up to 1, or that they do not exceed 1. Both aspects render the estimation problem difficult to solve and the solution very brittle to outliers. For instance, if we assume that there is a positive linear dependency between the number of bedrooms and the likelihood that someone will buy a house, the probability
Linear Neural Networks for ClassiÔ¨Åcation
128

might exceed 1 when it comes to buying a mansion! As such, we need a mechanism to ‚Äúsquish‚Äù the outputs. There are many ways we might accomplish this goal. For instance, we could assume that the outputs o are corrupted versions of y, where the corruption occurs by means of adding noise ‚Ç¨ drawn from a normal distribution. In other words, y = 0+ ‚Ç¨, where Ee; ~ N(0, o). This is the so-called probit model *¬Æ, first introduced by Fechner (1860). While appealing, it does not work quite as well nor lead to a particularly nice optimization problem, when compared to the softmax. 88
Another way to accomplish this goal (and to ensure nonnegativity) is to use an exponential function ùëÉ‚Äûùë¶ = ùëñ‚Äù / expùëúùëñ. This does indeed satisfy the requirement that the conditional class probability increases with increasing ùëúùëñ, it is monotonic, and all probabilities are nonnegative. We can then transform these values so that they add up to 1 by dividing each by their sum. This process is called normalization. Putting these two pieces together gives us the softmax function:
ÀÜy = softmax‚Äûo‚Äù where ÀÜùë¶ùëñ = Àù ùëó exp‚Äûùëú ùëó‚Äù . (4.1.3)
Note that the largest coordinate of o corresponds to the most likely class according to ÀÜy. Moreover, because the softmax operation preserves the ordering among its arguments, we do not need to compute the softmax to determine which class has been assigned the highest probability. Thus,
argmax ùëó ÀÜùë¶ ùëó = argmax ùëó ùëú ùëó. (4.1.4)
The idea of a softmax dates back to Gibbs (1902), who adapted ideas from physics. Dating even further back, Boltzmann, the father of modern statistical physics, used this trick to model a distribution over energy states in gas molecules. In particular, he discovered that the prevalence of a state of energy in a thermodynamic ensemble, such as the molecules in a gas, is proportional to exp(‚ÄîE/kT). Here, E is the energy of a state, T is the temperature, and k is the Boltzmann constant. When statisticians talk about increasing or decreasing the ‚Äútemperature‚Äù of a statistical system, they refer to changing T in order to favor lower or higher energy states. Following Gibbs‚Äô idea, energy equates to error. Energy-based models (Ranzato et al., 2007) use this point of view when describing problems in deep learning. Vectorization
To improve computational efficiency, we vectorize calculations in minibatches of data. As- sume that we are given a minibatch X ‚Ç¨ R‚Äô*¬¢ of n examples with dimensionality (number of inputs) d. Moreover, assume that we have q categories in the output. Then the weights satisfy W ‚Ç¨ R24 and the bias satisfies b ‚Ç¨ R!*4. O = XW ‚Äö b,
ÀÜY = softmax‚ÄûO‚Äù. (4.1.5)
exp‚Äûùëúùëñ‚Äù
Softmax Regression
129

This accelerates the dominant operation into a matrix‚Äìmatrix product XW. Moreover, sinceeachrowinXrepresentsadataexample, thesoftmaxoperationitselfcanbecomputed rowwise: for each row of O, exponentiate all entries and then normalize them by the sum. Note, though, that care must be taken to avoid exponentiating and taking logarithms of large numbers, since this can cause numerical overflow or underflow. Deep learning frameworks take care of this automatically. 4.1.2 Loss Function
Now that we have a mapping from features x to probabilities ÀÜy, we need a way to optimize the accuracy of this mapping. We will rely on maximum likelihood estimation, the very same method that we encountered when providing a probabilistic justification for the mean squared error loss in Section 3.1.3. Log-Likelihood
The softmax function gives us a vector ÀÜy, which we can interpret as the (estimated) con- ditional probabilities of each class, given any input x, such as ÀÜùë¶1 = ùëÉ‚Äûùë¶ = cat j x‚Äù. In the following we assume that for a dataset with features X the labels Y are represented using a one-hot encoding label vector. We can compare the estimates with reality by checking how probable the actual classes are according to our model, given the features:
ùëÉ‚ÄûY j X‚Äù = ùëÉ‚Äûy‚Äûùëñ‚Äù j x‚Äûùëñ‚Äù‚Äù. ùëñ=1 (4.1.6)
We are allowed to use the factorization since we assume that each label is drawn indepen- dently from its respective distribution ùëÉ‚Äûy j x‚Äûùëñ‚Äù‚Äù. Since maximizing the product of terms is awkward, we take the negative logarithm to obtain the equivalent problem of minimizing the negative log-likelihood:
n
n . .bubua .bubu. ‚Äîlog PCY | X) = )) = log P(y | x) = Vy, 9), (4.1.7) i=l i=l
where for any pair of label y and model prediction ÀÜy over ùëû classes, the loss function ùëô
is
q U(y,9) =- Dy; log sy. (4.1.8) j=l
For reasons explained later on, the loss function in (4.1.8) is commonly called the cross- entropy loss. Since y is a one-hot vector of length q, the sum over all its coordinates j van- ishes for all but one term. Note that the loss /(y, ¬•) is bounded from below by 0 whenever ¬• is a probability vector: no single entry is larger than 1, hence their negative logarithm can- not be lower than 0; /(y, ¬•) = 0 only if we predict the actual label with certainty. This can never happen for any finite setting of the weights because taking a softmax output towards 1 requires taking the corresponding input 0; to infinity (or all other outputs 0; for j # i to negative infinity). Even if our model could assign an output probability of 0, any error made when assigning such high confidence would incur infinite loss (‚Äî log 0 = oo). n
a
q
Linear Neural Networks for ClassiÔ¨Åcation
130

Softmax and Cross-Entropy Loss
Since the softmax function and the corresponding cross-entropy loss are so common, it is worth understanding a bit better how they are computed. Plugging (4.1.3) into the defini- tion of the loss in (4.1.8) and using the definition of the softmax we obtain
4
4 exp(o;) ly, 9) =- >) yj log =-‚Äî‚Äî ¬ª ! fel exp(0x) a q qd qd = >i yjlog >" exp(ox) ‚Äî >) ¬•j0; (4.1.9) j=l kal j=l q q = log > exp(ox) ‚Äî ¬ª yjOj- k=l j=l
To understand a bit better what is going on, consider the derivative with respect to any logit ùëú ùëó. We get
exp‚Äûùëú ùëó‚Äù
. exp(0;) Do UY.I) = xq 2 =~ - y; = softmax(o); - y;. 4.1.10 7 exp(ox) J iTS ( )
In other words, the derivative is the difference between the probability assigned by our model, as expressed by the softmax operation, and what actually happened, as expressed by elements in the one-hot label vector. In this sense, it is very similar to what we saw in regression, where the gradient was the difference between the observation ùë¶ and estimate ÀÜùë¶. This is not a coincidence. In any exponential family model, the gradients of the log- likelihood are given by precisely this term. This fact makes computing gradients easy in practice. Now consider the case where we observe not just a single outcome but an entire distribution over outcomes. We can use the same representation as before for the label y. The only dif- ference is that rather than a vector containing only binary entries, say ‚Äû0,0,1‚Äù, we now have a generic probability vector, say ‚Äû0.1,0.2,0.7‚Äù. The math that we used previously to define the loss ùëô in (4.1.8) still works well, just that the interpretation is slightly more general. It is the expected value of the loss for a distribution over labels. This loss is called the cross- entropy loss and it is one of the most commonly used losses for classification problems. We can demystify the name by introducing just the basics of information theory. In a nutshell, it measures the number of bits needed to encode what we see, y, relative to what we predict that should happen, ÀÜy. We provide a very basic explanation in the following.bubuFor further details on information theory see Cover and Thomas (1999) or MacKay (2003). 4.1.3 Information Theory Basics
Many deep learning papers use intuition and terms from information theory. To make sense of them, we need some common language. This is a survival guide. Information theory deals with the problem of encoding, decoding, transmitting, and manipulating information (also known as data). Softmax Regression
131

The central idea in information theory is to quantify the amount of information contained in data. This places a limit on our ability to compress data. For a distribution ùëÉ its entropy, ùêª¬ªùëÉ‚Ä¶, is defined as:
H[P] = ))-P(j) log PC). (4.1.11) J
One of the fundamental theorems of information theory states that in order to encode data drawn randomly from the distribution P, we need at least H[P] ‚Äúnats‚Äù to encode it (Shan- non, 1948). If you wonder what a ‚Äúnat‚Äù is, it is the equivalent of bit but when using a code with base e rather than one with base 2. Thus, one nat is mo ~ 1.44 bit. You might be wondering what compression has to do with prediction. Imagine that we have a stream of data that we want to compress. If it is always easy for us to predict the next token, then this data is easy to compress. Take the extreme example where every token in the stream always takes the same value. That is a very boring data stream! And not only it is boring, but it is also easy to predict. Because the tokens are always the same, we do not have to transmit any information to communicate the contents of the stream. Easy to predict, easy to compress. However if we cannot perfectly predict every event, then we might sometimes be surprised. Our surprise is greater when an event is assigned lower probability. Claude Shannon settled on log FO = ‚Äî log P(/) to quantify one‚Äôs surprisal at observing an event j having assigned it a (subjective) probability P(j). The entropy defined in (4.1.11) is then the expected surprisal when one assigned the correct probabilities that truly match the data-generating process. Cross-Entropy Revisited
So if entropy is the level of surprise experienced by someone who knows the true proba- bility, then you might be wondering, what is cross-entropy? The cross-entropy from P to Q, denoted H(P, Q), is the expected surprisal of an observer with subjective probabilities Q upon seeing data that was actually generated according to probabilities P. This is given by H(P,Q) ae Xj ~P(j) log Q(j). The lowest possible cross-entropy is achieved when P =Q. In this case, the cross-entropy from P to Q is H(P, P) = H(P). In short, we can think of the cross-entropy classification objective in two ways: (i) as max- imizing the likelihood of the observed data; and (ii) as minimizing our surprisal (and thus the number of bits) required to communicate the labels. 4.1.4 Summary and Discussion
Inthissection,weencounteredthefirstnontriviallossfunction,allowingustooptimizeover discrete output spaces. Key in its design was that we took a probabilistic approach, treating
Entropy
Surprisal
Linear Neural Networks for ClassiÔ¨Åcation
132

discrete categories as instances of draws from a probability distribution. As a side effect, we encountered the softmax, a convenient activation function that transforms outputs of an ordinary neural network layer into valid discrete probability distributions. We saw that the derivative of the cross-entropy loss when combined with softmax behaves very similarly to the derivative of squared error; namely by taking the difference between the expected behavior and its prediction. And, while we were only able to scratch the very surface of it, we encountered exciting connections to statistical physics and information theory. While this is enough to get you on your way, and hopefully enough to whet your appetite, we hardly dived deep here. Among other things, we skipped over computational con- siderations. Specifically, for any fully connected layer with ùëë inputs and ùëû outputs, the parametrization and computational cost is O‚Äûùëëùëû‚Äù, which can be prohibitively high in prac- tice. Fortunately, this cost of transforming ùëë inputs into ùëû outputs can be reduced through approximation and compression. For instance Deep Fried Convnets (Yang et al., 2015) uses a combination of permutations, Fourier transforms, and scaling to reduce the cost from quadratic to log-linear. Similar techniques work for more advanced structural matrix approximations (Sindhwani et al., 2015). Lastly, we can use quaternion-like decomposi- tions to reduce the cost to O‚Äû ùëëùëû ùëõ ‚Äù, again if we are willing to trade off a small amount of accuracy for computational and storage cost (Zhang et al., 2021) based on a compression factor ùëõ. This is an active area of research. What makes it challenging is that we do not necessarily strive for the most compact representation or the smallest number of floating point operations but rather for the solution that can be executed most efficiently on modern GPUs. 4.1.5 Exercises
1. We can explore the connection between exponential families and softmax in some more depth. 1. Compute the second derivative of the cross-entropy loss ùëô‚Äûy, ÀÜy‚Äù for softmax. 2. Computethevarianceofthedistributiongivenbysoftmax‚Äûo‚Äù andshowthatitmatches
the second derivative computed above. 2. Assume that we have three classes which occur with equal probability, i.e., the proba- bility vector is ‚Äû 1 , 1 , 1 ‚Äù. 3
3
3
1. What is the problem if we try to design a binary code for it? 2. Can you design a better code? Hint: what happens if we try to encode two indepen- dent observations? What if we encode ùëõ observations jointly? . When encoding signals transmitted over a physical wire, engineers do not always use binary codes. For instance, PAM-3¬∞¬∞ uses three signal levels {‚Äî1, 0, 1} as opposed to two levels {0,1}. How many ternary units do you need to transmit an integer in the range {0,...,7}? Why might this be a better idea in terms of electronics?bubu90
4. The Bradley‚ÄìTerry model90 uses a logistic model to capture preferences. For a user to
Softmax Regression
133

choose between apples and oranges one assumes scores ùëúapple and ùëúorange. Our require-
ments are that larger scores should lead to a higher likelihood in choosing the associated item and that the item with the largest score is the most likely one to be chosen (Bradley and Terry, 1952). 1. Prove that softmax satisfies this requirement. 2. What happens if you want to allow for a default option of choosing neither apples nor oranges? Hint: now the user has three choices.bubu5. Softmax gets its name from the following mapping: RealSoftMax‚Äûùëé, ùëè‚Äù = log‚Äûexp‚Äûùëé‚Äù‚Äö
exp‚Äûùëè‚Äù‚Äù. 1. Prove that RealSoftMax‚Äûùëé, ùëè‚Äù > max‚Äûùëé, ùëè‚Äù. 2. How small can you make the difference between both functions? Hint: without loss of generality you can set b = O anda > b. 3. Prove that this holds for A~!RealSoftMax(Aa, Ab), provided that A > 0. 4. Show that for 2 ‚Äî co we have A~!RealSoftMax(Aa, Ab) ‚Äî max(a, b). 5. Construct an analogous softmin function. 6. Extend this to more than two numbers.bubuÀù
6. The function ùëî‚Äûx‚Äù def
91 = log ùëñ expùë•ùëñ is sometimes also referred to as the log-partition function91. 1. Prove that the function is convex. Hint: to do so, use the fact that the first derivative amounts to the probabilities from the softmax function and show that the second derivative is the variance. 2. Show that ùëî is translation invariant, i.e., ùëî‚Äûx ‚Äö ùëè‚Äù = ùëî‚Äûx‚Äù. 3.bubuWhat happens if some of the coordinates ùë•ùëñ are very large? What happens if they‚Äôre
all very small? 4. Show that if we choose ùëè = maxùëñùë•ùëñ we end up with a numerically stable implemen-
tation. 7. Assume that we have some probability distribution ùëÉ. Suppose we pick another distri-
bution ùëÑ with ùëÑ‚Äûùëñ‚Äù / ùëÉ‚Äûùëñ‚Äùùõº for ùõº > 0. 1. Which choice of ùõº corresponds to doubling the temperature? Which choice corre-
sponds to halving it? 2. What happens if we let the temperature approach 0? 3. What happens if we let the temperature approach 1?bubu92
Discussions92. Linear Neural Networks for ClassiÔ¨Åcation
134

4.2 The Image Classification Dataset

One widely used dataset for image classification is the MNIST dataset¬∞? (LeCun et al., 1998) of handwritten digits. At the time of its release in the 1990s it posed a formidable challenge to most machine learning algorithms, consisting of 60,000 images of 28 x 28 pixels resolution (plus a test dataset of 10,000 images). To put things into perspective, back in 1995, aSun SPARCStation 5 with a whopping 64MB of RAM and a blistering 5 MFLOPs was considered state of the art equipment for machine learning at AT&T Bell Laboratories. Achieving high accuracy on digit recognition was a key component in automating letter sorting for the USPS in the 1990s. Deep networks such as LeNet-5 (LeCun et al., 1995), support vector machines with invariances (Schdlkopf et al., 1996), and tangent distance classifiers (Simard et al., 1998) all could reach error rates below 1%. 93
For over a decade, MNIST served as the point of reference for comparing machine learn- ing algorithms. While it had a good run as a benchmark dataset, even simple models by today‚Äôs standards achieve classification accuracy over 95%, making it unsuitable for distin- guishing between strong models and weaker ones. Even more, the dataset allows for very high levels of accuracy, not typically seen in many classification problems. This skewed algorithmic development towards specific families of algorithms that can take advantage of clean datasets, such as active set methods and boundary-seeking active set algorithms. Today, MNIST serves as more of a sanity check than as a benchmark. ImageNet (Deng et al., 2009) poses a much more relevant challenge. Unfortunately, ImageNet is too large for many of the examples and illustrations in this book, as it would take too long to train to make the examples interactive. As a substitute we will focus our discussion in the coming sections on the qualitatively similar, but much smaller Fashion-MNIST dataset (Xiao et al., 2017) which was released in 2017. It contains images of 10 categories of clothing at 28 x28 pixels resolution. %matplotlib inline import time import torch import torchvision from torchvision import transforms from d2l import torch as d2l
d2l.use_svg_display()
4.2.1 Loading the Dataset
Since the Fashion-MNIST dataset is so useful, all major frameworks provide preprocessed versions of it. We can download and read it into memory using built-in framework utili- ties. The Image ClassiÔ¨Åcation Dataset
135

class FashionMNIST(d2l.DataModule): #@save """The Fashion-MNIST dataset.""" def __init__(self, batch_size=64, resize=(28, 28)): super().__init__() self.save_hyperparameters() trans = transforms.Compose([transforms.Resize(resize), transforms.ToTensor()]) self.train = torchvision.datasets.FashionMNIST( root=self.root, train=True, transform=trans, download=True) self.val = torchvision.datasets.FashionMNIST( root=self.root, train=False, transform=trans, download=True)
Fashion-MNIST consists of images from 10 categories, each represented by 6000 images in the training dataset and by 1000 in the test dataset. A test dataset is used for evaluating model performance (it must not be used for training). Consequently the training set and the test set contain 60,000 and 10,000 images, respectively. data = FashionMNIST(resize=(32, 32)) len(data.train), len(data.val)
(60000, 10000)
The images are grayscale and upscaled to 32 x 32 pixels in resolution above. This is similar
The images are grayscale and upscaled to 32 x 32 pixels in resolution above. This is similar to the original MNIST dataset which consisted of (binary) black and white images. Note, though, that most modern image data has three channels (red, green, blue) and that hyper- spectral images can have in excess of 100 channels (the HyMap sensor has 126 channels). By convention we store an image as a c X /t X w tensor, where c is the number of color channels, h is the height and w is the width. data.train[0][0].shape
torch.Size([1, 32, 32])
The categories of Fashion-MNIST have human-understandable names. The following con- venience method converts between numeric labels and their names. @d2l.add_to_class(FashionMNIST) #@save def text_labels(self, indices): """Return text labels.""" labels = ['t-shirt', 'trouser', 'pullover', 'dress', 'coat', 'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot'] return [labels[int(i)] for i in indices]
4.2.2 Reading a Minibatch
To make our life easier when reading from the training and test sets, we use the built-in data iterator rather than creating one from scratch. Recall that at each iteration, a data iterator
Linear Neural Networks for ClassiÔ¨Åcation
136

reads a minibatch of data with size batch_size. We also randomly shuffle the examples for the training data iterator. @d2l.add_to_class(FashionMNIST) #@save def get_dataloader(self, train): data = self.train if train else self.val return torch.utils.data.DataLoader(data, self.batch_size, shuffle=train, num_workers=self.num_workers)
To see how this works, let‚Äôs load a minibatch of images by invoking the train_dataloader method. It contains 64 images. X, y = next(iter(data.train_dataloader())) print(X.shape, X.dtype, y.shape, y.dtype)
torch.Size([64, 1, 32, 32]) torch.float32 torch.Size([64]) torch.int64
Let‚Äôs look at the time it takes to read the images. Even though it is a built-in loader, it is not blazingly fast. Nonetheless, this is sufficient since processing images with a deep network takes quite a bit longer. Hence it is good enough that training a network will not be I/O constrained. tic = time.time() for X, y in data.train_dataloader(): continue f'{time.time() - tic:.2f} sec'
'4.69 sec'
4.2.3 Visualization
We will often be using the Fashion-MNIST dataset. A convenience function show_images can be used to visualize the images and the associated labels. Skipping implementation details, we just show the interface below: we only need to know how to invoke d2l. show_images rather than how it works for such utility functions. def show_images(imgs, num_rows, num_cols, titles=None, scale=1.5): #@save """Plot a list of images.""" raise NotImplementedError
Let‚Äôs put it to good use. In general, it is a good idea to visualize and inspect data that you are training on. Humans are very good at spotting oddities and because of that, visualization serves as an additional safeguard against mistakes and errors in the design of experiments. Here are the images and their corresponding labels (in text) for the first few examples in the training dataset. The Image ClassiÔ¨Åcation Dataset
137

@d2l.add_to_class(FashionMNIST) #@save def visualize(self, batch, nrows=1, ncols=8, labels=[]): X, y = batch if not labels: labels = self.text_labels(y) d2l.show_images(X.squeeze(1), nrows, ncols, titles=labels) batch = next(iter(data.val_dataloader())) data.visualize(batch)
pullover
ankle boot
trouser
trouser




WearenowreadytoworkwiththeFashion-MNISTdatasetinthesectionsthatfollow. 4.2.4 Summary
We now have a slightly more realistic dataset to use for classification. Fashion-MNIST is an apparel classification dataset consisting of images representing 10 categories. We will use this dataset in subsequent sections and chapters to evaluate various network designs, from a simple linear model to advanced residual networks. As we commonly do with images, we read them as a tensor of shape (batch size, number of channels, height, width). For now, we only have one channel as the images are grayscale (the visualization above uses a false color palette for improved visibility). Lastly, data iterators are a key component for efficient performance. For instance, we might use GPUs for efficient image decompression, video transcoding, or other preprocessing. Whenever possible, you should rely on well-implemented data iterators that exploit high- performance computing to avoid slowing down your training loop. 4.2.5 Exercises
1. Does reducing the batch_size (for instance, to 1) affect the reading performance? 2. The data iterator performance is important. Do you think the current implementation is fast enough? Explore various options to improve it. Use a system profiler to find out where the bottlenecks are. 94
3.bubuCheck out the framework‚Äôs online API documentation. Which other datasets are avail- able?bubuDiscussions94. shirt
shirt
trouser
coat




Linear Neural Networks for ClassiÔ¨Åcation
138

4.3 The Base Classification Model
a
You may have noticed that the implementations from scratch and the concise implementa- tion using framework functionality were quite similar in the case of regression. The same is true for classification. Since many models in this book deal with classification, it is worth adding functionalities to support this setting specifically. This section provides a base class for classification models to simplify future code. import torch from d2l import torch as d2l
4.3.1 The Classifier Class
We define the Classifier class below. In the validation_step we report both the loss value and the classification accuracy on a validation batch.bubuWe draw an update for every num_val_batches batches. This has the benefit of generating the averaged loss and ac- curacy on the whole validation data. These average numbers are not exactly correct if the final batch contains fewer examples, but we ignore this minor difference to keep the code simple. class Classifier(d2l.Module): #@save """The base class of classification models.""" def validation_step(self, batch): Y_hat = self(*batch[:-1]) self.plot('loss', self.loss(Y_hat, batch[-1]), train=False) self.plot('acc', self.accuracy(Y_hat, batch[-1]), train=False)
By default we use a stochastic gradient descent optimizer, operating on minibatches, just as we did in the context of linear regression. @d2l.add_to_class(d2l.Module) #@save def configure_optimizers(self): return torch.optim.SGD(self.parameters(), lr=self.lr)
4.3.2 Accuracy
Given the predicted probability distribution y_hat, we typically choose the class with the highest predicted probability whenever we must output a hard prediction. Indeed, many applications require that we make a choice.bubuFor instance, Gmail must categorize an email into ‚ÄúPrimary‚Äù, ‚ÄúSocial‚Äù, ‚ÄúUpdates‚Äù, ‚ÄúForums‚Äù, or ‚ÄúSpam‚Äù. It might estimate probabilities internally, but at the end of the day it has to choose one among the classes. When predictions are consistent with the label class y, they are correct. The classification accuracy is the fraction of all predictions that are correct. Although it can be difficult to optimize accuracy directly (it is not differentiable), it is often the performance measure that
The Base ClassiÔ¨Åcation Model
139

we care about the most. It is often the relevant quantity in benchmarks. As such, we will nearly always report it when training classifiers. Accuracy is computed as follows. First, if y_hat is a matrix, we assume that the second di- mensionstorespredictionscoresforeachclass. Weuseargmaxtoobtainthepredictedclass by the index for the largest entry in each row. Then we compare the predicted class with the ground truth y elementwise. Since the equality operator == is sensitive to data types, we convert y_hat‚Äôs data type to match that of y. The result is a tensor containing entries of 0 (false) and 1 (true). Taking the sum yields the number of correct predictions. @d2l.add_to_class(Classifier) #@save def accuracy(self, Y_hat, Y, averaged=True): """Compute the number of correct predictions.""" Y_hat = Y_hat.reshape((-1, Y_hat.shape[-1])) preds = Y_hat.argmax(axis=1).type(Y.dtype) compare = (preds == Y.reshape(-1)).type(torch.float32) return compare.mean() if averaged else compare
4.3.3 Summary
Classification is a sufficiently common problem that it warrants its own convenience func- tions. Of central importance in classification is the accuracy of the classifier.bubuNote that while we often care primarily about accuracy, we train classifiers to optimize a variety of other objectives for statistical and computational reasons. However, regardless of which loss function was minimized during training, it is useful to have a convenience method for assessing the accuracy of our classifier empirically. 4.3.4 Exercises
1. Denote by ùêøv the validation loss, and let ùêøq v be its quick and dirty estimate computed by the loss function averaging in this section. Lastly, denote by ùëôb v the loss on the last minibatch. Express ùêøv in terms of ùêøq v, ùëôb v, and the sample and minibatch sizes. 2. Show that the quick and dirty estimate ùêøq
v is unbiased. That is, show that ùê∏¬ªùêøv‚Ä¶ = ùê∏¬ªùêøq v‚Ä¶. Why would you still want to use ùêøv instead?bubu95
3. Given a multiclass classification loss, denoting by ùëô‚Äûùë¶, ùë¶0‚Äù the penalty of estimating
ùë¶0 when we see ùë¶ and given a probabilty ùëù‚Äûùë¶ j ùë•‚Äù, formulate the rule for an optimal selection of ùë¶0. Hint: express the expected loss, using ùëô and ùëù‚Äûùë¶ j ùë•‚Äù. Discussions95. Linear Neural Networks for ClassiÔ¨Åcation
140

4.4 Softmax Regression Implementation from Scratch

Because softmax regression is so fundamental, we believe that you ought to know how to implement it yourself. Here, we limit ourselves to defining the softmax-specific aspects of the model and reuse the other components from our linear regression section, including the training loop. import torch from d2l import torch as d2l
4.4.1 The Softmax
Let‚Äôs begin with the most important part: the mapping from scalars to probabilities. For a refresher, recall the operation of the sum operator along specific dimensions in a tensor, as discussed in Section 2.3.6 and Section 2.3.7. Given a matrix X we can sum over all elements (by default) or only over elements in the same axis. The axis variable lets us compute row and column sums:
X = torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]) X.sum(0, keepdims=True), X.sum(1, keepdims=True)
(tensor([[5., 7., 9.]]), tensor([[ 6.], [15.]]))
Computing the softmax requires three steps: (i) exponentiation of each term; (ii) a sum over each row to compute the normalization constant for each example; (iii) division of each row by its normalization constant, ensuring that the result sums to 1:
softmax‚ÄûX‚Äùùëñùëó = Àù ùëò exp‚ÄûXùëñùëò‚Äù . (4.4.1)
The (logarithm of the) denominator is called the (log) partition function. It was introduced in statistical physics96 to sum over all possible states in a thermodynamic ensemble. The implementation is straightforward:
96
def softmax(X): X_exp = torch.exp(X) partition = X_exp.sum(1, keepdims=True) return X_exp / partition # The broadcasting mechanism is applied here
For any input X, we turn each element into a nonnegative number. Each row sums up to 1, as is required for a probability. Caution: the code above is not robust against very large or very small arguments. While it is sufficient to illustrate what is happening, you should
exp‚ÄûXùëñùëó‚Äù
Softmax Regression Implementation from Scratch
141

not use this code verbatim for any serious purpose. Deep learning frameworks have such protections built in and we will be using the built-in softmax going forward. X = torch.rand((2, 5)) X_prob = softmax(X) X_prob, X_prob.sum(1)
(tensor([[0.2511, 0.1417, 0.1158, 0.2529, 0.2385], [0.2004, 0.1419, 0.1957, 0.2504, 0.2117]]), tensor([1., 1.]))
4.4.2 The Model
We now have everything that we need to implement the softmax regression model. As in our linear regression example, each instance will be represented by a fixed-length vector. Since the raw data here consists of 28 x 28 pixel images, we flatten each image, treating them as vectors of length 784. In later chapters, we will introduce convolutional neural networks, which exploit the spatial structure in a more satisfying way. In softmax regression, the number of outputs from our network should be equal to the number of classes. Since our dataset has 10 classes, our network has an output dimension of 10. Consequently, our weights constitute a 784 x 10 matrix plus a 1 x 10 row vector for the biases. As with linear regression, we initialize the weights W with Gaussian noise. The biases are initialized as zeros. class SoftmaxRegressionScratch(d2l.Classifier): def __init__(self, num_inputs, num_outputs, lr, sigma=0.01): super().__init__() self.save_hyperparameters() self.W = torch.normal(0, sigma, size=(num_inputs, num_outputs), requires_grad=True) self.b = torch.zeros(num_outputs, requires_grad=True) def parameters(self): return [self.W, self.b]
The code below defines how the network maps each input to an output. Note that we flatten each 28 x 28 pixel image in the batch into a vector using reshape before passing the data through our model. @d2l.add_to_class(SoftmaxRegressionScratch) def forward(self, X): X = X.reshape((-1, self.W.shape[0])) return softmax(torch.matmul(X, self.W) + self.b)
4.4.3 The Cross-Entropy Loss
Next we need to implement the cross-entropy loss function (introduced in Section 4.1.2). This may be the most common loss function in all of deep learning. At the moment, appli-
Linear Neural Networks for ClassiÔ¨Åcation
142

cations of deep learning easily cast as classification problems far outnumber those better treated as regression problems. Recall that cross-entropy takes the negative log-likelihood of the predicted probability as- signed to the true label. For efficiency we avoid Python for-loops and use indexing instead. In particular, the one-hot encoding in y allows us to select the matching terms in ÀÜy. To see this in action we create sample data y_hat with 2 examples of predicted probabilities over 3 classes and their corresponding labels y. The correct labels are 0 and 2 respectively (i.e., the first and third class). Using y as the indices of the probabilities in y_hat, we can pick out terms efficiently. y = torch.tensor([0, 2]) y_hat = torch.tensor([[0.1, 0.3, 0.6], [0.3, 0.2, 0.5]]) y_hat[[0, 1], y]
tensor([0.1000, 0.5000])
Now we can implement the cross-entropy loss function by averaging over the logarithms of the selected probabilities. def cross_entropy(y_hat, y):
return -torch.log(y_hat[list(range(len(y_hat))), y]).mean()
cross_entropy(y_hat, y)
tensor(1.4979)
@d2l.add_to_class(SoftmaxRegressionScratch) def loss(self, y_hat, y): return cross_entropy(y_hat, y)
4.4.4 Training
WereusethefitmethoddefinedinSection3.4totrainthemodelwith10epochs. Notethat the number of epochs (max_epochs), the minibatch size (batch_size), and learning rate (lr) are adjustable hyperparameters.bubuThat means that while these values are not learned during our primary training loop, they still influence the performance of our model, both vis-√†-vis training and generalization performance. In practice you will want to choose these values based on the validation split of the data and then, ultimately, to evaluate your final modelonthetest split. AsdiscussedinSection3.6.3, wewillregardthetestdataofFashion- MNIST as the validation set, thus reporting validation loss and validation accuracy on this split. Softmax Regression Implementation from Scratch
143

data = d2l.FashionMNIST(batch_size=256) model = SoftmaxRegressionScratch(num_inputs=784, num_outputs=10, lr=0.1) trainer = d2l.Trainer(max_epochs=10) trainer.fit(model, data)
0.9 0.8] ) mee ‚Äî train_loss 07 === val_loss ‚Äî-- val_acc 0.6 0.5 0 2 4 6 8 10
4.4.5 Prediction
Now that training is complete, our model is ready to classify some images. X, y = next(iter(data.val_dataloader())) preds = model(X).argmax(axis=1) preds.shape
torch.Size([256])
We are more interested in the images we label incorrectly. We visualize them by comparing their actual labels (first line of text output) with the predictions from the model (second line of text output). wrong = preds.type(y.dtype) != y X, y, preds = X[wrong], y[wrong], preds[wrong] labels = [a+'\n'+b for a, b in zip( data.text_labels(y), data.text_labels(preds))] data.visualize([X, y], labels=labels)
sandal ankle boot sneaker sneaker
sneaker sandal
pullover t-shirt
coat shirt




4.4.6 Summary
By now we are starting to get some experience with solving linear regression and classifi- cation problems. With it, we have reached what would arguably be the state of the art of
shirt t-shirt
pullover shirt
coat pullover




Linear Neural Networks for ClassiÔ¨Åcation
144

1960‚Äì1970s of statistical modeling. In the next section, we will show you how to leverage deep learning frameworks to implement this model much more efficiently.bubu4.4.7 Exercises
1. Inthissection, wedirectlyimplementedthesoftmaxfunctionbasedonthemathematical definitionofthesoftmaxoperation. AsdiscussedinSection4.1thiscancausenumerical instabilities.bubu1. Test whether softmax still works correctly if an input has a value of 100. 2. Test whether softmax still works correctly if the largest of all inputs is smaller than -100? 3. Implement a fix by looking at the value relative to the largest entry in the argument. 2. Implement a cross_entropy function that follows the definition of the cross-entropy Àù ùëñ ùë¶ùëñ log ÀÜùë¶ùëñ. loss function
1. Try it out in the code example of this section.bubu2. Why do you think it runs more slowly? 3. Should you use it? When would it make sense to? 4.bubuWhat do you need to be careful of? Hint: consider the domain of the logarithm. 3. Is it always a good idea to return the most likely label? For example, would you do this for medical diagnosis?bubuHow would you try to address this?bubu4. Assume that we want to use softmax regression to predict the next word based on some features. What are some problems that might arise from a large vocabulary? 5. Experiment with the hyperparameters of the code in this section. In particular:
1. Plot how the validation loss changes as you change the learning rate. 2. Do the validation and training loss change as you change the minibatch size? How large or small do you need to go before you see an effect?bubu97
Discussions97. 4.5 Concise Implementation of Softmax Regression
|
Just as high-level deep learning frameworks made it easier to implement linear regression (see Section 3.5), they are similarly convenient here. Concise Implementation of Softmax Regression
145

import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
4.5.1 Defining the Model
As in Section 3.5, we construct our fully connected layer using the built-in layer. The built- in __call__ method then invokes forward whenever we need to apply the network to some input. We use a Flatten layer to convert the fourth-order tensor X to second order by keeping the dimensionality along the first axis unchanged. class SoftmaxRegression(d2l.Classifier): #@save """The softmax regression model.""" def __init__(self, num_outputs, lr): super().__init__() self.save_hyperparameters() self.net = nn.Sequential(nn.Flatten(), nn.LazyLinear(num_outputs)) def forward(self, X): return self.net(X)
4.5.2 Softmax Revisited
In Section 4.4 we calculated our model‚Äôs output and applied the cross-entropy loss. While this is perfectly reasonable mathematically, it is risky computationally, because of numer- ical underflow and overflow in the exponentiation. Recall that the softmax function computes probabilities via ÀÜùë¶ ùëó = exp‚Äûùëúùëó‚Äù
Recall that the softmax function computes probabilities via $; = see. If some of the ox are very large, i.e., very positive, then exp(o,) might be larger than the largest number we can have for certain data types. This is called overflow. Likewise, if every argument is a very large negative number, we will get underflow. For instance, single precision floating point numbers approximately cover the range of 10-38 to 10¬∞8. As such, if the largest term in o lies outside the interval [-90, 90], the result will not be stable. A way round this problem is to subtract 6 def max, ox from all entries:
exp 0; exp(o; ‚Äî 6) expo exp(0; ‚Äî 0) Deexpox Leexp(on ‚Äî A) expd ‚Äî Dy exp(ox ‚Äî 4) $75 (4.5.1)
By construction we know that 0; ‚Äî 6 < 0 for all j. As such, for a q-class classification
By construction we know that 0; ‚Äî 6 < 0 for all j. As such, for a q-class classification problem, the denominator is contained in the interval [1,q]. Moreover, the numerator never exceeds 1, thus preventing numerical overflow. Numerical underflow only occurs when exp(o; ‚Äî 0) numerically evaluates as 0. Nonetheless, a few steps down the road we might find ourselves in trouble when we want to compute log $; as log 0. In particular, in backpropagation, we might find ourselves faced with a screenful of the dreaded NaN (Not a Number) results. Linear Neural Networks for ClassiÔ¨Åcation
146

Fortunately, we are saved by the fact that even though we are computing exponential func- tions, we ultimately intend to take their log (when calculating the cross-entropy loss). By combining softmax and cross-entropy, we can escape the numerical stability issues alto- gether. We have:
exp(oj ~ 9)
exp(oj ~ 9) I i, =] ‚Äî‚Äî‚Äî_‚Äî‚Äî‚Äî_ = O87 S18 SX explon ‚Äî 5) 0; ~6 log)" exp(ox - 3). (4.5.2) k
This avoids both overflow and underflow. We will want to keep the conventional softmax function handy in case we ever want to evaluate the output probabilities by our model. But instead of passing softmax probabilities into our new loss function, we just pass the logits andcomputethesoftmaxanditslogallatonceinsidethecross-entropylossfunction, which does smart things like the ‚ÄúLogSumExp trick‚Äù98. 98
@d2l.add_to_class(d2l.Classifier) #@save def loss(self, Y_hat, Y, averaged=True): Y_hat = Y_hat.reshape((-1, Y_hat.shape[-1])) Y = Y.reshape((-1,)) return F.cross_entropy( Y_hat, Y, reduction='mean' if averaged else 'none')
4.5.3 Training
Next we train our model. We use Fashion-MNIST images, flattened to 784-dimensional feature vectors. data = d2l.FashionMNIST(batch_size=256) model = SoftmaxRegression(num_outputs=10, lr=0.1) trainer = d2l.Trainer(max_epochs=10) trainer.fit(model, data)
0.9 0.84) eco et ‚Äî train_loss 0.7 === val_loss ‚Äî-- val_ace 0.6 on es, 05 *s------.__4 0 2 4 6 8 10
As before, this algorithm converges to a solution that is reasonably accurate, albeit this time with fewer lines of code than before. 4.5.4 Summary
High-levelAPIsareveryconvenientathidingfromtheiruserpotentiallydangerousaspects, such as numerical stability. Moreover, they allow users to design models concisely with
Generalization in ClassiÔ¨Åcation
147

very few lines of code. This is both a blessing and a curse. The obvious benefit is that it makes things highly accessible, even to engineers who never took a single class of statistics in their life (in fact, they are part of the target audience of the book). But hiding the sharp edges also comes with a price: a disincentive to add new and different components on your own, since there is little muscle memory for doing it. Moreover, it makes it more difficult to fix things whenever the protective padding of a framework fails to cover all the corner cases entirely. Again, this is due to lack of familiarity. As such, we strongly urge you to review both the bare bones and the elegant versions of many of the implementations that follow. While we emphasize ease of understanding, the implementations are nonetheless usually quite performant (convolutions are the big excep- tion here). It is our intention to allow you to build on these when you invent something new that no framework can give you.bubu4.5.5 Exercises
1. Deep learning uses many different number formats, including FP64 double precision (used extremely rarely), FP32 single precision, BFLOAT16 (good for compressed rep- resentations), FP16 (very unstable), TF32 (a new format from NVIDIA), and INT8. Compute the smallest and largest argument of the exponential function for which the result does not lead to numerical underflow or overflow. 2. INT8 is a very limited format consisting of nonzero numbers from 1 to 255. How could you extend its dynamic range without using more bits? Do standard multiplication and addition still work?bubu3. Increase the number of epochs for training. Why might the validation accuracy decrease after a while? How could we fix this?bubu4. What happens as you increase the learning rate? Compare the loss curves for several learning rates. Which one works better?bubuWhen?bubuDiscussions99. 99
4.6 Generalization in Classification
ae
So far, we have focused on how to tackle multiclass classification problems by training (linear) neural networks with multiple outputs and softmax functions. Interpreting our model‚Äôs outputs as probabilistic predictions, we motivated and derived the cross-entropy loss function, which calculates the negative log likelihood that our model (for a fixed set of parameters) assigns to the actual labels. And finally, we put these tools into practice by fitting our model to the training set.bubuHowever, as always, our goal is to learn general patterns, as assessed empirically on previously unseen data (the test set). High accuracy on the training set means nothing. Whenever each of our inputs is unique (and indeed this is true for most high-dimensional datasets), we can attain perfect accuracy on the training
Linear Neural Networks for ClassiÔ¨Åcation
148

set by just memorizing the dataset on the first training epoch, and subsequently looking up the label whenever we see a new image. And yet, memorizing the exact labels associated with the exact training examples does not tell us how to classify new examples. Absent further guidance, we might have to fall back on random guessing whenever we encounter new examples. A number of burning questions demand immediate attention:
1. How many test examples do we need to give a good estimate of the accuracy of our classifiers on the underlying population? 2. What happens if we keep evaluating models on the same test repeatedly? 3. Why should we expect that fitting our linear models to the training set should fare any better than our naive memorization scheme? Whereas Section 3.6 introduced the basics of overfitting and generalization in the context of
linear regression, this chapter will go a little deeper, introducing some of the foundational ideas of statistical learning theory. It turns out that we often can guarantee generalization a priori: for many models, and for any desired upper bound on the generalization gap ùúñ, we can often determine some required number of samples ùëõ such that if our training set contains at least ùëõ samples, our empirical error will lie within ùúñ of the true error, for any data generating distribution. Unfortunately, it also turns out that while these sorts of guar- antees provide a profound set of intellectual building blocks, they are of limited practical utility to the deep learning practitioner. In short, these guarantees suggest that ensuring generalization of deep neural networks a priori requires an absurd number of examples (perhaps trillions or more), even when we find that, on the tasks we care about, deep neural networks typically generalize remarkably well with far fewer examples (thousands). Thus deep learning practitioners often forgo a priori guarantees altogether, instead employing methods that have generalized well on similar problems in the past, and certifying gen- eralization post hoc through empirical evaluations. When we get to Chapter 5, we will revisit generalization and provide a light introduction to the vast scientific literature that has sprung in attempts to explain why deep neural networks generalize in practice. 4.6.1 The Test Set
Since we have already begun to rely on test sets as the gold standard method for assessing generalization error, let‚Äôs get started by discussing the properties of such error estimates. Let‚Äôs focus on a fixed classifier ùëì, without worrying about how it was obtained. Moreover suppose that we possess a fresh dataset of examples D = ‚Äûx‚Äûùëñ‚Äù, ùë¶‚Äûùëñ‚Äù‚Äùùëõ ùëñ=1 that were not used to train the classifier ùëì. The empirical error of our classifier ùëì on D is simply the fraction of instances for which the prediction ùëì ‚Äûx‚Äûùëñ‚Äù‚Äù disagrees with the true label ùë¶‚Äûùëñ‚Äù, and is given by the following expression:
ùúñD‚Äû ùëì‚Äù = 1 ùëõ ùëñ=1 1‚Äû ùëì ‚Äûx‚Äûùëñ‚Äù‚Äù ‚â† ùë¶‚Äûùëñ‚Äù‚Äù. (4.6.1)
Bycontrast, thepopulationerror istheexpected fractionofexamplesintheunderlyingpop- ulation (some distribution ùëÉ‚Äûùëã,ùëå‚Äù characterized by probability density function ùëù‚Äûx, ùë¶‚Äù)
Generalization in ClassiÔ¨Åcation
149

for which our classifier disagrees with the true label:
‚Ç¨(f) = Evey)-PUf) #9) = / / Ufo) # y)p(x, y) dxdy. (4.6.2)
While ùúñ‚Äû ùëì‚Äù is the quantity that we actually care about, we cannot observe it directly, just
as we cannot directly observe the average height in a large population without measuring every single person. We can only estimate this quantity based on samples. Because our test set D is statistically representative of the underlying population, we can view ùúñD‚Äû ùëì‚Äù as a statistical estimator of the population error ùúñ‚Äû ùëì‚Äù. Moreover, because our quantity of interestùúñ‚Äû ùëì‚Äù isanexpectation(oftherandomvariable1‚Äû ùëì ‚Äûùëã‚Äù ‚â† ùëå‚Äù)andthecorresponding estimator ùúñD‚Äû ùëì‚Äù is the sample average, estimating the population error is simply the classic problem of mean estimation, which you may recall from Section 2.6. An important classical result from probability theory called the central limit theorem guar- antees that whenever we possess n random samples a, ...,d@, drawn from any distribution with mean y and standard deviation o, then, as the number of samples n approaches infin- ity, the sample average (i approximately tends towards a normal distribution centered at the true mean and with standard deviation a /-Vn. Already, this tells us something important: as the number of examples grows large, our test error ‚Ç¨p(f) should approach the true error e(f) at a rate of O(1/Vn). Thus, to estimate our test error twice as precisely, we must collect four times as large a test set. To reduce our test error by a factor of one hundred, we must collect ten thousand times as large a test set. In general, such a rate of O(1/-n) is often the best we can hope for in statistics. Now that we know something about the asymptotic rate at which our test error ùúñD‚Äû ùëì‚Äù
Now that we know something about the asymptotic rate at which our test error ep(f) converges to the true error e(f), we can zoom in on some important details. Recall that the random variable of interest 1(f(X) # Y) can only take values 0 and 1| and thus is a Bernoulli random variable, characterized by a parameter indicating the probability that it takes value 1. Here, 1 means that our classifier made an error, so the parameter of our random variable is actually the true error rate e( f). The variance o of a Bernoulli depends on its parameter (here, e( f)) according to the expression e(f)(1 ‚Äî e(f)). While e(f) is initially unknown, we know that it cannot be greater than 1. A little investigation of this function reveals that our variance is highest when the true error rate is close to 0.5 and can be far lower when it is close to 0 or close to 1. This tells us that the asymptotic standard deviation of our estimate ep(f) of the error e(f) (over the choice of the n test samples) cannot be any greater than 0.25/n. If we ignore the fact that this rate characterizes behavior as the test set size approaches infinity rather than when we possess finite samples, this tells us that if we want our test error ‚Ç¨p(f) to approximate the population error e(f) such that one standard deviation corresponds to an interval of +0.01, then we should collect roughly 2500 samples. If we want to fit two standard deviations in that range and thus be 95% confident that ep(f) ‚Ç¨ e(f) + 0.01, then we will need 10,000 samples! This turns out to be the size of the test sets for many popular benchmarks in machine learn- ing. You might be surprised to find out that thousands of applied deep learning papers get published every year making a big deal out of error rate improvements of 0.01 or less. Of
‚Äû ‚Äû
Linear Neural Networks for ClassiÔ¨Åcation
150

course, when the error rates are much closer to 0, then an improvement of 0.01 can indeed
be a big deal. One pesky feature of our analysis thus far is that it really only tells us about asymptotics, i.e., how the relationship between ùúñD and ùúñ evolves as our sample size goes to infinity. Fortunately, because our random variable is bounded, we can obtain valid finite sample bounds by applying an inequality due to Hoeffding (1963):
P(en(f)- ‚Ç¨(f) > 1) < exp (-2n?) . (4.6.3)
Solving for the smallest dataset size that would allow us to conclude with 95% confidence that the distance ùë° between our estimate ùúñD‚Äû ùëì‚Äù and the true error rate ùúñ‚Äû ùëì‚Äù does not exceed 0.01, you will find that roughly 15,000 examples are required as compared to the 10,000 examples suggested by the asymptotic analysis above. If you go deeper into statistics you will find that this trend holds generally. Guarantees that hold even in finite samples are typically slightly more conservative. Note that in the scheme of things, these numbers are not so far apart, reflecting the general usefulness of asymptotic analysis for giving us ballpark figures even if they are not guarantees we can take to court. 4.6.2 Test Set Reuse
In some sense, you are now set up to succeed at conducting empirical machine learning research. Nearly all practical models are developed and validated based on test set perfor- mance and you are now a master of the test set. For any fixed classifier ùëì, you know how to evaluate its test error ùúñD‚Äû ùëì‚Äù, and know precisely what can (and cannot) be said about its population error ùúñ‚Äû ùëì‚Äù. So let‚Äôs say that you take this knowledge and prepare to train your first model ùëì1. Knowing
just how confident youneed to be in the performance of your classifier‚Äôserror rate youapply our analysis above to determine an appropriate number of examples to set aside for the test set. Moreover, let‚Äôs assume that you took the lessons from Section 3.6 to heart and made sure to preserve the sanctity of the test set by conducting all of your preliminary analysis, hyperparameter tuning, and even selection among multiple competing model architectures on a validation set. Finally you evaluate your model ùëì1 on the test set and report an unbiased estimate of the population error with an associated confidence interval. So far everything seems to be going well. However, that night you wake up at 3am with a brilliant idea for a new modeling approach. The next day, you code up your new model, tune its hyperparameters on the validation set and not only are you getting your new model ùëì2 to work but its error rate appears to be much lower than ùëì1‚Äôs. However, the thrill of discovery suddenly fades as you prepare for the final evaluation. You do not have a test set! Eventhoughtheoriginaltestset D isstillsittingonyourserver,younowfacetwoformidable
problems. First, when you collected your test set, you determined the required level of pre- cision under the assumption that you were evaluating a single classifier ùëì. However, if you get into the business of evaluating multiple classifiers ùëì1, ..., ùëìùëò on the same test set, you must consider the problem of false discovery. Before, you might have been 95% sure
Generalization in ClassiÔ¨Åcation
151

that ep(f) ‚Ç¨ e(f) + 0.01 for a single classifier f and thus the probability of a misleading
result was a mere 5%. With ùëò classifiers in the mix, it can be hard to guarantee that there is not even one among them whose test set performance is misleading. With 20 classifiers under consideration, you might have no power at all to rule out the possibility that at least one among them received a misleading score. This problem relates to multiple hypothesis testing, which despite a vast literature in statistics, remains a persistent problem plaguing scientific research. If that is not enough to worry you, there is a special reason to distrust the results that you get on subsequent evaluations. Recall that our analysis of test set performance rested on the assumption that the classifier was chosen absent any contact with the test set and thus we could view the test set as drawn randomly from the underlying population. Here, not only are you testing multiple functions, the subsequent function ùëì2 was chosen after you observed the test set performance of ùëì1. Once information from the test set has leaked to the modeler, it can never be a true test set again in the strictest sense. This problem is called adaptive overfitting and has recently emerged as a topic of intense interest to learning theorists and statisticians (Dwork et al., 2015). Fortunately, while it is possible to leak all information out of a holdout set, and the theoretical worst case scenarios are bleak, these analyses may be too conservative. In practice, take care to create real test sets, to consult them as infrequently as possible, to account for multiple hypothesis testing when reporting confidence intervals, and to dial up your vigilance more aggressively when the stakes are high and your dataset size is small. When running a series of benchmark challenges, it is often good practice to maintain several test sets so that after each round, the old test set can be demoted to a validation set. 4.6.3 Statistical Learning Theory
Put simply, test sets are all that we really have, and yet this fact seems strangely unsatisfy- ing. First, we seldom possess a true test set‚Äîunless we are the ones creating the dataset, someone else has probably already evaluated their own classifier on our ostensible ‚Äútest set‚Äù. And even when we have first dibs, we soon find ourselves frustrated, wishing we could evaluate our subsequent modeling attempts without the gnawing feeling that we can- not trust our numbers. Moreover, even a true test set can only tell us post hoc whether a classifier has in fact generalized to the population, not whether we have any reason to expect a priori that it should generalize. With these misgivings in mind, you might now be sufficiently primed to see the appeal of statistical learning theory, the mathematical subfield of machine learning whose practi- tioners aim to elucidate the fundamental principles that explain why/when models trained on empirical data can/will generalize to unseen data. One of the primary aims of statistical learning researchers has been to bound the generalization gap, relating the properties of the model class to the number of samples in the dataset. Learning theorists aim to bound the difference between the empirical error ùúñS‚Äû ùëìS‚Äù of a
learned classifier ùëìS, both trained and evaluated on the training set S, and the true error ùúñ‚Äû ùëìS‚Äù of that same classifier on the underlying population. This might look similar to the evaluation problem that we just addressed but there is a major difference. Earlier, the
Linear Neural Networks for ClassiÔ¨Åcation
152

classifier ùëì was fixed and we only needed a dataset for evaluative purposes. And indeed,
any fixed classifier does generalize: its error on a (previously unseen) dataset is an unbiased estimate of the population error. But what can we say when a classifier is trained and evaluated on the same dataset? Can we ever be confident that the training error will be close to the testing error? Suppose that our learned classifier ùëìS must be chosen from some pre-specified set of func-
tions F. Recall from our discussion of test sets that while it is easy to estimate the error of a single classifier, things get hairy when we begin to consider collections of classifiers. Even if the empirical error of any one (fixed) classifier will be close to its true error with high probability, once we consider a collection of classifiers, we need to worry about the possi- bility that just one of them will receive a badly estimated error. The worry is that we might pick such a classifier and thereby grossly underestimate the population error. Moreover, even for linear models, because their parameters are continuously valued, we are typically choosing from an infinite class of functions (jF j = 1). One ambitious solution to the problem is to develop analytic tools for proving uniform convergence, i.e., that with high probability, the empirical error rate for every classifier in the class f ‚Ç¨ F will simultaneously converge to its true error rate. In other words, we seek a theoretical principle that would allow us to state that with probability at least 1 ‚Äî 6 (for some small 5) no classifier‚Äôs error rate e(f) (among all classifiers in the class F) will be misestimated by more than some small amount a. Clearly, we cannot make such statements for all model classes F. Recall the class of memorization machines that always achieve empirical error 0 but never outperform random guessing on the underlying population. In a sense the class of memorizers is too flexible. No such a uniform convergence result couldpossiblyhold. Ontheotherhand, afixedclassifierisuseless‚Äîitgeneralizesperfectly, but fits neither the training data nor the test data. The central question of learning has thus historically been framed as a trade-off between more flexible (higher variance) model classes that better fit the training data but risk overfitting, versus more rigid (higher bias) model classes that generalize well but risk underfitting. A central question in learning theoryhasbeentodeveloptheappropriatemathematicalanalysistoquantifywhereamodel sits along this spectrum, and to provide the associated guarantees. In a series of seminal papers, Vapnik and Chervonenkis extended the theory on the con- vergence of relative frequencies to more general classes of functions (Vapnik and Cher- vonenkis, 1964, Vapnik and Chervonenkis, 1968, Vapnik and Chervonenkis, 1971, Vap- nik and Chervonenkis, 1981, Vapnik and Chervonenkis, 1991, Vapnik and Chervonenkis, 1974). One of the key contributions of this line of work is the Vapnik‚ÄìChervonenkis (VC) dimension, which measures (one notion of) the complexity (flexibility) of a model class. Moreover, one of their key results bounds the difference between the empirical error and the population error as a function of the VC dimension and the number of samples:
P(R[p, f] ‚Äî Remp[X, Y, f] < a) > 1-6 for a > cy(VC ‚Äî log 6)/n. (4.6.4)
Here ùõø > 0 is the probability that the bound is violated, ùõº is the upper bound on the
generalization gap, and ùëõ is the dataset size. Lastly, ùëê > 0 is a constant that depends only
p
(4.6.4)
Generalization in ClassiÔ¨Åcation
153

on the scale of the loss that can be incurred. One use of the bound might be to plug in desired values of 5 and a to determine how many samples to collect. The VC dimension quantifies the largest number of data points for which we can assign any arbitrary (binary) labeling and for each find some model f in the class that agrees with that labeling. For example, linear models on d-dimensional inputs have VC dimension d + 1. It is easy to see that a line can assign any possible labeling to three points in two dimensions, but not to four. Unfortunately, the theory tends to be overly pessimistic for more complex models and obtaining this guarantee typically requires far more examples than are actually needed to achieve the desired error rate. Note also that fixing the model class and 6, our error rate again decays with the usual O(1/-/n) rate. It seems unlikely that we could do better in terms of n. However, as we vary the model class, VC dimension can present a pessimistic picture of the generalization gap. 4.6.4 Summary
The most straightforward way to evaluate a model is to consult a test set comprised of pre- viously unseen data. Test set evaluations provide an unbiased estimate of the true error and converge at the desired O(1/-yn) rate as the test set grows. We can provide approx- imate confidence intervals based on exact asymptotic distributions or valid finite sample confidence intervals based on (more conservative) finite sample guarantees. Indeed test set evaluation is the bedrock of modern machine learning research. However, test sets are seldom true test sets (used by multiple researchers again and again). Once the same test set is used to evaluate multiple models, controlling for false discovery can be difficult. This can cause huge problems in theory. In practice, the significance of the problem depends on the size of the holdout sets in question and whether they are merely being used to choose hyperparameters or if they are leaking information more directly. Nevertheless, it is good practice to curate real test sets (or multiple) and to be as conservative as possible about how often they are used. Hoping to provide a more satisfying solution, statistical learning theorists have developed methods for guaranteeing uniform convergence over a model class. If indeed every model‚Äôs empirical error simultaneously converges to its true error, then we are free to choose the model that performs best, minimizing the training error, knowing that it too will perform similarly well on the holdout data. Crucially, any one of such results must depend on some property of the model class. Vladimir Vapnik and Alexey Chernovenkis introduced the VC dimension, presenting uniform convergence results that hold for all models in a VC class. The training errors for all models in the class are (simultaneously) guaranteed to be close to their true errors, and guaranteed to grow even closer at O(1/-/n) rates. Following the revolutionary discovery of VC dimension, numerous alternative complexity measures have been proposed, each facilitating an analogous generalization guarantee. See Boucheron et al. (2005) for a detailed discussion of several advanced ways of measuring function complexity. Unfortunately, while these complexity measures have become broadly useful tools in statistical theory, they turn out to be powerless (as straightforwardly applied) for explaining why deep neural networks generalize. Deep neural networks often have millions of parameters (or more), and can easily assign random labels to large collections of points. Nevertheless, they generalize well on practical problems and, surprisingly, they often gen-
Linear Neural Networks for ClassiÔ¨Åcation
154

eralize better, when they are larger and deeper, despite incurring higher VC dimensions. In the next chapter, we will revisit generalization in the context of deep learning.bubu4.6.5 Exercises
1. If we wish to estimate the error of a fixed model ùëì to within 0.0001 with probability
greater than 99.9%, how many samples do we need? 2. Suppose that somebody else possesses a labeled test set D and only makes available the unlabeled inputs (features). Now suppose that you can only access the test set labels by running a model ùëì (with no restrictions placed on the model class) on each of the un- labeled inputs and receiving the corresponding error ùúñD‚Äû ùëì‚Äù. How many models would you need to evaluate before you leak the entire test set and thus could appear to have error 0, regardless of your true error? 3. What is the VC dimension of the class of fifth-order polynomials? 4. What is the VC dimension of axis-aligned rectangles on two-dimensional data? 100
Discussions100. 4.7 Environment and Distribution Shift
a
In the previous sections, we worked through a number of hands-on applications of machine learning, fitting models to a variety of datasets. And yet, we never stopped to contemplate either where data came from in the first place or what we ultimately plan to do with the outputs from our models. Too often, machine learning developers in possession of data rush to develop models without pausing to consider these fundamental issues. Many failed machine learning deployments can be traced back to this failure. Sometimes models appear to perform marvelously as measured by test set accuracy but fail catastroph- ically in deployment when the distribution of data suddenly shifts. More insidiously, some- times the very deployment of a model can be the catalyst that perturbs the data distribution. Say, for example, that we trained a model to predict who will repay rather than default on a loan, finding that an applicant‚Äôs choice of footwear was associated with the risk of default (Oxfords indicate repayment, sneakers indicate default). We might be inclined thereafter to grant a loan to any applicant wearing Oxfords and to deny all applicants wearing sneak- ers. In this case, our ill-considered leap from pattern recognition to decision-making and our failure to critically consider the environment might have disastrous consequences. For starters, as soon as we began making decisions based on footwear, customers would catch on and change their behavior. Before long, all applicants would be wearing Oxfords, with- out any coincident improvement in credit-worthiness. Take a minute to digest this because
Environment and Distribution Shift
155

similar issues abound in many applications of machine learning: by introducing our model- based decisions to the environment, we might break the model. Whilewecannotpossiblygivethesetopicsacompletetreatmentinonesection, weaimhere to expose some common concerns, and to stimulate the critical thinking required to detect such situations early, mitigate damage, and use machine learning responsibly. Some of the solutions are simple (ask for the ‚Äúright‚Äù data), some are technically difficult (implement a reinforcement learning system), and others require that we step outside the realm of sta- tistical prediction altogether and grapple with difficult philosophical questions concerning the ethical application of algorithms. 4.7.1 Types of Distribution Shift
To begin, we stick with the passive prediction setting considering the various ways that data distributionsmightshiftandwhatmightbedonetosalvagemodelperformance. Inoneclas- sic setup, we assume that our training data was sampled from some distribution ùëùùëÜ‚Äûx, ùë¶‚Äù but that our test data will consist of unlabeled examples drawn from some different distri- bution ùëùùëá‚Äûx, ùë¶‚Äù. Already, we must confront a sobering reality. Absent any assumptions on how ùëùùëÜ and ùëùùëá relate to each other, learning a robust classifier is impossible. Consider a binary classification problem, where we wish to distinguish between dogs and cats. If the distribution can shift in arbitrary ways, then our setup permits the pathological case in which the distribution over inputs remains constant: ps(x) = pr(x), but the labels are all flipped: ps(y | x) = 1- pr(y | x). In other words, if God can suddenly decide that in the future all ‚Äúcats‚Äù are now dogs and what we previously called ‚Äúdogs‚Äù are now cats‚Äî without any change in the distribution of inputs p(x), then we cannot possibly distinguish this setting from one in which the distribution did not change at all. Fortunately, undersomerestrictedassumptionsonthewaysourdatamightchangeinthefu- ture, principled algorithms can detect shift and sometimes even adapt on the fly, improving on the accuracy of the original classifier. Covariate Shift
Among categories of distribution shift, covariate shift may be the most widely studied. Here, we assume that while the distribution of inputs may change over time, the labeling function, i.e., the conditional distribution ùëÉ‚Äûùë¶ j x‚Äù does not change. Statisticians call this covariate shift because the problem arises due to a shift in the distribution of the covari- ates (features). While we can sometimes reason about distribution shift without invoking causality, we note that covariate shift is the natural assumption to invoke in settings where we believe that x causes ùë¶. Consider the challenge of distinguishing cats and dogs.bubuOur training data might consist of images of the kind in Fig. 4.7.1. At test time we are asked to classify the images in Fig. 4.7.2. The training set consists of photos, while the test set contains only cartoons. Training on a
Linear Neural Networks for ClassiÔ¨Åcation
156

cat cat dog dog
tFig. 4.7.1
Training data for distinguishing cats and dogs (illustrations: Lafeez Hossain / 500px / Getty Images; ilkermetinkursova / iStock / Getty Images Plus; GlobalP / iStock / Getty Images Plus; Musthafa Aboobakuru / 500px / Getty Images). cat cat dog dog WE
tFig. 4.7.2
Test data for distinguishing cats and dogs (illustrations: SIBAS_minich / iStock / Getty Images Plus; Ghrzuzudu / iStock / Getty Images Plus; id-work / DigitalVision Vectors / Getty Images; Yime / iStock / Getty Images Plus). dataset with substantially different characteristics from the test set can spell trouble absent a coherent plan for how to adapt to the new domain. Label shift describes the converse problem. Here, we assume that the label marginal ùëÉ‚Äûùë¶‚Äù
can change but the class-conditional distribution ùëÉ‚Äûx j ùë¶‚Äù remains fixed across domains. Label shift is a reasonable assumption to make when we believe that ùë¶ causes x. For ex- ample, we may want to predict diagnoses given their symptoms (or other manifestations), even as the relative prevalence of diagnoses are changing over time. Label shift is the ap- propriate assumption here because diseases cause symptoms. In some degenerate cases the label shift and covariate shift assumptions can hold simultaneously. For example, when the label is deterministic, the covariate shift assumption will be satisfied, even when ùë¶ causes x. Interestingly, in these cases, it is often advantageous to work with methods that flow from the label shift assumption. That is because these methods tend to involve manipulat- ing objects that look like labels (often low-dimensional), as opposed to objects that look like inputs, which tend to be high-dimensional in deep learning. Label Shift
Environment and Distribution Shift
157

Concept Shift
We may also encounter the related problem of concept shift, which arises when the very definitions of labels can change. This sounds weird‚Äîa cat is a cat, no? However, other categories are subject to changes in usage over time. Diagnostic criteria for mental illness, what passes for fashionable, and job titles, are all subject to considerable amounts of con- cept shift. It turns out that if we navigate around the United States, shifting the source of our data by geography, we will find considerable concept shift regarding the distribution of names for soft drinks as shown in Fig. 4.7.3. (CO-BY- Alan McConchie, PopVsSoda.com
tFig. 4.7.3
Concept shift for soft drink names in the United States (CC-BY: Alan McConchie, PopVsSoda.com). If we were to build a machine translation system, the distribution ùëÉ‚Äûùë¶ j x‚Äù might be dif-
ferent depending on our location. This problem can be tricky to spot. We might hope to exploit knowledge that shift only takes place gradually either in a temporal or geographic sense. 4.7.2 Examples of Distribution Shift
Before delving into formalism and algorithms, we can discuss some concrete situations where covariate or concept shift might not be obvious. Medical Diagnostics
Imaginethatyouwanttodesignanalgorithmtodetectcancer.bubuYoucollectdatafromhealthy and sick people and you train your algorithm. It works fine, giving you high accuracy and you conclude that you are ready for a successful career in medical diagnostics. Not so fast. The distributions that gave rise to the training data and those you will encounter in the wild
Linear Neural Networks for ClassiÔ¨Åcation
158

might differ considerably. This happened to an unfortunate startup that some of we authors worked with years ago. They were developing a blood test for a disease that predominantly affects older men and hoped to study it using blood samples that they had collected from patients. However, it is considerably more difficult to obtain blood samples from healthy men than from sick patients already in the system. To compensate, the startup solicited blood donations from students on a university campus to serve as healthy controls in de- veloping their test. Then they asked whether we could help them to build a classifier for detecting the disease. As we explained to them, it would indeed be easy to distinguish between the healthy and sick cohorts with near-perfect accuracy. However, that is because the test subjects differed in age, hormone levels, physical activity, diet, alcohol consumption, and many more fac- tors unrelated to the disease. This was unlikely to be the case with real patients. Due to their sampling procedure, we could expect to encounter extreme covariate shift. Moreover, this case was unlikely to be correctable via conventional methods. In short, they wasted a significant sum of money. Self-Driving Cars
Say a company wanted to leverage machine learning for developing self-driving cars. One key component here is a roadside detector. Since real annotated data is expensive to get, they had the (smart and questionable) idea to use synthetic data from a game rendering engine as additional training data. This worked really well on ‚Äútest data‚Äù drawn from the rendering engine. Alas, inside a real car it was a disaster. As it turned out, the roadside had been rendered with a very simplistic texture. More importantly, all the roadside had been rendered with the same texture and the roadside detector learned about this ‚Äúfeature‚Äù very quickly. A similar thing happened to the US Army when they first tried to detect tanks in the forest. They took aerial photographs of the forest without tanks, then drove the tanks into the forest and took another set of pictures. The classifier appeared to work perfectly. Unfortunately, it had merely learned how to distinguish trees with shadows from trees without shadows‚Äîthe first set of pictures was taken in the early morning, the second set at noon. Nonstationary Distributions
A much more subtle situation arises when the distribution changes slowly (also known as nonstationary distribution) and the model is not updated adequately. Below are some typical cases.bubue We train a computational advertising model and then fail to update it frequently (e.g., we
forget to incorporate that an obscure new device called an iPad was just launched). e We build a spam filter. It works well at detecting all spam that we have seen so far. But
then the spammers wise up and craft new messages that look unlike anything we have seen before. Environment and Distribution Shift
159

We build a product recommendation system. It works throughout the winter but then
continues to recommend Santa hats long after Christmas. More Anecdotes
We build a face detector.bubuIt works well on all benchmarks. Unfortunately it fails on test
data‚Äîthe offending examples are close-ups where the face fills the entire image (no such data was in the training set). We build a web search engine for the US market and want to deploy it in the UK. We train an image classifier by compiling a large dataset where each among a large set
of classes is equally represented in the dataset, say 1000 categories, represented by 1000 images each. Then we deploy the system in the real world, where the actual label distribution of photographs is decidedly non-uniform. 4.7.3 Correction of Distribution Shift
As we have discussed, there are many cases where training and test distributions ùëÉ‚Äûx, ùë¶‚Äù
are different. In some cases, we get lucky and the models work despite covariate, label, or concept shift. In other cases, we can do better by employing principled strategies to cope with the shift. The remainder of this section grows considerably more technical.bubuThe impatient reader could continue on to the next section as this material is not prerequisite to subsequent concepts. Empirical Risk and Risk
Let‚Äôs first reflect on what exactly is happening during model training: we iterate over fea- tures and associated labels of training data f‚Äûx1, ùë¶1‚Äù, . . ., ‚Äûxùëõ, ùë¶ùëõ‚Äùg and update the param- eters of a model ùëì after every minibatch. For simplicity we do not consider regularization, so we largely minimize the loss on the training:
minimize ùëì 1 ùëõ ùëñ=1 ùëô‚Äû ùëì ‚Äûxùëñ‚Äù, ùë¶ùëñ‚Äù, (4.7.1)
where ùëô is the loss function measuring ‚Äúhow bad‚Äù the prediction ùëì ‚Äûxùëñ‚Äù is given the associ-
ated label ùë¶ùëñ. Statisticians call the term in (4.7.1) empirical risk. The empirical risk is an average loss over the training data for approximating the risk, which is the expectation of the loss over the entire population of data drawn from their true distribution ùëù‚Äûx, ùë¶‚Äù:
ùê∏ùëù‚Äûx,ùë¶‚Äù¬ªùëô‚Äû ùëì ‚Äûx‚Äù, ùë¶‚Äù‚Ä¶ = ùëô‚Äû ùëì ‚Äûx‚Äù, ùë¶‚Äùùëù‚Äûx, ùë¶‚Äù ùëëxùëëùë¶. (4.7.2)
However, in practice we typically cannot obtain the entire population of data. Thus, em- pirical risk minimization, which is minimizing the empirical risk in (4.7.1), is a practical strategy for machine learning, with the hope of approximately minimizing the risk. ‚Äû ‚Äû
Linear Neural Networks for ClassiÔ¨Åcation
160

Covariate Shift Correction
Assume that we want to estimate some dependency ùëÉ‚Äûùë¶ j x‚Äù for which we have labeled data
‚Äûxùëñ, ùë¶ùëñ‚Äù. Unfortunately, the observations xùëñ are drawn from some source distribution ùëû‚Äûx‚Äù rather than the target distribution ùëù‚Äûx‚Äù. Fortunately, the dependency assumption means that the conditional distribution does not change: ùëù‚Äûùë¶ j x‚Äù = ùëû‚Äûùë¶ j x‚Äù. If the source distribution ùëû‚Äûx‚Äù is ‚Äúwrong‚Äù, we can correct for that by using the following simple identity in the risk:
‚Äû ‚Äû
ùëô‚Äû ùëì ‚Äûx‚Äù, ùë¶‚Äùùëù‚Äûùë¶ j x‚Äùùëù‚Äûx‚Äù ùëëxùëëùë¶ = ùëô‚Äû ùëì ‚Äûx‚Äù, ùë¶‚Äùùëû‚Äûùë¶ j x‚Äùùëû‚Äûx‚Äù ùëù‚Äûx‚Äù ùëû‚Äûx‚Äù ùëëxùëëùë¶. In other words, we need to reweigh each data example by the ratio of the probability that it would have been drawn from the correct distribution to that from the wrong one:
ùõΩùëñ def = ùëû‚Äûxùëñ‚Äù . (4.7.4)
Plugging in the weight ùõΩùëñ for each data example ‚Äûxùëñ, ùë¶ùëñ‚Äù we can train our model using
weighted empirical risk minimization:
minimize ùëì 1 ùëõ ùëñ=1 ùõΩùëñùëô‚Äû ùëì ‚Äûxùëñ‚Äù, ùë¶ùëñ‚Äù. (4.7.5)
Alas, we do not know that ratio, so before we can do anything useful we need to estimate it. Many methods are available, including some fancy operator-theoretic approaches that attempt to recalibrate the expectation operator directly using a minimum-norm or a maxi- mum entropy principle. Note that for any such approach, we need samples drawn from both distributions‚Äîthe ‚Äútrue‚Äù p, e.g., by access to test data, and the one used for generating the training set qg (the latter is trivially available). Note however, that we only need features x ~ p(x); we do not need to access labels y ~ p(y). In this case, there exists a very effective approach that will give almost as good results as the original: namely, logistic regression, which is a special case of softmax regression (see Section 4.1) for binary classification. This is all that is needed to compute estimated probability ratios. We learn a classifier to distinguish between data drawn from ùëù‚Äûx‚Äù and data drawn from ùëû‚Äûx‚Äù. If it is impossible to distinguish between the two distributions then it means that the associated instances are equally likely to come from either one of those two distributions. On the other hand, any instances that can be well discriminated should be significantly overweighted or underweighted accordingly. For simplicity‚Äôs sake assume that we have an equal number of instances from both distribu- tions p(x) and q(x), respectively. Now denote by z labels that are 1 for data drawn from p and ‚Äî1 for data drawn from q. Then the probability in a mixed dataset is given by
P(z=1|x) _ p(x) and hence ‚Äî‚Äî__‚Äî = ‚Äî_.. P(z=-1|x) q(x) P(g =1 |x) = 2 - 5) +4) (4.7.6)
Thus, if we use a logistic regression approach, where ùëÉ‚Äûùëß = 1 j x‚Äù =
‚Äû ‚Äû
(4.7.3)
ùëù‚Äûxùëñ‚Äù
EEC (hisa
1
Environment and Distribution Shift
161

parametrized function), it follows that
1/(1 + exp(-h(x;)))
_ 1/(1 + exp(-h(x;))) ~ exp(‚Äîh(x;))/(1 + exp(-hQa))) Bi = exp(h(x;)). (4.7.7)
As a result, we need to solve two problems: the first, to distinguish between data drawn frombothdistributions, andthenaweightedempiricalriskminimizationproblemin(4.7.5) where we weigh terms by ùõΩùëñ. Now we are ready to describe a correction algorithm. Suppose that we have a training set {(X1,¬•1),---¬ª (Xn, Yn)} and an unlabeled test set {uj,..., Um}. For covariate shift, we assume that x; for all 1 < i < n are drawn from some source distribution and u; for all 1 <i < mare drawn from the target distribution. Here is a prototypical algorithm for correcting covariate shift:
1. Create a binary-classification training set: {(x1,-1),...,(Xn,-1), (ur, L),..-, (um, 1)}-
2. Train a binary classifier using logistic regression to get the function ‚Ñé. 3. Weigh training data using ùõΩùëñ = exp‚Äû‚Ñé‚Äûxùëñ‚Äù‚Äù or better ùõΩùëñ = min‚Äûexp‚Äû‚Ñé‚Äûxùëñ‚Äù‚Äù, ùëê‚Äù for some
constant ùëê. 4. Use weights ùõΩùëñ for training on f‚Äûx1, ùë¶1‚Äù, . .bubu., ‚Äûxùëõ, ùë¶ùëõ‚Äùg in (4.7.5). Note that the above algorithm relies on a crucial assumption. For this scheme to work, we need that each data example in the target (e.g., test time) distribution had nonzero proba- bility of occurring at training time. If we find a point where ùëù‚Äûx‚Äù > 0 but ùëû‚Äûx‚Äù = 0, then the corresponding importance weight should be infinity. Label Shift Correction
Assume that we are dealing with a classification task with ùëò categories. Using the same
notation in Section 4.7.3, ùëû and ùëù are the source distribution (e.g., training time) and target distribution (e.g., test time), respectively. Assume that the distribution of labels shifts over time: ùëû‚Äûùë¶‚Äù ‚â† ùëù‚Äûùë¶‚Äù, but the class-conditional distribution stays the same: ùëû‚Äûx j ùë¶‚Äù = ùëù‚Äûx j ùë¶‚Äù. If the source distribution ùëû‚Äûùë¶‚Äù is ‚Äúwrong‚Äù, we can correct for that according to the following identity in the risk as defined in (4.7.2):
‚Äû ‚Äû
ùëô‚Äû ùëì ‚Äûx‚Äù, ùë¶‚Äùùëù‚Äûx j ùë¶‚Äùùëù‚Äûùë¶‚Äù ùëëxùëëùë¶ = ùëô‚Äû ùëì ‚Äûx‚Äù, ùë¶‚Äùùëû‚Äûx j ùë¶‚Äùùëû‚Äûùë¶‚Äù ùëù‚Äûùë¶‚Äù ùëû‚Äûùë¶‚Äù ùëëxùëëùë¶. Here, our importance weights will correspond to the label likelihood ratios:
ùõΩùëñ def = ùëû‚Äûùë¶ùëñ‚Äù . (4.7.9)
One nice thing about label shift is that if we have a reasonably good model on the source distribution, then we can get consistent estimates of these weights without ever having to deal with the ambient dimension. In deep learning, the inputs tend to be high-dimensional objects like images, while the labels are often simpler objects like categories. To estimate the target label distribution, we first take our reasonably good off-the-shelf
‚Äû ‚Äû
(4.7.8)
ùëù‚Äûùë¶ùëñ‚Äù
Linear Neural Networks for ClassiÔ¨Åcation
162

classifier (typically trained on the training data) and compute its ‚Äúconfusion‚Äù matrix using the validation set (also from the training distribution). The confusion matrix, C, is simply a k Xk matrix, where each column corresponds to the label category (ground truth) and each row corresponds to our model‚Äôs predicted category. Each cell‚Äôs value c;; is the fraction of total predictions on the validation set where the true label was j and our model predicted lL. Now, we cannot calculate the confusion matrix on the target data directly because we do not get to see the labels for the examples that we see in the wild, unless we invest in a complex real-time annotation pipeline. What we can do, however, is average all of our model‚Äôs predictions at test time together, yielding the mean model outputs ùúá‚ÄûÀÜy‚Äù 2 Rùëò, where the ùëñth element ùúá‚ÄûÀÜùë¶ùëñ‚Äù is the fraction of the total predictions on the test set where our model predicted ùëñ. It turns out that under some mild conditions‚Äîif our classifier was reasonably accurate in the first place, and if the target data contains only categories that we have seen before, and if the label shift assumption holds in the first place (the strongest assumption here)‚Äîwe can estimate the test set label distribution by solving a simple linear system
Cùëù‚Äûy‚Äù = ùúá‚ÄûÀÜy‚Äù,
(4.7.10)
Àùùëò
cijp(yj) = ‚Äú(Si) holds for all 1 < i < k, where p(y;) is
because as an estimate wa cijp(yj) = ‚Äú(Si) holds for all 1 < i < k, where p(y;) is the j" element of the k-dimensional label distribution vector p(y). If our classifier is sufficiently accurate to begin with, then the confusion matrix C will be invertible, and we get a solution p(y) = C7! u(¬•). Because we observe the labels on the source data, it is easy to estimate the distribution q(y). Then, for any training example i with label y;, we can take the ratio of our esti- mated p(y;)/q(y;) to calculate the weight 8;, and plug this into weighted empirical risk minimization in (4.7.5). Concept Shift Correction
Conceptshiftismuchhardertofixinaprincipledmanner. Forinstance, inasituationwhere suddenly the problem changes from distinguishing cats from dogs to one of distinguishing white from black animals, it will be unreasonable to assume that we can do much better than just collecting new labels and training from scratch. Fortunately, in practice, such extreme shifts are rare. Instead, what usually happens is that the task keeps on changing slowly. To make things more concrete, here are some examples:
e Incomputational advertising, new products are launched, old products become less pop-
ular. This means that the distribution over ads and their popularity changes gradually and any click-through rate predictor needs to change gradually with it. e Traffic camera lenses degrade gradually due to environmental wear, affecting image
quality progressively. e News content changes gradually (i.e., most of the news remains unchanged but new sto-
ries appear). Environment and Distribution Shift
163

In such cases, we can use the same approach that we used for training networks to make them adapt to the change in the data. In other words, we use the existing network weights andsimplyperformafewupdatestepswiththenewdataratherthantrainingfromscratch. 4.7.4 A Taxonomy of Learning Problems
Armed with knowledge about how to deal with changes in distributions, we can now con- sider some other aspects of machine learning problem formulation. Batch Learning
In batch learning, we have access to training features and labels f‚Äûx1, ùë¶1‚Äù, . .bubu., ‚Äûxùëõ, ùë¶ùëõ‚Äùg,
whichweuse totrain a model ùëì ‚Äûx‚Äù. Later on, wedeploy this model toscore newdata ‚Äûx, ùë¶‚Äù drawn from the same distribution. This is the default assumption for any of the problems that we discuss here. For instance, we might train a cat detector based on lots of pictures of cats and dogs. Once we have trained it, we ship it as part of a smart catdoor computer vision system that lets only cats in. This is then installed in a customer‚Äôs home and is never updated again (barring extreme circumstances). Online Learning
Now imagine that the data ‚Äûxùëñ, ùë¶ùëñ‚Äù arrives one sample at a time. More specifically, assume
that we first observe xùëñ, then we need to come up with an estimate ùëì ‚Äûxùëñ‚Äù. Only once we have done this do we observe ùë¶ùëñ and so receive a reward or incur a loss, given our decision. Many real problems fall into this category. For example, we need to predict tomorrow‚Äôs stock price, which allows us to trade based on that estimate and at the end of the day we find out whether our estimate made us a profit. In other words, in online learning, we have the following cycle where we are continuously improving our model given new observations:
model f; ‚Äî> data x, ‚Äî> estimate f;(x;) ‚Äî (4.7.11) observation y, ‚Äî loss I(yr, f¬¢(x1)) ‚Äî> model fr+1 i
Bandits are a special case of the problem above. While in most learning problems we have a continuously parametrized function ùëì where we want to learn its parameters (e.g., a deep network), in a bandit problem we only have a finite number of arms that we can pull, i.e., a finite number of actions that we can take. It is not very surprising that for this simpler problem stronger theoretical guarantees in terms of optimality can be obtained. We list it mainly since this problem is often (confusingly) treated as if it were a distinct learning setting. Bandits
Linear Neural Networks for ClassiÔ¨Åcation
164

In many cases the environment remembers what we did. Not necessarily in an adversarial manner but it will just remember and the response will depend on what happened before. For instance, a coffee boiler controller will observe different temperatures depending on whether it was heating the boiler previously. PID (proportional-integral-derivative) con- troller algorithms are a popular choice there. Likewise, a user‚Äôs behavior on a news site will depend on what we showed them previously (e.g., they will read most news only once). Many such algorithms form a model of the environment in which they act so as to make their decisions appear less random. Recently, control theory (e.g., PID variants) has also been used to automatically tune hyperparameters to achieve better disentangling and recon- struction quality, and improve the diversity of generated text and the reconstruction quality of generated images (Shao et al., 2020). Reinforcement Learning
In the more general case of an environment with memory, we may encounter situations where the environment is trying to cooperate with us (cooperative games, in particular for non-zero-sum games), or others where the environment will try to win. Chess, Go, Backgammon, or StarCraft are some of the cases in reinforcement learning. Likewise, we might want to build a good controller for autonomous cars. Other cars are likely to respond to the autonomous car‚Äôs driving style in nontrivial ways, e.g., trying to avoid it, trying to cause an accident, or trying to cooperate with it. Considering the Environment
One key distinction between the different situations above is that a strategy that might have worked throughout in the case of a stationary environment, might not work throughout in an environment that can adapt. For instance, an arbitrage opportunity discovered by a trader is likely to disappear once it is exploited. The speed and manner at which the environment changes determines to a large extent the type of algorithms that we can bring to bear. For instance, if we know that things may only change slowly, we can force any estimate to change only slowly, too. If we know that the environment might change instantaneously, but only very infrequently, we can make allowances for that. These types of knowledge are crucial for the aspiring data scientist in dealing with concept shift, i.e., when the problem that is being solved can change over time. 4.7.5 Fairness, Accountability, and Transparency in Machine Learning
Finally, it is important to remember that when you deploy machine learning systems you are not merely optimizing a predictive model‚Äîyou are typically providing a tool that will be used to (partially or fully) automate decisions. These technical systems can impact the lives of individuals who are subject to the resulting decisions. The leap from considering predictions to making decisions raises not only new technical questions, but also a slew of
Control
Environment and Distribution Shift
165

ethical questions that must be carefully considered. If we are deploying a medical diagnos- tic system, we need to know for which populations it may work and for which it may not. Overlooking foreseeable risks to the welfare of a subpopulation could cause us to adminis- ter inferior care. Moreover, once we contemplate decision-making systems, we must step back and reconsider how we evaluate our technology. Among other consequences of this change of scope, we will find that accuracy is seldom the right measure. For instance, when translatingpredictionsintoactions, wewilloftenwanttotakeintoaccountthepotentialcost sensitivity of erring in various ways. If one way of misclassifying an image could be per- ceived as a racial sleight of hand, while misclassification to a different category would be harmless, then we might want to adjust our thresholds accordingly, accounting for societal values in designing the decision-making protocol. We also want to be careful about how prediction systems can lead to feedback loops. For example, consider predictive policing systems, which allocate patrol officers to areas with high forecasted crime. It is easy to see how a worrying pattern can emerge:
1. Neighborhoods with more crime get more patrols. 2. Consequently, more crimes are discovered in these neighborhoods, entering the training data available for future iterations. 3. Exposed to more positives, the model predicts yet more crime in these neighborhoods. 4. In the next iteration, the updated model targets the same neighborhood even more heav- ily leading to yet more crimes discovered, etc. Often, the various mechanisms by which a model‚Äôs predictions become coupled to its train- ing data are unaccounted for in the modeling process. This can lead to what researchers call runaway feedback loops. Additionally, we want to be careful about whether we are addressing the right problem in the first place. Predictive algorithms now play an outsize role in mediating the dissemination of information. Should the news that an individual en- counters be determined by the set of Facebook pages they have Liked? These are just a few among the many pressing ethical dilemmas that you might encounter in a career in machine learning. 4.7.6 Summary
In many cases training and test sets do not come from the same distribution. This is called distribution shift. The risk is the expectation of the loss over the entire population of data drawn from their true distribution. However, this entire population is usually unavailable. Empirical risk is an average loss over the training data to approximate the risk. In practice, we perform empirical risk minimization. Under the corresponding assumptions, covariate and label shift can be detected and cor- rected for at test time. Failure to account for this bias can become problematic at test time. Insomecases, theenvironmentmayrememberautomatedactionsandrespondinsurprising ways. We must account for this possibility when building models and continue to moni- tor live systems, open to the possibility that our models and the environment will become entangled in unanticipated ways. Linear Neural Networks for ClassiÔ¨Åcation
166

4.7.7 Exercises
1. What could happen when we change the behavior of a search engine? What might the users do? What about the advertisers? 2. Implement a covariate shift detector. Hint: build a classifier. 3. Implement a covariate shift corrector. 4. Besides distribution shift, what else could affect how the empirical risk approximates the risk? Discussions101. 101
5
Multilayer Perceptrons
In this chapter, we will introduce your first truly deep network. The simplest deep networks are called multilayer perceptrons, and they consist of multiple layers of neurons each fully connected to those in the layer below (from which they receive input) and those above (which they, in turn, influence). Although automatic differentiation significantly simplifies the implementation of deep learning algorithms, we will dive deep into how these gradi- ents are calculated in deep networks. Then we will be ready to discuss issues relating to numerical stability and parameter initialization that are key to successfully training deep networks. When we train such high-capacity models we run the risk of overfitting. Thus, we will revisit regularization and generalization for deep networks. Throughout, we aim to giveyouafirmgraspnotjustoftheconceptsbutalsoofthepracticeofusingdeepnetworks. At the end of this chapter, we apply what we have introduced so far to a real case: house price prediction. We punt matters relating to the computational performance, scalability, and efficiency of our models to subsequent chapters. 5.1 Multilayer Perceptrons
De
In Section 4.1, we introduced softmax regression, implementing the algorithm from scratch (Section4.4)andusinghigh-levelAPIs(Section4.5). Thisallowedustotrainclassifiersca- pable of recognizing 10 categories of clothing from low-resolution images. Along the way, we learned how to wrangle data, coerce our outputs into a valid probability distribution, apply an appropriate loss function, and minimize it with respect to our model‚Äôs parameters. Now that we have mastered these mechanics in the context of simple linear models, we can launch our exploration of deep neural networks, the comparatively rich class of models with which this book is primarily concerned. %matplotlib inline import torch from d2l import torch as d2l
5.1.1 Hidden Layers
We described affine transformations in Section 3.1.1 as linear transformations with added bias. To begin, recall the model architecture corresponding to our softmax regression ex-
167
Multilayer Perceptrons
168

ample, illustrated in Fig. 4.1.1. This model maps inputs directly to outputs via a single affine transformation, followed by a softmax operation. If our labels truly were related to the input data by a simple affine transformation, then this approach would be sufficient. However, linearity (in affine transformations) is a strong assumption. Limitations of Linear Models
For example, linearity implies the weaker assumption of monotonicity, i.e., that any in- crease in our feature must either always cause an increase in our model‚Äôs output (if the corresponding weight is positive), or always cause a decrease in our model‚Äôs output (if the corresponding weight is negative). Sometimes that makes sense. For example, if we were trying to predict whether an individual will repay a loan, we might reasonably assume that all other things being equal, an applicant with a higher income would always be more likely to repay than one with a lower income. While monotonic, this relationship likely is not linearly associated with the probability of repayment. An increase in income from $0 to $50,000 likely corresponds to a bigger increase in likelihood of repayment than an increase from $1 million to $1.05 million. One way to handle this might be to postprocess our outcome such that linearity becomes more plausible, by using the logistic map (and thus the logarithm of the probability of outcome). Note that we can easily come up with examples that violate monotonicity. Say for example that we want to predict health as a function of body temperature. For individuals with a normal body temperature above 37¬∞C (98.6¬∞F), higher temperatures indicate greater risk. However, if the body temperatures drops below 37¬∞C, lower temperatures indicate greater risk! Again, we might resolve the problem with some clever preprocessing, such as using the distance from 37¬∞C as a feature. But what about classifying images of cats and dogs? Should increasing the intensity of the pixel at location (13, 17) always increase (or always decrease) the likelihood that the image depicts a dog? Reliance on a linear model corresponds to the implicit assumption that the only requirement for differentiating cats and dogs is to assess the brightness of individual pixels. This approach is doomed to fail in a world where inverting an image preserves the category. And yet despite the apparent absurdity of linearity here, as compared with our previous examples, it is less obvious that we could address the problem with a simple preprocessing fix. That is, because the significance of any pixel depends in complex ways on its context (the values of the surrounding pixels). While there might exist a representation of our data that would take into account the relevant interactions among our features, on top of which a linear model would be suitable, we simply do not know how to calculate it by hand. With deep neural networks, we used observational data to jointly learn both a representation via hidden layers and a linear predictor that acts upon that representation. This problem of nonlinearity has been studied for at least a century (Fisher, 1925). For instance, decision trees in their most basic form use a sequence of binary decisions to de- cide upon class membership (Quinlan, 1993). Likewise, kernel methods have been used for many decades to model nonlinear dependencies (Aronszajn, 1950). This has found its
Multilayer Perceptrons
169

way into nonparametric spline models (Wahba, 1990) and kernel methods (Sch√∂lkopf and Smola, 2002). It is also something that the brain solves quite naturally. After all, neu- rons feed into other neurons which, in turn, feed into other neurons again (Ram√≥n y Cajal and Azoulay, 1894). Consequently we have a sequence of relatively simple transforma- tions. Incorporating Hidden Layers
We can overcome the limitations of linear models by incorporating one or more hidden layers. The easiest way to do this is to stack many fully connected layers on top of one another. Each layer feeds into the layer above it, until we generate outputs. We can think of the first L ‚Äî 1 layers as our representation and the final layer as our linear predictor. This architecture is commonly called a multilayer perceptron, often abbreviated as MLP (Fig. 5.1.1). Output layer Hidden layer Input layer
tFig. 5.1.1
An MLP with a hidden layer of Ô¨Åve hidden units. This MLP has four inputs, three outputs, and its hidden layer contains five hidden units. Since the input layer does not involve any calculations, producing outputs with this network requires implementing the computations for both the hidden and output layers; thus, the number of layers in this MLP is two. Note that both layers are fully connected. Every input influences every neuron in the hidden layer, and each of these in turn influences every neuron in the output layer. Alas, we are not quite done yet. From Linear to Nonlinear
As before, we denote by the matrix X ‚Ç¨ R‚Äù*¬¢ a minibatch of n examples where each exam-
As before, we denote by the matrix X ‚Ç¨ R‚Äù*¬¢ a minibatch of n examples where each exam- ple has d inputs (features). For a one-hidden-layer MLP whose hidden layer has h hidden units, we denote by H ‚Ç¨ R‚Äù*‚Äù the outputs of the hidden layer, which are hidden represen- tations. Since the hidden and output layers are both fully connected, we have hidden-layer weights W‚Äú) ‚Ç¨ R¬¢*" and biases b‚Äú) ‚Ç¨ R!*" and output-layer weights W ‚Ç¨ R‚Äô*4 and biases b) ‚Ç¨ R!*4. This allows us to calculate the outputs O ‚Ç¨ R‚Äù*4 of the one-hidden- layer MLP as follows:
H = XW‚Äû1‚Äù ‚Äö b‚Äû1‚Äù,
O = HW‚Äû2‚Äù ‚Äö b‚Äû2‚Äù. (5.1.1)
Note that after adding the hidden layer, our model now requires us to track and update additionalsetsofparameters. So whathavewegainedinexchange? Youmightbesurprised
Multilayer Perceptrons
170

to find out that‚Äîin the model defined above‚Äîwe gain nothing for our troubles! The reason isplain. Thehiddenunitsabovearegivenbyanaffinefunctionoftheinputs, andtheoutputs (pre-softmax) are just an affine function of the hidden units. An affine function of an affine function is itself an affine function. Moreover, our linear model was already capable of representing any affine function. Toseethisformallywecanjustcollapseoutthehiddenlayerintheabovedefinition,yielding an equivalent single-layer model with parameters W = W‚Äû1‚ÄùW‚Äû2‚Äù and b = b‚Äû1‚ÄùW‚Äû2‚Äù ‚Äö b‚Äû2‚Äù:
O = ‚ÄûXW‚Äû1‚Äù ‚Äö b‚Äû1‚Äù‚ÄùW‚Äû2‚Äù ‚Äö b‚Äû2‚Äù = XW‚Äû1‚ÄùW‚Äû2‚Äù ‚Äö b‚Äû1‚ÄùW‚Äû2‚Äù ‚Äö b‚Äû2‚Äù = XW ‚Äö b. (5.1.2)
In order to realize the potential of multilayer architectures, we need one more key ingre- dient: a nonlinear activation function o to be applied to each hidden unit following the affine transformation. For instance, a popular choice is the ReLU (rectified linear unit) ac- tivation function (Nair and Hinton, 2010) o(x) = max(0,x) operating on its arguments elementwise. The outputs of activation functions o-(-) are called activations. In general, with activation functions in place, it is no longer possible to collapse our MLP into a linear model:
H = ùúé‚ÄûXW‚Äû1‚Äù ‚Äö b‚Äû1‚Äù‚Äù, O = HW‚Äû2‚Äù ‚Äö b‚Äû2‚Äù. (5.1.3)
Since each row in X corresponds to an example in the minibatch, with some abuse of notation, we define the nonlinearity ùúé to apply to its inputs in a rowwise fashion, i.e., one example at a time. Note that we used the same notation for softmax when we denoted a rowwise operation in Section 4.1.1. Quite frequently the activation functions we use apply not merely rowwise but elementwise. That means that after computing the linear portion of the layer, we can calculate each activation without looking at the values taken by the other hidden units. To build more general MLPs, we can continue stacking such hidden layers, e.g., H‚Äû1‚Äù =
ùúé1‚ÄûXW‚Äû1‚Äù ‚Äöb‚Äû1‚Äù‚Äù and H‚Äû2‚Äù = ùúé2‚ÄûH‚Äû1‚ÄùW‚Äû2‚Äù ‚Äöb‚Äû2‚Äù‚Äù, one atop another, yielding ever more expressive models. Universal Approximators
We know that the brain is capable of very sophisticated statistical analysis. As such, it is worth asking, just how powerful a deep network could be. This question has been answered multiple times, e.g., in Cybenko (1989) in the context of MLPs, and in Micchelli (1984) in the context of reproducing kernel Hilbert spaces in a way that could be seen as radial basis function (RBF) networks with a single hidden layer. These (and related results) suggest that even with a single-hidden-layer network, given enough nodes (possibly absurdly many), and the right set of weights, we can model any function. Actually learning that function is the hard part, though. You might think of your neural network as being a bit like the C programming language. The language, like any other modern language, is capable of
Multilayer Perceptrons
171

expressing any computable program. But actually coming up with a program that meets your specifications is the hard part. Moreover, just because a single-hidden-layer network can learn any function does not mean that you should try to solve all of your problems with one. In fact, in this case kernel methods are way more effective, since they are capable of solving the problem exactly even in infinite dimensional spaces (Kimeldorf and Wahba, 1971, Sch√∂lkopf et al., 2001). In fact, we can approximate many functions much more compactly by using deeper (rather than wider) networks (Simonyan and Zisserman, 2014). We will touch upon more rigorous arguments in subsequent chapters. 5.1.2 Activation Functions
Activation functions decide whether a neuron should be activated or not by calculating the weighted sum and further adding bias to it. They are differentiable operators for trans- forming input signals to outputs, while most of them add nonlinearity. Because activation functions are fundamental to deep learning, let‚Äôs briefly survey some common ones. ReLU Function
The most popular choice, due to both simplicity of implementation and its good perfor- mance on a variety of predictive tasks, is the rectified linear unit (ReLU) (Nair and Hinton, 2010). ReLU provides a very simple nonlinear transformation. Given an element ùë•, the function is defined as the maximum of that element and 0:
ReLU‚Äûùë•‚Äù = max‚Äûùë•,0‚Äù. (5.1.4)
Informally, the ReLU function retains only positive elements and discards all negative el- ements by setting the corresponding activations to 0. To gain some intuition, we can plot the function. As you can see, the activation function is piecewise linear. x = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)
Puiu
y = torch.relu(x)
d2l.plot(x.detach(), y.detach(), 'x', 'relu(x)', figsize=(5, 2.5))
relu(x) 5
When the input is negative, the derivative of the ReLU function is 0, and when the input is positive, the derivative of the ReLU function is 1. Note that the ReLU function is not
Multilayer Perceptrons
172

differentiable when the input takes value precisely equal to 0. In these cases, we default to the left-hand-side derivative and say that the derivative is 0 when the input is 0. We can get away with this because the input may never actually be zero (mathematicians would say that it is nondifferentiable on a set of measure zero). There is an old adage that if subtle boundary conditions matter, we are probably doing (real) mathematics, not engineering. That conventional wisdom may apply here, or at least, the fact that we are not performing constrained optimization (Mangasarian, 1965, Rockafellar, 1970). We plot the derivative of the ReLU function below. y.backward(torch.ones_like(x), retain_graph=True) d2l.plot(x.detach(), x.grad, 'x', 'grad of relu', figsize=(5, 2.5))
eeoer BRD ¬Æ ¬© grad of relu hd N bad ¬∞
The reason for using ReLU is that its derivatives are particularly well behaved: either they vanish or they just let the argument through. This makes optimization better behaved and it mitigated the well-documented problem of vanishing gradients that plagued previous versions of neural networks (more on this later). Note that there are many variants to the ReLU function, including the parametrized ReLU (pReLU) function (He et al., 2015). This variation adds a linear term to ReLU, so some information still gets through, even when the argument is negative:
pReLU‚Äûùë•‚Äù = max‚Äû0,ùë•‚Äù ‚Äö ùõº min‚Äû0,ùë•‚Äù. (5.1.5)
Sigmoid Function
The sigmoid function transforms those inputs whose values lie in the domain R, to outputs
that lie on the interval (0, 1). For that reason, the sigmoid is often called a squashing func- tion: it squashes any input in the range (-inf, inf) to some value in the range (0, 1):
1 sigmoid(x) = Trexpiey : (5.1.6)
In the earliest neural networks, scientists were interested in modeling biological neurons that either fire or do not fire. Thus the pioneers of this field, going all the way back to McCulloch and Pitts, the inventors of the artificial neuron, focused on thresholding units (McCulloch and Pitts, 1943). A thresholding activation takes value 0 when its input is below some threshold and value 1 when the input exceeds the threshold. Multilayer Perceptrons
173

Whenattentionshiftedtogradient-basedlearning,thesigmoidfunctionwasanaturalchoice because it is a smooth, differentiable approximation to a thresholding unit. Sigmoids are still widely used as activation functions on the output units when we want to interpret the outputs as probabilities for binary classification problems: you can think of the sigmoid as a special case of the softmax. However, the sigmoid has largely been replaced by the simpler and more easily trainable ReLU for most use in hidden layers. Much of this has to do with the fact that the sigmoid poses challenges for optimization (LeCun et al., 1998) since its gradient vanishes for large positive and negative arguments. This can lead to plateaus that are difficult to escape from. Nonetheless sigmoids are important. In later chapters (e.g., Section 10.1) on recurrent neural networks, we will describe architectures that leverage sigmoid units to control the flow of information across time. Below, we plot the sigmoid function.bubuNote that when the input is close to 0, the sigmoid function approaches a linear transformation. y = torch.sigmoid(x) d2l.plot(x.detach(), y.detach(), 'x', 'sigmoid(x)', figsize=(5, 2.5))
1.0 0.8 0.6 0.4 sigmoid(x) 0.2 0.0
The derivative of the sigmoid function is given by the following equation:
ùëë
exp(-x)
exp(-x) (1 + exp(‚Äîx))? d z sigmoid(x) = = sigmoid(x) (1 - sigmoid(x)) . (5.1.7) Xx
The derivative of the sigmoid function is plotted below. Note that when the input is 0, the derivative of the sigmoid function reaches a maximum of 0.25. As the input diverges from 0 in either direction, the derivative approaches 0. # Clear out previous gradients x.grad.data.zero_() y.backward(torch.ones_like(x),retain_graph=True) d2l.plot(x.detach(), x.grad, 'x', 'grad of sigmoid', figsize=(5, 2.5))
# Clear out previous gradients
Tanh Function
Like the sigmoid function, the tanh (hyperbolic tangent) function also squashes its inputs, transforming them into elements on the interval between ‚Äî1 and 1:
1 - exp(‚Äî2x) tanh(x) = ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî.. anh(x) 1 + exp(‚Äî2x) (5.1.8)
1 - exp(‚Äî2x)
Multilayer Perceptrons
174

grad of sigmoid
We plot the tanh function below. Note that as input nears 0, the tanh function approaches a linear transformation. Although the shape of the function is similar to that of the sigmoid function, the tanh function exhibits point symmetry about the origin of the coordinate sys- tem (Kalman and Kwasny, 1992). y = torch.tanh(x) d2l.plot(x.detach(), y.detach(), 'x', 'tanh(x)', figsize=(5, 2.5))
y = torch.tanh(x)
1.0 0.5 0.0 tanh(x) -0.5 -1.0 I ¬© i a I s t N ¬∞ N s a ow
The derivative of the tanh function is:
ùëë
d Gy tanh(x) = 1- tanh? (x). (5.1.9)
It is plotted below. As the input nears 0, the derivative of the tanh function approaches a maximum of 1. And as we saw with the sigmoid function, as input moves away from 0 in either direction, the derivative of the tanh function approaches 0. # Clear out previous gradients x.grad.data.zero_() y.backward(torch.ones_like(x),retain_graph=True) d2l.plot(x.detach(), x.grad, 'x', 'grad of tanh', figsize=(5, 2.5))
5.1.3 Summary and Discussion
We now know how to incorporate nonlinearities to build expressive multilayer neural net- work architectures. As a side note, your knowledge already puts you in command of a sim- ilar toolkit to a practitioner circa 1990. In some ways, you have an advantage over anyone
Multilayer Perceptrons
175

1.0 0.8 0.6 0.4 grad of tanh 0.2 0.0
working back then, because you can leverage powerful open-source deep learning frame- works to build models rapidly, using only a few lines of code. Previously, training these networks required researchers to code up layers and derivatives explicitly in C, Fortran, or even Lisp (in the case of LeNet). A secondary benefit is that ReLU is significantly more amenable to optimization than the sigmoid or the tanh function. One could argue that this was one of the key innovations that helped the resurgence of deep learning over the past decade. Note, though, that research in activation functions has not stopped. For instance, the GELU (Gaussian error linear unit) activation function ùë•Œ¶‚Äûùë•‚Äù by Hendrycks and Gimpel (2016) (Œ¶‚Äûùë•‚Äù is the standard Gaussian cumulative distribution function) and the Swish activation function ùúé‚Äûùë•‚Äù = ùë• sigmoid‚ÄûùõΩùë•‚Äù as proposed in Ramachandran et al. (2017) can yield better accuracy in many cases.bubu5.1.4 Exercises
1. Show that adding layers to a linear deep network, i.e., a network without nonlinearity ùúé can never increase the expressive power of the network. Give an example where it actively reduces it.bubu2. Compute the derivative of the pReLU activation function. 3. Compute the derivative of the Swish activation function ùë• sigmoid‚ÄûùõΩùë•‚Äù. 4. Show that an MLP using only ReLU (or pReLU) constructs a continuous piecewise linear function. 5.bubuSigmoid and tanh are very similar. 1. Show that tanh‚Äûùë•‚Äù ‚Äö 1 = 2sigmoid‚Äû2ùë•‚Äù. 2. Prove that the function classes parametrized by both nonlinearities are identical. Hint: affine layers have bias terms, too. 6. Assume that we have a nonlinearity that applies to one minibatch at a time, such as the batch normalization (Ioffe and Szegedy, 2015). What kinds of problems do you expect this to cause?bubu102
7. Provide an example where the gradients vanish for the sigmoid activation function. Discussions102. Multilayer Perceptrons
176

5.2 Implementation of Multilayer Perceptrons
a
Multilayerperceptrons(MLPs)arenotmuchmorecomplextoimplementthansimplelinear models. The key conceptual difference is that we now concatenate multiple layers. import torch from torch import nn from d2l import torch as d2l
5.2.1 Implementation from Scratch
Let‚Äôs begin again by implementing such a network from scratch. Initializing Model Parameters
Recall that Fashion-MNIST contains 10 classes, and that each image consists of a 28 x
28 = 784 grid of grayscale pixel values. As before we will disregard the spatial structure among the pixels for now, so we can think of this as a classification dataset with 784 input featuresand10classes. Tobegin, wewillimplementanMLPwithonehiddenlayerand256 hidden units. Both the number of layers and their width are adjustable (they are considered hyperparameters). Typically, we choose the layer widths to be divisible by larger powers of 2. This is computationally efficient due to the way memory is allocated and addressed in hardware. Again, we will represent our parameters with several tensors. Note that for every layer, we must keep track of one weight matrix and one bias vector. As always, we allocate memory for the gradients of the loss with respect to these parameters. In the code below we use nn.Parameter to automatically register a class attribute as a
parameter to be tracked by autograd (Section 2.5). class MLPScratch(d2l.Classifier):
def __init__(self, num_inputs, num_outputs, num_hiddens, lr, sigma=0.01): super().__init__() self.save_hyperparameters() self.W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens) * sigma) self.b1 = nn.Parameter(torch.zeros(num_hiddens)) self.W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs) * sigma) self.b2 = nn.Parameter(torch.zeros(num_outputs))
To make sure we know how everything works, we will implement the ReLU activation ourselves rather than invoking the built-in relu function directly. Model
Implementation of Multilayer Perceptrons
177

def relu(X): a = torch.zeros_like(X) return torch.max(X, a)
Since we are disregarding spatial structure, we reshape each two-dimensional image into a flat vector of length num_inputs. Finally, we implement our model with just a few lines of code. Since we use the framework built-in autograd this is all that it takes. @d2l.add_to_class(MLPScratch) def forward(self, X): X = X.reshape((-1, self.num_inputs)) H = relu(torch.matmul(X, self.W1) + self.b1) return torch.matmul(H, self.W2) + self.b2
Fortunately, the training loop for MLPs is exactly the same as for softmax regression. We define the model, data, and trainer, then finally invoke the fit method on model and data. model = MLPScratch(num_inputs=784, num_outputs=10, num_hiddens=256, lr=0.1) data = d2l.FashionMNIST(batch_size=256) trainer = d2l.Trainer(max_epochs=10) trainer.fit(model, data)
‚Äî train_loss 1.2 ==- val_loss ‚Äî-- val_ace 1.0 0.8 0.6 0.4 0 2 4 6 8 10
5.2.2 Concise Implementation
As you might expect, by relying on the high-level APIs, we can implement MLPs even more concisely. Comparedwithourconciseimplementationofsoftmaxregressionimplementation(Section 4.5),theonlydifferenceisthatweaddtwofullyconnectedlayerswherewepreviouslyadded only one. The first is the hidden layer, the second is the output layer. Training
Model
Multilayer Perceptrons
178

class MLP(d2l.Classifier): def __init__(self, num_outputs, num_hiddens, lr): super().__init__() self.save_hyperparameters() self.net = nn.Sequential(nn.Flatten(), nn.LazyLinear(num_hiddens), nn.ReLU(), nn.LazyLinear(num_outputs))
Previously, we defined forward methods for models to transform input using the model parameters. These operations are essentially a pipeline: you take an input and apply a transformation (e.g., matrix multiplication with weights followed by bias addition), then repetitively use the output of the current transformation as input to the next transforma- tion. However, you may have noticed that no forward method is defined here. In fact, MLP inherits the forward method from the Module class (Section 3.2.2) to simply invoke self.net(X) (X is input), which is now defined as a sequence of transformations via the Sequential class. The Sequential class abstracts the forward process enabling us to fo- cus on the transformations. We will further discuss how the Sequential class works in Section 6.1.2. The training loop is exactly the same as when we implemented softmax regression. This modularity enables us to separate matters concerning the model architecture from orthog- onal considerations. model = MLP(num_outputs=10, num_hiddens=256, lr=0.1) trainer.fit(model, data)
10 ‚Äî train_loss ‚Äî-- val_loss at val_acc ne 0.6 0.4 0 2 4 6 8 10
5.2.3 Summary
Now that we have more practice in designing deep networks, the step from a single to mul- tiple layers of deep networks does not pose such a significant challenge any longer. In particular, we can reuse the training algorithm and data loader. Note, though, that imple- menting MLPs from scratch is nonetheless messy: naming and keeping track of the model parameters makes it difficult to extend models. For instance, imagine wanting to insert another layer between layers 42 and 43. This might now be layer 42b, unless we are willing
Training
Implementation of Multilayer Perceptrons
179

to perform sequential renaming. Moreover, if we implement the network from scratch, it is much more difficult for the framework to perform meaningful performance optimiza- tions. Nonetheless, you have now reached the state of the art of the late 1980s when fully con- nected deep networks were the method of choice for neural network modeling. Our next conceptual step will be to consider images. Before we do so, we need to review a number of statistical basics and details on how to compute models efficiently. 5.2.4 Exercises
1. Change the number of hidden units num_hiddens and plot how its number affects the accuracy of the model. What is the best value of this hyperparameter? 2. Try adding a hidden layer to see how it affects the results. 3. Why is it a bad idea to insert a hidden layer with a single neuron? What could go wrong?bubu4. How does changing the learning rate alter your results? With all other parameters fixed, which learning rate gives you the best results? How does this relate to the number of epochs? 5. Let‚Äôs optimize over all hyperparameters jointly, i.e., learning rate, number of epochs, number of hidden layers, and number of hidden units per layer. 1. What is the best result you can get by optimizing over all of them? 2. Why it is much more challenging to deal with multiple hyperparameters? 3. Describe an efficient strategy for optimizing over multiple parameters jointly. 6. Compare the speed of the framework and the from-scratch implementation for a chal- lenging problem. How does it change with the complexity of the network? 7. Measure the speed of tensor‚Äìmatrix multiplications for well-aligned and misaligned matrices. For instance, test for matrices with dimension 1024, 1025, 1026, 1028, and 1032. 1. How does this change between GPUs and CPUs? 2. Determine the memory bus width of your CPU and GPU. 103
8.bubuTry out different activation functions. Which one works best?bubu9. Is there a difference between weight initializations of the network? Does it matter?bubuDiscussions103. Multilayer Perceptrons
180

5.3 Forward Propagation, Backward Propagation, and Computational Graphs

So far, we have trained our models with minibatch stochastic gradient descent. However, when we implemented the algorithm, we only worried about the calculations involved in forward propagation through the model. When it came time to calculate the gradients, we justinvokedthebackpropagationfunctionprovidedbythedeeplearningframework. The automatic calculation of gradients profoundly simplifies the implementation of deep learning algorithms. Before automatic differentiation, even small changes to complicated models required recalculating complicated derivatives by hand. Surprisingly often, aca- demic papers had to allocate numerous pages to deriving update rules. While we must continue to rely on automatic differentiation so we can focus on the interesting parts, you ought to know how these gradients are calculated under the hood if you want to go beyond a shallow understanding of deep learning. In this section, we take a deep dive into the details of backward propagation (more com- monly called backpropagation). To convey some insight for both the techniques and their implementations, we rely on some basic mathematics and computational graphs. To start, we focus our exposition on a one-hidden-layer MLP with weight decay (‚Ñì2 regularization, to be described in subsequent chapters). 5.3.1 Forward Propagation
Forward propagation (or forward pass) refers to the calculation and storage of intermediate variables (including outputs) for a neural network in order from the input layer to the output layer. We now work step-by-step through the mechanics of a neural network with one hiddenlayer.bubuThismayseemtediousbutintheeternalwordsoffunkvirtuosoJamesBrown, you must ‚Äúpay the cost to be the boss‚Äù. For the sake of simplicity, let‚Äôs assume that the input example is x 2 Rùëë and that our hidden
layer does not include a bias term. Here the intermediate variable is:
where W‚Äú)) ‚Ç¨ R‚Äô‚Ñ¢4 is the weight parameter of the hidden layer. After running the inter-
mediate variable z 2 R‚Ñé through the activation function ùúô we obtain our hidden activation vector of length ‚Ñé:
The hidden layer output h is also an intermediate variable. Assuming that the parameters of the output layer possess only a weight of W¬Æ ‚Ç¨ RY*", we can obtain an output layer variable with a vector of length q:
z = W‚Äû1‚Äùx,
(5.3.1)
h = ùúô‚Äûz‚Äù. (5.3.2)
o = W‚Äû2‚Äùh. (5.3.3)
Forward Propagation, Backward Propagation, and Computational Graphs
181

Assuming that the loss function is ùëô and the example label is ùë¶, we can then calculate the
loss term for a single data example,
As we will see the definition of ‚Ñì2 regularization to be introduced later, given the hyperpa-
rameter ùúÜ, the regularization term is
ùúÜ
ùë† = 2 kW‚Äû1‚Äùk2 F ‚Äö kW‚Äû2‚Äùk2 F , (5.3.5)
where the Frobenius norm of the matrix is simply the ‚Ñì2 norm applied after flattening the
matrixintoavector. Finally, themodel‚Äôsregularizedlossonagivendataexampleis:
We refer to ùêΩ as the objective function in the following discussion. 5.3.2 Computational Graph of Forward Propagation
Plotting computational graphs helps us visualize the dependencies of operators and vari- ables within the calculation. Fig. 5.3.1 contains the graph associated with the simple net- work described above, where squares denote variables and circles denote operators. The lower-left corner signifies the input and the upper-right corner is the output. Notice that the directions of the arrows (which illustrate data flow) are primarily rightward and up- ward. x +04
tFig.bubu5.3.1
Computational graph of forward propagation. 5.3.3 Backpropagation
Backpropagation refers to the method of calculating the gradient of neural network param- eters. In short, the method traverses the network in reverse order, from the output to the input layer, according to the chain rule from calculus. The algorithm stores any interme- diate variables (partial derivatives) required while calculating the gradient with respect to some parameters. Assume that we have functions Y = ùëì ‚ÄûX‚Äù and Z = ùëî‚ÄûY‚Äù, in which the input and the output X,Y,Z are tensors of arbitrary shapes. By using the chain rule, we can compute the derivative of Z with respect to X via
ùúïZ
ùúïX = prod ùúïY , ùúïX . (5.3.7)
Here we use the prod operator to multiply its arguments after the necessary operations, such as transposition and swapping input positions, have been carried out. For vectors, this is straightforward: it is simply matrix‚Äìmatrix multiplication. For higher dimensional
ùêø = ùëô‚Äûo, ùë¶‚Äù. (5.3.4)
ùêΩ = ùêø ‚Äö ùë†. (5.3.6)
ùúïZ
ùúïY
Multilayer Perceptrons
182

tensors, we use the appropriate counterpart. The operator prod hides all the notational overhead. Recall that the parameters of the simple network with one hidden layer, whose computa- tional graph is in Fig. 5.3.1, are W) and W). The objective of backpropagation is to calculate the gradients 0J/9W)) and J/8W). To accomplish this, we apply the chain tule and calculate, in turn, the gradient of each intermediate variable and parameter. The order of calculations are reversed relative to those performed in forward propagation, since we need to start with the outcome of the computational graph and work our way towards the parameters. The first step is to calculate the gradients of the objective function J = L+s with respect to the loss term L and the regularization term s:
ùúïùêΩ ùúïùêø = 1 and ùúïùêΩ ùúïùë† = 1. (5.3.8)
Next, we compute the gradient of the objective function with respect to variable of the output layer o according to the chain rule:
ùúïùêΩ
ùúïo = prod ùúïùêø , ùúïo = ùúïo 2 Rùëû. (5.3.9)
Next, we calculate the gradients of the regularization term with respect to both parame- ters:
ùúïùë†
ùúïW‚Äû1‚Äù = ùúÜW‚Äû1‚Äù and ùúïW‚Äû2‚Äù = ùúÜW‚Äû2‚Äù. (5.3.10)
Now we are able to calculate the gradient 0J/9W ‚Ç¨ RY" of the model parameters
closest to the output layer. Using the chain rule yields:
ùúïùêΩ ùúïW‚Äû2‚Äù = prod ùúïùêΩ ùúïo , ùúïo ùúïW‚Äû2‚Äù ‚Äö prod ùúïùêΩ ùúïùë† , ùúïùë† ùúïW‚Äû2‚Äù = ùúïùêΩ ùúïo h> ‚Äö ùúÜW‚Äû2‚Äù. (5.3.11)
To obtain the gradient with respect to W‚Äú") we need to continue backpropagation along the output layer to the hidden layer. The gradient with respect to the hidden layer output dJ/dh ‚Ç¨ R" is given by
ùúïùêΩ ùúïh = prod ùúïùêΩ ùúïo , ùúïo ùúïh = W‚Äû2‚Äù> ùúïùêΩ ùúïo . (5.3.12)
Since the activation function ¬¢ applies elementwise, calculating the gradient J/dz ‚Ç¨ R"
Since the activation function ¬¢ applies elementwise, calculating the gradient J/dz ‚Ç¨ R" of the intermediate variable z requires that we use the elementwise multiplication operator, which we denote by ¬©:
os Oz (2 =) os = prod oh‚Äô da = ono? (z) . (5.3.13)
Finally, we can obtain the gradient 0J/9W"!) ¬¢ R‚Äô*4 of the model parameters closest to the input layer. According to the chain rule, we get
ùúïùêΩ ùúïW‚Äû1‚Äù = prod ùúïùêΩ ùúïz , ùúïz ùúïW‚Äû1‚Äù ‚Äö prod ùúïùêΩ ùúïùë† , ùúïùë† ùúïW‚Äû1‚Äù = ùúïùêΩ ùúïz x> ‚Äö ùúÜW‚Äû1‚Äù. (5.3.14)
ùúïùêΩ
ùúïùêø
ùúïùêø
ùúïùë†
Forward Propagation, Backward Propagation, and Computational Graphs
183

5.3.4 Training Neural Networks
When training neural networks, forward and backward propagation depend on each other. In particular, for forward propagation, we traverse the computational graph in the direc- tion of dependencies and compute all the variables on its path. These are then used for backpropagation where the compute order on the graph is reversed. Take the aforementioned simple network as an illustrative example. On the one hand, com- puting the regularization term (5.3.5) during forward propagation depends on the current values of model parametersW‚Äû1‚Äù andW‚Äû2‚Äù. They are given by the optimization algorithm according to backpropagation in the most recent iteration. On the other hand, the gradient calculation for the parameter (5.3.11) during backpropagation depends on the current value of the hidden layer output h, which is given by forward propagation. Therefore when training neural networks, once model parameters are initialized, we alter- nate forward propagation with backpropagation, updating model parameters using gradi- ents given by backpropagation. Note that backpropagation reuses the stored intermediate values from forward propagation to avoid duplicate calculations. One of the consequences is that we need to retain the intermediate values until backpropagation is complete. This is also one of the reasons why training requires significantly more memory than plain predic- tion. Besides, the size of such intermediate values is roughly proportional to the number of network layers and the batch size. Thus, training deeper networks using larger batch sizes more easily leads to out-of-memory errors. 5.3.5 Summary
Forward propagation sequentially calculates and stores intermediate variables within the computational graph defined by the neural network. It proceeds from the input to the out- put layer. Backpropagation sequentially calculates and stores the gradients of intermediate variables and parameters within the neural network in the reversed order. When training deep learning models, forward propagation and backpropagation are interdependent, and training requires significantly more memory than prediction. 5.3.6 Exercises
1.bubuAssume that the inputs X to some scalar function f are n x m matrices. What is the
dimensionality of the gradient of ùëì with respect to X? 2. Add a bias to the hidden layer of the model described in this section (you do not need to include bias in the regularization term). 1.bubuDraw the corresponding computational graph. 2. Derive the forward and backward propagation equations. 3. Compute the memory footprint for training and prediction in the model described in this section. 4.bubuAssume that you want to compute second derivatives. What happens to the computa- tional graph? How long do you expect the calculation to take? Multilayer Perceptrons
184

5. Assume that the computational graph is too large for your GPU. 1. Can you partition it over more than one GPU? 2. What are the advantages and disadvantages over training on a smaller minibatch? Discussions104. 104
5.4 Numerical Stability and Initialization
|
Thus far, every model that we have implemented required that we initialize its parameters according to some pre-specified distribution. Until now, we took the initialization scheme for granted, glossing over the details of how these choices are made. You might have even gotten the impression that these choices are not especially important. On the contrary, the choice of initialization scheme plays a significant role in neural network learning, and it can be crucial for maintaining numerical stability. Moreover, these choices can be tied up in interesting ways with the choice of the nonlinear activation function. Which function we choose and how we initialize parameters can determine how quickly our optimization algorithm converges. Poor choices here can cause us to encounter exploding or vanishing gradients while training. In this section, we delve into these topics in greater detail and discuss some useful heuristics that you will find useful throughout your career in deep learning. %matplotlib inline import torch from d2l import torch as d2l
5.4.1 Vanishing and Exploding Gradients
Consider a deep network with ùêø layers, input x and output o. With each layer ùëô defined by
a transformation ùëìùëô parametrized by weights W‚Äûùëô‚Äù, whose hidden layer output is h‚Äûùëô‚Äù (let h‚Äû0‚Äù = x), our network can be expressed as:
h = f,(h‚Äú"!) and thus 0 = fr o-++0 fi(x). (5.4.1)
If all the hidden layer output and the input are vectors, we can write the gradient of o with respect to any set of parameters W‚Äûùëô‚Äù as follows:
Oy O = Oyie-yh‚Ñ¢ Oyo ht) dyin h . Ne (5.4.2) mie) mine yin de
In other words, this gradient is the product of L ‚Äî / matrices M‚Äú... M*)) and the
gradient vector v‚Äûùëô‚Äù. Thus we are susceptible to the same problems of numerical underflow that often crop up when multiplying together too many probabilities. When dealing with probabilities, a common trick is to switch into log-space, i.e., shifting pressure from the
Numerical Stability and Initialization
185

mantissatotheexponentofthenumericalrepresentation. Unfortunately, ourproblemabove is more serious: initially the matrices M‚Äûùëô‚Äù may have a wide variety of eigenvalues. They might be small or large, and their product might be very large or very small. The risks posed by unstable gradients go beyond numerical representation. Gradients of unpredictable magnitude also threaten the stability of our optimization algorithms. We may be facing parameter updates that are either (i) excessively large, destroying our model (the exploding gradient problem); or (ii) excessively small (the vanishing gradient problem), rendering learning impossible as parameters hardly move on each update. Vanishing Gradients
One frequent culprit causing the vanishing gradient problem is the choice of the activation function o that is appended following each layer‚Äôs linear operations. Historically, the sig- moid function 1/(1+exp(‚Äîx)) (introduced in Section 5.1) was popular because it resembles a thresholding function. Since early artificial neural networks were inspired by biological neural networks, the idea of neurons that fire either fully or not at all (like biological neu- rons) seemed appealing. Let‚Äôs take a closer look at the sigmoid to see why it can cause vanishing gradients. x = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)
y = torch.sigmoid(x)
y.backward(torch.ones_like(x))
d2l.plot(x.detach().numpy(), [y.detach().numpy(), x.grad.numpy()], legend=['sigmoid', 'gradient'], figsize=(4.5, 2.5))
1.0 7 sigmoid 0.8 4{--- gradient 0.6 0.4 0.2 0.0
As you can see, the sigmoid‚Äôs gradient vanishes both when its inputs are large and when they are small. Moreover, when backpropagating through many layers, unless we are in the Goldilocks zone, where the inputs to many of the sigmoids are close to zero, the gradients of the overall product may vanish. When our network boasts many layers, unless we are careful, the gradient will likely be cut off at some layer. Indeed, this problem used to plague deep network training. Consequently, ReLUs, which are more stable (but less neurally plausible), have emerged as the default choice for practitioners. Multilayer Perceptrons
186

Exploding Gradients
The opposite problem, when gradients explode, can be similarly vexing. To illustrate this a bit better, we draw 100 Gaussian random matrices and multiply them with some initial matrix. For the scale that we picked (the choice of the variance ùúé2 = 1), the matrix product explodes. When this happens because of the initialization of a deep network, we have no chance of getting a gradient descent optimizer to converge. M = torch.normal(0, 1, size=(4, 4)) print('a single matrix \n',M) for i in range(100): M = M @ torch.normal(0, 1, size=(4, 4)) print('after multiplying 100 matrices\n', M)
a single matrix tensor([[-0.8755, -1.2171, 1.3316, 0.1357], [ 0.4399, 1.4073, -1.9131, -0.4608], [-2.1420, 0.3643, -0.5267, 1.0277], [-0.1734, -0.7549, 2.3024, 1.3085]]) after multiplying 100 matrices tensor([[-2.9185e+23, 1.3915e+25, -1.1865e+25, 1.4354e+24], [ 4.9142e+23, -2.3430e+25, 1.9979e+25, -2.4169e+24], [ 2.6578e+23, -1.2672e+25, 1.0805e+25, -1.3072e+24], [-5.2223e+23, 2.4899e+25, -2.1231e+25, 2.5684e+24]])
Breaking the Symmetry
Another problem in neural network design is the symmetry inherent in their parametriza- tion. Assume that we have a simple MLP with one hidden layer and two units. In this case, we could permute the weights W‚Äû1‚Äù of the first layer and likewise permute the weights of the output layer to obtain the same function. There is nothing special differentiating the first and second hidden units. In other words, we have permutation symmetry among the hidden units of each layer. This is more than just a theoretical nuisance. Consider the aforementioned one-hidden- layer MLP with two hidden units. For illustration, suppose that the output layer transforms the two hidden units into only one output unit. Imagine what would happen if we initialized all the parameters of the hidden layer as W‚Äû1‚Äù = ùëê for some constant ùëê. In this case, during forward propagation either hidden unit takes the same inputs and parameters producing the same activation which is fed to the output unit. During backpropagation, differentiating the output unit with respect to parameters W‚Äû1‚Äù gives a gradient all of whose elements take the same value. Thus, after gradient-based iteration (e.g., minibatch stochastic gradient de- scent), all the elements ofW‚Äû1‚Äù still take the same value. Such iterations would never break the symmetry on their own and we might never be able to realize the network‚Äôs expressive power. The hidden layer would behave as if it had only a single unit. Note that while mini- batch stochastic gradient descent would not break this symmetry, dropout regularization (to be introduced later) would! Numerical Stability and Initialization
187

5.4.2 Parameter Initialization
One way of addressing‚Äîor at least mitigating‚Äîthe issues raised above is through care- ful initialization. As we will see later, additional care during optimization and suitable regularization can further enhance stability. Default Initialization
In the previous sections, e.g., in Section 3.5, we used a normal distribution to initialize the values of our weights. If we do not specify the initialization method, the framework will use a default random initialization method, which often works well in practice for moderate problem sizes. Xavier Initialization
Let‚Äôs look at the scale distribution of an output ùëúùëñ for some fully connected layer without
nonlinearities. With ùëõin inputs ùë• ùëó and their associated weights ùë§ùëñùëó for this layer, an output is given by
ùëúùëñ = ùë§ùëñùëóùë• ùëó. ùëó=1 (5.4.3)
The weights ùë§ùëñùëó are all drawn independently from the same distribution. Furthermore, let‚Äôs
assume that this distribution has zero mean and variance ùúé2. Note that this does not mean that the distribution has to be Gaussian, just that the mean and variance need to exist. For now, let‚Äôs assume that the inputs to the layer ùë• ùëó also havezero mean and variance ùõæ2 and that they are independent of ùë§ùëñùëó and independent of each other. In this case, we can compute the mean of ùëúùëñ:
E[oj] = ¬ªy E[wijx;] =I zi 5.44 =) EbwislE bx] (644)
= 0,
and the variance:
2,2 =Nino-y‚Äô. One way to keep the variance fixed is to set ùëõinùúé2 = 1. Now consider backpropagation. There we face a similar problem, albeit with gradients being propagated from the layers
Fin
Multilayer Perceptrons
188

closer to the output. Using the same reasoning as for forward propagation, we see that the gradients‚Äô variance can blow up unless ùëõoutùúé2 = 1, where ùëõout is the number of outputs of this layer. This leaves us in a dilemma: we cannot possibly satisfy both conditions simultaneously.bubuInstead, we simply try to satisfy:
1 2 ‚Äûùëõin ‚Äö ùëõout‚Äùùúé2 = 1 or equivalently ùúé = 2 ùëõin ‚Äö ùëõout . (5.4.6)
This is the reasoning underlying the now-standard and practically beneficial Xavier initial- ization, named after the first author of its creators (Glorot and Bengio, 2010). Typically, the Xavier initialization samples weights from a Gaussian distribution with zero mean and vari- 2 = _2__. We can also adapt this to choose the variance when sampling weights Nin+Nout ance a from a uniform distribution. Note that the uniform distribution U(‚Äîa, a) has variance *-. Plugging ¬¢ into our condition on og? prompts us to initialize according to
s
6 6 U| -,{| ‚Äî‚Äî‚Äî_..,4] ‚Äî‚Äî‚Äî‚Äî ] (5.4.7) Nin + Nout Y Nin + Nout
Though the assumption for nonexistence of nonlinearities in the above mathematical rea- soning can be easily violated in neural networks, the Xavier initialization method turns out to work well in practice. The reasoning above barely scratches the surface of modern approaches to parameter ini- tialization. A deep learning framework often implements over a dozen different heuristics. Moreover, parameter initialization continues to be a hot area of fundamental research in deep learning. Among these are heuristics specialized for tied (shared) parameters, super- resolution, sequence models, and other situations. For instance, Xiao et al. (2018) demon- strated the possibility of training 10,000-layer neural networks without architectural tricks by using a carefully-designed initialization method. If the topic interests you we suggest a deep dive into this module‚Äôs offerings, reading the papers that proposed and analyzed each heuristic, and then exploring the latest publications on the topic. Perhaps you will stumble across or even invent a clever idea and contribute an implementation to deep learning frameworks. 5.4.3 Summary
Vanishing and exploding gradients are common issues in deep networks. Great care in parameter initialization is required to ensure that gradients and parameters remain well controlled. Initialization heuristics are needed to ensure that the initial gradients are neither too large nor too small. Random initialization is key to ensuring that symmetry is broken before optimization. Xavier initialization suggests that, for each layer, variance of any outputisnotaffectedbythenumberofinputs, andvarianceofanygradientisnotaffectedby the number of outputs. ReLU activation functions mitigate the vanishing gradient problem. This can accelerate convergence. r
s
Beyond
Generalization in Deep Learning
189

5.4.4 Exercises
1. Can you design other cases where a neural network might exhibit symmetry that needs breaking, besides the permutation symmetry in an MLP‚Äôs layers? 2. Can we initialize all weight parameters in linear regression or in softmax regression to the same value? 3. Look up analytic bounds on the eigenvalues of the product of two matrices. What does this tell you about ensuring that gradients are well conditioned? 4. If we know that some terms diverge, can we fix this after the fact? Look at the paper on layerwise adaptive rate scaling for inspiration (You et al., 2017). Discussions105. 105
5.5 Generalization in Deep Learning
|
In Chapter 3 and Chapter 4, we tackled regression and classification problems by fitting linear models to training data. In both cases, we provided practical algorithms for finding the parameters that maximized the likelihood of the observed training labels. And then, towards the end of each chapter, we recalled that fitting the training data was only an in- termediate goal. Our real quest all along was to discover general patterns on the basis of which we can make accurate predictions even on new examples drawn from the same underlying population. Machine learning researchers are consumers of optimization algo- rithms. Sometimes, we must even develop new optimization algorithms. But at the end of the day, optimization is merely a means to an end. At its core, machine learning is a statistical discipline and we wish to optimize training loss only insofar as some statistical principle (known or unknown) leads the resulting models to generalize beyond the training set. On the bright side, it turns out that deep neural networks trained by stochastic gradient de- scent generalize remarkably well across myriad prediction problems, spanning computer vision; natural language processing; time series data; recommender systems; electronic health records; protein folding; value function approximation in video games and board games; and numerous other domains. On the downside, if you were looking for a straight- forward account of either the optimization story (why we can fit them to training data) or the generalization story (why the resulting models generalize to unseen examples), then you might want to pour yourself a drink. While our procedures for optimizing linear models and the statistical properties of the solutions are both described well by a comprehensive body of theory, our understanding of deep learning still resembles the wild west on both fronts. Both the theory and practice of deep learning are rapidly evolving, with theorists adopting new strategies to explain what‚Äôs going on, even as practitioners continue to innovate at
Multilayer Perceptrons
190

a blistering pace, building arsenals of heuristics for training deep networks and a body of intuitions and folk knowledge that provide guidance for deciding which techniques to apply in which situations. The summary of the present moment is that the theory of deep learning has produced promising lines of attack and scattered fascinating results, but still appears far from a com- prehensive account of both (i) why we are able to optimize neural networks and (ii) how modelslearnedbygradientdescentmanagetogeneralizesowell, evenonhigh-dimensional tasks. However, inpractice, (i)isseldomaproblem(wecanalwaysfindparametersthatwill fit all of our training data) and thus understanding generalization is far the bigger problem. On the other hand, even absent the comfort of a coherent scientific theory, practitioners have developed a large collection of techniques that may help you to produce models that generalize well in practice. While no pithy summary can possibly do justice to the vast topic of generalization in deep learning, and while the overall state of research is far from resolved, we hope, in this section, to present a broad overview of the state of research and practice. 5.5.1 Revisiting Overfitting and Regularization
According to the ‚Äúno free lunch‚Äù theorem of Wolpert and Macready (1995), any learn- ing algorithm generalizes better on data with certain distributions, and worse with other distributions. Thus, given a finite training set, a model relies on certain assumptions: to achieve human-level performance it may be useful to identify inductive biases that reflect how humans think about the world. Such inductive biases show preferences for solutions with certain properties. For example, a deep MLP has an inductive bias towards building up a complicated function by the composition of simpler functions. With machine learning models encoding inductive biases, our approach to training them typically consists of two phases: (i) fit the training data; and (ii) estimate the generalization error (the true error on the underlying population) by evaluating the model on holdout data. The difference between our fit on the training data and our fit on the test data is called the generalization gap and when this is large, we say that our models overfit to the training data. In extreme cases of overfitting, we might exactly fit the training data, even when the test error remains significant. And in the classical view, the interpretation is that our models are too complex, requiring that we either shrink the number of features, the number of nonzero parameters learned, or the size of the parameters as quantified. Recall the plot of model complexity compared with loss (Fig. 3.6.1) from Section 3.6. However deep learning complicates this picture in counterintuitive ways. First, for classifi- cation problems, our models are typically expressive enough to perfectly fit every training example, even in datasets consisting of millions (Zhang et al., 2021). In the classical pic- ture, we might think that this setting lies on the far right extreme of the model complexity axis, and that any improvements in generalization error must come by way of regulariza- tion, eitherbyreducingthecomplexityofthemodel class, or byapplyingapenalty, severely constraining the set of values that our parameters might take. But that is where things start to get weird. Generalization in Deep Learning
191

Strangely, for many deep learning tasks (e.g., image recognition and text classification) we
are typically choosing among model architectures, all of which can achieve arbitrarily low training loss (and zero training error). Because all models under consideration achieve zero training error, the only avenue for further gains is to reduce overfitting. Even stranger, it is often the case that despite fitting the training data perfectly, we can actually reduce the generalization error further by making the model even more expressive, e.g., adding layers, nodes, or training for a larger number of epochs. Stranger yet, the pattern relating the generalization gap to the complexity of the model (as captured, for example, in the depth or width of the networks) can be non-monotonic, with greater complexity hurting at first but subsequently helping in a so-called ‚Äúdouble-descent‚Äù pattern (Nakkiran et al., 2021). Thus the deep learning practitioner possesses a bag of tricks, some of which seemingly restrict the model in some fashion and others that seemingly make it even more expressive, and all of which, in some sense, are applied to mitigate overfitting. Complicating things even further, while the guarantees provided by classical learning the- ory can be conservative even for classical models, they appear powerless to explain why it is that deep neural networks generalize in the first place. Because deep neural networks are capable of fitting arbitrary labels even for large datasets, and despite the use of famil- iar methods such as ‚Ñì2 regularization, traditional complexity-based generalization bounds, e.g., those based on the VC dimension or Rademacher complexity of a hypothesis class cannot explain why neural networks generalize. 5.5.2 Inspiration from Nonparametrics
Approaching deep learning for the first time, it is tempting to think of them as parametric models. After all, the models do have millions of parameters. When we update the models, we update their parameters. When we save the models, we write their parameters to disk. However, mathematics and computer science are riddled with counterintuitive changes of perspective, and surprising isomorphisms between seemingly different problems. While neural networks clearly have parameters, in some ways it can be more fruitful to think of them as behaving like nonparametric models. So what precisely makes a model nonpara- metric? While the name covers a diverse set of approaches, one common theme is that nonparametric methods tend to have a level of complexity that grows as the amount of available data grows. Perhaps the simplest example of a nonparametric model is the ùëò-nearest neighbor algorithm
(we will cover more nonparametric models later, for example in Section 11.2). Here, at training time, the learner simply memorizes the dataset. Then, at prediction time, when confronted with a new point x, the learner looks up the ùëò nearest neighbors (the ùëò points x0 ùëñ that minimize some distance ùëë‚Äûx,x0 ùëñ‚Äù). When ùëò = 1, this algorithm is called 1-nearest neighbors, and the algorithm will always achieve a training error of zero. That however, does not mean that the algorithm will not generalize. In fact, it turns out that under some mild conditions, the 1-nearest neighbor algorithm is consistent (eventually converging to the optimal predictor). Note that 1-nearest neighbor requires that we specify some distance function ùëë, or equiva-
lently, that we specify some vector-valued basis function ùúô‚Äûx‚Äù for featurizing our data. For
Multilayer Perceptrons
192

any choice of the distance metric, we will achieve zero training error and eventually reach an optimal predictor, but different distance metrics ùëë encode different inductive biases and with a finite amount of available data will yield different predictors. Different choices of the distance metric ùëë represent different assumptions about the underlying patterns and the performance of the different predictors will depend on how compatible the assumptions are with the observed data. In a sense, because neural networks are over-parametrized, possessing many more parame- ters than are needed to fit the training data, they tend to interpolate the training data (fitting it perfectly) and thus behave, in some ways, more like nonparametric models. More re- cent theoretical research has established deep connection between large neural networks and nonparametric methods, notably kernel methods. In particular, Jacot et al. (2018) demonstrated that in the limit, as multilayer perceptrons with randomly initialized weights grow infinitely wide, they become equivalent to (nonparametric) kernel methods for a spe- cific choice of the kernel function (essentially, a distance function), which they call the neural tangent kernel. While current neural tangent kernel models may not fully explain the behavior of modern deep networks, their success as an analytical tool underscores the usefulness of nonparametric modeling for understanding the behavior of over-parametrized deep networks. 5.5.3 Early Stopping
While deep neural networks are capable of fitting arbitrary labels, even when labels are assigned incorrectly or randomly (Zhang et al., 2021), this capability only emerges over many iterations of training. A new line of work (Rolnick et al., 2017) has revealed that in the setting of label noise, neural networks tend to fit cleanly labeled data first and only subsequently to interpolate the mislabeled data. Moreover, it has been established that this phenomenon translates directly into a guarantee on generalization: whenever a model has fitted the cleanly labeled data but not randomly labeled examples included in the training set, it has in fact generalized (Garg et al., 2021). Together these findings help to motivate early stopping, a classic technique for regularizing deep neural networks. Here, rather than directly constraining the values of the weights, one constrains the number of epochs of training. The most common way to determine the stopping criterion is to monitor validation error throughout training (typically by checking once after each epoch) and to cut off training when the validation error has not decreased by more than some small amount ùúñ for some number of epochs. This is sometimes called a patience criterion. As well as the potential to lead to better generalization in the setting of noisy labels, another benefit of early stopping is the time saved. Once the patience criterion is met, one can terminate training. For large models that might require days of training simultaneously across eight or more GPUs, well-tuned early stopping can save researchers days of time and can save their employers many thousands of dollars. Notably, when there is no label noise and datasets are realizable (the classes are truly sep- arable, e.g., distinguishing cats from dogs), early stopping tends not to lead to significant improvements in generalization. On the other hand, when there is label noise, or intrinsic
Generalization in Deep Learning
193

variability in the label (e.g., predicting mortality among patients), early stopping is crucial. Training models until they interpolate noisy data is typically a bad idea. 5.5.4 Classical Regularization Methods for Deep Networks
In Chapter 3, we described several classical regularization techniques for constraining the complexity of our models. In particular, Section 3.7 introduced a method called weight decay,whichconsistsofaddingaregularizationtermtothelossfunctioninordertopenalize large values of the weights. Depending on which weight norm is penalized this technique is known either as ridge regularization (for ‚Ñì2 penalty) or lasso regularization (for an ‚Ñì1 penalty). In the classical analysis of these regularizers, they are considered as sufficiently restrictive on the values that the weights can take to prevent the model from fitting arbitrary labels. In deep learning implementations, weight decay remains a popular tool. However, re- searchers have noted that typical strengths of ‚Ñì2 regularization are insufficient to prevent the networks from interpolating the data (Zhang et al., 2021) and thus the benefits if interpreted as regularization might only make sense in combination with the early stopping criterion. Absent early stopping, it is possible that just like the number of layers or number of nodes (in deep learning) or the distance metric (in 1-nearest neighbor), these methods may lead to better generalization not because they meaningfully constrain the power of the neural net- work but rather because they somehow encode inductive biases that are better compatible with the patterns found in datasets of interests. Thus, classical regularizers remain popular in deep learning implementations, even if the theoretical rationale for their efficacy may be radically different. Notably, deep learning researchers have also built on techniques first popularized in classi- calregularizationcontexts, suchasaddingnoisetomodelinputs. Inthenextsectionwewill introduce the famous dropout technique (invented by Srivastava et al. (2014)), which has become a mainstay of deep learning, even as the theoretical basis for its efficacy remains similarly mysterious. 5.5.5 Summary
Unlike classical linear models, which tend to have fewer parameters than examples, deep networks tend to be over-parametrized, and for most tasks are capable of perfectly fitting the training set. This interpolation regime challenges many hard fast-held intuitions. Func- tionally, neural networks look like parametric models. But thinking of them as nonpara- metric models can sometimes be a more reliable source of intuition. Because it is often the case that all deep networks under consideration are capable of fitting all of the train- ing labels, nearly all gains must come by mitigating overfitting (closing the generalization gap). Paradoxically, the interventions that reduce the generalization gap sometimes appear to increase model complexity and at other times appear to decrease complexity. However, these methods seldom decrease complexity sufficiently for classical theory to explain the generalization of deep networks, and why certain choices lead to improved generalization remains for the most part a massive open question despite the concerted efforts of many brilliant researchers. Multilayer Perceptrons
194

5.5.6 Exercises
1. Inwhatsensedotraditionalcomplexity-basedmeasuresfailtoaccountforgeneralization of deep neural networks? 2. Why might early stopping be considered a regularization technique? 3. How do researchers typically determine the stopping criterion? 4. What important factor seems to differentiate cases when early stopping leads to big improvements in generalization? 5. Beyond generalization, describe another benefit of early stopping. 106
Discussions106. 5.6 Dropout

Let‚Äôs think briefly about what we expect from a good predictive model. We want it to pe- form well on unseen data. Classical generalization theory suggests that to close the gap between train and test performance, we should aim for a simple model. Simplicity can come in the form of a small number of dimensions. We explored this when discussing the monomial basis functions of linear models in Section 3.6. Additionally, as we saw when discussing weight decay (‚Ñì2 regularization) in Section 3.7, the (inverse) norm of the param- eters also represents a useful measure of simplicity. Another useful notion of simplicity is smoothness, i.e., that the function should not be sensitive to small changes to its inputs. For instance, when we classify images, we would expect that adding some random noise to the pixels should be mostly harmless. Bishop (1995) formalized this idea when he proved that training with input noise is equiva- lent to Tikhonov regularization. This work drew a clear mathematical connection between the requirement that a function be smooth (and thus simple), and the requirement that it be resilient to perturbations in the input. Then, Srivastava et al. (2014) developed a clever idea for how to apply Bishop‚Äôs idea to the internal layers of a network, too. Their idea, called dropout, involves injecting noise while computing each internal layer during forward propagation, and it has become a standard technique for training neural networks. The method is called dropout because we literally drop out some neurons during training. Throughout training, on each iteration, standard dropout consists of zeroing out some fraction of the nodes in each layer before calculating the subsequent layer. To be clear, we are imposing our own narrative with the link to Bishop. The original pa- per on dropout offers intuition through a surprising analogy to sexual reproduction. The authors argue that neural network overfitting is characterized by a state in which each layer
195

relies on a specific pattern of activations in the previous layer, calling this condition co- adaptation. Dropout, they claim, breaks up co-adaptation just as sexual reproduction is argued to break up co-adapted genes. While such an justification of this theory is cer- tainly up for debate, the dropout technique itself has proved enduring, and various forms of dropout are implemented in most deep learning libraries. The key challenge is how to inject this noise. One idea is to inject it in an unbiased manner so that the expected value of each layer‚Äîwhile fixing the others‚Äîequals the value it would have taken absent noise. In Bishop‚Äôs work, he added Gaussian noise to the inputs to a linear model. At each training iteration, he added noise sampled from a distribution with mean zero ‚Ç¨ ~ N(0,c7) to the input x, yielding a perturbed point x‚Äô = x + ‚Ç¨. In expectation, E[x‚Äô] =x. In standard dropout regularization, one zeros out some fraction of the nodes in each layer and then debiases each layer by normalizing by the fraction of nodes that were retained (not dropped out). In other words, with dropout probability ùëù, each intermediate activation ‚Ñé is replaced by a random variable ‚Ñé0 as follows:
(
‚Ñé0 = 0 ‚Ñé with probability ùëù otherwise (5.6.1)
By design, the expectation remains unchanged, i.e., ùê∏¬ª‚Ñé0‚Ä¶ = ‚Ñé. import torch from torch import nn from d2l import torch as d2l
5.6.1 Dropout in Practice
Recall the MLP with a hidden layer and five hidden units from Fig. 5.1.1. When we apply dropout to a hidden layer, zeroing out each hidden unit with probability ùëù, the result can be viewed as a network containing only a subset of the original neurons. In Fig. 5.6.1, ‚Ñé2 and ‚Ñé5 are removed. Consequently, the calculation of the outputs no longer depends on ‚Ñé2 or ‚Ñé5 and their respective gradient also vanishes when performing backpropagation. In this way, the calculation of the output layer cannot be overly dependent on any one element of ‚Ñé1, . .bubu., ‚Ñé5. Before dropout After dropout
tFig. 5.6.1 MLP before and after dropout. Dropout
Multilayer Perceptrons
196

Typically, we disable dropout at test time. Given a trained model and a new example, we do not drop out any nodes and thus do not need to normalize. However, there are some exceptions: some researchers use dropout at test time as a heuristic for estimating the uncertainty of neural network predictions: if the predictions agree across many different dropout outputs, then we might say that the network is more confident. 5.6.2 Implementation from Scratch
To implement the dropout function for a single layer, we must draw as many samples from a Bernoulli (binary) random variable as our layer has dimensions, where the random variable takes value 1 (keep) with probability 1 ‚Äî p and 0 (drop) with probability p. One easy way to implement this is to first draw samples from the uniform distribution U[0, 1]. Then we can keep those nodes for which the corresponding sample is greater than p, dropping the rest. Inthe followingcode, weimplement a dropout_layer function that drops outthe elements in the tensor input X with probability dropout, rescaling the remainder as described above: dividing the survivors by 1.0-dropout. def dropout_layer(X, dropout): assert 0 <= dropout <= 1 if dropout == 1: return torch.zeros_like(X) mask = (torch.rand(X.shape) > dropout).float() return mask * X / (1.0 - dropout)
def dropout_layer(X, dropout):
We can test out the dropout_layer function on a few examples. In the following lines of code, we pass our input X through the dropout operation, with probabilities 0, 0.5, and 1, respectively. X = torch.arange(16, dtype = torch.float32).reshape((2, 8)) print('dropout_p = 0:', dropout_layer(X, 0)) print('dropout_p = 0.5:', dropout_layer(X, 0.5)) print('dropout_p = 1:', dropout_layer(X, 1))
dropout_p = 0: tensor([[ 0., 1., 2., 3., 4., 5., 6., 7.], [ 8., 9., 10., 11., 12., 13., 14., 15.]]) dropout_p = 0.5: tensor([[ 0., 2., 0., 6., 8., 0., 0., 0.], [16., 18., 20., 22., 24., 26., 28., 30.]]) dropout_p = 1: tensor([[0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0.]])
Defining the Model
Themodelbelowappliesdropouttotheoutputofeachhiddenlayer(followingtheactivation function). We can set dropout probabilities for each layer separately. A common choice is to set a lower dropout probability closer to the input layer. We ensure that dropout is only active during training. 197

class DropoutMLPScratch(d2l.Classifier): def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2, dropout_1, dropout_2, lr): super().__init__() self.save_hyperparameters() self.lin1 = nn.LazyLinear(num_hiddens_1) self.lin2 = nn.LazyLinear(num_hiddens_2) self.lin3 = nn.LazyLinear(num_outputs) self.relu = nn.ReLU() def forward(self, X): H1 = self.relu(self.lin1(X.reshape((X.shape[0], -1)))) if self.training: H1 = dropout_layer(H1, self.dropout_1) H2 = self.relu(self.lin2(H1)) if self.training: H2 = dropout_layer(H2, self.dropout_2) return self.lin3(H2)
The following is similar to the training of MLPs described previously. hparams = {'num_outputs':10, 'num_hiddens_1':256, 'num_hiddens_2':256, 'dropout_1':0.5, 'dropout_2':0.5, 'lr':0.1} model = DropoutMLPScratch(**hparams) data = d2l.FashionMNIST(batch_size=256) trainer = d2l.Trainer(max_epochs=10) trainer.fit(model, data)
14 ‚Äî train_loss ‚Äî-- val_loss 12 ‚Äî-- val_ace 1.0 0.8 0.6 0.4 0 2 4 6 8 10 epoch
5.6.3 Concise Implementation
With high-level APIs, all we need to do is add a Dropout layer after each fully connected layer, passing in the dropout probability as the only argument to its constructor. During training, the Dropout layer will randomly drop out outputs of the previous layer (or equiv- alently, the inputs to the subsequent layer) according to the specified dropout probability. When not in training mode, the Dropout layer simply passes the data through during test- ing. Dropout
Training
Multilayer Perceptrons
198

class DropoutMLP(d2l.Classifier): def __init__(self, num_outputs, num_hiddens_1, num_hiddens_2, dropout_1, dropout_2, lr): super().__init__() self.save_hyperparameters() self.net = nn.Sequential( nn.Flatten(), nn.LazyLinear(num_hiddens_1), nn.ReLU(), nn.Dropout(dropout_1), nn.LazyLinear(num_hiddens_2), nn.ReLU(), nn.Dropout(dropout_2), nn.LazyLinear(num_outputs))
Next, we train the model. model = DropoutMLP(**hparams) trainer.fit(model, data)
14 ‚Äî train_loss =-- val_loss 1.2 ‚Äî-- val_ace 1.0 0.8 0.6 0.4
5.6.4 Summary
Beyond controlling the number of dimensions and the size of the weight vector, dropout is yet another tool for avoiding overfitting. Often tools are used jointly. Note that dropout is used only during training: it replaces an activation ‚Ñé with a random variable with expected value ‚Ñé. 5.6.5 Exercises
1. What happens if you change the dropout probabilities for the first and second layers? In particular, what happens if you switch the ones for both layers? Design an experi- ment to answer these questions, describe your results quantitatively, and summarize the qualitative takeaways. 2. Increase the number of epochs and compare the results obtained when using dropout with those when not using it. 3. What is the variance of the activations in each hidden layer when dropout is and is not applied? Draw a plot to show how this quantity evolves over time for both models. 4. Why is dropout not typically used at test time? 5. Using the model in this section as an example, compare the effects of using dropout and
Predicting House Prices on Kaggle
199

weight decay. What happens when dropout and weight decay are used at the same time? Are the results additive? Are there diminished returns (or worse)? Do they cancel each other out?bubu6. What happens if we apply dropout to the individual weights of the weight matrix rather than the activations? 7. Invent another technique for injecting random noise at each layer that is different from the standard dropout technique. Can you develop a method that outperforms dropout on the Fashion-MNIST dataset (for a fixed architecture)? Discussions107. 107

5.7 Predicting House Prices on Kaggle
a
Now that we have introduced some basic tools for building and training deep networks and regularizing them with techniques including weight decay and dropout, we are ready to put all this knowledge into practice by participating in a Kaggle competition. The house price prediction competition is a great place to start. The data is fairly generic and do not exhibit exotic structure that might require specialized models (as audio or video might). This dataset, collected by De Cock (2011), covers house prices in Ames, Iowa from the period 2006‚Äì2010. It is considerably larger than the famous Boston housing dataset108 of Harrison and Rubinfeld (1978), boasting both more examples and more features. 108 
In this section, we will walk you through details of data preprocessing, model design, and hyperparameter selection. We hope that through a hands-on approach, you will gain some intuitions that will guide you in your career as a data scientist. %matplotlib inline import pandas as pd import torch from torch import nn from d2l import torch as d2l
5.7.1 Downloading Data
Throughout the book, we will train and test models on various downloaded datasets. Here, we implement two utility functions for downloading and extracting zip or tar files. Again, we skip implementation details of such utility functions. def download(url, folder, sha1_hash=None): """Download a file to folder and return the local filepath.""" def extract(filename, folder): """Extract a zip/tar file into folder."""
Multilayer Perceptrons
200

5.7.2 Kaggle
Kaggle 109 is a popular platform that hosts machine learning competitions. Each com-
petition centers on a dataset and many are sponsored by stakeholders who offer prizes to the winning solutions.bubuThe platform helps users to interact via forums and shared code, fostering both collaboration and competition. While leaderboard chasing often spirals out of control, with researchers focusing myopically on preprocessing steps rather than asking fundamental questions, there is also tremendous value in the objectivity of a platform that facilitates direct quantitative comparisons among competing approaches as well as code sharing so that everyone can learn what did and did not work. If you want to participate in a Kaggle competition, you will first need to register for an account (see Fig. 5.7.1). 109
mae ie
, cs)
Q Competitions Datasets Kernels Discussion Le: ‚ÄòSign In Kaggle is the place to do data science projects ‚ÄòSign up with just one click: ‚ÄòWe wort share anything without your pemision See how it works ¬Æ i ae EAS Be Manually create an account: o¬¢ ll aoa) = ~~ > Password √©
tFig. 5.7.1
The Kaggle website. On the house price prediction competition page, as illustrated in Fig. 5.7.2, you can find the dataset (under the ‚ÄúData‚Äù tab), submit predictions, and see your ranking, The URL is right here:
https://www.kaggle.com/c/house-prices-advanced-regression-techniques
House Prices: Advanced Regression Techniques 5,012 teams - Ongoing Overview Data Kernels Discussion Leaderboard Rules Team CRTs Submit Predictions Overview Description Start here if... Evaluation You have some experience with R or Python and machine learning basics. This is a perfect competition Frequently Asked for data science students who have completed an online course in machine learning and are looking to Questions expand their skill set before trying a featured competition. Tutorials Competition Description
tFig. 5.7.2
The house price prediction competition page. 5.7.3 Accessing and Reading the Dataset
Predicting House Prices on Kaggle
201

Note that the competition data is separated into training and test sets. Each record includes the property value of the house and attributes such as street type, year of construction, roof type, basement condition, etc. The features consist of various data types. For example, the year of construction is represented by an integer, the roof type by discrete categorical assignments, and other features by floating point numbers. And here is where reality com- plicates things: for some examples, some data is altogether missing with the missing value marked simply as ‚Äúna‚Äù. The price of each house is included for the training set only (it is a competition after all). We will want to partition the training set to create a validation set, but we only get to evaluate our models on the official test set after uploading predictions to Kaggle. The ‚ÄúData‚Äù tab on the competition tab in Fig.bubu5.7.2 has links for downloading the data. To get started, we will read in and process the data using pandas, which we introduced in Section 2.2. For convenience, we can download and cache the Kaggle housing dataset. If a file corresponding to this dataset already exists in the cache directory and its SHA-1 matches sha1_hash, our code will use the cached file to avoid clogging up your Internet with redundant downloads. class KaggleHouse(d2l.DataModule): def __init__(self, batch_size, train=None, val=None): super().__init__() self.save_hyperparameters() if self.train is None: self.raw_train = pd.read_csv(d2l.download( d2l.DATA_URL + 'kaggle_house_pred_train.csv', self.root, sha1_hash='585e9cc93e70b39160e7921475f9bcd7d31219ce')) self.raw_val = pd.read_csv(d2l.download( d2l.DATA_URL + 'kaggle_house_pred_test.csv', self.root, sha1_hash='fa19780a7b011d9b009e8bff8e99922a8ee2eb90'))
Thetrainingdatasetincludes1460examples, 80features,andonelabel, whilethevalidation data contains 1459 examples and 80 features. data = KaggleHouse(batch_size=64) print(data.raw_train.shape) print(data.raw_val.shape)
Downloading ../data/kaggle_house_pred_train.csv from http://d2l-data.s3- ‚Ü©!accelerate.amazonaws.com/kaggle_house_pred_train.csv... Downloading ../data/kaggle_house_pred_test.csv from http://d2l-data.s3- ‚Ü©!accelerate.amazonaws.com/kaggle_house_pred_test.csv... (1460, 81) (1459, 80)
5.7.4 Data Preprocessing
Let‚Äôs take a look at the first four and final two features as well as the label (SalePrice) from the first four examples. Multilayer Perceptrons
202

print(data.raw_train.iloc[:4, [0, 1, 2, 3, -3, -2, -1]])
Id MSSubClass MSZoning LotFrontage SaleType SaleCondition SalePrice 0 1 60 RL 65.0 WD Normal 208500 1 2 20 RL 80.0 WD Normal 181500 2 3 60 RL 68.0 WD Normal 223500 3 4 70 RL 60.0 WD Abnorml 140000
We can see that in each example, the first feature is the identifier. This helps the model determineeachtrainingexample.bubuWhilethisisconvenient,itdoesnotcarryanyinformation for prediction purposes. Hence, we will remove it from the dataset before feeding the data into the model. Furthermore, given a wide variety of data types, we will need to preprocess the data before we can start modeling. Let‚Äôs start with the numerical features. First, we apply a heuristic, replacing all missing values by the corresponding feature‚Äôs mean. Then, to put all features on a common scale, we standardize the data by rescaling features to zero mean and unit variance:
where ùúá and ùúé denote mean and standard deviation, respectively. To verify that this indeed
where jz and o denote mean and standard deviation, respectively. To verify that this indeed transforms our feature (variable) such that it has zero mean and unit variance, note that E[~*] = ¬£* = 0 and that E[(x - )?] = (0? +p?) - 2p?bubu+?bubu= o. Intuitively, we standardize the data for two reasons. First, it proves convenient for optimization. Second, because we do not know a priori which features will be relevant, we do not want to penalize coefficients assigned to one feature more than any other. Next we deal with discrete values. These include features such as ‚ÄúMSZoning‚Äù. We replace them by a one-hot encoding in the same way that we earlier transformed multiclass labels into vectors (see Section 4.1.1). For instance, ‚ÄúMSZoning‚Äù assumes the values ‚ÄúRL‚Äù and ‚ÄúRM‚Äù. Dropping the ‚ÄúMSZoning‚Äù feature, two new indicator features ‚ÄúMSZoning_RL‚Äù and ‚ÄúMSZoning_RM‚Äù are created with values being either 0 or 1. According to one-hot encoding, if the original value of ‚ÄúMSZoning‚Äù is ‚ÄúRL‚Äù, then ‚ÄúMSZoning_RL‚Äù is 1 and ‚ÄúMSZoning_RM‚Äù is 0. The pandas package does this automatically for us. @d2l.add_to_class(KaggleHouse) def preprocess(self): # Remove the ID and label columns label = 'SalePrice' features = pd.concat( (self.raw_train.drop(columns=['Id', label]), self.raw_val.drop(columns=['Id']))) # Standardize numerical columns numeric_features = features.dtypes[features.dtypes!='object'].index features[numeric_features] = features[numeric_features].apply( lambda x: (x - x.mean()) / (x.std())) # Replace NAN numerical features by 0 features[numeric_features] = features[numeric_features].fillna(0)
xX-p
ùë• ùúé , (5.7.1)
(continues on next page)
Predicting House Prices on Kaggle
203

# Replace discrete features by one-hot encoding features = pd.get_dummies(features, dummy_na=True) # Save preprocessed features self.train = features[:self.raw_train.shape[0]].copy() self.train[label] = self.raw_train[label] self.val = features[self.raw_train.shape[0]:].copy()
You can see that this conversion increases the number of features from 79 to 331 (excluding ID and label columns). data.preprocess() data.train.shape
(1460, 331)
5.7.5 Error Measure
To get started we will train a linear model with squared loss. Not surprisingly, our linear model will not lead to a competition-winning submission but it does provide a sanity check to see whether there is meaningful information in the data. If we cannot do better than random guessing here, then there might be a good chance that we have a data processing bug. And if things work, the linear model will serve as a baseline giving us some intuition about how close the simple model gets to the best reported models, giving us a sense of how much gain we should expect from fancier models. With house prices, as with stock prices, we care about relative quantities more than ab- solute quantities. Thus we tend to care more about the relative error = than about the absolute error y ‚Äî }. For instance, if our prediction is off by $100,000 when estimating the price of a house in rural Ohio, where the value of a typical house is $125,000, then we are probably doing a horrible job. On the other hand, if we err by this amount in Los Altos Hills, California, this might represent a stunningly accurate prediction (there, the median house price exceeds $4 million). One way to address this problem is to measure the discrepancy in the logarithm of the price estimates. In fact, this is also the official error measure used by the competition to evaluate the quality of submissions. After all, a small value 6 for | log y ‚Äî log $| < 6 translates into e~¬Æ < 2 < e¬Æ, This leads to the following root-mean-squared-error between the logarithm of the predicted price and the logarithm of the label price:
vt
ae ~ >, (log yi log $1)‚Äù. (5.7.2) i=l
@d2l.add_to_class(KaggleHouse) def get_dataloader(self, train):
(continued from previous page)
(continues on next page)
Multilayer Perceptrons
204

label = 'SalePrice' data = self.train if train else self.val if label not in data: return get_tensor = lambda x: torch.tensor(x.values.astype(float), dtype=torch.float32) # Logarithm of prices tensors = (get_tensor(data.drop(columns=[label])), # X torch.log(get_tensor(data[label])).reshape((-1, 1))) # Y return self.get_tensorloader(tensors, train)
5.7.6 ùêæ-Fold Cross-Validation
You might recall that we introduced cross-validation in Section 3.6.3, where we discussed how to deal with model selection. We will put this to good use to select the model design and to adjust the hyperparameters. We first need a function that returns the ùëñth fold of the data in a ùêæ-fold cross-validation procedure. It proceeds by slicing out the ùëñth segment as validation data and returning the rest as training data. Note that this is not the most efficient way of handling data and we would definitely do something much smarter if our dataset was considerably larger. But this added complexity might obfuscate our code unnecessarily so we can safely omit it here owing to the simplicity of our problem. def k_fold_data(data, k): rets = [] fold_size = data.train.shape[0] // k for j in range(k): idx = range(j * fold_size, (j+1) * fold_size) rets.append(KaggleHouse(data.batch_size, data.train.drop(index=idx), data.train.loc[idx])) return rets
Theaveragevalidationerrorisreturnedwhenwetrainùêæ timesintheùêæ-foldcross-validation. def k_fold(trainer, data, k, lr): val_loss, models = [], [] for i, data_fold in enumerate(k_fold_data(data, k)): model = d2l.LinearRegression(lr) model.board.yscale='log' if i != 0: model.board.display = False trainer.fit(model, data_fold) val_loss.append(float(model.board.data['val_loss'][-1].y)) models.append(model) print(f'average validation log mse = {sum(val_loss)/len(val_loss)}') return models
5.7.7 Model Selection
In this example, we pick an untuned set of hyperparameters and leave it up to the reader to improve the model. Finding a good choice can take time, depending on how many variables one optimizes over. With a large enough dataset, and the normal sorts of hyperparameters,
(continued from previous page)
Predicting House Prices on Kaggle
205

ùêæ-fold cross-validation tends to be reasonably resilient against multiple testing. However,
if we try an unreasonably large number of options we might find that our validation perfor- mance is no longer representative of the true error. trainer = d2l.Trainer(max_epochs=10) models = k_fold(trainer, data, k=5, lr=0.01)
average validation log mse = 0.17325432986021042
‚Äî train_loss 1014 ==¬ª val_loss
Noticethatsometimesthenumberoftrainingerrorsforasetofhyperparameterscanbevery low, even as the number of errors on ùêæ-fold cross-validation grows considerably higher. This indicates that we are overfitting.bubuThroughout training you will want to monitor both numbers. Less overfitting might indicate that our data can support a more powerful model. Massive overfitting might suggest that we can gain by incorporating regularization tech- niques. 5.7.8 Submitting Predictions on Kaggle
Now that we know what a good choice of hyperparameters should be, we might calculate the average predictions on the test set by all the ùêæ models. Saving the predictions in a csv file will simplify uploading the results to Kaggle. The following code will generate a file called submission.csv. preds = [model(torch.tensor(data.val.values.astype(float), dtype=torch. ‚Ü©!float32)) for model in models] # Taking exponentiation of predictions in the logarithm scale ensemble_preds = torch.exp(torch.cat(preds, 1)).mean(1) submission = pd.DataFrame({'Id':data.raw_val.Id, 'SalePrice':ensemble_preds.detach().numpy()}) submission.to_csv('submission.csv', index=False)
Next, as demonstrated in Fig. 5.7.3, we can submit our predictions on Kaggle and see how they compare with the actual house prices (labels) on the test set. The steps are quite simple:
e Log in to the Kaggle website and visit the house price prediction competition page. Multilayer Perceptrons
206

e Click the ‚ÄúSubmit Predictions‚Äù or ‚ÄúLate Submission‚Äù button. e Click the ‚ÄúUpload Submission File‚Äù button in the dashed box at the bottom of the page
and select the prediction file you wish to upload. e Click the ‚ÄúMake Submission‚Äù button at the bottom of the page to view your results. Step1 Upload submission file + Upload Submission File ‚ÄòYour submission should be in CSV format. ‚ÄòWe expect the solution file to have 1459 prediction rows, This ile You can upload this in a zip/ez/rar/72 should have a header row. Please see sample submission file on archive, if you prefer.bubu‚Äòthe data page. Step2 Bl %*@o@ | SHH ~ ce) Describe submission (GES)
tFig. 5.7.3
Submitting data to Kaggle
5.7.9 Summary and Discussion
Real data often contains a mix of different data types and needs to be preprocessed. Rescal- ing real-valued data to zero mean and unit variance is a good default. So is replacing miss- ing values with their mean. Furthermore, transforming categorical features into indicator features allows us to treat them like one-hot vectors. When we tend to care more about the relative error than about the absolute error, we can measure the discrepancy in the loga- rithm of the prediction. To select the model and adjust the hyperparameters, we can use ùêæ-fold cross-validation . 5.7.10 Exercises
1. Submit your predictions for this section to Kaggle. How good are they?bubu2. Is it always a good idea to replace missing values by a mean? Hint: can you construct a situation where the values are not missing at random? 3. Improve the score by tuning the hyperparameters through ùêæ-fold cross-validation. 4. Improve the score by improving the model (e.g., layers, weight decay, and dropout). 5. What happens if we do not standardize the continuous numerical features as we have done in this section? 110
Discussions110. 6
Builders‚Äô Guide
Alongside giant datasets and powerful hardware, great software tools have played an in- dispensable role in the rapid progress of deep learning. Starting with the pathbreaking Theano library released in 2007, flexible open-source tools have enabled researchers to rapidly prototype models, avoiding repetitive work when recycling standard components while still maintaining the ability to make low-level modifications. Over time, deep learn- ing‚Äôs libraries have evolved to offer increasingly coarse abstractions. Just as semiconductor designers went from specifying transistors to logical circuits to writing code, neural net- works researchers have moved from thinking about the behavior of individual artificial neu- rons to conceiving of networks in terms of whole layers, and now often design architectures with far coarser blocks in mind. So far, we have introduced some basic machine learning concepts, ramping up to fully- functional deep learning models. In the last chapter, we implemented each component of an MLP from scratch and even showed how to leverage high-level APIs to roll out the same models effortlessly. To get you that far that fast, we called upon the libraries, but skipped over more advanced details about how they work. In this chapter, we will peel back the curtain, digging deeper into the key components of deep learning computation, namely model construction, parameter access and initialization, designing custom layers and blocks, reading and writing models to disk, and leveraging GPUs to achieve dramatic speedups. These insights will move you from end user to power user, giving you the tools neededtoreapthebenefitsofamaturedeeplearninglibrarywhileretainingtheflexibilityto implement more complex models, including those you invent yourself! While this chapter does not introduce any new models or datasets, the advanced modeling chapters that follow rely heavily on these techniques. 6.1 Layers and Modules
De
When we first introduced neural networks, we focused on linear models with a single out- put. Here, the entire model consists of just a single neuron. Note that a single neuron (i) takes some set of inputs; (ii) generates a corresponding scalar output; and (iii) has a set of associated parameters that can be updated to optimize some objective function of interest. Then, once we started thinking about networks with multiple outputs, we leveraged vec- torized arithmetic to characterize an entire layer of neurons. Just like individual neurons,
207
Builders‚Äô Guide
208

layers (i) take a set of inputs, (ii) generate corresponding outputs, and (iii) are described by a set of tunable parameters. When we worked through softmax regression, a single layer was itself the model. However, even when we subsequently introduced MLPs, we could still think of the model as retaining this same basic structure. Interestingly, for MLPs, both the entire model and its constituent layers share this structure. The entire model takes in raw inputs (the features), generates outputs (the predictions), and possesses parameters (the combined parameters from all constituent layers). Likewise, each individual layer ingests inputs (supplied by the previous layer) generates outputs (the inputs to the subsequent layer), and possesses a set of tunable parameters that are updated according to the signal that flows backwards from the subsequent layer. While you might think that neurons, layers, and models give us enough abstractions to go about our business, it turns out that we often find it convenient to speak about components that are larger than an individual layer but smaller than the entire model. For example, the ResNet-152architecture, whichiswildlypopularincomputervision, possesseshundredsof layers. These layers consist of repeating patterns of groups of layers. Implementing such a network one layer at a time can grow tedious. This concern is not just hypothetical‚Äî such design patterns are common in practice. The ResNet architecture mentioned above won the 2015 ImageNet and COCO computer vision competitions for both recognition and detection (He et al., 2016) and remains a go-to architecture for many vision tasks. Similar architectures in which layers are arranged in various repeating patterns are now ubiquitous in other domains, including natural language processing and speech. To implement these complex networks, we introduce the concept of a neural network mod- ule. A module could describe a single layer, a component consisting of multiple layers, or the entire model itself! One benefit of working with the module abstraction is that they can be combined into larger artifacts, often recursively. This is illustrated in Fig.bubu6.1.1. By defining code to generate modules of arbitrary complexity on demand, we can write surprisingly compact code and still implement complex neural networks. tFig. 6.1.1 Multiple layers are combined into modules, forming repeating patterns of larger models. From a programming standpoint, a module is represented by a class. Any subclass of it must define a forward propagation method that transforms its input into output and must store any necessary parameters. Note that some modules do not require any parameters at
Layers and Modules
209

all. Finally a module must possess a backpropagation method, for purposes of calculating gradients. Fortunately, due to some behind-the-scenes magic supplied by the auto differen- tiation (introduced in Section 2.5) when defining our own module, we only need to worry about parameters and the forward propagation method. import torch from torch import nn from torch.nn import functional as F
To begin, we revisit the code that we used to implement MLPs (Section 5.1). The follow- ing code generates a network with one fully connected hidden layer with 256 units and ReLU activation, followed by a fully connected output layer with ten units (no activation function). net = nn.Sequential(nn.LazyLinear(256), nn.ReLU(), nn.LazyLinear(10))
X = torch.rand(2, 20)
net(X).shape
torch.Size([2, 10])
In this example, we constructed our model by instantiating an nn.Sequential, with layers in the order that they should be executed passed as arguments. In short, nn.Sequential defines a special kind of Module, the class that presents a module in PyTorch. It maintains an ordered list of constituent Modules.bubuNote that each of the two fully connected layers is an instance of the Linear class which is itself a subclass of Module. The forward propagation (forward) method is also remarkably simple: it chains each module in the list together, passing the output of each as input to the next. Note that until now, we have been invok- ing our models via the construction net(X) to obtain their outputs. This is actually just shorthand for net.__call__(X). 6.1.1 A Custom Module
Perhaps the easiest way to develop intuition about how a module works is to implement one ourselves. Before we do that, we briefly summarize the basic functionality that each module must provide:
1. Ingest input data as arguments to its forward propagation method. 2. Generate an output by having the forward propagation method return a value. Note that the output may have a different shape from the input. For example, the first fully connected layer in our model above ingests an input of arbitrary dimension but returns an output of dimension 256. 3. Calculate the gradient of its output with respect to its input, which can be accessed via its backpropagation method. Typically this happens automatically.bubuBuilders‚Äô Guide
210

4. Store and provide access to those parameters necessary for executing the forward prop- agation computation. 5.bubuInitialize model parameters as needed. In the following snippet, we code up a module from scratch corresponding to an MLP with one hidden layer with 256 hidden units, and a 10-dimensional output layer. Note that the MLP class below inherits the class that represents a module. We will heavily rely on the parent class‚Äôs methods, supplying only our own constructor (the __init__ method in Python) and the forward propagation method. class MLP(nn.Module): def __init__(self): # Call the constructor of the parent class nn.Module to perform # the necessary initialization super().__init__() self.hidden = nn.LazyLinear(256) self.out = nn.LazyLinear(10) # Define the forward propagation of the model, that is, how to return the # required model output based on the input X def forward(self, X): return self.out(F.relu(self.hidden(X)))
Let‚Äôs first focus on the forward propagation method. Note that it takes X as input, calcu- lates the hidden representation with the activation function applied, and outputs its logits. In this MLP implementation, both layers are instance variables. To see why this is reason- able, imagine instantiating two MLPs, net1 and net2, and training them on different data. Naturally, we would expect them to represent two different learned models. We instantiate the MLP‚Äôs layers in the constructor and subsequently invoke these layers on each call to the forward propagation method. Note a few key details. First, our customized __init__ method invokes the parent class‚Äôs __init__ method via super().__init__() sparing us the pain of restating boilerplate code applicable to most modules. We then instantiate our two fully connected layers, assigning them to self.hidden and self.out. Note that unless we implement a new layer, we need not worry about the backpropagation method or parameter initialization. The system will generate these methods automatically. Let‚Äôs try this out. net = MLP() net(X).shape
torch.Size([2, 10])
A key virtue of the module abstraction is its versatility. We can subclass a module to create layers (such as the fully connected layer class), entire models (such as the MLP class above), or various components of intermediate complexity. We exploit this versatility throughout the coming chapters, such as when addressing convolutional neural networks. Layers and Modules
211

6.1.2 The Sequential Module
We can now take a closer look at how the Sequential class works. Recall that Sequen- tial was designed to daisy-chain other modules together. To build our own simplified MySequential, we just need to define two key methods:
1. A method for appending modules one by one to a list. 2. A forward propagation method for passing an input through the chain of modules, in the same order as they were appended. The following MySequential class delivers the same functionality of the default Sequen- tial class. class MySequential(nn.Module): def __init__(self, *args): super().__init__() for idx, module in enumerate(args): self.add_module(str(idx), module) def forward(self, X): for module in self.children(): X = module(X) return X
In the __init__ method, we add every module by calling the add_modules method. These modules can be accessed by the children method at a later date. In this way the system knows the added modules, and it will properly initialize each module‚Äôs parameters. When our MySequential‚Äôs forward propagation method is invoked, each added module is executed in the order in which they were added. We can now reimplement an MLP using our MySequential class. net = MySequential(nn.LazyLinear(256), nn.ReLU(), nn.LazyLinear(10)) net(X).shape
torch.Size([2, 10])
Note that this use of MySequential is identical to the code we previously wrote for the Sequential class (as described in Section 5.1). 6.1.3 Executing Code in the Forward Propagation Method
The Sequential class makes model construction easy, allowing us to assemble new archi- tectures without having to define our own class. However, not all architectures are simple daisy chains. When greater flexibility is required, we will want to define our own blocks. For example, we might want to execute Python‚Äôs control flow within the forward propaga- tion method. Moreover, we might want to perform arbitrary mathematical operations, not simply relying on predefined neural network layers. Builders‚Äô Guide
212

You may have noticed that until now, all of the operations in our networks have acted upon our network‚Äôs activations and its parameters. Sometimes, however, we might want to in- corporate terms that are neither the result of previous layers nor updatable parameters. We call these constant parameters. Say for example that we want a layer that calculates the function f(x, w) = c- w'x, where x is the input, w is our parameter, and c is some speci- fied constant that is not updated during optimization. So we implement a FixedHiddenMLP class as follows. class FixedHiddenMLP(nn.Module): def __init__(self): super().__init__() # Random weight parameters that will not compute gradients and # therefore keep constant during training self.rand_weight = torch.rand((20, 20)) self.linear = nn.LazyLinear(20) def forward(self, X): X = self.linear(X) X = F.relu(X @ self.rand_weight + 1) # Reuse the fully connected layer. This is equivalent to sharing # parameters with two fully connected layers X = self.linear(X) # Control flow while X.abs().sum() > 1: X /= 2 return X.sum()
In this model, we implement a hidden layer whose weights (self.rand_weight) are ini- tialized randomly at instantiation and are thereafter constant. This weight is not a model parameter and thus it is never updated by backpropagation. The network then passes the output of this ‚Äúfixed‚Äù layer through a fully connected layer. Note that before returning the output, our model did something unusual. We ran a while- loop, testing on the condition its ‚Ñì1 norm is larger than 1, and dividing our output vector by 2 until it satisfied the condition. Finally, we returned the sum of the entries in X. To our knowledge, no standard neural network performs this operation. Note that this particular operation may not be useful in any real-world task. Our point is only to show you how to integrate arbitrary code into the flow of your neural network computations. net = FixedHiddenMLP() net(X)
tensor(-0.3836, grad_fn=<SumBackward0>)
We can mix and match various ways of assembling modules together. In the following example, we nest modules in some creative ways. class NestMLP(nn.Module):
(continues on next page)
Parameter Management
213

def __init__(self): super().__init__() self.net = nn.Sequential(nn.LazyLinear(64), nn.ReLU(), nn.LazyLinear(32), nn.ReLU()) self.linear = nn.LazyLinear(16) def forward(self, X): return self.linear(self.net(X))
chimera = nn.Sequential(NestMLP(), nn.LazyLinear(20), FixedHiddenMLP()) chimera(X)
tensor(0.0679, grad_fn=<SumBackward0>)
6.1.4 Summary
Individual layers can be modules. Many layers can comprise a module.bubuMany modules can comprise a module. A module can contain code. Modules take care of lots of housekeeping, including param- eter initialization and backpropagation. Sequential concatenations of layers and modules are handled by the Sequential module. 6.1.5 Exercises
1. What kinds of problems will occur if you change MySequential to store modules in a Python list? 2. Implement a module that takes two modules as an argument, say net1 and net2 and returns the concatenated output of both networks in the forward propagation. This is also called a parallel module. 3. Assume that you want to concatenate multiple instances of the same network. Imple- ment a factory function that generates multiple instances of the same module and build a larger network from it. Discussions111. 111
6.2 Parameter Management
|
Once we have chosen an architecture and set our hyperparameters, we proceed to the train- ing loop, where our goal is to find parameter values that minimize our loss function. After training, we will need these parameters in order to make future predictions. Additionally, we will sometimes wish to extract the parameters perhaps to reuse them in some other
(continued from previous page)
Builders‚Äô Guide
214

context, to save our model to disk so that it may be executed in other software, or for ex- amination in the hope of gaining scientific understanding. Most of the time, we will be able to ignore the nitty-gritty details of how parameters are declared and manipulated, relying on deep learning frameworks to do the heavy lifting. However, when we move away from stacked architectures with standard layers, we will sometimes need to get into the weeds of declaring and manipulating parameters. In this section, we cover the following:
e Accessing parameters for debugging, diagnostics, and visualizations. e Sharing parameters across different model components. import torch from torch import nn
We start by focusing on an MLP with one hidden layer. net = nn.Sequential(nn.LazyLinear(8), nn.ReLU(), nn.LazyLinear(1)) X = torch.rand(size=(2, 4)) net(X).shape
torch.Size([2, 1])
6.2.1 Parameter Access
Let‚Äôs start with how to access parameters from the models that you already know. WhenamodelisdefinedviatheSequentialclass, wecanfirstaccessanylayerbyindexing into the model as though it were a list. Each layer‚Äôs parameters are conveniently located in its attribute. We can inspect the parameters of the second fully connected layer as follows. net[2].state_dict()
OrderedDict([('weight', tensor([[-0.1649, 0.0605, 0.1694, -0.2524, 0.3526, -0.3414, - ‚Ü©!0.2322, 0.0822]])), ('bias', tensor([0.0709]))])
We can see that this fully connected layer contains two parameters, corresponding to that layer‚Äôs weights and biases, respectively. Parameter Management
215

Targeted Parameters
Note that each parameter is represented as an instance of the parameter class.bubuTo do any- thing useful with the par                    ameters, we first need to access the underlying numerical values. There are several ways to do this.bubuSome are simpler while others are more general. The following code extracts the bias from the second neural network layer, which returns a parameter class instance, and further accesses that parameter‚Äôs value. type(net[2].bias), net[2].bias.data
(torch.nn.parameter.Parameter, tensor([0.0709]))
Parameters are complex objects, containing values, gradients, and additional information. That is why we need to request the value explicitly.bubuIn addition to the value, each parameter also allows us to access the gradient. Because we have not invoked backpropagation for this network yet, it is in its initial state. net[2].weight.grad == None
True
All Parameters at Once
When we need to perform operations on all parameters, accessing them one-by-one can grow tedious. The situation can grow especially unwieldy when we work with more com- plex, e.g., nested, modules, since we would need to recurse through the entire tree to extract each sub-module‚Äôs parameters. Below we demonstrate accessing the parameters of all lay- ers. [(name, param.shape) for name, param in net.named_parameters()]
[('0.weight', torch.Size([8, 4])), ('0.bias', torch.Size([8])), ('2.weight', torch.Size([1, 8])), ('2.bias', torch.Size([1]))]
6.2.2 Tied Parameters
Often,wewanttoshareparametersacrossmultiplelayers. Let‚Äôsseehowtodothiselegantly. In the following we allocate a fully connected layer and then use its parameters specifically to set those of another layer. Here we need to run the forward propagation net(X) before accessing the parameters. Builders‚Äô Guide
216

# We need to give the shared layer a name so that we can refer to its # parameters shared = nn.LazyLinear(8) net = nn.Sequential(nn.LazyLinear(8), nn.ReLU(), shared, nn.ReLU(), shared, nn.ReLU(), nn.LazyLinear(1)) net(X) # Check whether the parameters are the same print(net[2].weight.data[0] == net[4].weight.data[0]) net[2].weight.data[0, 0] = 100 # Make sure that they are actually the same object rather than just having the # same value print(net[2].weight.data[0] == net[4].weight.data[0])
tensor([True, True, True, True, True, True, True, True]) tensor([True, True, True, True, True, True, True, True])
This example shows that the parameters of the second and third layer are tied. They are not just equal, they are represented by the same exact tensor. Thus, if we change one of the parameters, the other one changes, too. parameters, the other one changes, too. You might wonder, when parameters are tied what happens to the gradients? Since the model parameters contain gradients, the gradients of the second hidden layer and the third hidden layer are added together during backpropagation. 6.2.3 Summary
We have several ways of accessing and tying model parameters. 6.2.4 Exercises
1. Use the NestMLP model defined in Section 6.1 and access the parameters of the various layers. 2. Construct an MLP containing a shared parameter layer and train it. During the training process, observe the model parameters and gradients of each layer. 3. Why is sharing parameters a good idea? Discussions112. 112 
6.3 Parameter Initialization
a
Now that we know how to access the parameters, let‚Äôs look at how to initialize them prop- erly. We discussed the need for proper initialization in Section 5.4. The deep learning
Parameter Initialization
217

framework provides default random initializations to its layers. However, we often want to initialize our weights according to various other protocols. The framework provides most commonly used protocols, and also allows to create a custom initializer. import torch from torch import nn
By default, PyTorch initializes weight and bias matrices uniformly by drawing from a range that is computed according to the input and output dimension. PyTorch‚Äôs nn.init module provides a variety of preset initialization methods. net = nn.Sequential(nn.LazyLinear(8), nn.ReLU(), nn.LazyLinear(1)) X = torch.rand(size=(2, 4)) net(X).shape
torch.Size([2, 1])
6.3.1 Built-in Initialization
Let‚Äôs begin by calling on built-in initializers. The code below initializes all weight parame- ters as Gaussian random variables with standard deviation 0.01, while bias parameters are cleared to zero. def init_normal(module): if type(module) == nn.Linear: nn.init.normal_(module.weight, mean=0, std=0.01) nn.init.zeros_(module.bias) net.apply(init_normal) net[0].weight.data[0], net[0].bias.data[0]
(tensor([-0.0129, -0.0007, -0.0033, 0.0276]), tensor(0.))
We can also initialize all the parameters to a given constant value (say, 1). def init_constant(module): if type(module) == nn.Linear: nn.init.constant_(module.weight, 1) nn.init.zeros_(module.bias) net.apply(init_constant) net[0].weight.data[0], net[0].bias.data[0]
(tensor([1., 1., 1., 1.]), tensor(0.))
We can also apply different initializers for certain blocks. For example, below we initialize
Builders‚Äô Guide
218

the first layer with the Xavier initializer and initialize the second layer to a constant value of 42. def init_xavier(module): if type(module) == nn.Linear: nn.init.xavier_uniform_(module.weight) def init_42(module): if type(module) == nn.Linear: nn.init.constant_(module.weight, 42) net[0].apply(init_xavier) net[2].apply(init_42) print(net[0].weight.data[0]) print(net[2].weight.data)
tensor([-0.0974, 0.1707, 0.5840, -0.5032]) tensor([[42., 42., 42., 42., 42., 42., 42., 42.]])
Custom Initialization
Sometimes, the initialization methods we need are not provided by the deep learning frame- work. In the example below, we define an initializer for any weight parameter ùë§ using the following strange distribution:
U(5, 10) with probability w~ 40 with probability U(-10,-5) with probability (6.3.1) BIR NIH Ble
Again, we implement a my_init function to apply to net. def my_init(module): if type(module) == nn.Linear: print("Init", *[(name, param.shape) for name, param in module.named_parameters()][0]) nn.init.uniform_(module.weight, -10, 10) module.weight.data *= module.weight.data.abs() >= 5 net.apply(my_init) net[0].weight[:2] Init weight torch.Size([8, 4]) Init weight torch.Size([1, 8]) tensor([[ 0.0000, -7.6364, -0.0000, -6.1206], [ 9.3516, -0.0000, 5.1208, -8.4003]], grad_fn=<SliceBackward0>)
Note that we always have the option of setting parameters directly. Lazy Initialization
219

net[0].weight.data[:] += 1 net[0].weight.data[0, 0] = 42 net[0].weight.data[0]
tensor([42.0000, -6.6364, 1.0000, -5.1206])
6.3.2 Summary
We can initialize parameters using built-in and custom initializers. 6.3.3 Exercises
Look up the online documentation for more built-in initializers.bubuDiscussions113. 113 Discussions !!,
113
Bi El
6.4 Lazy Initialization
|
So far, it might seem that we got away with being sloppy in setting up our networks. Specif- ically, we did the following unintuitive things, which might not seem like they should work:
e We defined the network architectures without specifying the input dimensionality. e We added layers without specifying the output dimension of the previous layer. e We even ‚Äúinitialized‚Äù these parameters before providing enough information to deter-
mine how many parameters our models should contain. You might be surprised that our code runs at all. After all, there is no way the deep learning framework could tell what the input dimensionality of a network would be. The trick here is that the framework defers initialization, waiting until the first time we pass data through the model, to infer the sizes of each layer on the fly. Later on, when working with convolutional neural networks, this technique will become even more convenient since the input dimensionality (e.g., the resolution of an image) will affect the dimensionality of each subsequent layer. Hence the ability to set parameters without the need to know, at the time of writing the code, the value of the dimension can greatly simplify the task of specifying and subsequently modifying our models. Next, we go deeper into the mechanics of initialization. import torch from torch import nn from d2l import torch as d2l
Builders‚Äô Guide
220

To begin, let‚Äôs instantiate an MLP. net = nn.Sequential(nn.LazyLinear(256), nn.ReLU(), nn.LazyLinear(10))
At this point, the network cannot possibly know the dimensions of the input layer‚Äôs weights because the input dimension remains unknown. Consequently the framework has not yet initialized any parameters. We confirm by at- tempting to access the parameters below. net[0].weight
<UninitializedParameter>
Next let‚Äôs pass data through the network to make the framework finally initialize parame- ters. X = torch.rand(2, 20) net(X)
net[0].weight.shape
torch.Size([256, 20])
As soon as we know the input dimensionality, 20, the framework can identify the shape of the first layer‚Äôs weight matrix by plugging in the value of 20. Having recognized the first layer‚Äôs shape, the framework proceeds to the second layer, and so on through the computa- tional graph until all shapes are known. Note that in this case, only the first layer requires lazy initialization, but the framework initializes sequentially. Once all parameter shapes are known, the framework can finally initialize the parameters. The following method passes in dummy inputs through the network for a dry run to infer all parameter shapes and subsequently initializes the parameters. It will be used later when default random initializations are not desired. @d2l.add_to_class(d2l.Module) #@save def apply_init(self, inputs, init=None): self.forward(*inputs) if init is not None: self.net.apply(init)
6.4.1 Summary
Lazy initialization can be convenient, allowing the framework to infer parameter shapes automatically, making it easy to modify architectures and eliminating one common source of errors. We can pass data through the model to make the framework finally initialize parameters. Custom Layers
221

6.4.2 Exercises
1. What happens if you specify the input dimensions to the first layer but not to subsequent layers? Do you get immediate initialization? 2. What happens if you specify mismatching dimensions? 3. What would you need to do if you have input of varying dimensionality? Hint: look at the parameter tying.bubu114 Discussions114. 6.5 Custom Layers
|
One factor behind deep learning‚Äôs success is the availability of a wide range of layers that can be composed in creative ways to design architectures suitable for a wide variety of tasks. For instance, researchers have invented layers specifically for handling images, text, looping over sequential data, and performing dynamic programming. Sooner or later, you will need a layer that does not exist yet in the deep learning framework. In these cases, you must build a custom layer.bubuIn this section, we show you how. import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
6.5.1 Layers without Parameters
To start, we construct a custom layer that does not have any parameters of its own. This should look familiar if you recall our introduction to modules in Section 6.1.bubuThe following CenteredLayer class simply subtracts the mean from its input. To build it, we simply need to inherit from the base layer class and implement the forward propagation function. class CenteredLayer(nn.Module): def __init__(self): super().__init__() def forward(self, X): return X - X.mean()
Let‚Äôs verify that our layer works as intended by feeding some data through it. layer = CenteredLayer() layer(torch.tensor([1.0, 2, 3, 4, 5]))
Builders‚Äô Guide
222

tensor([-2., -1., 0., 1., 2.])
We can now incorporate our layer as a component in constructing more complex mod- els. net = nn.Sequential(nn.LazyLinear(128), CenteredLayer())
As an extra sanity check, we can send random data through the network and check that the mean is in fact 0. Because we are dealing with floating point numbers, we may still see a very small nonzero number due to quantization. Y = net(torch.rand(4, 8)) Y.mean()
tensor(-6.5193e-09, grad_fn=<MeanBackward0>)
6.5.2 Layers with Parameters
Now that we know how to define simple layers, let‚Äôs move on to defining layers with pa- rameters that can be adjusted through training. We can use built-in functions to create parameters, which provide some basic housekeeping functionality. In particular, they gov- ern access, initialization, sharing, saving, and loading model parameters. This way, among other benefits, we will not need to write custom serialization routines for every custom layer. Now let‚Äôs implement our own version of the fully connected layer. Recall that this layer requires two parameters, one to represent the weight and the other for the bias. In this im- plementation, we bake in the ReLU activation as a default. This layer requires two input arguments: in_units and units, which denote the number of inputs and outputs, respec- tively. class MyLinear(nn.Module): def __init__(self, in_units, units): super().__init__() self.weight = nn.Parameter(torch.randn(in_units, units)) self.bias = nn.Parameter(torch.randn(units,)) def forward(self, X): linear = torch.matmul(X, self.weight.data) + self.bias.data return F.relu(linear)
Next, we instantiate the MyLinear class and access its model parameters. linear = MyLinear(5, 3) linear.weight
223

Parameter containing: tensor([[ 0.4783, 0.4284, -0.0899], [-0.6347, 0.2913, -0.0822], [-0.4325, -0.1645, -0.3274], [ 1.1898, 0.6482, -1.2384], [-0.1479, 0.0264, -0.9597]], requires_grad=True)
We can directly carry out forward propagation calculations using custom layers. linear(torch.rand(2, 5))
tensor([[0.0000, 0.9316, 0.0000], [0.1808, 1.4208, 0.0000]])
We can also construct models using custom layers. Once we have that we can use it just like the built-in fully connected layer. net = nn.Sequential(MyLinear(64, 8), MyLinear(8, 1)) net(torch.rand(2, 64))
tensor([[ 0.0000], [13.0800]])
6.5.3 Summary
We can design custom layers via the basic layer class. This allows us to define flexible new layers that behave differently from any existing layers in the library. Once defined, custom layers can be invoked in arbitrary contexts and architectures. Layers can have local parameters, which can be created through built-in functions. 6.5.4 Exercises
1. Design a layer that takes an input and computes a tensor reduction, i.e., it returns ùë¶ùëò =
Àù ùëñ, ùëó ùëäùëñùëóùëòùë•ùëñùë• ùëó. 2. Design a layer that returns the leading half of the Fourier coefficients of the data. Discussions115. 115

6.6 File I/O
eee
So far we have discussed how to process data and how to build, train, and test deep learn- ing models. However, at some point we will hopefully be happy enough with the learned
File I/O
Builders‚Äô Guide
224

models that we will want to save the results for later use in various contexts (perhaps even to make predictions in deployment). Additionally, when running a long training process, the best practice is to periodically save intermediate results (checkpointing) to ensure that we do not lose several days‚Äô worth of computation if we trip over the power cord of our server. Thus it is time to learn how to load and store both individual weight vectors and entire models.bubuThis section addresses both issues. import torch from torch import nn from torch.nn import functional as F
6.6.1 Loading and Saving Tensors
For individual tensors, we can directly invoke the load and save functions to read and write them respectively. Both functions require that we supply a name, and save requires as input the variable to be saved. x = torch.arange(4) torch.save(x, 'x-file')
We can now read the data from the stored file back into memory. x2 = torch.load('x-file') x2
tensor([0, 1, 2, 3])
We can store a list of tensors and read them back into memory. y = torch.zeros(4) torch.save([x, y],'x-files') x2, y2 = torch.load('x-files') (x2, y2)
(tensor([0, 1, 2, 3]), tensor([0., 0., 0., 0.]))
We can even write and read a dictionary that maps from strings to tensors. This is conve- nient when we want to read or write all the weights in a model. mydict = {'x': x, 'y': y} torch.save(mydict, 'mydict') mydict2 = torch.load('mydict') mydict2
225

{'x': tensor([0, 1, 2, 3]), 'y': tensor([0., 0., 0., 0.])}
6.6.2 Loading and Saving Model Parameters
Saving individual weight vectors (or other tensors) is useful, but it gets very tedious if we want to save (and later load) an entire model. After all, we might have hundreds of param- eter groups sprinkled throughout. For this reason the deep learning framework provides built-in functionalities to load and save entire networks. An important detail to note is that this saves model parameters and not the entire model. For example, if we have a 3-layer MLP, we need to specify the architecture separately. The reason for this is that the models themselves can contain arbitrary code, hence they cannot be serialized as naturally. Thus, in order to reinstate a model, we need to generate the architecture in code and then load the parameters from disk. Let‚Äôs start with our familiar MLP. class MLP(nn.Module): def __init__(self): super().__init__() self.hidden = nn.LazyLinear(256) self.output = nn.LazyLinear(10) def forward(self, x): return self.output(F.relu(self.hidden(x))) net = MLP() X = torch.randn(size=(2, 20)) Y = net(X)
Next, we store the parameters of the model as a file with the name ‚Äúmlp.params‚Äù. torch.save(net.state_dict(), 'mlp.params')
To recover the model, we instantiate a clone of the original MLP model. Instead of ran- domlyinitializingthemodelparameters,wereadtheparametersstoredinthefiledirectly. clone = MLP() clone.load_state_dict(torch.load('mlp.params')) clone.eval()
MLP( (hidden): LazyLinear(in_features=0, out_features=256, bias=True) (output): LazyLinear(in_features=0, out_features=10, bias=True) )
Since both instances have the same model parameters, the computational result of the same input X should be the same. Let‚Äôs verify this. File I/O
Builders‚Äô Guide
226

Y_clone = clone(X) Y_clone == Y
tensor([[True, True, True, True, True, True, True, True, True, True], [True, True, True, True, True, True, True, True, True, True]])
6.6.3 Summary
The save and load functions can be used to perform file I/O for tensor objects. We can save and load the entire sets of parameters for a network via a parameter dictionary.bubuSaving the architecture has to be done in code rather than in parameters. 6.6.4 Exercises
1. Even if there is no need to deploy trained models to a different device, what are the practical benefits of storing model parameters? 2. Assume that we want to reuse only parts of a network to be incorporated into a network having a different architecture. How would you go about using, say the first two layers from a previous network in a new network? 3. How would you go about saving the network architecture and parameters? What restric- tions would you impose on the architecture?bubuDiscussions116. 116
116
6.7 GPUs
Cee
In tab_intro_decade, we illustrated the rapid growth of computation over the past two decades. In a nutshell, GPU performance has increased by a factor of 1000 every decade since 2000. This offers great opportunities but it also suggests that there was significant demand for such performance. In this section, we begin to discuss how to harness this computational performance for your research. First by using a single GPU and at a later point, how to use multiple GPUs and multiple servers (with multiple GPUs). Specifically, we will discuss how to use a single NVIDIA GPU for calculations. First, make sure you have at least one NVIDIA GPU installed. Then, download the NVIDIA driver and CUDA117 and follow the prompts to set the appropriate path. Once these prepa- rations are complete, the nvidia-smi command can be used to view the graphics card information. 117
In PyTorch, every array has a device; we often refer it as a context. So far, by default, all
227

variables and associated computation have been assigned to the CPU. Typically, other con- texts might be various GPUs. Things can get even hairier when we deploy jobs across mul- tiple servers. By assigning arrays to contexts intelligently, we can minimize the time spent transferring data between devices. For example, when training neural networks on a server with a GPU, we typically prefer for the model‚Äôs parameters to live on the GPU. To run the programs in this section, you need at least two GPUs. Note that this might be extravagant for most desktop computers but it is easily available in the cloud, e.g., by using the AWS EC2 multi-GPU instances. Almost all other sections do not require multiple GPUs, but here we simply wish to illustrate data flow between different devices. import torch from torch import nn from d2l import torch as d2l
6.7.1 Computing Devices
We can specify devices, such as CPUs and GPUs, for storage and calculation. By default, tensors are created in the main memory and then the CPU is used for calculations. In PyTorch, the CPU and GPU can be indicated by torch.device('cpu') and torch. device('cuda'). It should be noted that the cpu device means all physical CPUs and memory. This means that PyTorch‚Äôs calculations will try to use all CPU cores. However, a gpu device only represents one card and the corresponding memory. If there are multiple GPUs, we use torch.device(f'cuda:{i}') to represent the ùëñth GPU (ùëñ starts at 0). Also, gpu:0 and gpu are equivalent. def cpu(): #@save """Get the CPU device.""" return torch.device('cpu') def gpu(i=0): #@save """Get a GPU device.""" return torch.device(f'cuda:{i}') cpu(), gpu(), gpu(1)
cpu(Q), gpu(), gpu(1)
(device(type='cpu'), device(type='cuda', index=0), device(type='cuda', index=1))
We can query the number of available GPUs. def num_gpus(): #@save """Get the number of available GPUs.""" return torch.cuda.device_count()
num_gpus()
GPUs
Builders‚Äô Guide
228

2
Now we define two convenient functions that allow us to run code even if the requested GPUs do not exist. def try_gpu(i=0): #@save """Return gpu(i) if exists, otherwise return cpu().""" if num_gpus() >= i + 1: return gpu(i) return cpu() def try_all_gpus(): #@save """Return all available GPUs, or [cpu(),] if no GPU exists.""" return [gpu(i) for i in range(num_gpus())] try_gpu(), try_gpu(10), try_all_gpus()
(device(type='cuda', index=0), device(type='cpu'), [device(type='cuda', index=0), device(type='cuda', index=1)])
6.7.2 Tensors and GPUs
By default, tensors are created on the CPU. We can query the device where the tensor is located. x = torch.tensor([1, 2, 3]) x.device
device(type='cpu')
It is important to note that whenever we want to operate on multiple terms, they need to be
on the same device. For instance, if we sum two tensors, we need to make sure that both arguments live on the same device‚Äîotherwise the framework would not know where to store the result or even how to decide where to perform the computation. Storage on the GPU
There are several ways to store a tensor on the GPU. For example, we can specify a stor- age device when creating a tensor. Next, we create the tensor variable X on the first gpu. The tensor created on a GPU only consumes the memory of this GPU. We can use the nvidia-smi command to view GPU memory usage. In general, we need to make sure that we do not create data that exceeds the GPU memory limit. X = torch.ones(2, 3, device=try_gpu())
X
229

tensor([[1., 1., 1.], [1., 1., 1.]], device='cuda:0')
Assuming that you have at least two GPUs, the following code will create a random tensor, Y, on the second GPU. Y = torch.rand(2, 3, device=try_gpu(1)) Y
tensor([[0.0022, 0.5723, 0.2890], [0.1456, 0.3537, 0.7359]], device='cuda:1')
If we want to compute X + Y, we need to decide where to perform this operation. For instance, as shown in Fig. 6.7.1, we can transfer X to the second GPU and perform the operation there. Do not simply add X and Y, since this will result in an exception. The runtime engine would not know what to do: it cannot find data on the same device and it fails. Since Y lives on the second GPU, we need to move X there before we can add the two. - = gpu(0) gpu(1)
tFig. 6.7.1
Copy data to perform an operation on the same device. Z = X.cuda(1) print(X) print(Z)
tensor([[1., 1., 1.], [1., 1., 1.]], device='cuda:0') tensor([[1., 1., 1.], [1., 1., 1.]], device='cuda:1')
Now that the data (both Z and Y) are on the same GPU), we can add them up. Y + Z
tensor([[1.0022, 1.5723, 1.2890], [1.1456, 1.3537, 1.7359]], device='cuda:1')
GPUs
Copying
Builders‚Äô Guide
230

But what if your variable Z already lived on your second GPU? What happens if we still call Z.cuda(1)? It will return Z instead of making a copy and allocating new memory. Z.cuda(1) is Z
True
People use GPUs to do machine learning because they expect them to be fast. But trans- ferring variables between devices is slow: much slower than computation. So we want you to be 100% certain that you want to do something slow before we let you do it. If the deep learning framework just did the copy automatically without crashing then you might not realize that you had written some slow code. Transferring data is not only slow, it also makes parallelization a lot more difficult, since we have to wait for data to be sent (or rather to be received) before we can proceed with more operations. This is why copy operations should be taken with great care. As a rule of thumb, many small operations are much worse than one big operation. Moreover, several operations at a time are much better than many single operations interspersed in the code unless you know what you are doing. This is the case since such operations can block if one device has to wait for the other before it can do something else. It is a bit like ordering your coffee in a queue rather than pre-ordering it by phone and finding out that it is ready when you are. Last, when we print tensors or convert tensors to the NumPy format, if the data is not in the main memory, the framework will copy it to the main memory first, resulting in additional transmission overhead. Even worse, it is now subject to the dreaded global interpreter lock that makes everything wait for Python to complete. 6.7.3 Neural Networks and GPUs
Similarly, a neural network model can specify devices. The following code puts the model parameters on the GPU. net = nn.Sequential(nn.LazyLinear(1)) net = net.to(device=try_gpu())
We will see many more examples of how to run models on GPUs in the following chapters, simply because the models will become somewhat more computationally intensive. For example, when the input is a tensor on the GPU, the model will calculate the result on the same GPU. net(X)
Side Notes
231

tensor([[0.7802], [0.7802]], device='cuda:0', grad_fn=<AddmmBackward0>)
Let‚Äôs confirm that the model parameters are stored on the same GPU. net[0].weight.data.device
device(type='cuda', index=0)
Let the trainer support GPU. @d2l.add_to_class(d2l.Trainer) #@save def __init__(self, max_epochs, num_gpus=0, gradient_clip_val=0): self.save_hyperparameters() self.gpus = [d2l.gpu(i) for i in range(min(num_gpus, d2l.num_gpus()))] @d2l.add_to_class(d2l.Trainer) #@save def prepare_batch(self, batch): if self.gpus: batch = [a.to(self.gpus[0]) for a in batch] return batch @d2l.add_to_class(d2l.Trainer) #@save def prepare_model(self, model): model.trainer = self model.board.xlim = [0, self.max_epochs] if self.gpus: model.to(self.gpus[0]) self.model = model
In short, as long as all data and parameters are on the same device, we can learn models efficiently. In the following chapters we will see several such examples.bubu6.7.4 Summary
We can specify devices for storage and calculation, such as the CPU or GPU. By default, data is created in the main memory and then uses the CPU for calculations. The deep learning framework requires all input data for calculation to be on the same device, be it CPU or the same GPU. You can lose significant performance by moving data without care. A typical mistake is as follows: computing the loss for every minibatch on the GPU and reporting it back to the user on the command line (or logging it in a NumPy ndarray) will trigger a global interpreter lock which stalls all GPUs. It is much better to allocate memory for logging inside the GPU and only move larger logs. 6.7.5 Exercises
1. Try a larger computation task, such as the multiplication of large matrices, and see the difference in speed between the CPU and GPU. What about a task with a small number of calculations? GPUs
Builders‚Äô Guide
232

2. How should we read and write model parameters on the GPU? 3. Measure the time it takes to compute 1000 matrix‚Äîmatrix multiplications of 100 x 100
matrices and log the Frobenius norm of the output matrix one result at a time. Compare it with keeping a log on the GPU and transferring only the final result. 4. Measure how much time it takes to perform two matrix‚Äìmatrix multiplications on two GPUs at the same time. Compare it with computing in in sequence on one GPU. Hint: you should see almost linear scaling.bubuDiscussions118. 118
7
Convolutional Neural Networks
Image data is represented as a two-dimensional grid of pixels, be the image monochro- matic or in color. Accordingly each pixel corresponds to one or multiple numerical values respectively. So far we have ignored this rich structure and treated images as vectors of numbers by flattening them, irrespective of the spatial relation between pixels. This deeply unsatisfying approach was necessary in order to feed the resulting one-dimensional vectors through a fully connected MLP. Because these networks are invariant to the order of the features, we could get similar results regardless of whether we preserve an order corresponding to the spatial structure of the pixels or if we permute the columns of our design matrix before fitting the MLP‚Äôs parameters. Ideally, we would leverage our prior knowledge that nearby pixels are typically related to each other, to build efficient models for learning from image data. This chapter introduces convolutional neural networks (CNNs) (LeCun et al., 1995), a powerful family of neural networks that are designed for precisely this purpose. CNN- based architectures are now ubiquitous in the field of computer vision. For instance, on the Imagnet collection (Deng et al., 2009) it was only the use of convolutional neural networks, in short Convnets, that provided significant performance improvements (Krizhevsky et al., 2012). Modern CNNs, as they are called colloquially, owe their design to inspirations from biol- ogy, group theory, and a healthy dose of experimental tinkering. In addition to their sample efficiency in achieving accurate models, CNNs tend to be computationally efficient, both because they require fewer parameters than fully connected architectures and because con- volutions are easy to parallelize across GPU cores (Chetlur et al., 2014). Consequently, practitioners often apply CNNs whenever possible, and increasingly they have emerged as credible competitors even on tasks with a one-dimensional sequence structure, such as audio (Abdel-Hamid et al., 2014), text (Kalchbrenner et al., 2014), and time series analy- sis (LeCun et al., 1995), where recurrent neural networks are conventionally used. Some clever adaptations of CNNs have also brought them to bear on graph-structured data (Kipf and Welling, 2016) and in recommender systems. First, we will dive more deeply into the motivation for convolutional neural networks. This is followed by a walk through the basic operations that comprise the backbone of all con- volutional networks. These include the convolutional layers themselves, nitty-gritty details including padding and stride, the pooling layers used to aggregate information across ad- jacent spatial regions, the use of multiple channels at each layer, and a careful discussion
233
Convolutional Neural Networks
234

of the structure of modern architectures. We will conclude the chapter with a full working example of LeNet, the first convolutional network successfully deployed, long before the rise of modern deep learning. In the next chapter, we will dive into full implementations of some popular and comparatively recent CNN architectures whose designs represent most of the techniques commonly used by modern practitioners. 7.1 From Fully Connected Layers to Convolutions
|
To this day, the models that we have discussed so far remain appropriate options when we are dealing with tabular data. By tabular, we mean that the data consist of rows corre- sponding to examples and columns corresponding to features. With tabular data, we might anticipate that the patterns we seek could involve interactions among the features, but we do not assume any structure a priori concerning how the features interact. Sometimes, we truly lack the knowledge to be able to guide the construction of fancier architectures. In these cases, an MLP may be the best that we can do. However, for high- dimensional perceptual data, such structureless networks can grow unwieldy. For instance, let‚Äôs return to our running example of distinguishing cats from dogs. Say that we do a thorough job in data collection, collecting an annotated dataset of one-megapixel photographs. This means that each input to the network has one million dimensions. Even an aggressive reduction to one thousand hidden dimensions would require a fully connected layer characterized by 10¬∞x 10? = 10¬∞ parameters. Unless we have lots of GPUs, a talent for distributed optimization, and an extraordinary amount of patience, learning the parameters of this network may turn out to be infeasible. A careful reader might object to this argument on the basis that one megapixel resolution may not be necessary. However, while we might be able to get away with one hundred thousand pixels, our hidden layer of size 1000 grossly underestimates the number of hid- den units that it takes to learn good representations of images, so a practical system will still require billions of parameters. Moreover, learning a classifier by fitting so many pa- rameters might require collecting an enormous dataset. And yet today both humans and computers are able to distinguish cats from dogs quite well, seemingly contradicting these intuitions. That is because images exhibit rich structure that can be exploited by humans and machine learning models alike. Convolutional neural networks (CNNs) are one cre- ative way that machine learning has embraced for exploiting some of the known structure in natural images. 7.1.1 Invariance
Imagine that we want to detect an object in an image. It seems reasonable that whatever methodweusetorecognizeobjectsshouldnotbeoverlyconcernedwiththepreciselocation of the object in the image. Ideally, our system should exploit this knowledge. Pigs usually do not fly and planes usually do not swim. Nonetheless, we should still recognize a pig
From Fully Connected Layers to Convolutions
235

were one to appear at the top of the image. We can draw some inspiration here from the children‚Äôs game ‚ÄúWhere‚Äôs Waldo‚Äù (which itself has inspired many real-life imitations, such as that depicted in Fig. 7.1.1). The game consists of a number of chaotic scenes bursting with activities. Waldo shows up somewhere in each, typically lurking in some unlikely location. The reader‚Äôs goal is to locate him. Despite his characteristic outfit, this can be surprisingly difficult, due to the large number of distractions. However, what Waldo looks like does not depend upon where Waldo is located. We could sweep the image with a Waldo detector that could assign a score to each patch, indicating the likelihood that the patch contains Waldo. In fact, many object detection and segmentation algorithms are based on this approach (Long et al., 2015). CNNs systematize this idea of spatial invariance, exploiting it to learn useful representations with fewer parameters. tFig. 7.1.1
Can you Ô¨Ånd Waldo (image courtesy of William Murphy (Infomatique))? We can now make these intuitions more concrete by enumerating a few desiderata to guide our design of a neural network architecture suitable for computer vision:
1. In the earliest layers, our network should respond similarly to the same patch, regardless of where it appears in the image. This principle is called translation invariance (or translation equivariance). 2. The earliest layers of the network should focus on local regions, without regard for the contents of the image in distant regions. This is the locality principle. Eventually, these local representations can be aggregated to make predictions at the whole image level. 3. As we proceed, deeper layers should be able to capture longer-range features of the image, in a way similar to higher level vision in nature. Let‚Äôs see how this translates into mathematics. 7.1.2 Constraining the MLP
Tostartoff, wecanconsideranMLPwithtwo-dimensionalimagesXasinputsandtheirim- mediatehiddenrepresentationsHsimilarlyrepresentedasmatrices(theyaretwo-dimensional
Convolutional Neural Networks
236

tensors in code), where both X and H have the same shape. Let that sink in. We now imagine that not only the inputs but also the hidden representations possess spatial struc- ture. Let ¬ªX‚Ä¶ùëñ, ùëó and ¬ªH‚Ä¶ùëñ, ùëó denote the pixel at location ‚Äûùëñ, ùëó‚Äù in the input image and hidden rep-
resentation, respectively. Consequently, to have each of the hidden units receive input from each of the input pixels, we would switch from using weight matrices (as we did previously in MLPs) to representing our parameters as fourth-order weight tensors W. Suppose that U contains biases, we could formally express the fully connected layer as
(HY, = (Ul + > Whip cil Xe kool 7A = [U]i7+ >) Mi ja. (Xliva,jno- er) a ob
The switch from W to V is entirely cosmetic for now since there is a one-to-one correspon- dence between coefficients in both fourth-order tensors. We simply re-index the subscripts (k, 1) such that k = i+aand/ = j + b. In other words, we set [V]i,;,a,5 = [W]i,j,i+a,j+b- The indices a and b run over both positive and negative offsets, covering the entire image. For any given location (i, j) in the hidden representation [H];,;, we compute its value by summing over pixels in x, centered around (i, j) and weighted by [V]j,;,a,p. Before we carry on, let‚Äôs consider the total number of parameters required for a single layer in this parametrization: a 1000 x 1000 image (1 megapixel) is mapped to a 1000 x 1000 hidden representation. This requires 10!?bubuparameters, far beyond what computers currently can handle. Translation Invariance
Now let‚Äôs invoke the first principle established above: translation invariance (Zhang et al., 1988). This implies that a shift in the input X should simply lead to a shift in the hidden representation H. This is only possible if V and U do not actually depend on ‚Äûùëñ, ùëó‚Äù. As such, we have ¬ªV‚Ä¶ùëñ, ùëó,ùëé,ùëè = ¬ªV‚Ä¶ùëé,ùëè and U is a constant, say ùë¢. As a result, we can simplify the definition for H:
¬ªH‚Ä¶ùëñ, ùëó = ùë¢ ‚Äö ¬ªV‚Ä¶ùëé,ùëè¬ªX‚Ä¶ùëñ‚Äöùëé, ùëó‚Äöùëè. ùëé ùëè (7.1.2)
This is a convolution! We are effectively weighting pixels at ‚Äûùëñ ‚Äö ùëé, ùëó ‚Äö ùëè‚Äù in the vicinity of
This is a convolution! We are effectively weighting pixels at (i+ a, j + b) in the vicinity of location (i, 7) with coefficients [V],,, to obtain the value [H];,;. Note that [V],,, needs many fewer coefficients than [V]j,;,a,p since it no longer depends on the location within the image. Consequently, the number of parameters required is no longer 10!? but a much more reasonable 4 x 10¬∞: we still have the dependency on a, b ‚Ç¨ (‚Äî1000, 1000). In short, we have made significant progress. Time-delay neural networks (TDNNs) are some of the first examples to exploit this idea (Waibel et al., 1989). Now let‚Äôs invoke the second principle: locality. As motivated above, we believe that we should not have to look very far away from location ‚Äûùëñ, ùëó‚Äù in order to glean relevant infor-
Locality
From Fully Connected Layers to Convolutions
237

mation to assess what is going on at ¬ªH‚Ä¶ùëñ, ùëó. This means that outside some range jùëéj > Œî or jùëèj > Œî, we should set ¬ªV‚Ä¶ùëé,ùëè = 0. Equivalently, we can rewrite ¬ªH‚Ä¶ùëñ, ùëó as
A
A A (H]ijsut D) >) (Va ol Xisa.j+o- (7.1.3) a=‚ÄîAb=-A
This reduces the number of parameters from 4x 10¬∞ to 4A?, where A is typically smaller than 10. As such, we reduced the number of parameters by another four orders of magnitude. Note that (7.1.3), is what is called, in a nutshell, a convolutional layer. Convolutional neural networks (CNNs) are a special family of neural networks that contain convolutional layers. In the deep learning research community, V is referred to as a convolution kernel, a filter, or simply the layer‚Äôs weights that are learnable parameters. While previously, we might have required billions of parameters to represent just a single layer in an image-processing network, we now typically need just a few hundred, without altering the dimensionality of either the inputs or the hidden representations. The price paid for this drastic reduction in parameters is that our features are now translation invariant and that our layer can only incorporate local information, when determining the value of each hidden activation. All learning depends on imposing inductive bias. When that bias agrees with reality, we get sample-efficient models that generalize well to unseen data. But of course, if those biases do not agree with reality, e.g., if images turned out not to be translation invariant, our models might struggle even to fit our training data. This dramatic reduction in parameters brings us to our last desideratum, namely that deeper layers should represent larger and more complex aspects of an image. This can be achieved by interleaving nonlinearities and convolutional layers repeatedly. 7.1.3 Convolutions
Let‚Äôs briefly review why (7.1.3) is called a convolution. In mathematics, the convolution between two functions (Rudin, 1973), say ùëì,ùëî : Rùëë ! R is defined as
Ur 8000 = f fae - nde. (7.1.4)
That is, we measure the overlap between ùëì and ùëî when one function is ‚Äúflipped‚Äù and shifted
by x. Whenever we have discrete objects, the integral turns into a sum. For instance, for vectors from the set of square-summable infinite-dimensional vectors with index running over Z we obtain the following definition:
(F*9@= >" flagi-a). (7.1.5)
For two-dimensional tensors, we have a corresponding sum with indices ‚Äûùëé, ùëè‚Äù for ùëì and
For two-dimensional tensors, we have a corresponding sum with indices (a, b) for f and (i ‚Äî a, j ‚Äî b) for g, respectively:
(f* iA) =>. >) fla b)gli- a,j -).bubu(7.1.6) ab
This looks similar to (7.1.3), with one major difference. Rather than using ‚Äûùëñ ‚Äö ùëé, ùëó ‚Äö ùëè‚Äù,
we are using the difference instead. Note, though, that this distinction is mostly cosmetic
A
‚Äû
Convolutional Neural Networks
238

sincewecanalwaysmatchthenotationbetween(7.1.3)and(7.1.6). Ouroriginaldefinition in (7.1.3) more properly describes a cross-correlation. We will come back to this in the following section. 7.1.4 Channels
ReturningtoourWaldodetector, let‚Äôsseewhatthislookslike. Theconvolutionallayerpicks windows of a given size and weighs intensities according to the filter V, as demonstrated in Fig. 7.1.2. We might aim to learn a model so that wherever the ‚Äúwaldoness‚Äù is highest, we should find a peak in the hidden layer representations. ¬• > 2
tFig. 7.1.2
Detect Waldo (image courtesy of William Murphy (Infomatique)). There is just one problem with this approach.bubuSo far, we blissfully ignored that images consist of three channels: red, green, and blue. In sum, images are not two-dimensional objects but rather third-order tensors, characterized by a height, width, and channel, e.g., with shape 1024 x 1024x3 pixels. While the first two of these axes concern spatial relation- ships, the third can be regarded as assigning a multidimensional representation to each pixel location. We thus index X as [X]j,;,x. The convolutional filter has to adapt accordingly. Instead of [V]a,¬ª, we now have [V] a,b,c. Moreover, just as our input consists of a third-order tensor, it turns out to be a good idea to similarly formulate our hidden representations as third-order tensors H. In other words, ratherthanjusthavingasinglehiddenrepresentationcorrespondingtoeachspatiallocation, we want an entire vector of hidden representations corresponding to each spatial location. We could think of the hidden representations as comprising a number of two-dimensional grids stacked on top of each other. As in the inputs, these are sometimes called channels. They are also sometimes called feature maps, as each provides a spatialized set of learned features for the subsequent layer. Intuitively, you might imagine that at lower layers that are closer to inputs, some channels could become specialized to recognize edges while others could recognize textures. To support multiple channels in both inputs (X) and hidden representations (H), we can add
From Fully Connected Layers to Convolutions
239

a fourth coordinate to V: ¬ªV‚Ä¶ùëé,ùëè,ùëê,ùëë. Putting everything together we have:
A
A
A A [Hina = >) >) di[V abcd Xliva,j+b.es (7.1.7) a=-Ab=-A ¬¢
where ùëë indexes the output channels in the hidden representations H. The subsequent con-
volutional layer will go on to take a third-order tensor, H, as input. We take (7.1.7), because of its generality, as the definition of a convolutional layer for multiple channels, where V is a kernel or filter of the layer. There are still many operations that we need to address. For instance, we need to figure out how to combine all the hidden representations to a single output, e.g., whether there is a Waldo anywhere in the image. We also need to decide how to compute things efficiently, how to combine multiple layers, appropriate activation functions, and how to make reason- able design choices to yield networks that are effective in practice. We turn to these issues in the remainder of the chapter. 7.1.5 Summary and Discussion
In this section we derived the structure of convolutional neural networks from first prin- ciples. While it is unclear whether this was the route taken to the invention of CNNs, it is satisfying to know that they are the right choice when applying reasonable principles to how image processing and computer vision algorithms should operate, at least at lower levels. In particular, translation invariance in images implies that all patches of an image will be treated in the same manner. Locality means that only a small neighborhood of pix- els will be used to compute the corresponding hidden representations. Some of the earliest references to CNNs are in the form of the Neocognitron (Fukushima, 1982). A second principle that we encountered in our reasoning is how to reduce the number of parameters in a function class without limiting its expressive power, at least, whenever certain assumptions on the model hold. We saw a dramatic reduction of complexity as a result of this restriction, turning computationally and statistically infeasible problems into tractable models. Addingchannelsallowedustobringbacksomeofthecomplexitythatwaslostduetothere- strictions imposed on the convolutional kernel by locality and translation invariance. Note that it is quite natural to add channels other than just red, green, and blue. Many satellite images, in particular for agriculture and meteorology, have tens to hundreds of channels, generating hyperspectral images instead. They report data on many different wavelengths. In the following we will see how to use convolutions effectively to manipulate the dimen- sionality of the images they operate on, how to move from location-based to channel-based representations, and how to deal with large numbers of categories efficiently. 7.1.6 Exercises
1. Assume that the size of the convolution kernel is Œî = 0. Show that in this case the convolution kernel implements an MLP independently for each set of channels. This leads to the Network in Network architectures (Lin et al., 2013).bubuConvolutional Neural Networks
240

2. Audio data is often represented as a one-dimensional sequence. 1. When might you want to impose locality and translation invariance for audio? 2. Derive the convolution operations for audio. 3. Can you treat audio using the same tools as computer vision? Hint: use the spectro- gram. 3. Why might translation invariance not be a good idea after all? Give an example.bubu4. Do you think that convolutional layers might also be applicable for text data? Which problems might you encounter with language?bubu5. What happens with convolutions when an object is at the boundary of an image? 6. Prove that the convolution is symmetric, ie., f * g = g* f. Discussions119. 119

7.2 Convolutions for Images
a
Now that we understand how convolutional layers work in theory, we are ready to see how they work in practice. Building on our motivation of convolutional neural networks as efficient architectures for exploring structure in image data, we stick with images as our running example. import torch from torch import nn from d2l import torch as d2l
7.2.1 The Cross-Correlation Operation
Recall that strictly speaking, convolutional layers are a misnomer, since the operations they express are more accurately described as cross-correlations. Based on our descriptions of convolutional layers in Section 7.1, in such a layer, an input tensor and a kernel tensor are combined to produce an output tensor through a cross-correlation operation. Let‚Äôs ignore channels for now and see how this works with two-dimensional data and hidden representations. In Fig. 7.2.1, the input is a two-dimensional tensor with a height of 3 and width of 3. We mark the shape of the tensor as 3 x 3 or (3, 3). The height and width of the kernel are both 2. The shape of the kernel window (or convolution window) is given by the height and width of the kernel (here it is 2 x 2). In the two-dimensional cross-correlation operation, we begin with the convolution window positioned at the upper-left corner of the input tensor and slide it across the input tensor, both from left to right and top to bottom. When the convolution window slides to a certain
Convolutions for Images
241

Input Kernel Output of1]2 o|1 19| 25 3) 4]5 * = 2/3 37| 43 e|7|s
tFig. 7.2.1
Two-dimensional cross-correlation operation. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: Ox0+1x*14+3x24+4x3=19. position, the input subtensor contained in that window and the kernel tensor are multiplied elementwise and the resulting tensor is summed up yielding a single scalar value. This result gives the value of the output tensor at the corresponding location. Here, the output tensor has a height of 2 and width of 2 and the four elements are derived from the two- dimensional cross-correlation operation:
Ox04+1x14+3x2+4x3=19, 1x04+2x1+4x24+5x3=25, 3x04+4x14+6x24+7x3 = 37, 4x04+5x14+7x2+8x3=43. (7.2.1)
Note that along each axis, the output size is slightly smaller than the input size. Because the kernel has width and height greater than 1, we can only properly compute the cross- correlation for locations where the kernel fits wholly within the image, the output size is given by the input size ny X ny minus the size of the convolution kernel kp X kw via
(ny ‚Äî ky + 1) X (ny ‚Äî kw + 1). (7.2.2)
This is the case since we need enough space to ‚Äúshift‚Äù the convolution kernel across the image. Later we will see how to keep the size unchanged by padding the image with zeros around its boundary so that there is enough space to shift the kernel. Next, we implement this process in the corr2d function, which accepts an input tensor X and a kernel tensor K and returns an output tensor Y. def corr2d(X, K): #@save """Compute 2D cross-correlation.""" h, w = K.shape Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i, j] = (X[i:i + h, j:j + w] * K).sum() return Y
We can construct the input tensor X and the kernel tensor K from Fig. 7.2.1 to validate the output of the above implementation of the two-dimensional cross-correlation opera- tion. X = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]])
(continues on next page)
Convolutional Neural Networks
242

K = torch.tensor([[0.0, 1.0], [2.0, 3.0]]) corr2d(X, K)
tensor([[19., 25.], [37., 43.]])
7.2.2 Convolutional Layers
A convolutional layer cross-correlates the input and kernel and adds a scalar bias to produce an output. The two parameters of a convolutional layer are the kernel and the scalar bias. When training models based on convolutional layers, we typically initialize the kernels randomly, just as we would with a fully connected layer. Wearenowreadytoimplement atwo-dimensionalconvolutionallayerbasedonthecorr2d function defined above. In the __init__ constructor method, we declare weight and bias as the two model parameters. The forward propagation method calls the corr2d function and adds the bias. class Conv2D(nn.Module): def __init__(self, kernel_size): super().__init__() self.weight = nn.Parameter(torch.rand(kernel_size)) self.bias = nn.Parameter(torch.zeros(1)) def forward(self, x): return corr2d(x, self.weight) + self.bias
In hxw convolution or an x w convolution kernel, the height and width of the convolution
In hxw convolution or an x w convolution kernel, the height and width of the convolution kernel are h and w, respectively. We also refer to a convolutional layer with an h x w convolution kernel simply as an h x w convolutional layer. 7.2.3 Object Edge Detection in Images
Let‚Äôs take a moment to parse a simple application of a convolutional layer: detecting the edge of an object in an image by finding the location of the pixel change. First, we construct an ‚Äúimage‚Äù of 6 x 8 pixels.bubuThe middle four columns are black (0) and the rest are white (1). X = torch.ones((6, 8)) X[:, 2:6] = 0 X
tensor([[1., 1., 0., 0., 0., 0., 1., 1.], [1., 1., 0., 0., 0., 0., 1., 1.], [1., 1., 0., 0., 0., 0., 1., 1.],
(continued from previous page)
(continues on next page)
Convolutions for Images
243

[1., 1., 0., 0., 0., 0., 1., 1.], [1., 1., 0., 0., 0., 0., 1., 1.], [1., 1., 0., 0., 0., 0., 1., 1.]])
Next, we construct a kernel K with a height of 1 and a width of 2. When we perform the cross-correlation operation with the input, if the horizontally adjacent elements are the same, the output is 0. Otherwise, the output is nonzero. Note that this kernel is a special case of a finite difference operator. At location (i, j) it computes x;,; ‚Äî x(i+1),j, ie., it computes the difference between the values of horizontally adjacent pixels. This is a discrete approximation of the first derivative in the horizontal direction. After all, for a function f (i,j) its derivative ‚Äî0;f(i, 7) = limeso LED fire) Let‚Äôs see how this works in practice. K = torch.tensor([[1.0, -1.0]])
We are ready to perform the cross-correlation operation with arguments X (our input) and K (our kernel). As you can see, we detect 1 for the edge from white to black and ‚Äî1 for the edge from black to white. All other outputs take value 0. Y = corr2d(X, K) Y
tensor([[ 0., 1., 0., 0., 0., -1., 0.], [ 0., 1., 0., 0., 0., -1., 0.], [ 0., 1., 0., 0., 0., -1., 0.], [ 0., 1., 0., 0., 0., -1., 0.], [ 0., 1., 0., 0., 0., -1., 0.], [ 0., 1., 0., 0., 0., -1., 0.]])
We can now apply the kernel to the transposed image. As expected, it vanishes. The kernel K only detects vertical edges. corr2d(X.t(), K)
tensor([[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]])
7.2.4 Learning a Kernel
(continued from previous page)
Convolutional Neural Networks
244

Designing an edge detector by finite differences [1, -1] is neat if we know this is precisely what we are looking for. However, as we look at larger kernels, and consider successive layers of convolutions, it might be impossible to specify precisely what each filter should be doing manually. Now let‚Äôs see whether we can learn the kernel that generated Y from X by looking at the input‚Äìoutput pairs only. We first construct a convolutional layer and initialize its kernel as a random tensor. Next, in each iteration, we will use the squared error to compare Y with the output of the convolutional layer. We can then calculate the gradient to update the kernel. For the sake of simplicity, in the following we use the built-in class for two-dimensional convolutional layers and ignore the bias. # Construct a two-dimensional convolutional layer with 1 output channel and a # kernel of shape (1, 2). For the sake of simplicity, we ignore the bias here conv2d = nn.LazyConv2d(1, kernel_size=(1, 2), bias=False)
# The two-dimensional convolutional layer uses four-dimensional input and # output in the format of (example, channel, height, width), where the batch # size (number of examples in the batch) and the number of channels are both 1 X = X.reshape((1, 1, 6, 8)) Y = Y.reshape((1, 1, 6, 7)) lr = 3e-2 # Learning rate for i in range(10): Y_hat = conv2d(X) l = (Y_hat - Y) ** 2 conv2d.zero_grad() l.sum().backward() # Update the kernel conv2d.weight.data[:] -= lr * conv2d.weight.grad if (i + 1) % 2 == 0: print(f'epoch {i + 1}, loss {l.sum():.3f}')
epoch 2, loss 16.481 epoch 4, loss 5.069 epoch 6, loss 1.794 epoch 8, loss 0.688 epoch 10, loss 0.274
Note that the error has dropped to a small value after 10 iterations. Now we will take a look at the kernel tensor we learned. conv2d.weight.data.reshape((1, 2))
tensor([[ 1.0398, -0.9328]])
Indeed, the learned kernel tensor is remarkably close to the kernel tensor K we defined
earlier. Convolutions for Images
245

7.2.5 Cross-Correlation and Convolution
RecallourobservationfromSection7.1ofthecorrespondencebetweenthecross-correlation and convolution operations. Here let‚Äôs continue to consider two-dimensional convolutional layers. What if such layers perform strict convolution operations as defined in (7.1.6) in- stead of cross-correlations? In order to obtain the output of the strict convolution operation, we only need to flip the two-dimensional kernel tensor both horizontally and vertically, and then perform the cross-correlation operation with the input tensor. It is noteworthy that since kernels are learned from data in deep learning, the outputs of convolutional layers remain unaffected no matter such layers perform either the strict con- volution operations or the cross-correlation operations. To illustrate this, suppose that a convolutional layer performs cross-correlation and learns the kernel in Fig. 7.2.1, which is here denoted as the matrix K. Assuming that other con- ditions remain unchanged, when this layer instead performs strict convolution, the learned kernel K0 will be the same as K after K0 is flipped both horizontally and vertically. That is to say, when the convolutional layer performs strict convolution for the input in Fig. 7.2.1 and K0, the same output in Fig. 7.2.1 (cross-correlation of the input and K) will be obtained. Inkeepingwithstandardterminologyindeeplearningliterature, wewillcontinuetoreferto the cross-correlation operation as a convolution even though, strictly-speaking, it is slightly different. Furthermore, we use the term element to refer to an entry (or component) of any tensor representing a layer representation or a convolution kernel. 7.2.6 Feature Map and Receptive Field
As described in Section 7.1.4, the convolutional layer output in Fig. 7.2.1 is sometimes called a feature map, as it can be regarded as the learned representations (features) in the spatial dimensions (e.g., width and height) to the subsequent layer. In CNNs, for any el- ement ùë• of some layer, its receptive field refers to all the elements (from all the previous layers) that may affect the calculation of ùë• during the forward propagation. Note that the receptive field may be larger than the actual size of the input. Let‚Äôs continue to use Fig. 7.2.1 to explain the receptive field. Given the 2 x 2 convolution
Let‚Äôs continue to use Fig. 7.2.1 to explain the receptive field. Given the 2 x 2 convolution kernel, the receptive field of the shaded output element (of value 19) is the four elements in the shaded portion of the input. Now let‚Äôs denote the 2 x 2 output as Y and consider a deeper CNN with an additional 2x2 convolutional layer that takes Y as its input, outputting a single element z. In this case, the receptive field of z on Y includes all the four elements of Y, while the receptive field on the input includes all the nine input elements. Thus, when any element in a feature map needs a larger receptive field to detect input features over a broader area, we can build a deeper network. Receptive fields derive their name from neurophysiology. A series of experiments on a range of animals using different stimuli (Hubel and Wiesel, 1959, Hubel and Wiesel, 1962, Hubel and Wiesel, 1968) explored the response of what is called the visual cortex on said stimuli. By and large they found that lower levels respond to edges and related shapes. Convolutional Neural Networks
246

Later on, Field (1987) illustrated this effect on natural images with, what can only be called, convolutional kernels. We reprint a key figure in Fig.bubu7.2.2 to illustrate the striking simi- larities. tFig. 7.2.2
Figure and caption taken from Field (1987): An example of coding with six different channels. (Left) Examples of the six types of sensor associated with each channel. (Right) Convolution of the image in (Middle) with the six sensors shown in (Left). The response of the individual sensors is determined by sampling these Ô¨Åltered images at a distance proportional to the size of the sensor (shown with dots). This diagram shows the response of only the even symmetric sensors. As it turns out, this relation even holds for the features computed by deeper layers of net- works trained on image classification tasks, as demonstrated in, for example, Kuzovkin et al. (2018). Suffice it to say, convolutions have proven to be an incredibly powerful tool for computer vision, both in biology and in code. As such, it is not surprising (in hindsight) that they heralded the recent success in deep learning. 7.2.7 Summary
The core computation required for a convolutional layer is a cross-correlation operation. We saw that a simple nested for-loop is all that is required to compute its value. If we have multiple input and multiple output channels, we are performing a matrix‚Äìmatrix op- eration between channels. As can be seen, the computation is straightforward and, most importantly, highly local. This affords significant hardware optimization and many recent results in computer vision are only possible because of that. After all, it means that chip designers can invest in fast computation rather than memory when it comes to optimizing for convolutions. While this may not lead to optimal designs for other applications, it does open the door to ubiquitous and affordable computer vision. Padding and Stride
247

In terms of convolutions themselves, they can be used for many purposes, for example detecting edges and lines, blurring images, or sharpening them. Most importantly, it is not necessary that the statistician (or engineer) invents suitable filters. Instead, we can simply learn them from data. This replaces feature engineering heuristics by evidence- based statistics. Lastly, and quite delightfully, these filters are not just advantageous for building deep networks but they also correspond to receptive fields and feature maps in the brain. This gives us confidence that we are on the right track.bubu7.2.8 Exercises
1. Construct an image X with diagonal edges. 1. What happens if you apply the kernel K in this section to it? 2. What happens if you transpose X? 3. What happens if you transpose K? 2. Design some kernels manually.bubu1. Given a directional vector v = (v1, v2), derive an edge-detection kernel that detects edges orthogonal to v, i.e., edges in the direction (v2, ‚Äîv)). 2. Derive a finite difference operator for the second derivative. What is the minimum size of the convolutional kernel associated with it? Which structures in images re- spond most strongly to it? 3. How would you design a blur kernel? Why might you want to use such a kernel? 4. What is the minimum size of a kernel to obtain a derivative of order ùëë? 3. When you try to automatically find the gradient for the Conv2D class we created, what kind of error message do you see? 4. How do you represent a cross-correlation operation as a matrix multiplication by chang- ing the input and kernel tensors? 120 
Discussions120. 7.3 Padding and Stride
a
Recall the example of a convolution in Fig. 7.2.1. The input had both a height and width of 3 and the convolution kernel had both a height and width of 2, yielding an output represen- tation with dimension 2 x 2. Assuming that the input shape is mp x ny and the convolution kernel shape is ky X ky, the output shape will be (mp ‚Äî kn + 1) X (ny ‚Äî kw + 1): we can only shift the convolution kernel so far until it runs out of pixels to apply the convolution to. Convolutional Neural Networks
248

In the following we will explore a number of techniques, including padding and strided convolutions, that offer more control over the size of the output. As motivation, note that since kernels generally have width and height greater than 1, after applying many successive convolutions, we tend to wind up with outputs that are considerably smaller than our input. If we start with a 240 x 240 pixel image, ten layers of 5 x 5 convolutions reduce the image to 200 x 200 pixels, slicing off 30% of the image and with it obliterating any interesting information on the boundaries of the original image. Padding is the most popular tool for handling this issue. In other cases, we may want to reduce the dimensionality drastically, e.g., if we find the original input resolution to be unwieldy. Strided convolutions are a popular technique that can help in these instances. import torch from torch import nn
7.3.1 Padding
As described above, one tricky issue when applying convolutional layers is that we tend to lose pixels on the perimeter of our image. Consider Fig. 7.3.1 that depicts the pixel utilization as a function of the convolution kernel size and the position within the image. The pixels in the corners are hardly used at all. tFig. 7.3.1
Pixel utilization for convolutions of size 1 x 1, 2 x 2, and 3 x 3 respectively. Since we typically use small kernels, for any given convolution we might only lose a few pixels but this can add up as we apply many successive convolutional layers. One straight- forward solution to this problem is to add extra pixels of filler around the boundary of our input image, thus increasing the effective size of the image. Typically, we set the values of the extra pixels to zero. In Fig. 7.3.2, we pad a 3 x 3 input, increasing its size to 5 x 5. The corresponding output then increases to a 4x4 matrix. The shaded portions are the first out- put element as well as the input and kernel tensor elements used for the output computation: 0x0+0x1+0x2+0x3=0. Kernel Output o}3|s8]4 of1 9 | 19] 25] 10 * = 2/3 21/37 | 43] 16 6|7]8]o
tFig. 7.3.2
Two-dimensional cross-correlation with padding. Padding and Stride
249

In general, if we add a total of ùëùh rows of padding (roughly half on top and half on bottom) and a total of ùëùw columns of padding (roughly half on the left and half on the right), the output shape will be
(ny ‚Äî kn + pnt 1) X (nw ‚Äî kw + pw t D)-
(7.3.1)
This means that the height and width of the output will increase by ùëùh and ùëùw, respec-
tively. In many cases, we will want to set py = kn ‚Äî 1 and py = kw ‚Äî | to give the input and output the same height and width. This will make it easier to predict the output shape of each layer when constructing the network. Assuming that kp is odd here, we will pad pp/2 rows on both sides of the height. If ky is even, one possibility is to pad [pp/2] rows on the top of the input and | p,/2] rows on the bottom. We will pad both sides of the width in the same way. CNNs commonly use convolution kernels with odd height and width values, such as 1, 3, 5, or 7. Choosing odd kernel sizes has the benefit that we can preserve the dimensionality while padding with the same number of rows on top and bottom, and the same number of columns on left and right. Moreover, this practice of using odd kernels and padding to precisely preserve dimension- ality offers a clerical benefit. For any two-dimensional tensor X, when the kernel‚Äôs size is odd and the number of padding rows and columns on all sides are the same, thereby pro- ducing an output with the same height and width as the input, we know that the output Y[i, j] is calculated by cross-correlation of the input and convolution kernel with the window centered on X[i, j]. In the following example, we create a two-dimensional convolutional layer with a height and width of 3 and apply 1 pixel of padding on all sides. Given an input with a height and width of 8, we find that the height and width of the output is also 8. # We define a helper function to calculate convolutions. It initializes the # convolutional layer weights and performs corresponding dimensionality # elevations and reductions on the input and output def comp_conv2d(conv2d, X): # (1, 1) indicates that batch size and the number of channels are both 1 X = X.reshape((1, 1) + X.shape) Y = conv2d(X) # Strip the first two dimensions: examples and channels return Y.reshape(Y.shape[2:]) # 1 row and column is padded on either side, so a total of 2 rows or columns # are added conv2d = nn.LazyConv2d(1, kernel_size=3, padding=1) X = torch.rand(size=(8, 8)) comp_conv2d(conv2d, X).shape
torch.Size([8, 8])
Convolutional Neural Networks
250

When the height and width of the convolution kernel are different, we can make the output and input have the same height and width by setting different padding numbers for height and width. # We use a convolution kernel with height 5 and width 3. The padding on either # side of the height and width are 2 and 1, respectively conv2d = nn.LazyConv2d(1, kernel_size=(5, 3), padding=(2, 1)) comp_conv2d(conv2d, X).shape
torch.Size([8, 8])
7.3.2 Stride
When computing the cross-correlation, we start with the convolution window at the upper- left corner of the input tensor, and then slide it over all locations both down and to the right. In the previous examples, we defaulted to sliding one element at a time. However, sometimes, either for computational efficiency or because we wish to downsample, we move our window more than one element at a time, skipping the intermediate locations. This is particularly useful if the convolution kernel is large since it captures a large area of the underlying image. We refer to the number of rows and columns traversed per slide as stride. So far, we have used strides of 1, both for height and width. Sometimes, we may want to use a larger stride. Fig. 7.3.3 shows a two-dimensional cross-correlation operation with a stride of 3 vertically and 2 horizontally. The shaded portions are the output elements as well as the input and kernel tensor elements used for the output computation: 0x 0+0x1+1x2+2x3=8, 0x0+6x1+0x2+0x3 = 6. We can see that when the second element of the first column is generated, the convolution window slides down three rows. The convolution window slides two columns to the right when the second element of the first row is generated. When the convolution window continues to slide two columns to the right on the input, there is no output because the input element cannot fill the window (unless we add another column of padding). Input Kernel Output
tFig. 7.3.3
Cross-correlation with strides of 3 and 2 for height and width, respectively. In general, when the stride for the height is ùë†h and the stride for the width is ùë†w, the output
shape is
L(tn ‚Äî kn + prt Sn)/Sn] X L(nw ‚Äî kw + pw + Sw)/Sw)-
If we set pn = ky ‚Äî 1 and py = ky ‚Äî 1, then the output shape can be simplified to | (mp +
(7.3.2)
Padding and Stride
251

Sn ‚Äî 1)/snJ X [(nw + Sw ‚Äî 1)/swJ. Going a step further, if the input height and width are
Sn ‚Äî 1)/snJ X [(nw + Sw ‚Äî 1)/swJ. Going a step further, if the input height and width are divisible by the strides on the height and width, then the output shape will be (7n/sn) X (nw/sw). Below, we set the strides on both the height and width to 2, thus halving the input height and width. conv2d = nn.LazyConv2d(1, kernel_size=3, padding=1, stride=2) comp_conv2d(conv2d, X).shape
torch.Size([4, 4])
Let‚Äôs look at a slightly more complicated example. conv2d = nn.LazyConv2d(1, kernel_size=(3, 5), padding=(0, 1), stride=(3, 4)) comp_conv2d(conv2d, X).shape
torch.Size([2, 2])
7.3.3 Summary and Discussion
Padding can increase the height and width of the output. This is often used to give the output the same height and width as the input to avoid undesirable shrinkage of the output.bubuMoreover, itensuresthatallpixelsareusedequallyfrequently. Typicallywepicksymmetric padding on both sides of the input height and width. In this case we refer to ‚Äûùëùh, ùëùw‚Äù padding. Most commonly we set ùëùh = ùëùw, in which case we simply state that we choose padding ùëù. A similar convention applies to strides. When horizontal stride ùë†h and vertical stride ùë†w
A similar convention applies to strides. When horizontal stride s, and vertical stride sy, match, we simply talk about stride s. The stride can reduce the resolution of the output, for example reducing the height and width of the output to only 1/n of the height and width of the input for n > 1. By default, the padding is 0 and the stride is 1. So far all padding that we discussed simply extended images with zeros. This has signif- icant computational benefit since it is trivial to accomplish. Moreover, operators can be engineered to take advantage of this padding implicitly without the need to allocate addi- tional memory. At the same time, it allows CNNs to encode implicit position information withinanimage, simplybylearningwherethe‚Äúwhitespace‚Äùis. Therearemanyalternatives to zero-padding.bubuAlsallakh et al. (2020) provided an extensive overview of those (albeit without a clear case for when to use nonzero paddings unless artifacts occur). 7.3.4 Exercises
1. Given the final code example in this section with kernel size ‚Äû3,5‚Äù, padding ‚Äû0,1‚Äù, and
stride ‚Äû3,4‚Äù, calculate the output shape to check if it is consistent with the experimental result. Convolutional Neural Networks
252

2. For audio signals, what does a stride of 2 correspond to? 3. Implement mirror padding, i.e., padding where the border values are simply mirrored to extend tensors. 4. What are the computational benefits of a stride larger than 1? 5. What might be statistical benefits of a stride larger than 1? 6. How would you implement a stride of 1 2? What does it correspond to?bubuWhen would this be useful?bubuDiscussions121. 121

7.4 Multiple Input and Multiple Output Channels
es
While we described the multiple channels that comprise each image (e.g., color images have the standard RGB channels to indicate the amount of red, green and blue) and con- volutional layers for multiple channels in Section 7.1.4, until now, we simplified all of our numerical examples by working with just a single input and a single output channel. This allowed us to think of our inputs, convolution kernels, and outputs each as two-dimensional tensors. When we add channels into the mix, our inputs and hidden representations both become three-dimensional tensors. For example, each RGB input image has shape 3 x h x w. We refer to this axis, with a size of 3, as the channel dimension. The notion of channels is as old as CNNs themselves: for instance LeNet-5 (LeCun et al., 1995) uses them. In this section, we will take a deeper look at convolution kernels with multiple input and multiple output channels. import torch from d2l import torch as d2l
7.4.1 Multiple Input Channels
When the input data contains multiple channels, we need to construct a convolution kernel with the same number of input channels as the input data, so that it can perform cross- correlation with the input data. Assuming that the number of channels for the input data is cj, the number of input channels of the convolution kernel also needs to be cj. If our convolution kernel‚Äôs window shape is ky X ky, then, when cj = 1, we can think of our convolution kernel as just a two-dimensional tensor of shape kp X kw. However, when cj > 1, we need a kernel that contains a tensor of shape kp X ky for ev-
However, when cj > 1, we need a kernel that contains a tensor of shape kp X ky for ev- ery input channel. Concatenating these cj tensors together yields a convolution kernel of shape cj X kp, X kw. Since the input and convolution kernel each have c; channels, we can
Multiple Input and Multiple Output Channels
253

perform a cross-correlation operation on the two-dimensional tensor of the input and the two-dimensional tensor of the convolution kernel for each channel, adding the ùëêi results together (summing over the channels) to yield a two-dimensional tensor. This is the result of a two-dimensional cross-correlation between a multi-channel input and a multi-input- channel convolution kernel. Fig. 7.4.1 provides an example of a two-dimensional cross-correlation with two input chan- nels. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: (1 x 1+2x2+4x3+5x4)+(0x04+1x1+ 3x2+4~x 3) =56. Input Kernel Input Kemel Output 1)2)3 1/2 4)/5]6)]* Co 3) 4 o}1]2 7{8] 9 56 | 72 ¬´(2|1h = + = 3] 4] 5 alla late 104] 120 6)7)/8 oy1 3[4]s5|* 2/3 e|7|8
tFig. 7.4.1
Cross-correlation computation with two input channels. Tomakesurewereallyunderstandwhatisgoingonhere,wecanimplementcross-correlation
operations with multiple input channels ourselves. Notice that all we are doing is perform- ing a cross-correlation operation per channel and then adding up the results. def corr2d_multi_in(X, K):
# Iterate through the 0th dimension (channel) of K first, then add them up return sum(d2l.corr2d(x, k) for x, k in zip(X, K))
We can construct the input tensor X and the kernel tensor K corresponding to the values in Fig. 7.4.1 to validate the output of the cross-correlation operation. X = torch.tensor([[[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]], [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]]) K = torch.tensor([[[0.0, 1.0], [2.0, 3.0]], [[1.0, 2.0], [3.0, 4.0]]]) corr2d_multi_in(X, K)
tensor([[ 56., 72.], [104., 120.]])
7.4.2 Multiple Output Channels
Regardless of the number of input channels, so far we always ended up with one output channel. However, as we discussed in Section 7.1.4, it turns out to be essential to have multiple channels at each layer. In the most popular neural network architectures, we actu- ally increase the channel dimension as we go deeper in the neural network, typically down- sampling to trade off spatial resolution for greater channel depth. Intuitively, you could
Convolutional Neural Networks
254

think of each channel as responding to a different set of features. The reality is a bit more complicatedthan this. Anaiveinterpretationwould suggestthat representations arelearned independently per pixel or per channel. Instead, channels are optimized to be jointly useful. This means that rather than mapping a single channel to an edge detector, it may simply mean that some direction in channel space corresponds to detecting edges. Denote by c; and c, the number of input and output channels, respectively, and by k, and ky, the height and width of the kernel. To get an output with multiple channels, we can create a kernel tensor of shape cj X kp X kw for every output channel. We concatenate them on the output channel dimension, so that the shape of the convolution kernel is cy X cj X ky X ky. In cross-correlation operations, the result on each output channel is calculated from the convolution kernel corresponding to that output channel and takes input from all channels in the input tensor. We implement a cross-correlation function to calculate the output of multiple channels as shown below. def corr2d_multi_in_out(X, K): # Iterate through the 0th dimension of K, and each time, perform # cross-correlation operations with input X. All of the results are # stacked together return torch.stack([corr2d_multi_in(X, k) for k in K], 0)
def corr2d_multi_in_out(X, K):
We construct a trivial convolution kernel with three output channels by concatenating the kernel tensor for K with K+1 and K+2. K = torch.stack((K, K + 1, K + 2), 0) K.shape
torch.Size([3, 2, 2, 2])
Below, we perform cross-correlation operations on the input tensor X with the kernel tensor K. Now the output contains three channels. The result of the first channel is consistent with the result of the previous input tensor X and the multi-input channel, single-output channel kernel. corr2d_multi_in_out(X, K)
tensor([[[ 56., 72.], [104., 120.]], [[ 76., 100.], [148., 172.]], [[ 96., 128.], [192., 224.]]])
Multiple Input and Multiple Output Channels
255

74.3 1x 1 Convolutional Layer
At first, a 1 x 1 convolution, i.e., ky = kw = 1, does not seem to make much sense. At first, a 1 x 1 convolution, i.e., ky = kw = 1, does not seem to make much sense. After all, a convolution correlates adjacent pixels. A 1 x 1 convolution obviously does not. Nonetheless, they are popular operations that are sometimes included in the designs of complex deep networks (Lin et al., 2013, Szegedy et al., 2017). Let‚Äôs see in some detail what it actually does. Because the minimum window is used, the 1 x 1 convolution loses the ability of larger con-
Because the minimum window is used, the 1 x 1 convolution loses the ability of larger con- volutional layers to recognize patterns consisting of interactions among adjacent elements in the height and width dimensions. The only computation of the 1 x 1 convolution occurs on the channel dimension. Fig. 7.4.2 shows the cross-correlation computation using the 1 x 1 convolution kernel with 3
Fig. 7.4.2 shows the cross-correlation computation using the 1 x 1 convolution kernel with 3 input channels and 2 output channels. Note that the inputs and outputs have the same height and width. Each element in the output is derived from a linear combination of elements at the same position in the input image. You could think of the 1 x 1 convolutional layer as constituting a fully connected layer applied at every single pixel location to transform the cj Corresponding input values into c, output values. Because this is still a convolutional layer, the weights are tied across pixel location. Thus the 1 x 1 convolutional layer requires Co X cj weights (plus the bias). Also note that convolutional layers are typically followed by nonlinearities. This ensures that 1 x 1 convolutions cannot simply be folded into other convolutions. Input Kernel Output
tFig. 7.4.2
The cross-correlation computation uses the 1 x 1 convolution kernel with three input
channels and two output channels. The input and output have the same height and width. Let‚Äôs check whether this works in practice: we implement a | x 1 convolution using a fully
connected layer. The only thing is that we need to make some adjustments to the data shape before and after the matrix multiplication. def corr2d_multi_in_out_1x1(X, K): c_i, h, w = X.shape c_o = K.shape[0] X = X.reshape((c_i, h * w)) K = K.reshape((c_o, c_i)) # Matrix multiplication in the fully connected layer Y = torch.matmul(K, X) return Y.reshape((c_o, h, w))
When performing | x | convolutions, the above function is equivalent to the previously im-
plemented cross-correlation function corr2d_multi_in_out. Let‚Äôs check this with some sample data. Convolutional Neural Networks
256

X = torch.normal(0, 1, (3, 3, 3)) K = torch.normal(0, 1, (2, 3, 1, 1)) Y1 = corr2d_multi_in_out_1x1(X, K) Y2 = corr2d_multi_in_out(X, K) assert float(torch.abs(Y1 - Y2).sum()) < 1e-6
7.4.4 Discussion
Channels allow us to combine the best of both worlds: MLPs that allow for significant nonlinearities and convolutions that allow for localized analysis of features. In particular, channels allow the CNN to reason with multiple features, such as edge and shape detec- tors at the same time. They also offer a practical trade-off between the drastic parameter reduction arising from translation invariance and locality, and the need for expressive and diverse models in computer vision. Note, though, that this flexibility comes at a price. Given an image of size (hx w), the cost
Note, though, that this flexibility comes at a price. Given an image of size (hx w), the cost for computing a k x k convolution is O(/- w+ k?). For c; and cy input and output channels respectively this increases to O(h¬ª w - k? - cj Co). For a 256 x 256 pixel image with a 5x5 kernel and 128 input and output channels respectively this amounts to over 53 billion operations (we count multiplications and additions separately). Later on we will encounter effective strategies to cut down on the cost, e.g., by requiring the channel-wise operations to be block-diagonal, leading to architectures such as ResNeXt (Xie et al., 2017). 7.4.5 Exercises
1. Assume that we have two convolution kernels of size ùëò1 and ùëò2, respectively (with no
nonlinearity in between). 1. Prove that the result of the operation can be expressed by a single convolution. 2. What is the dimensionality of the equivalent single convolution? 3. Is the converse true, i.e., can you always decompose a convolution into two smaller ones? 2. Assume an input of shape cj X 4 x w and a convolution kernel of shape cy x cj X kp X kw,
padding of ‚Äûùëùh, ùëùw‚Äù, and stride of ‚Äûùë†h, ùë†w‚Äù. 1. What is the computational cost (multiplications and additions) for the forward prop- agation? 2.bubuWhat is the memory footprint? 3. What is the memory footprint for the backward computation? 4. What is the computational cost for the backpropagation? 3. By what factor does the number of calculations increase if we double both the number of input channels ùëêi and the number of output channels ùëêo? What happens if we double the padding? 257

4. Are the variables Y1 and Y2 in the final example of this section exactly the same? Why?bubu5. Express convolutions as a matrix multiplication, even when the convolution window is not 1x1. 6. Your task is to implement fast convolutions with a k x k kernel. One of the algorithm
candidates is to scan horizontally across the source, reading a ùëò-wide strip and comput- ing the 1-wide output strip one value at a time. The alternative is to read a ùëò ‚Äö Œî wide strip and compute a Œî-wide output strip. Why is the latter preferable? Is there a limit to how large you should choose Œî? 7. Assume that we have ac X c matrix.bubu1. How much faster is it to multiply with a block-diagonal matrix if the matrix is broken up into ùëè blocks? 2.bubuWhat is the downside of having ùëè blocks? How could you fix it, at least partly?bubu122 
Discussions122. 7.5 Pooling

In many cases our ultimate task asks some global question about the image, e.g., does it contain a cat? Consequently, the units of our final layer should be sensitive to the entire input. By gradually aggregating information, yielding coarser and coarser maps, we ac- complish this goal of ultimately learning a global representation, while keeping all of the advantages of convolutional layers at the intermediate layers of processing. The deeper we go in the network, the larger the receptive field (relative to the input) to which each hidden node is sensitive. Reducing spatial resolution accelerates this process, since the convolution kernels cover a larger effective area. Moreover, when detecting lower-level features, such as edges (as discussed in Section 7.2), we often want our representations to be somewhat invariant to translation. For instance, if we take the image X with a sharp delineation between black and white and shift the whole image by one pixel to the right, i.e., Z[i, j] = X[i, j + 1], then the output for the new image Z might be vastly different. The edge will have shifted by one pixel. In reality, objects hardly ever occur exactly at the same place. In fact, even with a tripod and a stationary object, vibration of the camera due to the movement of the shutter might shift everything by a pixel or so (high-end cameras are loaded with special features to address this problem). This section introduces pooling layers, which serve the dual purposes of mitigating the sensitivity of convolutional layers to location and of spatially downsampling representa- tions. Pooling
Convolutional Neural Networks
258

import torch from torch import nn from d2l import torch as d2l
7.5.1 Maximum Pooling and Average Pooling
Like convolutional layers, pooling operators consist of a fixed-shape window that is slid over all regions in the input according to its stride, computing a single output for each lo- cation traversed by the fixed-shape window (sometimes known as the pooling window). However, unlike the cross-correlation computation of the inputs and kernels in the con- volutional layer, the pooling layer contains no parameters (there is no kernel). Instead, pooling operators are deterministic, typically calculating either the maximum or the aver- age value of the elements in the pooling window. These operations are called maximum pooling (max-pooling for short) and average pooling, respectively. Average pooling is essentially as old as CNNs. The idea is akin to downsampling an image. Rather than just taking the value of every second (or third) pixel for the lower resolution image, we can average over adjacent pixels to obtain an image with better signal-to-noise ratio since we are combining the information from multiple adjacent pixels. Max-pooling was introduced in Riesenhuber and Poggio (1999) in the context of cognitive neuroscience todescribehowinformationaggregationmightbeaggregatedhierarchicallyforthepurpose ofobjectrecognition; therealreadywasanearlierversioninspeechrecognition(Yamaguchi et al., 1990). In almost all cases, max-pooling, as it is also referred to, is preferable to average pooling. In both cases, as with the cross-correlation operator, we can think of the pooling window as starting from the upper-left of the input tensor and sliding across it from left to right and top to bottom. At each location that the pooling window hits, it computes the maximum or average value of the input subtensor in the window, depending on whether max or average pooling is employed. Input Output o]1]2 4]5 3[4]5 2x2 Max-pooling 7he 6|7]e
6|7]e Max-pooling with a pooling window shape of 2 x 2. The shaded portions are the first
output element as well as the input tensor elements used for the output computation: max‚Äû0,1,3,4‚Äù = 4. The output tensor in Fig. 7.5.1 has a height of 2 and a width of 2. The four elements are
259

derived from the maximum value in each pooling window:
max‚Äû0,1,3,4‚Äù = 4, max‚Äû1,2,4,5‚Äù = 5, max‚Äû3,4,6,7‚Äù = 7, max‚Äû4,5,7,8‚Äù = 8. (7.5.1)
More generally, we can define a p x qg pooling layer by aggregating over a region of said
More generally, we can define a p x qg pooling layer by aggregating over a region of said size. Returning to the problem of edge detection, we use the output of the convolutional layer as input for 2 x 2 max-pooling. Denote by X the input of the convolutional layer input and Y the pooling layer output. Regardless of whether or not the values of X[i, jJ, XLi, j + 1], XCit+1, j] and X[it+1, j + 1] are different, the pooling layer always outputs YCi, j] = 1. That is to say, using the 2 x 2 max-pooling layer, we can still detect if the pattern recognized by the convolutional layer moves no more than one element in height or width. In the code below, we implement the forwardpropagation of the pooling layer in the pool2d function. This function is similar to the corr2d function in Section 7.2. However, no kernel is needed, computing the output as either the maximum or the average of each region in the input. def pool2d(X, pool_size, mode='max'): p_h, p_w = pool_size Y = torch.zeros((X.shape[0] - p_h + 1, X.shape[1] - p_w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): if mode == 'max': Y[i, j] = X[i: i + p_h, j: j + p_w].max() elif mode == 'avg': Y[i, j] = X[i: i + p_h, j: j + p_w].mean() return Y
WecanconstructtheinputtensorXinFig.7.5.1tovalidatetheoutputofthetwo-dimensional max-pooling layer. X = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]]) pool2d(X, (2, 2))
tensor([[4., 5.], [7., 8.]])
Also, we can experiment with the average pooling layer. pool2d(X, (2, 2), 'avg')
tensor([[2., 3.], [5., 6.]])
Pooling
Convolutional Neural Networks
260

7.5.2 Padding and Stride
Aswithconvolutionallayers, poolinglayerschangetheoutputshape. Andasbefore, wecan adjust the operation to achieve a desired output shape by padding the input and adjusting the stride. We can demonstrate the use of padding and strides in pooling layers via the built-in two-dimensional max-pooling layer from the deep learning framework. We first construct an input tensor X whose shape has four dimensions, where the number of examples (batch size) and number of channels are both 1. X = torch.arange(16, dtype=torch.float32).reshape((1, 1, 4, 4)) X
tensor([[[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]]])
Since pooling aggregates information from an area, deep learning frameworks default to matching pooling window sizes and stride. For instance, if we use a pooling window of shape (3, 3) we get a stride shape of (3, 3) by default. pool2d = nn.MaxPool2d(3) # Pooling has no model parameters, hence it needs no initialization pool2d(X)
tensor([[[[10.]]]])
Needless to say, the stride and padding can be manually specified to override framework defaults if required. pool2d = nn.MaxPool2d(3, padding=1, stride=2) pool2d(X)
tensor([[[[ 5., 7.], [13., 15.]]]])
Of course, we can specify an arbitrary rectangular pooling window with arbitrary height and width respectively, as the example below shows. pool2d = nn.MaxPool2d((2, 3), stride=(2, 3), padding=(0, 1)) pool2d(X)
tensor([[[[ 5., 7.], [13., 15.]]]])
261

7.5.3 Multiple Channels
When processing multi-channel input data, the pooling layer pools each input channel sep- arately, rather than summing the inputs up over channels as in a convolutional layer. This means that the number of output channels for the pooling layer is the same as the number of input channels. Below, we will concatenate tensors X and X + 1 on the channel dimension to construct an input with two channels. X = torch.cat((X, X + 1), 1) X
tensor([[[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]], [[ 1., 2., 3., 4.], [ 5., 6., 7., 8.], [ 9., 10., 11., 12.], [13., 14., 15., 16.]]]])
As we can see, the number of output channels is still two after pooling. pool2d = nn.MaxPool2d(3, padding=1, stride=2) pool2d(X)
tensor([[[[ 5., 7.], [13., 15.]], [[ 6., 8.], [14., 16.]]]])
7.5.4 Summary
Pooling is an exceedingly simple operation. It does exactly what its name indicates, ag- gregate results over a window of values. All convolution semantics, such as strides and padding apply in the same way as they did previously. Note that pooling is indifferent to channels, i.e., it leaves the number of channels unchanged and it applies to each channel separately. Lastly, of the two popular pooling choices, max-pooling is preferable to average pooling, as it confers some degree of invariance to output. A popular choice is to pick a pooling window size of 2 x 2 to quarter the spatial resolution of output. Note that there are many more ways of reducing resolution beyond pooling. For instance, in stochastic pooling (Zeiler and Fergus, 2013) and fractional max-pooling (Graham, 2014) aggregation is combined with randomization. This can slightly improve the accuracy in some cases. Lastly, as we will see later with the attention mechanism, there are more refined ways of aggregating over outputs, e.g., by using the alignment between a query and representation vectors. Pooling
Convolutional Neural Networks
262

7.5.5 Exercises
1. Implement average pooling through a convolution. 2. Prove that max-pooling cannot be implemented through a convolution alone. 3. Max-pooling can be accomplished using ReLU operations, i.e., ReLU‚Äûùë•‚Äù = max‚Äû0,ùë•‚Äù. 1. Express max‚Äûùëé, ùëè‚Äù by using only ReLU operations. 2. Use this to implement max-pooling by means of convolutions and ReLU layers. 3. How many channels and layers do you need for a 2 x 2 convolution? How many for
3. How many channels and layers do you need for a 2 x 2 convolution? How many for a3 x 3 convolution? 4. What is the computational cost of the pooling layer? Assume that the input to the pooling layer is of size c x h x w, the pooling window has a shape of pp X pw with a padding of (Ph, Pw) and a stride of (sh, sw). 5. Why do you expect max-pooling and average pooling to work differently? 6. Do we need a separate minimum pooling layer? Can you replace it with another opera- tion? 7. We could use the softmax operation for pooling. Why might it not be so popular?bubuDiscussions123. 123

7.6 Convolutional Neural Networks (LeNet)
a
We now have all the ingredients required to assemble a fully-functional CNN. In our earlier encounter with image data, we applied a linear model with softmax regression (Section 4.4) and an MLP (Section 5.2) to pictures of clothing in the Fashion-MNIST dataset. To make such data amenable we first flattened each image from a 28 x 28 matrix into a fixed-length 784-dimensional vector, and thereafter processed them in fully connected layers. Now that we have a handle on convolutional layers, we can retain the spatial structure in our images. As an additional benefit of replacing fully connected layers with convolutional layers, we will enjoy more parsimonious models that require far fewer parameters. In this section, we will introduce LeNet, among the first published CNNs to capture wide attention for its performance on computer vision tasks. The model was introduced by (and named for) Yann LeCun, then a researcher at AT&T Bell Labs, for the purpose of rec- ognizing handwritten digits in images (LeCun et al., 1998). This work represented the culmination of a decade of research developing the technology; LeCun‚Äôs team published the first study to successfully train CNNs via backpropagation (LeCun et al., 1989). At the time LeNet achieved outstanding results matching the performance of support vector machines, then a dominant approach in supervised learning, achieving an error rate of less
Convolutional Neural Networks (LeNet)
263

than 1% per digit. LeNet was eventually adapted to recognize digits for processing deposits in ATM machines. To this day, some ATMs still run the code that Yann LeCun and his colleague Leon Bottou wrote in the 1990s! import torch from torch import nn from d2l import torch as d2l
7.6.1 LeNet
At a high level, LeNet (LeNet-5) consists of two parts: (i) a convolutional encoder consist- ing of two convolutional layers; and (ii) a dense block consisting of three fully connected layers. The architecture is summarized in Fig.bubu7.6.1. convolution pooling dense convolution pooling jense Jo [‚Äî |e ET dense 120 - FS full 84- F√© full = Out 6@14x14 4 S2 feature map 28x28 image 6@28x28 16@10x10 C1 feature map C3 feature map 1605x5 S4 feature map
tFig. 7.6.1
Data Ô¨Çow in LeNet. The input is a handwritten digit, the output is a probability over 10 possible outcomes. The basic units in each convolutional block are a convolutional layer, a sigmoid activation function, and a subsequent average pooling operation. Note that while ReLUs and max- pooling work better, they had not yet been discovered. Each convolutional layer uses a5 x5 kernel and a sigmoid activation function. These layers map spatially arranged inputs to a number of two-dimensional feature maps, typically increasing the number of channels. The first convolutional layer has 6 output channels, while the second has 16. Each 2x 2 pooling operation (stride 2) reduces dimensionality by a factor of 4 via spatial downsampling. The convolutional block emits an output with shape given by (batch size, number of channel, height, width). Inorder to pass output from the convolutional block to the dense block, wemustflatten each exampleintheminibatch. Inotherwords, wetakethisfour-dimensionalinputandtransform itinto the two-dimensionalinputexpectedbyfullyconnected layers: asareminder, thetwo- dimensional representation that we desire uses the first dimension to index examples in the minibatch and the second to give the flat vector representation of each example. LeNet‚Äôs dense block has three fully connected layers, with 120, 84, and 10 outputs, respectively. Because we are still performing classification, the 10-dimensional output layer corresponds to the number of possible output classes. Convolutional Neural Networks
264

While getting to the point where you truly understand what is going on inside LeNet may have taken a bit of work, we hope that the following code snippet will convince you that implementing such models with modern deep learning frameworks is remarkably simple. We need only to instantiate a Sequential block and chain together the appropriate layers, using Xavier initialization as introduced in Section 5.4.2. def init_cnn(module): #@save """Initialize weights for CNNs.""" if type(module) == nn.Linear or type(module) == nn.Conv2d: nn.init.xavier_uniform_(module.weight)
class LeNet(d2l.Classifier): #@save """The LeNet-5 model.""" def __init__(self, lr=0.1, num_classes=10): super().__init__() self.save_hyperparameters() self.net = nn.Sequential( nn.LazyConv2d(6, kernel_size=5, padding=2), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.LazyConv2d(16, kernel_size=5), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.LazyLinear(120), nn.Sigmoid(), nn.LazyLinear(84), nn.Sigmoid(), nn.LazyLinear(num_classes))
We have taken some liberty in the reproduction of LeNet insofar as we have replaced the Gaussian activation layer by a softmax layer. This greatly simplifies the implementation, not least due to the fact that the Gaussian decoder is rarely used nowadays.bubuOther than that, this network matches the original LeNet-5 architecture. Let‚Äôs see what happens inside the network. By passing a single-channel (black and white) 28x28 image through the network and printing the output shape at each layer, we can inspect the model to ensure that its operations line up with what we expect from Fig. 7.6.2. FC (10) t FC (84) t FC (120) == 5 x 5 Conv (16) =e 5 x 5 Conv (6), pad 2 Image (28 x 28)
tFig. 7.6.2
Compressed notation for LeNet-5. Convolutional Neural Networks (LeNet)
265

@d2l.add_to_class(d2l.Classifier) #@save def layer_summary(self, X_shape): X = torch.randn(*X_shape) for layer in self.net: X = layer(X) print(layer.__class__.__name__, 'output shape:\t', X.shape) model = LeNet() model.layer_summary((1, 1, 28, 28))
model = LeNet() model.layer_summary((1, 1, 28, 28))
Conv2d output shape:
torch.Size([1, 6, 28, 28])
torch.Size([1, 6, 28, 28]) torch.Size([1, 6, 14, 14]) torch.Size([1, 16, 10, 10]) torch.Size([1, 16, 10, 10]) torch.Size([1, 16, 5, 5]) torch.Size([1, 400]) torch.Size([1, 120]) torch.Size([1, 120]) torch.Size([1, 84]) torch.Size([1, 84]) torch.Size([1, 10])
Sigmoid output shape:
AvgPool2d output shape:
Conv2d output shape:
Sigmoid output shape:
AvgPool2d output shape:
Flatten output shape:
Linear output shape:
Sigmoid output shape:
Linear output shape:
Sigmoid output shape:
Linear output shape:
Note that the height and width of the representation at each layer throughout the convolu- tional block is reduced (compared with the previous layer). The first convolutional layer uses two pixels of padding to compensate for the reduction in height and width that would otherwise result from using a 5 x 5 kernel. As an aside, the image size of 28 x 28 pixels in the original MNIST OCR dataset is a result of trimming two pixel rows (and columns) from the original scans that measured 32 x 32 pixels. This was done primarily to save space (a 30% reduction) at a time when megabytes mattered. In contrast, the second convolutional layer forgoes padding, and thus the height and width are both reduced by four pixels. As we go up the stack of layers, the number of channels increases layer-over-layer from 1 in the input to 6 after the first convolutional layer and 16 after the second convolutional layer. However, each pooling layer halves the height and width. Finally, eachfullyconnectedlayerreducesdimensionality, finallyemittinganoutput whose dimension matches the number of classes. 7.6.2 Training
Now that we have implemented the model, let‚Äôs run an experiment to see how the LeNet-5 model fares on Fashion-MNIST. While CNNs have fewer parameters, they can still be more expensive to compute than similarly deep MLPs because each parameter participates in many more multiplications. If you have access to a GPU, this might be a good time to put it into action to speed up training. Note that the d2l.Trainer class takes care of all details. By default, it initializes the model parameters on the available devices. Just as with MLPs, our loss function is cross-entropy, and we minimize it via minibatch stochastic gradient descent. Convolutional Neural Networks
266

trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128) model = LeNet(lr=0.1) model.apply_init([next(iter(data.get_dataloader(True)))[0]], init_cnn) trainer.fit(model, data)
‚Äî train_loss 2.0 ‚Äî-- val_loss ‚Äî-- val_ace 15 1.0 0.5 wo ‚Äî c 0.0 0 2 4 6 8 10 epoch
7.6.3 Summary
We have made significant progress in this chapter. We moved from the MLPs of the 1980s to the CNNs of the 1990s and early 2000s. The architectures proposed, e.g., in the form of LeNet-5 remain meaningful, even to this day. It is worth comparing the error rates on Fashion-MNISTachievablewithLeNet-5bothtotheverybestpossiblewithMLPs(Section 5.2) and those with significantly more advanced architectures such as ResNet (Section 8.6). LeNet is much more similar to the latter than to the former. One of the primary differences, as we shall see, is that greater amounts of computation enabled significantly more complex architectures. A second difference is the relative ease with which we were able to implement LeNet. What used to be an engineering challenge worth months of C++ and assembly code, engineering to improve SN, an early Lisp-based deep learning tool (Bottou and Le Cun, 1988), and fi- nallyexperimentationwithmodelscannowbeaccomplishedinminutes. Itisthisincredible productivity boost that has democratized deep learning model development tremendously. In the next chapter we will journey down this rabbit to hole to see where it takes us.bubu7.6.4 Exercises
1. Let‚Äôs modernize LeNet. Implement and test the following changes:
1. Replace average pooling with max-pooling. 2. Replace the softmax layer with ReLU. 2. Try to change the size of the LeNet style network to improve its accuracy in addition to max-pooling and ReLU. 1. Adjust the convolution window size. 2. Adjust the number of output channels. Convolutional Neural Networks (LeNet)
267

3. Adjust the number of convolution layers. 4. Adjust the number of fully connected layers. 5. Adjust the learning rates and other training details (e.g., initialization and number of epochs). 3. Try out the improved network on the original MNIST dataset. 4. Display the activations of the first and second layer of LeNet for different inputs (e.g., sweaters and coats). 5. What happens to the activations when you feed significantly different images into the network (e.g., cats, cars, or even random noise)? Discussions124. 124

8
Modern Convolutional Neural Networks
Now that we understand the basics of wiring together CNNs, let‚Äôs take a tour of modern CNN architectures. This tour is, by necessity, incomplete, thanks to the plethora of excit- ing new designs being added. Their importance derives from the fact that not only can they be used directly for vision tasks, but they also serve as basic feature generators for more advanced tasks such as tracking (Zhang et al., 2021), segmentation (Long et al., 2015), ob- ject detection (Redmon and Farhadi, 2018), or style transformation (Gatys et al., 2016). In this chapter, most sections correspond to a significant CNN architecture that was at some point (or currently) the base model upon which many research projects and deployed sys- tems were built. Each of these networks was briefly a dominant architecture and many were winners or runners-up in the ImageNet competition 125 which has served as a barometer of progress on supervised learning in computer vision since 2010. It is only recently that Transformers have begun to displace CNNs, starting with Dosovitskiy et al. (2021) and followed by the Swin Transformer (Liu et al., 2021). We will cover this development later in Chapter 11. 125
While the idea of deep neural networks is quite simple (stack together a bunch of layers), performance can vary wildly across architectures and hyperparameter choices. The neural networks described in this chapter are the product of intuition, a few mathematical insights, and a lot of trial and error. We present these models in chronological order, partly to convey a sense of the history so that you can form your own intuitions about where the field is heading and perhaps develop your own architectures. For instance, batch normalization and residual connections described in this chapter have offered two popular ideas for training and designing deep models, both of which have since also been applied to architectures beyond computer vision. We begin our tour of modern CNNs with AlexNet (Krizhevsky et al., 2012), the first large- scale network deployed to beat conventional computer vision methods on a large-scale vi- sion challenge; the VGG network (Simonyan and Zisserman, 2014), which makes use of a numberofrepeatingblocksofelements; thenetworkinnetwork(NiN)thatconvolveswhole neural networks patch-wise over inputs (Lin et al., 2013); GoogLeNet that uses networks with multi-branch convolutions (Szegedy et al., 2015); the residual network (ResNet) (He et al., 2016), which remains one of the most popular off-the-shelf architectures in computer vision; ResNeXt blocks (Xie et al., 2017) for sparser connections; and DenseNet (Huang et al., 2017) for a generalization of the residual architecture. Over time many special opti- mizations for efficient networks have been developed, such as coordinate shifts (ShiftNet) (Wu et al., 2018). This culminated in the automatic search for efficient architectures such
268
Deep Convolutional Neural Networks (AlexNet)
269

as MobileNet v3 (Howard et al., 2019). It also includes the semi-automatic design explo- ration of Radosavovic et al. (2020) that led to the RegNetX/Y which we will discuss later in this chapter. The work is instructive insofar as it offers a path for marrying brute force computation with the ingenuity of an experimenter in the search for efficient design spaces. Of note is also the work of Liu et al. (2022) as it shows that training techniques (e.g., op- timizers, data augmentation, and regularization) play a pivotal role in improving accuracy. It also shows that long-held assumptions, such as the size of a convolution window, may need to be revisited, given the increase in computation and data. We will cover this and many more questions in due course throughout this chapter. 8.1 Deep Convolutional Neural Networks (AlexNet)

Although CNNs were well known in the computer vision and machine learning commu- nities following the introduction of LeNet (LeCun et al., 1995), they did not immediately dominate the field. Although LeNet achieved good results on early small datasets, the per- formance and feasibility of training CNNs on larger, more realistic datasets had yet to be established. In fact, for much of the intervening time between the early 1990s and the wa- tershed results of 2012 (Krizhevsky et al., 2012), neural networks were often surpassed by other machine learning methods, such as kernel methods (Sch√∂lkopf and Smola, 2002), ensemble methods (Freund and Schapire, 1996), and structured estimation (Taskar et al., 2004). For computer vision, this comparison is perhaps not entirely accurate. That is, although the inputs to convolutional networks consist of raw or lightly-processed (e.g., by center- ing) pixel values, practitioners would never feed raw pixels into traditional models. In- stead, typical computer vision pipelines consisted of manually engineering feature extrac- tion pipelines, such as SIFT (Lowe, 2004), SURF (Bay et al., 2006), and bags of visual words (Sivic and Zisserman, 2003). Rather than learning the features, the features were crafted. Most of the progress came from having more clever ideas for feature extraction on the one hand and deep insight into geometry (Hartley and Zisserman, 2000) on the other. The learning algorithm was often considered an afterthought. Although some neural network accelerators were available in the 1990s, they were not yet sufficiently powerful to make deep multichannel, multilayer CNNs with a large number of parameters. For instance, NVIDIA‚Äôs GeForce 256 from 1999 was able to process at most 480 million floating-point operations, such as additions and multiplications, per sec- ond (MFLOPS), without any meaningful programming framework for operations beyond games. Today‚Äôs accelerators are able to perform in excess of 1000 TFLOPs per device. Moreover, datasets were still relatively small: OCR on 60,000 low-resolution 28 x 28 pixel images was considered a highly challenging task. Added to these obstacles, key tricks for training neural networks including parameter initialization heuristics (Glorot and Bengio, 2010), clever variants of stochastic gradient descent (Kingma and Ba, 2014), non-squashing
Modern Convolutional Neural Networks
270

activation functions (Nair and Hinton, 2010), and effective regularization techniques (Sri- vastava et al., 2014) were still missing. Thus, rather than training end-to-end (pixel to classification) systems, classical pipelines looked more like this:
1. Obtain an interesting dataset.bubuIn the early days, these datasets required expensive sen- sors. For instance, the Apple QuickTake 100 126 of 1994 sported a whopping 0.3 megapixel(VGA)resolution,capableofstoringupto8images,allforthepriceof$1000. 126
2.bubuPreprocess the dataset with hand-crafted features based on some knowledge of optics, geometry, other analytic tools, and occasionally on the serendipitous discoveries by lucky graduate students. 3. Feed the data through a standard set of feature extractors such as the SIFT (scale- invariant feature transform) (Lowe, 2004), the SURF (speeded up robust features) (Bay et al., 2006), or any number of other hand-tuned pipelines. OpenCV still provides SIFT extractors to this day! 4. Dump the resulting representations into your favorite classifier, likely a linear model or kernel method, to train a classifier. If you spoke to machine learning researchers, they would reply that machine learning was both important and beautiful. Elegant theories proved the properties of various classifiers (Boucheron et al., 2005) and convex optimization (Boyd and Vandenberghe, 2004) had become the mainstay for obtaining them. The field of machine learning was thriving, rig- orous, and eminently useful. However, if you spoke to a computer vision researcher, you would hear a very different story. The dirty truth of image recognition, they would tell you, is that features, geometry (Hartley and Zisserman, 2000, Hartley and Kahl, 2009), and engineering, rather than novel learning algorithms, drove progress. Computer vision researchers justifiably believed that a slightly bigger or cleaner dataset or a slightly im- proved feature-extraction pipeline mattered far more to the final accuracy than any learning algorithm. import torch from torch import nn from d2l import torch as d2l
8.1.1 Representation Learning
Another way to cast the state of affairs is that the most important part of the pipeline was the representation. And up until 2012 the representation was calculated mostly mechanically.bubuIn fact, engineering a new set of feature functions, improving results, and writing up the method all featured prominently in papers. SIFT (Lowe, 2004), SURF (Bay et al., 2006), HOG (histograms of oriented gradient) (Dalal and Triggs, 2005), bags of visual words (Sivic and Zisserman, 2003), and similar feature extractors ruled the roost. Another group of researchers, including Yann LeCun, Geoff Hinton, Yoshua Bengio, An- drew Ng, Shun-ichi Amari, and Juergen Schmidhuber, had different plans. They believed
Deep Convolutional Neural Networks (AlexNet)
271

that features themselves ought to be learned. Moreover, they believed that to be reasonably complex, the features ought to be hierarchically composed with multiple jointly learned layers, each with learnable parameters. In the case of an image, the lowest layers might come to detect edges, colors, and textures, by analogy with how the visual system in ani- mals processes its input. In particular, the automatic design of visual features such as those obtained by sparse coding (Olshausen and Field, 1996) remained an open challenge until the advent of modern CNNs. It was not until Dean et al. (2012), Le (2013) that the idea of generating features from image data automatically gained significant traction. The first modern CNN (Krizhevsky et al., 2012), named AlexNet after one of its inventors, Alex Krizhevsky, is largely an evolutionary improvement over LeNet. It achieved excellent performance in the 2012 ImageNet challenge.bubutFig. 8.1.1
Image Ô¨Ålters learned by the Ô¨Årst layer of AlexNet. Reproduction courtesy of Krizhevsky et al. (2012). Interestingly, in the lowest layers of the network, the model learned feature extractors that resembled some traditional filters. Fig. 8.1.1 shows lower-level image descriptors. Higher layers in the network might build upon these representations to represent larger structures, like eyes, noses, blades of grass, and so on. Even higher layers might represent whole objects like people, airplanes, dogs, or frisbees. Ultimately, the final hidden state learns a compact representation of the image that summarizes its contents such that data belonging to different categories can be easily separated. AlexNet (2012) and its precursor LeNet (1995) share many architectural elements. This begs the question: why did it take so long? A key difference was that, over the previous two decades, the amount of data and the computing power available had increased significantly. As such AlexNet was much larger: it was trained on much more data, and on much faster GPUs compared to the CPUs available in 1995. Modern Convolutional Neural Networks
272

Missing Ingredient: Data
Deep models with many layers require large amounts of data in order to enter the regime where they significantly outperform traditional methods based on convex optimizations (e.g., linearandkernelmethods). However, giventhelimitedstoragecapacityofcomputers, the relative expense of (imaging) sensors, and the comparatively tighter research budgets in the 1990s, most research relied on tiny datasets. Numerous papers relied on the UCI collection of datasets, many of which contained only hundreds or (a few) thousands of images captured in low resolution and often with an artificially clean background. In 2009, the ImageNet dataset was released (Deng ef al., 2009), challenging researchers to learn models from 1 million examples, 1000 each from 1000 distinct categories of ob- jects. The categories themselves were based on the most popular noun nodes in WordNet (Miller, 1995). The ImageNet team used Google Image Search to prefilter large candidate sets for each category and employed the Amazon Mechanical Turk crowdsourcing pipeline to confirm for each image whether it belonged to the associated category. This scale was un- precedented, exceeding others by over an order of magnitude (e.g., CIFAR-100 has 60,000 images). Another aspect was that the images were at relatively high resolution of 224 x 224 pixels, unlike the 80 million-sized TinyImages dataset (Torralba er al., 2008), consisting of 32 x 32 pixel thumbnails. This allowed for the formation of higher-level features. The associated competition, dubbed the ImageNet Large Scale Visual Recognition Challenge (Russakovsky et al., 2015), pushed computer vision and machine learning research for- ward, challenging researchers to identify which models performed best at a greater scale than academics had previously considered. The largest vision datasets, such as LAION-5B (Schuhmann et al., 2022) contain billions of images with additional metadata. Missing Ingredient: Hardware
Deep learning models are voracious consumers of compute cycles. Training can take hun- dreds of epochs, and each iteration requires passing data through many layers of compu- tationally expensive linear algebra operations. This is one of the main reasons why in the 1990s and early 2000s, simple algorithms based on the more-efficiently optimized convex objectives were preferred. Graphical processing units (GPUs) proved to be a game changer in making deep learn- ing feasible. These chips had earlier been developed for accelerating graphics processing to benefit computer games. In particular, they were optimized for high throughput 4 x 4 matrix‚Äîvector products, which are needed for many computer graphics tasks. Fortunately, the math is strikingly similar to that required for calculating convolutional layers. Around that time, NVIDIA and ATI had begun optimizing GPUs for general computing opera- tions (Fernando, 2004), going as far as to market them as general-purpose GPUs (GPG- PUs). To provide some intuition, consider the cores of a modern microprocessor (CPU).bubuEach of the cores is fairly powerful running at a high clock frequency and sporting large caches (up to several megabytes of L3). Each core is well-suited to executing a wide range of in- structions, with branch predictors, a deep pipeline, specialized execution units, speculative
Deep Convolutional Neural Networks (AlexNet)
273

execution, and many other bells and whistles that enable it to run a large variety of pro- grams with sophisticated control flow. This apparent strength, however, is also its Achilles heel: general-purpose cores are very expensive to build. They excel at general-purpose code with lots of control flow. This requires lots of chip area, not just for the actual ALU (arithmetic logical unit) where computation happens, but also for all the aforementioned bells and whistles, plus memory interfaces, caching logic between cores, high-speed in- terconnects, and so on. CPUs are comparatively bad at any single task when compared with dedicated hardware. Modern laptops have 4‚Äì8 cores, and even high-end servers rarely exceed 64 cores per socket, simply because it is not cost-effective. By comparison, GPUs can consist of thousands of small processing elements (NIVIDA‚Äôs latestAmperechipshaveupto6912CUDAcores),oftengroupedintolargergroups(NVIDIA calls them warps). The details differ somewhat between NVIDIA, AMD, ARM and other chip vendors. While each core is relatively weak, running at about 1GHz clock frequency, it is the total number of such cores that makes GPUs orders of magnitude faster than CPUs. For instance, NVIDIA‚Äôs recent Ampere A100 GPU offers over 300 TFLOPs per chip for specialized 16-bit precision (BFLOAT16) matrix-matrix multiplications, and up to 20 TFLOPs for more general-purpose floating point operations (FP32). At the same time, floating point performance of CPUs rarely exceeds 1 TFLOPs. For instance, Ama- zon‚Äôs Graviton 3 reaches 2 TFLOPs peak performance for 16-bit precision operations, a number similar to the GPU performance of Apple‚Äôs M1 processor. There are many reasons why GPUs are much faster than CPUs in terms of FLOPs. First, power consumption tends to grow quadratically with clock frequency. Hence, for the power budget of a CPU core that runs four times faster (a typical number), you can use 16 GPU cores at + the speed, which yields 16x + = 4 times the performance. Second, GPU cores are much simpler (in fact, for a long time they were not even able to execute general-purpose code), which makes them more energy efficient. For instance, (i) they tend not to support speculative evaluation, (ii) it typically is not possible to program each processing element individually, and (iii) the caches per core tend to be much smaller. Last, many operations in deep learning require high memory bandwidth. Again, GPUs shine here with buses that are at least 10 times as wide as many CPUs. Back to 2012. A major breakthrough came when Alex Krizhevsky and Ilya Sutskever im- plemented a deep CNN that could run on GPUs. They realized that the computational bot- tlenecks in CNNs, convolutions and matrix multiplications, are all operations that could be parallelized in hardware. Using two NVIDIA GTX 580s with 3GB of memory, either of which was capable of 1.5 TFLOPs (still a challenge for most CPUs a decade later), they im- plemented fast convolutions. The cuda-convnet127 code was good enough that for several years it was the industry standard and powered the first couple of years of the deep learning boom. 127
8.1.2 AlexNet
AlexNet, which employed an 8-layer CNN, won the ImageNet Large Scale Visual Recog- nition Challenge 2012 by a large margin (Russakovsky et al., 2013). This network showed,
Modern Convolutional Neural Networks
274

for the first time, that the features obtained by learning can transcend manually-designed features, breaking the previous paradigm in computer vision. The architectures of AlexNet and LeNet are strikingly similar, as Fig.bubu8.1.2 illustrates. Note that we provide a slightly streamlined version of AlexNet removing some of the design quirks that were needed in 2012 to make the model fit on two small GPUs. FC (1000) f FC (4096) i FC (4096) ft FC (10) 3.x 3 Conv (256), pad 1 f f FC (84) 3.x 3 Conv (384), pad 1 t i FC (120) 3x3 Conv (384), pad 1 5 x 5 Conv (16) 5 x 5 Conv (256), pad 2 t ft 5x 5 Conv (6), pad 2 11 x 11 Conv (96), stride 4 i f Image (28 x 28) Image (3 x 224 x 224)
tFig. 8.1.2
From LeNet (left) to AlexNet (right).bubuThere are also significant differences between AlexNet and LeNet. First, AlexNet is much deeper than the comparatively small LeNet-5. AlexNet consists of eight layers: five con- volutional layers, two fully connected hidden layers, and one fully connected output layer. Second, AlexNet used the ReLU instead of the sigmoid as its activation function. Let‚Äôs delve into the details below. Architecture
In AlexNet‚Äôs first layer, the convolution window shape is 11 x 11. Since the images in
In AlexNet‚Äôs first layer, the convolution window shape is 11 x 11. Since the images in ImageNet are eight times taller and wider than the MNIST images, objects in ImageNet data tend to occupy more pixels with more visual detail. Consequently, a larger convolution window is needed to capture the object. The convolution window shape in the second layer is reduced to 5 x 5, followed by 3 x 3. In addition, after the first, second, and fifth convolutional layers, the network adds max-pooling layers with a window shape of 3 x 3 and a stride of 2. Moreover, AlexNet has ten times more convolution channels than LeNet. After the final convolutional layer, there are two huge fully connected layers with 4096 out- puts. These layers require nearly 1GB model parameters. Because of the limited memory
Deep Convolutional Neural Networks (AlexNet)
275

in early GPUs, the original AlexNet used a dual data stream design, so that each of their two GPUs could be responsible for storing and computing only its half of the model. Fortu- nately, GPU memory is comparatively abundant now, so we rarely need to break up models across GPUs these days (our version of the AlexNet model deviates from the original paper in this aspect). Activation Functions
Furthermore, AlexNet changed the sigmoid activation function to a simpler ReLU activa- tion function. On the one hand, the computation of the ReLU activation function is simpler. For example, it does not have the exponentiation operation found in the sigmoid activation function. On the other hand, the ReLU activation function makes model training easier when using different parameter initialization methods. This is because, when the output of the sigmoid activation function is very close to 0 or 1, the gradient of these regions is almost 0, so that backpropagation cannot continue to update some of the model parameters. By contrast, the gradient of the ReLU activation function in the positive interval is always 1 (Section 5.1.2). Therefore, if the model parameters are not properly initialized, the sigmoid function may obtain a gradient of almost 0 in the positive interval, meaning that the model cannot be effectively trained. Capacity Control and Preprocessing
AlexNet controls the model complexity of the fully connected layer by dropout (Section 5.6), while LeNet only uses weight decay. To augment the data even further, the training loop of AlexNet added a great deal of image augmentation, such as flipping, clipping, and color changes. This makes the model more robust and the larger sample size effectively reduces overfitting. See Buslaev et al.bubu(2020) for an in-depth review of such preprocessing steps. class AlexNet(d2l.Classifier): def __init__(self, lr=0.1, num_classes=10): super().__init__() self.save_hyperparameters() self.net = nn.Sequential( nn.LazyConv2d(96, kernel_size=11, stride=4, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), nn.LazyConv2d(256, kernel_size=5, padding=2), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), nn.LazyConv2d(384, kernel_size=3, padding=1), nn.ReLU(), nn.LazyConv2d(384, kernel_size=3, padding=1), nn.ReLU(), nn.LazyConv2d(256, kernel_size=3, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), nn.Flatten(), nn.LazyLinear(4096), nn.ReLU(), nn.Dropout(p=0.5), nn.LazyLinear(4096), nn.ReLU(),nn.Dropout(p=0.5), nn.LazyLinear(num_classes)) self.net.apply(d2l.init_cnn)
We construct a single-channel data example with both height and width of 224 to observe the output shape of each layer. It matches the AlexNet architecture in Fig. 8.1.2. Modern Convolutional Neural Networks
276

AlexNet().layer_summary((1, 1, 224, 224))
Conv2d output shape: torch.Size([1, 96, 54, 54]) ReLU output shape: torch.Size([1, 96, 54, 54]) MaxPool2d output shape: torch.Size([1, 96, 26, 26]) Conv2d output shape: torch.Size([1, 256, 26, 26]) ReLU output shape: torch.Size([1, 256, 26, 26]) MaxPool2d output shape: torch.Size([1, 256, 12, 12]) Conv2d output shape: torch.Size([1, 384, 12, 12]) ReLU output shape: torch.Size([1, 384, 12, 12]) Conv2d output shape: torch.Size([1, 384, 12, 12]) ReLU output shape: torch.Size([1, 384, 12, 12]) Conv2d output shape: torch.Size([1, 256, 12, 12]) ReLU output shape: torch.Size([1, 256, 12, 12]) MaxPool2d output shape: torch.Size([1, 256, 5, 5]) Flatten output shape: torch.Size([1, 6400]) Linear output shape: torch.Size([1, 4096]) ReLU output shape: torch.Size([1, 4096]) Dropout output shape: torch.Size([1, 4096]) Linear output shape: torch.Size([1, 4096]) ReLU output shape: torch.Size([1, 4096]) Dropout output shape: torch.Size([1, 4096]) Linear output shape: torch.Size([1, 10])
8.1.3 Training
Although AlexNet was trained on ImageNet in Krizhevsky et al. (2012), we use Fashion- MNIST here since training an ImageNet model to convergence could take hours or days even on a modern GPU. One of the problems with applying AlexNet directly on Fashion- MNIST is that its images have lower resolution (28 x 28 pixels) than ImageNet images. To make things work, we upsample them to 224x224. This is generally not a smart practice, as it simply increases the computational complexity without adding information. Nonetheless, we do it here to be faithful to the AlexNet architecture. We perform this resizing with the resize argument in the d21.FashionMNIST constructor. Now, we can start training AlexNet. Compared to LeNet in Section 7.6, the main change here is the use of a smaller learning rate and much slower training due to the deeper and wider network, the higher image resolution, and the more costly convolutions. model = AlexNet(lr=0.01) data = d2l.FashionMNIST(batch_size=128, resize=(224, 224)) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) trainer.fit(model, data)
8.1.4 Discussion
AlexNet‚Äôs structure bears a striking resemblance to LeNet, with a number of critical im- provements, both for accuracy (dropout) and for ease of training (ReLU). What is equally striking is the amount of progress that has been made in terms of deep learning tooling. Deep Convolutional Neural Networks (AlexNet)
277

‚Äî train_loss 2.0 ‚Äî-- val_loss ‚Äî-- val_acc 15 1.0 0.5 Cc a - 0.0 0 2 4 6 8 10
What was several months of work in 2012 can now be accomplished in a dozen lines of code using any modern framework. Reviewing the architecture, we see that AlexNet has an Achilles heel when it comes to effi- ciency: the last two hidden layers require matrices of size 6400 x 4096 and 4096 x 4096, re- spectively. This corresponds to 164 MB of memory and 81 MFLOPs of computation, both of which are a nontrivial outlay, especially on smaller devices, such as mobile phones. This is one of the reasons why AlexNet has been surpassed by much more effective architectures that we will cover in the following sections. Nonetheless, it is a key step from shallow to deep networks that are used nowadays. Note that even though the number of parameters exceeds by far the amount of training data in our experiments (the last two layers have more than 40 million parameters, trained on a datasets of 60 thousand images), there is hardly any overfitting: training and validation loss are virtually identical throughout training. This is due to the improved regularization, such as dropout, inherent in modern deep network designs. Although it seems that there are only a few more lines in AlexNet‚Äôs implementation than in LeNet‚Äôs, it took the academic community many years to embrace this conceptual change and take advantage of its excellent experimental results. This was also due to the lack of efficient computational tools. At the time neither DistBelief (Dean et al., 2012) nor Caffe (Jia et al., 2014) existed, and Theano (Bergstra et al., 2010) still lacked many distinguishing features. ItwastheavailabilityofTensorFlow(Abadietal.,2016)thatdramaticallychanged the situation. 8.1.5 Exercises
1. Following up on the discussion above, analyze the computational properties of AlexNet. 1. Compute the memory footprint for convolutions and fully connected layers, respec- tively. Which one dominates? 2. Calculate the computational cost for the convolutions and the fully connected layers. 3. How does the memory (read and write bandwidth, latency, size) affect computation? Is there any difference in its effects for training and inference? 2. You are a chip designer and need to trade off computation and memory bandwidth. For example, a faster chip requires more power and possibly a larger chip area. More
Modern Convolutional Neural Networks
278

memory bandwidth requires more pins and control logic, thus also more area. How do you optimize?bubu3. Why do engineers no longer report performance benchmarks on AlexNet? 4. Try increasing the number of epochs when training AlexNet. Compared with LeNet, how do the results differ? Why?bubu5. AlexNet may be too complex for the Fashion-MNIST dataset, in particular due to the low resolution of the initial images. 1.bubuTry simplifying the model to make the training faster, while ensuring that the accu- racy does not drop significantly. 2. Design a better model that works directly on 28 x 28 images. 6. Modify the batch size, and observe the changes in throughput (images/s), accuracy, and GPU memory. 7. Apply dropout and ReLU to LeNet-5. Does it improve?bubuCan you improve things further by preprocessing to take advantage of the invariances inherent in the images? 8. Can you make AlexNet overfit? Which feature do you need to remove or change to break training? Discussions128. 128

8.2 Networks Using Blocks (VGG)
a
While AlexNet offered empirical evidence that deep CNNs can achieve good results, it did not provide a general template to guide subsequent researchers in designing new networks. In the following sections, we will introduce several heuristic concepts commonly used to design deep networks. ProgressinthisfieldmirrorsthatofVLSI(verylargescaleintegration)inchipdesignwhere engineers moved from placing transistors to logical elements to logic blocks (Mead, 1980). Similarly, thedesignofneuralnetworkarchitectureshasgrownprogressivelymoreabstract, with researchers moving from thinking in terms of individual neurons to whole layers, and now to blocks, repeating patterns of layers. A decade later, this has now progressed to researchers using entire trained models to repurpose them for different, albeit related, tasks. Such large pretrained models are typically called foundation models (Bommasani et al., 2021). Back to network design. The idea of using blocks first emerged from the Visual Geometry Group (VGG) at Oxford University, in their eponymously-named VGG network (Simonyan and Zisserman, 2014). It is easy to implement these repeated structures in code with any modern deep learning framework by using loops and subroutines. Networks Using Blocks (VGG)
279

import torch from torch import nn from d2l import torch as d2l
8.2.1 VGG Blocks
The basic building block of CNNs is a sequence of the following: (i) a convolutional layer with padding to maintain the resolution, (ii) a nonlinearity such as a ReLU, (iii) a pooling layer such as max-pooling to reduce the resolution. One of the problems with this approach is that the spatial resolution decreases quite rapidly. In particular, this imposes a hard limit of log2 ùëë convolutional layers on the network before all dimensions (ùëë) are used up. For instance, in the case of ImageNet, it would be impossible to have more than 8 convolutional layers in this way. The key idea of Simonyan and Zisserman (2014) was to use multiple convolutions in be- tween downsampling via max-pooling in the form of a block. They were primarily in- terested in whether deep or wide networks perform better. For instance, the successive application of two 3 x 3 convolutions touches the same pixels as a single 5 x 5 convolution does. At the same time, the latter uses approximately as many parameters (25 - c?) as three 3x3 convolutions do (3-9+c?). Ina rather detailed analysis they showed that deep and nar- row networks significantly outperform their shallow counterparts. This set deep learning on a quest for ever deeper networks with over 100 layers for typical applications. Stacking 3 x 3 convolutions has become a gold standard in later deep networks (a design decision only to be revisited recently by Liu et al. (2022)). Consequently, fast implementations for small convolutions have become a staple on GPUs (Lavin and Gray, 2016). Back to VGG: a VGG block consists of a sequence of convolutions with 3 x 3 kernels with
Back to VGG: a VGG block consists of a sequence of convolutions with 3 x 3 kernels with padding of 1 (keeping height and width) followed by a 2 x 2 max-pooling layer with stride of 2 (halving height and width after each block). In the code below, we define a function called vgg_block to implement one VGG block. The function below takes two arguments, corresponding to the number of convolutional layers num_convs and the number of output channels num_channels. def vgg_block(num_convs, out_channels): layers = [] for _ in range(num_convs): layers.append(nn.LazyConv2d(out_channels, kernel_size=3, padding=1)) layers.append(nn.ReLU()) layers.append(nn.MaxPool2d(kernel_size=2,stride=2)) return nn.Sequential(*layers)
8.2.2 VGG Network
Like AlexNet and LeNet, the VGG Network can be partitioned into two parts: the first consisting mostly of convolutional and pooling layers and the second consisting of fully
Modern Convolutional Neural Networks
280

connected layers that are identical to those in AlexNet. The key difference is that the con- volutional layers are grouped in nonlinear transformations that leave the dimensonality un- changed, followed by a resolution-reduction step, as depicted in Fig. 8.2.1.bubuAlexNet
FC (1000) t FC (4096) VGG t FC (4096) FC (1000) t FC (4096) t t 3.x 3 Conv (384), pad 1 Fo (4086) t t 3x 3 Conv (384), pad 1 EEE t VGG block ; 3.x 3 Conv (384), pad 1 < a [znerane2 | ; 3x 3 Conv, pad 1 t 5 x 5 Conv (256), pad 2 ; a R ; 3x 3 Cony, pad 1 4 11x 11 Conv (96), stride 4
tFig. 8.2.1
From AlexNet to VGG. The key difference is that VGG consists of blocks of layers, whereas AlexNet‚Äôs layers are all designed individually. The convolutional part of the network connects several VGG blocks from Fig. 8.2.1 (also defined in the vgg_block function) in succession. This grouping of convolutions is a pat- tern that has remained almost unchanged over the past decade, although the specific choice of operations has undergone considerable modifications. The variable arch consists of a list of tuples (one per block), where each contains two values: the number of convolutional layers and the number of output channels, which are precisely the arguments required to call the vgg_block function. As such, VGG defines a family of networks rather than just a specific manifestation. To build a specific network we simply iterate over arch to compose the blocks. class VGG(d2l.Classifier): def __init__(self, arch, lr=0.1, num_classes=10): super().__init__() self.save_hyperparameters() conv_blks = [] for (num_convs, out_channels) in arch: conv_blks.append(vgg_block(num_convs, out_channels)) self.net = nn.Sequential( *conv_blks, nn.Flatten(),
(continues on next page)
Networks Using Blocks (VGG)
281

nn.LazyLinear(4096), nn.ReLU(), nn.Dropout(0.5), nn.LazyLinear(4096), nn.ReLU(), nn.Dropout(0.5), nn.LazyLinear(num_classes)) self.net.apply(d2l.init_cnn)
The original VGG network had five convolutional blocks, among which the first two have one convolutional layer each and the latter three contain two convolutional layers each. The first block has 64 output channels and each subsequent block doubles the number of output channels, until that number reaches 512. Since this network uses eight convolutional layers and three fully connected layers, it is often called VGG-11. VGG(arch=((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))).layer_summary( (1, 1, 224, 224))
Sequential output shape: torch.Size([1, 64, 112, 112]) Sequential output shape: torch.Size([1, 128, 56, 56]) Sequential output shape: torch.Size([1, 256, 28, 28]) Sequential output shape: torch.Size([1, 512, 14, 14]) Sequential output shape: torch.Size([1, 512, 7, 7]) Flatten output shape: torch.Size([1, 25088]) Linear output shape: torch.Size([1, 4096]) ReLU output shape: torch.Size([1, 4096]) Dropout output shape: torch.Size([1, 4096]) Linear output shape: torch.Size([1, 4096]) ReLU output shape: torch.Size([1, 4096]) Dropout output shape: torch.Size([1, 4096]) Linear output shape: torch.Size([1, 10])
As you can see, we halve height and width at each block, finally reaching a height and width of 7 before flattening the representations for processing by the fully connected part of the network. Simonyan and Zisserman (2014) described several other variants of VGG. In fact, it has become the norm to propose families of networks with different speed‚Äìaccuracy trade-off when introducing a new architecture. 8.2.3 Training
Since VGG-11 is computationally more demanding than AlexNet we construct a network with a smaller number of channels. This is more than sufficient for training on Fashion- MNIST. The model training process is similar to that of AlexNet in Section 8.1. Again ob- serve the close match between validation and training loss, suggesting only a small amount of overfitting. model = VGG(arch=((1, 16), (1, 32), (2, 64), (2, 128), (2, 128)), lr=0.01) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128, resize=(224, 224)) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) trainer.fit(model, data)
(continued from previous page)
Modern Convolutional Neural Networks
282

‚Äî train_loss 2.0 =-- val_loss ‚Äî-- val_acc 15 1.0 0.5 0 2 4 6 8 10 epoch
8.2.4 Summary
One might argue that VGG is the first truly modern convolutional neural network. While AlexNet introduced many of the components of what make deep learning effective at scale, it is VGG that arguably introduced key properties such as blocks of multiple convolutions and a preference for deep and narrow networks. It is also the first network that is actually an entire family of similarly parametrized models, giving the practitioner ample trade-off between complexity and speed. This is also the place where modern deep learning frame- works shine. It is no longer necessary to generate XML configuration files to specify a network but rather, to assemble said networks through simple Python code. More recently ParNet (Goyal et al., 2021) demonstrated that it is possible to achieve com- petitive performance using a much more shallow architecture through a large number of parallel computations. This is an exciting development and there is hope that it will influ- ence architecture designs in the future. For the remainder of the chapter, though, we will follow the path of scientific progress over the past decade. 8.2.5 Exercises
1. ComparedwithAlexNet, VGGismuchslowerintermsofcomputation, anditalsoneeds more GPU memory. 1. Compare the number of parameters needed for AlexNet and VGG. 2. Compare the number of floating point operations used in the convolutional layers and in the fully connected layers. 3. How could you reduce the computational cost created by the fully connected layers? 2. When displaying the dimensions associated with the various layers of the network, we only see the information associated with eight blocks (plus some auxiliary transforms), even though the network has 11 layers. Where did the remaining three layers go?bubu3. Use Table 1 in the VGG paper (Simonyan and Zisserman, 2014) to construct other com- mon models, such as VGG-16 or VGG-19. 4. Upsampling the resolution in Fashion-MNIST eight-fold from 28 x 28 to 224 x 224
dimensions is very wasteful. Try modifying the network architecture and resolution conversion, e.g., to 56 or to 84 dimensions for its input instead. Can you do so without
Network in Network (NiN)
283

reducing the accuracy of the network? Consult the VGG paper (Simonyan and Zisser- man, 2014) for ideas on adding more nonlinearities prior to downsampling. Discussions129. 129
8.3 Network in Network (NiN)

LeNet, AlexNet, and VGG all share a common design pattern: extract features exploiting spatial structure via a sequence of convolutions and pooling layers and post-process the representations via fully connected layers. The improvements upon LeNet by AlexNet and VGG mainly lie in how these later networks widen and deepen these two modules. This design poses two major challenges. First, the fully connected layers at the end of the architecture consume tremendous numbers of parameters. For instance, even a simple model such as VGG-11 requires a monstrous matrix, occupying almost 400MB of RAM in single precision (FP32). This is a significant impediment to computation, in particular on mobile and embedded devices. After all, even high-end mobile phones sport no more than 8GB of RAM. At the time VGG was invented, this was an order of magnitude less (the iPhone 4S had 512MB). As such, it would have been difficult to justify spending the majority of memory on an image classifier. Second, it is equally impossible to add fully connected layers earlier in the network to increase the degree of nonlinearity: doing so would destroy the spatial structure and require potentially even more memory. The network in network (NiN) blocks (Lin et al., 2013) offer an alternative, capable of solving both problems in one simple strategy. They were proposed based on a very simple insight: (i) use 1 x 1 convolutions to add local nonlinearities across the channel activations and (ii) use global average pooling to integrate across all locations in the last representation layer. Note that global average pooling would not be effective, were it not for the added nonlinearities. Let‚Äôs dive into this in detail. import torch from torch import nn from d2l import torch as d2l
8.3.1 NiN Blocks
Recall Section 7.4.3. In it we said that the inputs and outputs of convolutional layers consist of four-dimensional tensors with axes corresponding to the example, channel, height, and width. Also recall that the inputs and outputs of fully connected layers are typically two- dimensional tensors corresponding to the example and feature. The idea behind NiN is to apply a fully connected layer at each pixel location (for each height and width). The
Modern Convolutional Neural Networks
284

resulting 1x 1 convolution can be thought of as a fully connected layer acting independently
on each pixel location. Fig. 8.3.1 illustrates the main structural differences between VGG and NiN, and their blocks. Note both the difference in the NiN blocks (the initial convolution is followed by 1 x 1 con- volutions, whereas VGG retains 3 x 3 convolutions) and at the end where we no longer require a giant fully connected layer. VGG FC (1000) t FC (4096) t FC (4096) ere rT T 3x 3 Conv (10), pad 1 [Fama wa] t ‚Äî‚Äî 3 x 3 Conv (384), pad 1 i t ; a VGG block 1 i NIN block 5 x 5 Conv (256), pad 2 =r 7 a 1x1 Conv 3x 3 Cony, pad 1 t 7 ' a 1x1 Cony ‚Äî t ry Conv 3x 3 Conv, pad 1 11 x 11 Conv (96), stride 4
tFig. 8.3.1
Comparing the architectures of VGG and NiN, and of their blocks. def nin_block(out_channels, kernel_size, strides, padding): return nn.Sequential( nn.LazyConv2d(out_channels, kernel_size, strides, padding), nn.ReLU(), nn.LazyConv2d(out_channels, kernel_size=1), nn.ReLU(), nn.LazyConv2d(out_channels, kernel_size=1), nn.ReLU())
8.3.2 NiN Model
NiN uses the same initial convolution sizes as AlexNet (it was proposed shortly thereafter). The kernel sizes are 11 x 11, 5 x 5, and 3 x 3, respectively, and the numbers of output
NiN
Network in Network (NiN)
285

channels match those of AlexNet. Each NiN block is followed by a max-pooling layer with a stride of 2 and a window shape of 3 x 3. The second significant difference between NiN and both AlexNet and VGG is that NiN avoids fully connected layers altogether. Instead, NiN uses a NiN block with a number of output channels equal to the number of label classes, followed by a global average pooling layer, yielding a vector of logits. This design significantly reduces the number of required model parameters, albeit at the expense of a potential increase in training time. class NiN(d2l.Classifier): def __init__(self, lr=0.1, num_classes=10): super().__init__() self.save_hyperparameters() self.net = nn.Sequential( nin_block(96, kernel_size=11, strides=4, padding=0), nn.MaxPool2d(3, stride=2), nin_block(256, kernel_size=5, strides=1, padding=2), nn.MaxPool2d(3, stride=2), nin_block(384, kernel_size=3, strides=1, padding=1), nn.MaxPool2d(3, stride=2), nn.Dropout(0.5), nin_block(num_classes, kernel_size=3, strides=1, padding=1), nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten()) self.net.apply(d2l.init_cnn)
We create a data example to see the output shape of each block. NiN().layer_summary((1, 1, 224, 224))
Sequential output shape: torch.Size([1, 96, 54, 54]) MaxPool2d output shape: torch.Size([1, 96, 26, 26]) Sequential output shape: torch.Size([1, 256, 26, 26]) MaxPool2d output shape: torch.Size([1, 256, 12, 12]) Sequential output shape: torch.Size([1, 384, 12, 12]) MaxPool2d output shape: torch.Size([1, 384, 5, 5]) Dropout output shape: torch.Size([1, 384, 5, 5]) Sequential output shape: torch.Size([1, 10, 5, 5]) AdaptiveAvgPool2d output shape: torch.Size([1, 10, 1, 1]) Flatten output shape: torch.Size([1, 10])
8.3.3 Training
As before we use Fashion-MNIST to train the model using the same optimizer that we used for AlexNet and VGG. model = NiN(lr=0.05) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128, resize=(224, 224)) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) trainer.fit(model, data)
Modern Convolutional Neural Networks
286

‚Äî train_loss 2.0 ‚Äî-~ val_loss ‚Äî-- val_acc 15 1.0 0.5 , 0 2 4 6 8 10
8.3.4 Summary
NiN has dramatically fewer parameters than AlexNet and VGG. This stems primarily from the fact that it needs no giant fully connected layers.bubuInstead, it uses global average pooling to aggregate across all image locations after the last stage of the network body. This obvi- ates the need for expensive (learned) reduction operations and replaces them by a simple average. What surprised researchers at the time was the fact that this averaging operation did not harm accuracy. Note that averaging across a low-resolution representation (with many channels) also adds to the amount of translation invariance that the network can han- dle. Choosing fewer convolutions with wide kernels and replacing them by x | convolutions
Choosing fewer convolutions with wide kernels and replacing them by x | convolutions aids the quest for fewer parameters further. It can cater for a significant amount of non- linearity across channels within any given location.bubuBoth | x 1 convo! average pooling significantly influenced subsequent CNN designs. utions and global
8.3.5 Exercises
1. Why are there two 1 x 1 convolutional layers per NiN block? Increase their number to
three.bubuReduce their number to one. What changes?bubu2. What changes if you replace the 1 x 1 convolutions by 3 x 3 convolutions? 3. What happens if you replace the global average pooling by a fully connected layer (speed, accuracy, number of parameters)? 4. Calculate the resource usage for NiN. 1.bubuWhat is the number of parameters? 2. What is the amount of computation? 3. What is the amount of memory needed during training? 4. What is the amount of memory needed during prediction? 5. What are possible problems with reducing the 384 x 5 x 5 representation toa 10x 5x5
representation in one step? 6. Use the structural design decisions in VGG that led to VGG-11, VGG-16, and VGG-19 to design a family of NiN-like networks. Multi-Branch Networks (GoogLeNet)
287

Discussions130. 130
8.4 Multi-Branch Networks (GoogLeNet)
eC
In 2014, GoogLeNet won the ImageNet Challenge (Szegedy et al., 2015), using a structure that combined the strengths of NiN (Lin et al., 2013), repeated blocks (Simonyan and Zis- serman, 2014), and a cocktail of convolution kernels. It was arguably also the first network that exhibited a clear distinction among the stem (data ingest), body (data processing), and head (prediction) in a CNN. This design pattern has persisted ever since in the design of deep networks: the stem is given by the first two or three convolutions that operate on the image. They extract low-level features from the underlying images. This is followed by a body of convolutional blocks. Finally, the head maps the features obtained so far to the required classification, segmentation, detection, or tracking problem at hand. The key contribution in GoogLeNet was the design of the network body. It solved the prob- lem of selecting convolution kernels in an ingenious way. While other works tried to iden- tify which convolution, ranging from | x 1 to 11 x 11 would be best, it simply concatenated multi-branch convolutions. In what follows we introduce a slightly simplified version of GoogLeNet: the original design included a number of tricks for stabilizing training through intermediate loss functions, applied to multiple layers of the network. They are no longer necessary due to the availability of improved training algorithms. import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
8.4.1 Inception Blocks
The basic convolutional block in GoogLeNet is called an Inception block, stemming from the meme ‚Äúwe need to go deeper‚Äù from the movie Inception. Concatenation i‚Äù f 1x 1 Conv 1x 1 Conv
tFig.bubu8.4.1
Structure of the Inception block. As depicted in Fig. 8.4.1, the inception block consists of four parallel branches. The first three branches use convolutional layers with window sizes of 1 x 1, 3 x 3, and 5 x 5 to extract information from different spatial sizes. The middle two branches also add a 1 x 1
Modern Convolutional Neural Networks
288

convolution of the input to reduce the number of channels, reducing the model‚Äôs complex- ity. The fourth branch uses a 3 x 3 max-pooling layer, followed by a 1 x 1 convolutional layer to change the number of channels. The four branches all use appropriate padding to give the input and output the same height and width. Finally, the outputs along each branch are concatenated along the channel dimension and comprise the block‚Äôs output. The commonly-tuned hyperparameters of the Inception block are the number of output channels per layer, i.e., how to allocate capacity among convolutions of different size. class Inception(nn.Module): # c1--c4 are the number of output channels for each branch def __init__(self, c1, c2, c3, c4, **kwargs): super(Inception, self).__init__(**kwargs) # Branch 1 self.b1_1 = nn.LazyConv2d(c1, kernel_size=1) # Branch 2 self.b2_1 = nn.LazyConv2d(c2[0], kernel_size=1) self.b2_2 = nn.LazyConv2d(c2[1], kernel_size=3, padding=1) # Branch 3 self.b3_1 = nn.LazyConv2d(c3[0], kernel_size=1) self.b3_2 = nn.LazyConv2d(c3[1], kernel_size=5, padding=2) # Branch 4 self.b4_1 = nn.MaxPool2d(kernel_size=3, stride=1, padding=1) self.b4_2 = nn.LazyConv2d(c4, kernel_size=1) def forward(self, x): b1 = F.relu(self.b1_1(x)) b2 = F.relu(self.b2_2(F.relu(self.b2_1(x)))) b3 = F.relu(self.b3_2(F.relu(self.b3_1(x)))) b4 = F.relu(self.b4_2(self.b4_1(x))) return torch.cat((b1, b2, b3, b4), dim=1)
To gain some intuition for why this network works so well, consider the combination of the filters. They explore the image in a variety of filter sizes.bubuThis means that details at different extents can be recognized efficiently by filters of different sizes. At the same time, we can allocate different amounts of parameters for different filters. 8.4.2 GoogLeNet Model
As shown in Fig. 8.4.2, GoogLeNet uses a stack of a total of 9 inception blocks, arranged into three groups with max-pooling in between, and global average pooling in its head to generate its estimates. Max-pooling between inception blocks reduces the dimensionality. At its stem, the first module is similar to AlexNet and LeNet. i AUD | Xb joodxew ‚Ç¨ XE lOOdxeN ‚Ç¨ XE joogxew ‚Ç¨ xX & JoogBay |eqoip tT Od loodxew ‚Ç¨ XE
tFig. 8.4.2
The GoogLeNet architecture. Multi-Branch Networks (GoogLeNet)
289

We can now implement GoogLeNet piece by piece. Let‚Äôs begin with the stem. The first module uses a 64-channel 7 x 7 convolutional layer. class GoogleNet(d2l.Classifier): def b1(self): return nn.Sequential( nn.LazyConv2d(64, kernel_size=7, stride=2, padding=3), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
The second module uses two convolutional layers: first, a 64-channel 1 x 1 convolutional
The second module uses two convolutional layers: first, a 64-channel 1 x 1 convolutional layer, followed by a 3 x 3 convolutional layer that triples the number of channels. This corresponds to the second branch in the Inception block and concludes the design of the body. At this point we have 192 channels. @d2l.add_to_class(GoogleNet) def b2(self): return nn.Sequential( nn.LazyConv2d(64, kernel_size=1), nn.ReLU(), nn.LazyConv2d(192, kernel_size=3, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
The third module connects two complete Inception blocks in series. The number of output channels of the first Inception block is 64+ 128 + 32 + 32 = 256. This amounts to a ratio of the number of output channels among the four branches of 2 : 4: 1 : 1. To achieve this, we first reduce the input dimensions by $ and by $ in the second and third branch respectively to arrive at 96 = 192/2 and 16 = 192/12 channels respectively. The number of output channels of the second Inception block is increased to 128 ‚Äö 192 ‚Äö
96 ‚Äö 64 = 480, yielding a ratio of 128 : 192 : 96 : 64 = 4 : 6 : 3 : 2. As before, we need to reduce the number of intermediate dimensions in the second and third channel. A scale of 2 and 1 1 8 respectively suffices, yielding 128 and 32 channels respectively. This is captured by the arguments of the following Inception block constructors. @d2l.add_to_class(GoogleNet) def b3(self): return nn.Sequential(Inception(64, (96, 128), (16, 32), 32), Inception(128, (128, 192), (32, 96), 64), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
The fourth module is more complicated. It connects five Inception blocks in series, and they have 192+ 208+ 48+ 64 = 512, 160+224+ 64464 = 512, 128+256+64+ 64 = 512, 112+ 288 + 644 64 = 528, and 256 + 320+ 128+ 128 = 832 output channels, respectively. The number of channels assigned to these branches is similar to that in the third module: the second branch with the 3 x3 convolutional layer outputs the largest number of channels, followed by the first branch with only the 1 x 1 convolutional layer, the third branch with the 5 x 5 convolutional layer, and the fourth branch with the 3 x 3 max-pooling layer. The second and third branches will first reduce the number of channels according to the ratio. These ratios are slightly different in different Inception blocks. Modern Convolutional Neural Networks
290

@d2l.add_to_class(GoogleNet) def b4(self): return nn.Sequential(Inception(192, (96, 208), (16, 48), 64), Inception(160, (112, 224), (24, 64), 64), Inception(128, (128, 256), (24, 64), 64), Inception(112, (144, 288), (32, 64), 64), Inception(256, (160, 320), (32, 128), 128), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
The fifth module has two Inception blocks with 256‚Äö320‚Äö128‚Äö128 = 832 and 384‚Äö384‚Äö
128 ‚Äö 128 = 1024 output channels. The number of channels assigned to each branch is the same as that in the third and fourth modules, but differs in specific values.bubuIt should be noted that the fifth block is followed by the output layer. This block uses the global average pooling layer to change the height and width of each channel to 1, just as in NiN. Finally, we turn the output into a two-dimensional array followed by a fully connected layer whose number of outputs is the number of label classes. @d2l.add_to_class(GoogleNet) def b5(self): return nn.Sequential(Inception(256, (160, 320), (32, 128), 128), Inception(384, (192, 384), (48, 128), 128), nn.AdaptiveAvgPool2d((1,1)), nn.Flatten())
Now that we defined all blocks b1 through b5, it is just a matter of assembling them all into a full network. @d2l.add_to_class(GoogleNet) def __init__(self, lr=0.1, num_classes=10): super(GoogleNet, self).__init__() self.save_hyperparameters() self.net = nn.Sequential(self.b1(), self.b2(), self.b3(), self.b4(), self.b5(), nn.LazyLinear(num_classes)) self.net.apply(d2l.init_cnn)
The GoogLeNet model is computationally complex. Note the large number of relatively arbitrary hyperparameters in terms of the number of channels chosen, the number of blocks prior to dimensionality reduction, the relative partitioning of capacity across channels, etc. Much of it is due to the fact that at the time when GoogLeNet was introduced, automatic tools for network definition or design exploration were not yet available. For instance, by now we take it for granted that a competent deep learning framework is capable of inferring dimensionalities of input tensors automatically. At the time, many such configurations had to be specified explicitly by the experimenter, thus often slowing down active experimen- tation. Moreover, the tools needed for automatic exploration were still in flux and initial experiments largely amounted to costly brute-force exploration, genetic algorithms, and similar strategies. For now the only modification we will carry out is to reduce the input height and width from 224 to 96 to have a reasonable training time on Fashion-MNIST. This simplifies the
Multi-Branch Networks (GoogLeNet)
291

computation. Let‚Äôs have a look at the changes in the shape of the output between the various modules. model = GoogleNet().layer_summary((1, 1, 96, 96))
Sequential output shape: torch.Size([1, 64, 24, 24]) Sequential output shape: torch.Size([1, 192, 12, 12]) Sequential output shape: torch.Size([1, 480, 6, 6]) Sequential output shape: torch.Size([1, 832, 3, 3]) Sequential output shape: torch.Size([1, 1024]) Linear output shape: torch.Size([1, 10])
8.4.3 Training
As before, we train our model using the Fashion-MNIST dataset. We transform it to 96x 96
pixel resolution before invoking the training procedure. model = GoogleNet(lr=0.01) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128, resize=(96, 96)) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) trainer.fit(model, data)
‚Äî train_loss 2.0 === val_loss ‚Äî-- val_ace 1.5 1.0 05 vi eS 0.0 0 2 4 6 8 10
8.4.4 Discussion
A key feature of GoogLeNet is that it is actually cheaper to compute than its predecessors while simultaneously providing improved accuracy. This marks the beginning of a much more deliberate network design that trades off the cost of evaluating a network with a reduc- tion in errors.bubuIt also marks the beginning of experimentation at a block level with network design hyperparameters, even though it was entirely manual at the time. We will revisit this topic in Section 8.8 when discussing strategies for network structure exploration. Over the following sections we will encounter a number of design choices (e.g., batch nor- malization, residual connections, and channel grouping) that allow us to improve networks significantly. For now, you can be proud to have implemented what is arguably the first truly modern CNN. Modern Convolutional Neural Networks
292

8.4.5 Exercises
1. GoogLeNet was so successful that it went through a number of iterations, progressively improving speed and accuracy. Try to implement and run some of them.bubuThey include the following:
1. Add a batch normalization layer (Ioffe and Szegedy, 2015), as described later in Section 8.5. 2. Make adjustments to the Inception block (width, choice and order of convolutions), as described in Szegedy et al. (2016).bubu3. Use label smoothing for model regularization, as described in Szegedy et al. (2016).bubu4. MakefurtheradjustmentstotheInceptionblockbyaddingresidualconnection(Szegedy et al., 2017), as described later in Section 8.6. 2. What is the minimum image size needed for GoogLeNet to work? 3. Can you design a variant of GoogLeNet that works on Fashion-MNIST‚Äôs native resolu- tion of 28 x 28 pixels? How would you need to change the stem, the body, and the head of the network, if anything at all? 4. Compare the model parameter sizes of AlexNet, VGG, NiN, and GoogLeNet. How do the latter two network architectures significantly reduce the model parameter size? 5. Compare the amount of computation needed in GoogLeNet and AlexNet. Howdoes this affect the design of an accelerator chip, e.g., in terms of memory size, memory band- width, cache size, the amount of computation, and the benefit of specialized operations? 131
Discussions131. 8.5 Batch Normalization
ae
Training deep neural networks is difficult. Getting them to converge in a reasonable amount of time can be tricky. In this section, we describe batch normalization, a popular and effective technique that consistently accelerates the convergence of deep networks (Ioffe and Szegedy, 2015). Together with residual blocks‚Äîcovered later in Section 8.6‚Äîbatch normalization has made it possible for practitioners to routinely train networks with over 100 layers. A secondary (serendipitous) benefit of batch normalization lies in its inherent regularization. import torch from torch import nn from d2l import torch as d2l
Batch Normalization
293

8.5.1 Training Deep Networks
When working with data, we often preprocess before training. Choices regarding data pre-
processing often make an enormous difference in the final results. Recall our application of MLPs to predicting house prices (Section 5.7). Our first step when working with real data wastostandardizeourinputfeaturestohavezeromean ùùÅ = 0andunitvarianceùö∫ = 1across multiple observations (Friedman, 1987), frequently rescaling the latter so that the diagonal is unity, i.e., Œ£ùëñùëñ = 1. Yet another strategy is to rescale vectors to unit length, possibly zero mean per observation. This can work well, e.g., for spatial sensor data. These pre- processing techniques and many others, are beneficial for keeping the estimation problem well controlled. For a review of feature selection and extraction see the article of Guyon et al. (2008), for example. Standardizing vectors also has the nice side-effect of constraining the function complexity of functions that act upon it. For instance, the celebrated radius- margin bound (Vapnik, 1995) in support vector machines and the Perceptron Convergence Theorem (Novikoff, 1962) rely on inputs of bounded norm. Intuitively, this standardization plays nicely with our optimizers since it puts the parameters a priori on a similar scale. As such, it is only natural to ask whether a corresponding normalization step inside a deep network might not be beneficial. While this is not quite the reasoning that led to the invention of batch normalization (Ioffe and Szegedy, 2015), it is a useful way of understanding it and its cousin, layer normalization (Ba et al., 2016), within a unified framework. Second, for a typical MLP or CNN, as we train, the variables in intermediate layers (e.g., affine transformation outputs in MLP) may take values with widely varying magnitudes: whether along the layers from input to output, across units in the same layer, and over time due to our updates to the model parameters. The inventors of batch normalization postulated informally that this drift in the distribution of such variables could hamper the convergence of the network. Intuitively, we might conjecture that if one layer has variable activations that are 100 times that of another layer, this might necessitate compensatory adjustments in the learning rates. Adaptive solvers such as AdaGrad (Duchi et al., 2011), Adam (Kingma and Ba, 2014), Yogi (Zaheer et al., 2018), or Distributed Shampoo (Anil et al., 2020) aim to address this from the viewpoint of optimization, e.g., by adding aspects of second-order methods. The alternative is to prevent the problem from occurring, simply by adaptive normalization. Third, deeper networks are complex and tend to be more liable to overfitting. This means that regularization becomes more critical. A common technique for regularization is noise injection. This has been known for a long time, e.g., with regard to noise injection for the inputs (Bishop, 1995). It also forms the basis of dropout in Section 5.6. As it turns out, quite serendipitously, batch normalization conveys all three benefits: preprocessing, numerical stability, and regularization. Batch normalization is applied to individual layers, or optionally, to all of them: In each training iteration, we first normalize the inputs (of batch normalization) by subtracting their mean and dividing by their standard deviation, where both are estimated based on the statis- tics of the current minibatch. Next, we apply a scale coefficient and an offset to recover the
Modern Convolutional Neural Networks
294

lost degrees of freedom. It is precisely due to this normalization based on batch statistics that batch normalization derives its name. Note that if we tried to apply batch normalization with minibatches of size 1, we would not be able to learn anything. That is because after subtracting the means, each hidden unit would take value 0. As you might guess, since we are devoting a whole section to batch normalization, with large enough minibatches the approach proves effective and stable. One takeaway here is that when applying batch normalization, the choice of batch size is even more significant than without batch normalization, or at least, suitable calibration is needed as we might adjust batch size. Denote by B a minibatch and let x 2 B be an input to batch normalization (BN). In this
case the batch normalization is defined as follows:
x-a BN(x) =yo ~ S48. (8.5.1) og
In (8.5.1), ÀÜùùÅB is the sample mean and ÀÜùùàB is the sample standard deviation of the minibatch B. After applying standardization, the resulting minibatch has zero mean and unit variance. The choice of unit variance (rather than some other magic number) is arbitrary. We recover this degree of freedom by including an elementwise scale parameter ùú∏ and shift parameter ùú∑ that have the same shape as x. Both are parameters that need to be learned as part of model training. The variable magnitudes for intermediate layers cannot diverge during training since batch normalization actively centers and rescales them back to a given mean and size (via ÀÜùùÅB and ÀÜùùàB). Practical experience confirms that, as alluded to when discussing feature rescaling, batch normalization seems to allow for more aggressive learning rates. We calculate ÀÜùùÅB and ÀÜùùàB in (8.5.1) as follows:
.bubu. 1 a fis = Dd, xand Os = Te DK As) +e. (8.5.2) xeB
Note that we add a small constant ùúñ > 0 to the variance estimate to ensure that we never
attempt division by zero, even in cases where the empirical variance estimate might be very small or vanish. The estimates ÀÜùùÅB and ÀÜùùàB counteract the scaling issue by using noisy estimates of mean and variance. You might think that this noisiness should be a problem. On the contrary, it is actually beneficial. This turns out to be a recurring theme in deep learning. For reasons that are not yet well- characterized theoretically, various sources of noise in optimization often lead to faster training and less overfitting: this variation appears to act as a form of regularization. Teye et al.bubu(2018) and Luo et al. (2018) related the properties of batch normalization to Bayesian priors and penalties, respectively. In particular, this sheds some light on the puzzle of why batch normalization works best for moderate minibatch sizes in the 50‚Äì100 range. This particular size of minibatch seems to inject just the ‚Äúright amount‚Äù of noise per layer, both in terms of scale via ÀÜùùà, and in terms of offset via ÀÜùùÅ: a larger minibatch regularizes less due to the more stable estimates, whereas tiny minibatches destroy useful signal due to high variance. Exploring this direction further, considering alternative types of preprocessing and filtering may yet lead to other effective types of regularization. x-a ~
Batch Normalization
295

Fixing a trained model, you might think that we would prefer using the entire dataset to estimate the mean and variance. Once training is complete, why would we want the same image to be classified differently, depending on the batch in which it happens to reside? During training, such exact calculation is infeasible because the intermediate variables for all data examples change every time we update our model. However, once the model is trained, we can calculate the means and variances of each layer‚Äôs variables based on the entire dataset. Indeed this is standard practice for models employing batch normalization; thus batch normalization layers function differently in training mode (normalizing by mini- batchstatistics)thaninpredictionmode(normalizingbydatasetstatistics). Inthisformthey closely resemble the behavior of dropout regularization of Section 5.6, where noise is only injected during training. 8.5.2 Batch Normalization Layers
Batch normalization implementations for fully connected layers and convolutional layers are slightly different. One key difference between batch normalization and other layers is that because the former operates on a full minibatch at a time, we cannot just ignore the batch dimension as we did before when introducing other layers. Fully Connected Layers
When applying batch normalization to fully connected layers, Ioffe and Szegedy (2015), in their original paper inserted batch normalization after the affine transformation and before the nonlinear activation function. Later applications experimented with inserting batch normalization right after activation functions. Denoting the input to the fully connected layer by x, the affine transformation by Wx ‚Äö b (with the weight parameter W and the bias parameter b), and the activation function by ùúô, we can express the computation of a batch-normalization-enabled, fully connected layer output h as follows:
h = ùúô‚ÄûBN‚ÄûWx ‚Äö b‚Äù‚Äù. (8.5.3)
Recall that mean and variance are computed on the same minibatch on which the transfor- mation is applied. Convolutional Layers
Similarly, withconvolutionallayers, wecanapplybatchnormalizationaftertheconvolution but before the nonlinear activation function. The key difference from batch normalization in fully connected layers is that we apply the operation on a per-channel basis across all locations. This is compatible with our assumption of translation invariance that led to convolutions: we assumed that the specific location of a pattern within an image was not critical for the purpose of understanding. Assume that our minibatches contain ùëö examples and that for each channel, the output
Assume that our minibatches contain m examples and that for each channel, the output of the convolution has height p and width g. For convolutional layers, we carry out each batch normalization over the m - p - q elements per output channel simultaneously. Thus,
Modern Convolutional Neural Networks
296

we collect the values over all spatial locations when computing the mean and variance and consequently apply the same mean and variance within a given channel to normalize the value at each spatial location. Each channel has its own scale and shift parameters, both of which are scalars. Layer Normalization
Note that in the context of convolutions the batch normalization is well defined even for minibatches of size 1: after all, we have all the locations across an image to average. Con- sequently, mean and variance are well defined, even if it is just within a single observation. This consideration led Ba et al. (2016) to introduce the notion of layer normalization. It works just like a batch norm, only that it is applied to one observation at a time. Conse- quently both the offset and the scaling factor are scalars. For an ùëõ-dimensional vector x, layer norms are given by
x ! LN‚Äûx‚Äù = ÀÜùúé , (8.5.4)
where scaling and offset are applied coefficient-wise and given by
<
atl < af ly ¬ª def a2 del q)2 f= at and 6¬∞ = nye) +e. (8.5.5) i=
As before we add a small offset ùúñ > 0 to prevent division by zero. One of the major benefits
As before we add a small offset ‚Ç¨ > 0 to prevent division by zero. One of the major benefits of using layer normalization is that it prevents divergence. After all, ignoring e, the output of the layer normalization is scale independent. That is, we have LN(x) ~ LN(a@x) for any choice of a # 0. This becomes an equality for |a| ‚Äî oo (the approximate equality is due to the offset ‚Ç¨ for the variance). Another advantage of the layer normalization is that it does not depend on the minibatch size. It is also independent of whether we are in training or test regime. In other words, it is simplyadeterministictransformationthatstandardizestheactivationstoagivenscale. This can be very beneficial in preventing divergence in optimization. We skip further details and recommend that interested readers consult the original paper. Batch Normalization During Prediction
As we mentioned earlier, batch normalization typically behaves differently in training mode thaninpredictionmode. First, thenoiseinthesamplemeanandthesamplevariancearising from estimating each on minibatches is no longer desirable once we have trained the model. Second, we might not have the luxury of computing per-batch normalization statistics. For example, we might need to apply our model to make one prediction at a time. Typically, after training, we use the entire dataset to compute stable estimates of the vari- able statistics and then fix them at prediction time. Hence, batch normalization behaves differently during training than at test time. Recall that dropout also exhibits this charac- teristic. Batch Normalization
297

8.5.3 Implementation from Scratch
To see how batch normalization works in practice, we implement one from scratch be-
low. def batch_norm(X, gamma, beta, moving_mean, moving_var, eps, momentum):
# Use is_grad_enabled to determine whether we are in training mode if not torch.is_grad_enabled(): # In prediction mode, use mean and variance obtained by moving average X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps) else: assert len(X.shape) in (2, 4) if len(X.shape) == 2: # When using a fully connected layer, calculate the mean and # variance on the feature dimension mean = X.mean(dim=0) var = ((X - mean) ** 2).mean(dim=0) else: # When using a two-dimensional convolutional layer, calculate the # mean and variance on the channel dimension (axis=1). Here we # need to maintain the shape of X, so that the broadcasting # operation can be carried out later mean = X.mean(dim=(0, 2, 3), keepdim=True) var = ((X - mean) ** 2).mean(dim=(0, 2, 3), keepdim=True) # In training mode, the current mean and variance are used X_hat = (X - mean) / torch.sqrt(var + eps) # Update the mean and variance using moving average moving_mean = (1.0 - momentum) * moving_mean + momentum * mean moving_var = (1.0 - momentum) * moving_var + momentum * var Y = gamma * X_hat + beta # Scale and shift return Y, moving_mean.data, moving_var.data
We can now create a proper BatchNorm layer. Our layer will maintain proper parameters for scale gamma and shift beta, both of which will be updated in the course of training. Addi- tionally, our layer will maintain moving averages of the means and variances for subsequent use during model prediction. Puttingasidethealgorithmicdetails, notethedesignpatternunderlyingourimplementation of the layer. Typically, we define the mathematics in a separate function, say batch_norm. We then integrate this functionality into a custom layer, whose code mostly addresses book- keeping matters, such as moving data to the right device context, allocating and initializing any required variables, keeping track of moving averages (here for mean and variance), and so on. This pattern enables a clean separation of mathematics from boilerplate code. Also note that for the sake of convenience we did not worry about automatically inferring the input shape here; thus we need to specify the number of features throughout. By now all modern deep learning frameworks offer automatic detection of size and shape in the high-level batch normalization APIs (in practice we will use this instead). class BatchNorm(nn.Module):
# num_features: the number of outputs for a fully connected layer or the
# number of output channels for a convolutional layer. num_dims: 2 for a
(continues on next page)
Modern Convolutional Neural Networks
298

# fully connected layer and 4 for a convolutional layer def __init__(self, num_features, num_dims): super().__init__() if num_dims == 2: shape = (1, num_features) else: shape = (1, num_features, 1, 1) # The scale parameter and the shift parameter (model parameters) are # initialized to 1 and 0, respectively self.gamma = nn.Parameter(torch.ones(shape)) self.beta = nn.Parameter(torch.zeros(shape)) # The variables that are not model parameters are initialized to 0 and # 1 self.moving_mean = torch.zeros(shape) self.moving_var = torch.ones(shape) def forward(self, X): # If X is not on the main memory, copy moving_mean and moving_var to # the device where X is located if self.moving_mean.device != X.device: self.moving_mean = self.moving_mean.to(X.device) self.moving_var = self.moving_var.to(X.device) # Save the updated moving_mean and moving_var Y, self.moving_mean, self.moving_var = batch_norm( X, self.gamma, self.beta, self.moving_mean, self.moving_var, eps=1e-5, momentum=0.1) return Y
We used momentum to govern the aggregation over past mean and variance estimates. This
is somewhat of a misnomer as it has nothing whatsoever to do with the momentum term of optimization.bubuNonetheless, it is the commonly adopted name for this term and in deference to API naming convention we use the same variable name in our code. 8.5.4 LeNet with Batch Normalization
To see how to apply BatchNorm in context, below we apply it to a traditional LeNet model (Section 7.6). Recall that batch normalization is applied after the convolutional layers or fully connected layers but before the corresponding activation functions. class BNLeNetScratch(d2l.Classifier): def __init__(self, lr=0.1, num_classes=10): super().__init__() self.save_hyperparameters() self.net = nn.Sequential( nn.LazyConv2d(6, kernel_size=5), BatchNorm(6, num_dims=4), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.LazyConv2d(16, kernel_size=5), BatchNorm(16, num_dims=4), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.LazyLinear(120), BatchNorm(120, num_dims=2), nn.Sigmoid(), nn.LazyLinear(84), BatchNorm(84, num_dims=2), nn.Sigmoid(), nn.LazyLinear(num_classes))
(continued from previous page)
Batch Normalization
299

As before, we will train our network on the Fashion-MNIST dataset. This code is virtually identical to that when we first trained LeNet. trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128) model = BNLeNetScratch(lr=0.1) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) trainer.fit(model, data)
og) \ eo ‚Äúa ‚Äî train_loss 06 === val_loss ‚Äî-- val_acc 0.4 0 2 4 6 8 10
Let‚Äôs have a look at the scale parameter gamma and the shift parameter beta learned from the first batch normalization layer. model.net[1].gamma.reshape((-1,)), model.net[1].beta.reshape((-1,))
(tensor([1.4334, 1.9905, 1.8584, 2.0740, 2.0522, 1.8877], device='cuda:0', grad_fn=<ViewBackward0>), tensor([ 0.7354, -1.3538, -0.2567, -0.9991, -0.3028, 1.3125], device='cuda:0 ‚Ü©!', grad_fn=<ViewBackward0>))
8.5.5 Concise Implementation
Compared with the BatchNorm class, which we just defined ourselves, we can use the BatchNorm class defined in high-level APIs from the deep learning framework directly. The code looks virtually identical to our implementation above, except that we no longer need to provide additional arguments for it to get the dimensions right. class BNLeNet(d2l.Classifier): def __init__(self, lr=0.1, num_classes=10): super().__init__() self.save_hyperparameters() self.net = nn.Sequential( nn.LazyConv2d(6, kernel_size=5), nn.LazyBatchNorm2d(), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.LazyConv2d(16, kernel_size=5), nn.LazyBatchNorm2d(), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.LazyLinear(120), nn.LazyBatchNorm1d(),
(continues on next page)
Modern Convolutional Neural Networks
300

nn.Sigmoid(), nn.LazyLinear(84), nn.LazyBatchNorm1d(), nn.Sigmoid(), nn.LazyLinear(num_classes))
Below, we use the same hyperparameters to train our model. Note that as usual, the high- level API variant runs much faster because its code has been compiled to C++ or CUDA while our custom implementation must be interpreted by Python. trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128) model = BNLeNet(lr=0.1) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) trainer.fit(model, data)
os{\ ‚Äî train_loss === val_loss seal NS ‚Äî-- valace . Li 0.4 0 2 4 6 8 10
8.5.6 Discussion
Intuitively, batch normalization is thought to make the optimization landscape smoother. However, we must be careful to distinguish between speculative intuitions and true expla- nations for the phenomena that we observe when training deep models. Recall that we do not even know why simpler deep neural networks (MLPs and conventional CNNs) general- ize well in the first place. Even with dropout and weight decay, they remain so flexible that their ability to generalize to unseen data likely needs significantly more refined learning- theoretic generalization guarantees. The original paper proposing batch normalization (Ioffe and Szegedy, 2015), in addition to introducingapowerfulandusefultool, offeredanexplanationforwhyitworks: byreducing internal covariate shift. Presumably by internal covariate shift they meant something like the intuition expressed above‚Äîthe notion that the distribution of variable values changes overthecourseoftraining. However, thereweretwoproblemswiththisexplanation: i)This drift is very different from covariate shift, rendering the name a misnomer. If anything, it is closer to concept drift. ii) The explanation offers an under-specified intuition but leaves the question of why precisely this technique works an open question wanting for a rigorous explanation. Throughout this book, we aim to convey the intuitions that practitioners use to guide their development of deep neural networks. However, we believe that it is important to separate these guiding intuitions from established scientific fact. Eventually, when you
(continued from previous page)
Batch Normalization
301

master this material and start writing your own research papers you will want to be clear to delineate between technical claims and hunches. Following the success of batch normalization, its explanation in terms of internal covariate shift has repeatedly surfaced in debates in the technical literature and broader discourse about how to present machine learning research. In a memorable speech given while ac- cepting a Test of Time Award at the 2017 NeurIPS conference, Ali Rahimi used internal covariate shift as a focal point in an argument likening the modern practice of deep learning to alchemy. Subsequently, the example was revisited in detail in a position paper outlining troubling trends in machine learning (Lipton and Steinhardt, 2018). Other authors have proposed alternative explanations for the success of batch normalization, some (Santurkar et al., 2018) claiming that batch normalization‚Äôs success comes despite exhibiting behavior that is in some ways opposite to those claimed in the original paper. We note that the internal covariate shift is no more worthy of criticism than any of thou- sandsofsimilarlyvagueclaimsmadeeveryyearinthetechnicalmachinelearningliterature. Likely, its resonance as a focal point of these debates owes to its broad recognizability for the target audience. Batch normalization has proven an indispensable method, applied in nearly all deployed image classifiers, earning the paper that introduced the technique tens of thousands of citations. We conjecture, though, that the guiding principles of regularization through noise injection, acceleration through rescaling and lastly preprocessing may well lead to further inventions of layers and techniques in the future. On a more practical note, there are a number of aspects worth remembering about batch normalization:
e During model training, batch normalization continuously adjusts the intermediate output
of the network by utilizing the mean and standard deviation of the minibatch, so that the values of the intermediate output in each layer throughout the neural network are more stable. Batch normalization is slightly different for fully connected layers than for convolutional
layers. In fact, for convolutional layers, layer normalization can sometimes be used as an alternative. Like a dropout layer, batch normalization layers have different behaviors in training mode
than in prediction mode. Batch normalization is useful for regularization and improving convergence in optimiza-
tion. By contrast, the original motivation of reducing internal covariate shift seems not to be a valid explanation. e For more robust models that are less sensitive to input perturbations, consider removing
batch normalization (Wang et al., 2022). 8.5.7 Exercises
1. Shouldweremovethebiasparameterfromthefullyconnectedlayerortheconvolutional layer before the batch normalization? Why? Modern Convolutional Neural Networks
302

2. Compare the learning rates for LeNet with and without batch normalization. 1.bubuPlot the increase in validation accuracy. 2. How large can you make the learning rate before the optimization fails in both cases? 3. Do we need batch normalization in every layer? Experiment with it. 4. Implement a ‚Äúlite‚Äù version of batch normalization that only removes the mean, or alter- natively one that only removes the variance. How does it behave?bubu5. Fix the parameters beta and gamma. Observe and analyze the results.bubu6. Can you replace dropout by batch normalization? How does the behavior change?bubu7. Research ideas: think of other normalization transforms that you can apply:
1. Can you apply the probability integral transform? 2. Can you use a full-rank covariance estimate? Why should you probably not do that?bubu3. Can you use other compact matrix variants (block-diagonal, low-displacement rank, Monarch, etc.)? 4. Does a sparsification compression act as a regularizer? 5. Are there other projections (e.g., convex cone, symmetry group-specific transforms) that you can use? Discussions132. 132

8.6 Residual Networks (ResNet) and ResNeXt
i ‚ÄîCSsSCSC‚ÄòC‚ÄòsC‚Äò
As we design ever deeper networks it becomes imperative to understand how adding layers can increase the complexity and expressiveness of the network. Even more important is the ability to design networks where adding layers makes networks strictly more expressive rather than just different.bubuTo make some progress we need a bit of mathematics. import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
8.6.1 Function Classes
Consider F, the class of functions that a specific network architecture (together with learn-
Consider F , the class of functions that a specific network architecture (together with learn- ing rates and other hyperparameter settings) can reach. That is, for all f ‚Ç¨ F there exists some set of parameters (e.g., weights and biases) that can be obtained through training on a suitable dataset. Let‚Äôs assume that f* is the ‚Äútruth‚Äù function that we really would like to
Residual Networks (ResNet) and ResNeXt
303

find. If it is in F, we are in good shape but typically we will not be quite so lucky.bubuInstead,
find. If it is in F, we are in good shape but typically we will not be quite so lucky. Instead, we will try to find some f% which is our best bet within ¬•. For instance, given a dataset with features X and labels y, we might try finding it by solving the following optimization problem:
Se a argmin L(X, y, f) subject to f ‚Ç¨ F. (8.6.1) f
We know that regularization (Morozov, 1984, Tikhonov and Arsenin, 1977) may control complexity of F and achieve consistency, so a larger size of training data generally leads to better f;. It is only reasonable to assume that if we design a different and more powerful architecture F‚Äô we should arrive at a better outcome. In other words, we would expect that fZ, is ‚Äúbetter‚Äù than f7. However, if F ¬¢ F‚Äô there is no guarantee that this should even happen. In fact, f;, might well be worse.bubuAs illustrated by Fig. 8.6.1, for non-nested function classes, a larger function class does not always move closer to the ‚Äútruth‚Äù function f*. For instance, on the left of Fig. 8.6.1, though #3 is closer to f* than ¬•;, #6 moves away and there is no guarantee that further increasing the complexity can reduce the distance from f*. With nested function classes where #; C --- C F¬¢ on the right of Fig. 8.6.1, we can avoid the aforementioned issue from the non-nested function classes. Non-nested function classes Nested function classes
tFig. 8.6.1
Non-nested function classes
For non-nested function classes, a larger (indicated by area) function class does not guarantee we will get closer to the ‚Äútruth‚Äù function (f*). This does not happen in nested function classes. Thus, onlyiflargerfunctionclassescontainthesmalleronesareweguaranteedthatincreas- ing them strictly increases the expressive power of the network. For deep neural networks, if we can train the newly-added layer into an identity function ùëì ‚Äûx‚Äù = x, the new model will be as effective as the original model. As the new model may get a better solution to fit the training dataset, the added layer might make it easier to reduce training errors. This is the question that He et al. (2016) considered when working on very deep com- puter vision models. At the heart of their proposed residual network (ResNet) is the idea that every additional layer should more easily contain the identity function as one of its elements. These considerations are rather profound but they led to a surprisingly simple solution, a residual block. With it, ResNet won the ImageNet Large Scale Visual Recogni- tion Challenge in 2015. The design had a profound influence on how to build deep neural networks. For instance, residual blocks have been added to recurrent networks (Kim et al., 2017, Prakash et al., 2016). Likewise, Transformers (Vaswani et al., 2017) use them to
Nested function classes
Modern Convolutional Neural Networks
304

stack many layers of networks efficiently. It is also used in graph neural networks (Kipf and Welling, 2016) and, as a basic concept, it has been used extensively in computer vision (Redmon and Farhadi, 2018, Ren et al., 2015). Note that residual networks are predated by highway networks (Srivastava et al., 2015) that share some of the motivation, albeit without the elegant parametrization around the identity function. 8.6.2 Residual Blocks
Let‚Äôs focus on a local part of a neural network, as depicted in Fig. 8.6.2.bubuDenote the input by x. We assume that f(x), the desired underlying mapping we want to obtain by learning, is to be used as input to the activation function on the top. On the left, the portion within the dotted-line box must directly learn f(x). On the right, the portion within the dotted-line box needs to learn the residual mapping g(x) = f (x) ‚Äî x, which is how the residual block derives its name. If the identity mapping f(x) = x is the desired underlying mapping, the residual mapping amounts to g(x) = 0 and it is thus easier to learn: we only need to push the weights and biases of the upper weight layer (e.g., fully connected layer and convolutional layer) within the dotted-line box to zero. The right figure illustrates the residual block of ResNet, where the solid line carrying the layer input x to the addition operator is called a residual connection (or shortcut connection). With residual blocks, inputs can forward propagate faster through the residual connections across layers. In fact, the residual block can be thought of as a special case of the multi-branch Inception block: it has two branches one of which is the identity mapping. 4 4 Activation function Activation function t fix) = 9x) +x x Weight layer t Activation function F Weight layer t Activation function t Weight layer Weight layer x x
tFig. 8.6.2
In a regular block (left), the portion within the dotted-line box must directly learn the mapping f(x). Ina residual block (right), the portion within the dotted-line box needs to learn the residual mapping g(x) = f(x) ‚Äî x, making the identity mapping f(x) = x easier to learn. ResNet has VGG‚Äôs full 3 x 3 convolutional layer design. The residual block has two 3 x 3
ResNet has VGG‚Äôs full 3 x 3 convolutional layer design. The residual block has two 3 x 3 convolutional layers with the same number of output channels. Each convolutional layer is followed by a batch normalization layer and a ReLU activation function. Then, we skip these two convolution operations and add the input directly before the final ReLU activation function. This kind of design requires that the output of the two convolutional layers has to be of the same shape as the input, so that they can be added together. If we want to change the number of channels, we need to introduce an additional 1 x 1 convolutional layer to
Residual Networks (ResNet) and ResNeXt
305

transform the input into the desired shape for the addition operation. Let‚Äôs have a look at the code below. class Residual(nn.Module): #@save """The Residual block of ResNet models.""" def __init__(self, num_channels, use_1x1conv=False, strides=1): super().__init__() self.conv1 = nn.LazyConv2d(num_channels, kernel_size=3, padding=1, stride=strides) self.conv2 = nn.LazyConv2d(num_channels, kernel_size=3, padding=1) if use_1x1conv: self.conv3 = nn.LazyConv2d(num_channels, kernel_size=1, stride=strides) else: self.conv3 = None self.bn1 = nn.LazyBatchNorm2d() self.bn2 = nn.LazyBatchNorm2d() def forward(self, X): Y = F.relu(self.bn1(self.conv1(X))) Y = self.bn2(self.conv2(Y)) if self.conv3: X = self.conv3(X) Y += X return F.relu(Y)
This code generates two types of networks: one where we add the input to the output before applying the ReLU nonlinearity whenever use_1x1conv=False; and one where we adjust channels and resolution by means of a 1 x 1 convolution before adding. Fig.bubu8.6.3 illustrates this. ' i ' i ' Batch norm t ' Batch norm ' 1 1 \ f ' 1 f \ ' 3x 3 Conv ! ' 3x 3 Conv ! ' 1 ' 1 ' i] ' i] ! ! !bubu! 1x 1. Conv ' i] ' i] H Batch norm ' H Batch norm ' 1 1 1 f i 1 f i | 3x 3 Conv ! | 3x 3 Conv ! i] 1 i ! x x
tFig. 8.6.3
ResNet block with and without | x 1 convolution, which transforms the input into the
desired shape for the addition operation. Now let‚Äôs look at a situation where the input and output are of the same shape, where | x 1
convolution is not needed. Modern Convolutional Neural Networks
306

blk = Residual(3) X = torch.randn(4, 3, 6, 6) blk(X).shape
torch.Size([4, 3, 6, 6])
We also have the option to halve the output height and width while increasing the number of output channels. In this case we use | x 1 convolutions via use_1xlconv=True. This comes in handy at the beginning of each ResNet block to reduce the spatial dimensionality via strides=2. blk = Residual(6, use_1x1conv=True, strides=2) blk(X).shape
torch.Size([4, 6, 3, 3])
8.6.3 ResNet Model
The first two layers of ResNet are the same as those of the GoogLeNet we described before: the 7 x 7 convolutional layer with 64 output channels and a stride of 2 is followed by the 3 x 3 max-pooling layer with a stride of 2. The difference is the batch normalization layer added after each convolutional layer in ResNet. class ResNet(d2l.Classifier): def b1(self): return nn.Sequential( nn.LazyConv2d(64, kernel_size=7, stride=2, padding=3), nn.LazyBatchNorm2d(), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
GoogLeNet uses four modules made up of Inception blocks. However, ResNet uses four modules made up of residual blocks, each of which uses several residual blocks with the same number of output channels. The number of channels in the first module is the same as the number of input channels. Since a max-pooling layer with a stride of 2 has already been used, it is not necessary to reduce the height and width. In the first residual block for each of the subsequent modules, the number of channels is doubled compared with that of the previous module, and the height and width are halved. @d2l.add_to_class(ResNet) def block(self, num_residuals, num_channels, first_block=False): blk = [] for i in range(num_residuals): if i == 0 and not first_block: blk.append(Residual(num_channels, use_1x1conv=True, strides=2)) else:
(continues on next page)
Residual Networks (ResNet) and ResNeXt
307

blk.append(Residual(num_channels)) return nn.Sequential(*blk)
Then, we add all the modules to ResNet. Here, two residual blocks are used for each mod- ule. Lastly, just like GoogLeNet, we add a global average pooling layer, followed by the fully connected layer output. @d2l.add_to_class(ResNet) def __init__(self, arch, lr=0.1, num_classes=10): super(ResNet, self).__init__() self.save_hyperparameters() self.net = nn.Sequential(self.b1()) for i, b in enumerate(arch): self.net.add_module(f'b{i+2}', self.block(*b, first_block=(i==0))) self.net.add_module('last', nn.Sequential( nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(), nn.LazyLinear(num_classes))) self.net.apply(d2l.init_cnn)
There are four convolutional layers in each module (excluding the 1 x 1 convolutional layer). There are four convolutional layers in each module (excluding the 1 x 1 convolutional layer). Together with the first 7 x7 convolutional layer and the final fully connected layer, there are 18 layers in total. Therefore, this model is commonly known as ResNet-18. By configuring different numbers of channels and residual blocks in the module, we can create different ResNet models, such as the deeper 152-layer ResNet-152. Although the main architecture of ResNet is similar to that of GoogLeNet, ResNet‚Äôs structure is simpler and easier to mod- ify. All these factors have resulted in the rapid and widespread use of ResNet.bubuFig. 8.6.4 depicts the full ResNet-18. Od ‚ÄòNUON LX L v wuou yojeg
tFig. 8.6.4
The ResNet-18 architecture. Before training ResNet, let‚Äôs observe how the input shape changes across different modules in ResNet. As in all the previous architectures, the resolution decreases while the number of channels increases up until the point where a global average pooling layer aggregates all features. class ResNet18(ResNet): def __init__(self, lr=0.1, num_classes=10): super().__init__(((2, 64), (2, 128), (2, 256), (2, 512)), lr, num_classes)
(continued from previous page)
Modern Convolutional Neural Networks
308

ResNet18().layer_summary((1, 1, 96, 96))
Sequential output shape: torch.Size([1, 64, 24, 24]) Sequential output shape: torch.Size([1, 64, 24, 24]) Sequential output shape: torch.Size([1, 128, 12, 12]) Sequential output shape: torch.Size([1, 256, 6, 6]) Sequential output shape: torch.Size([1, 512, 3, 3]) Sequential output shape: torch.Size([1, 10])
8.6.4 Training
We train ResNet on the Fashion-MNIST dataset, just like before. ResNet is quite a pow- erful and flexible architecture. The plot capturing training and validation loss illustrates a significant gap between both graphs, with the training loss being considerably lower. For a network of this flexibility, more training data would offer distinct benefit in closing the gap and improving accuracy. model = ResNet18(lr=0.01) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128, resize=(96, 96)) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) trainer.fit(model, data)
model = ResNet18(lr=0.01)
ee reed 0.8 0.6 ‚Äî train_loss ‚Äî-- val_loss 0.47 \Ss. oS = valace wet Ne hos 0.2 0.0 T i 1 T 0 2 4 6 8 10
8.6.5 ResNeXt
One of the challenges one encounters in the design of ResNet is the trade-off between non- linearity and dimensionality within a given block. That is, we could add more nonlinearity by increasing the number of layers, or by increasing the width of the convolutions. An al- ternative strategy is to increase the number of channels that can carry information between blocks. Unfortunately, the latter comes with a quadratic penalty since the computational cost of ingesting cj channels and emitting co channels is proportional to O(c; - co) (see our discussion in Section 7.4). We can take some inspiration from the Inception block of Fig.bubu8.4.1 which has informa- tion flowing through the block in separate groups. Applying the idea of multiple indepen- dent groups to the ResNet block of Fig. 8.6.3 led to the design of ResNeXt (Xie et al.,
Residual Networks (ResNet) and ResNeXt
309

2017). Different from the smorgasbord of transformations in Inception, ResNeXt adopts the same transformation in all branches, thus minimizing the need for manual tuning of each branch. b ¬¢ output channels ¬¢ output t 1x 1Conv 1x 1 Conv 1 7 Concat b intermediate channels b channels Ty | 3x 3 Conv 3x 3 Conv ane 3x 3 Conv * * b/g channels per group b channels 1x 1Conv 1x 1 Conv nae 1x 1 Conv 1x 1Conv t i ! j i g groups ¬¢ input channels, ¬¢ input channels
tFig. 8.6.5
The ResNeXt block. The use of grouped convolution with g groups is g times faster than a dense convolution. It is a bottleneck residual block when the number of intermediate channels b is less than c. Breaking up a convolution from cj to co channels into one of g groups of size ci/g gener-
Breaking up a convolution from cj to co channels into one of g groups of size ci/g gener- ating g outputs of size co/g is called, quite fittingly, a grouped convolution. The computa- tional cost (proportionally) is reduced from O(c;-Co) to O(g-(ci/g)-(Co/g)) = O(ci-Co/g), ie., itis g times faster. Even better, the number of parameters needed to generate the output is also reduced from a cj X Co matrix to g smaller matrices of size (ci/g) X (Co/g), again a g times reduction. In what follows we assume that both cj and cy are divisible by g. The only challenge in this design is that no information is exchanged between the ùëî groups. The only challenge in this design is that no information is exchanged between the g groups. The ResNeXt block of Fig. 8.6.5 amends this in two ways: the grouped convolution with a 3 x 3 kernel is sandwiched in between two | x | convolutions. The second one serves double duty in changing the number of channels back. The benefit is that we only pay the O(c - b) cost for 1 x 1 kernels and can make do with an O(b/g) cost for 3 x 3 kernels. Similar to the residual block implementation in Section 8.6.2, the residual connection is replaced (thus generalized) by a 1 x 1 convolution. The right-hand figure in Fig. 8.6.5 provides a much more concise summary of the resulting network block. It will also play a major role in the design of generic modern CNNs in Section 8.8. Note that the idea of grouped convolutions dates back to the implementation of AlexNet (Krizhevsky et al., 2012). When distributing the network across two GPUs with limited memory, the implementation treated each GPU as its own channel with no ill effects. The following implementation of the ResNeXtBlock class takes as argument groups (ùëî),
withbot_channels(ùëè)intermediate(bottleneck)channels. Lastly, whenweneedtoreduce
channels
Simplified diagram
Modern Convolutional Neural Networks
310

theheightandwidthoftherepresentation,weaddastrideof2bysettinguse_1x1conv=True, strides=2. class ResNeXtBlock(nn.Module): #@save """The ResNeXt block.""" def __init__(self, num_channels, groups, bot_mul, use_1x1conv=False, strides=1): super().__init__() bot_channels = int(round(num_channels * bot_mul)) self.conv1 = nn.LazyConv2d(bot_channels, kernel_size=1, stride=1) self.conv2 = nn.LazyConv2d(bot_channels, kernel_size=3, stride=strides, padding=1, groups=bot_channels//groups) self.conv3 = nn.LazyConv2d(num_channels, kernel_size=1, stride=1) self.bn1 = nn.LazyBatchNorm2d() self.bn2 = nn.LazyBatchNorm2d() self.bn3 = nn.LazyBatchNorm2d() if use_1x1conv: self.conv4 = nn.LazyConv2d(num_channels, kernel_size=1, stride=strides) self.bn4 = nn.LazyBatchNorm2d() else: self.conv4 = None def forward(self, X): Y = F.relu(self.bn1(self.conv1(X))) Y = F.relu(self.bn2(self.conv2(Y))) Y = self.bn3(self.conv3(Y)) if self.conv4: X = self.bn4(self.conv4(X))
return F.relu(Y + X)
Its use is entirely analogous to that of the ResNetBlock discussed previously. For instance, when using (use_1x1conv=False, strides=1), the input and output are of the same shape. Alternatively, setting use_1x1conv=True, strides=2 halves the output height and width. blk = ResNeXtBlock(32, 16, 1) X = torch.randn(4, 32, 96, 96) blk(X).shape
torch.Size([4, 32, 96, 96])
8.6.6 Summary and Discussion
Nested function classes are desirable since they allow us to obtain strictly more power- ful rather than also subtly different function classes when adding capacity. One way of accomplishing this is by letting additional layers to simply pass through the input to the output.bubuResidual connections allow for this. As a consequence, this changes the inductive bias from simple functions being of the form ùëì ‚Äûx‚Äù = 0 to simple functions looking like ùëì ‚Äûx‚Äù = x. Residual Networks (ResNet) and ResNeXt
311

The residual mapping can learn the identity function more easily, such as pushing param- eters in the weight layer to zero. We can train an effective deep neural network by having residualblocks. Inputscanforwardpropagatefasterthroughtheresidualconnectionsacross layers. As a consequence, we can thus train much deeper networks. For instance, the origi- nal ResNet paper (He et al., 2016) allowed for up to 152 layers. Another benefit of residual networks is that it allows us to add layers, initialized as the identity function, during the training process. After all, the default behavior of a layer is to let the data pass through unchanged. This can accelerate the training of very large networks in some cases. Prior to residual connections, bypassing paths with gating units were introduced to effec- tively train highway networks with over 100 layers (Srivastava et al., 2015). Using identity functions as bypassing paths, ResNet performed remarkably well on multiple computer vi- sion tasks. Residual connections had a major influence on the design of subsequent deep neural networks, of either convolutional or sequential nature. As we will introduce later, the Transformer architecture (Vaswani et al., 2017) adopts residual connections (together with other design choices) and is pervasive in areas as diverse as language, vision, speech, and reinforcement learning. ResNeXt is an example for how the design of convolutional neural networks has evolved over time: by being more frugal with computation and trading it off against the size of the activations (number of channels), it allows for faster and more accurate networks at lower cost. An alternative way of viewing grouped convolutions is to think of a block-diagonal matrix for the convolutional weights. Note that there are quite a few such ‚Äútricks‚Äù that lead to more efficient networks. For instance, ShiftNet (Wu et al., 2018) mimicks the effects of a3x3 convolution, simply by adding shifted activations to the channels, offering increased function complexity, this time without any computational cost. A common feature of the designs we have discussed so far is that the network design is fairly manual, primarily relying on the ingenuity of the designer to find the ‚Äúright‚Äù network hyperparameters. While clearly feasible, it is also very costly in terms of human time and thereisnoguaranteethattheoutcomeisoptimalinanysense. InSection8.8wewilldiscuss a number of strategies for obtaining high quality networks in a more automated fashion. In particular, we will review the notion of network design spaces that led to the RegNetX/Y models (Radosavovic et al., 2020). 8.6.7 Exercises
1. What are the major differences between the Inception block in Fig. 8.4.1 and the residual block? How do they compare in terms of computation, accuracy, and the classes of functions they can describe?bubu2. Refer to Table 1 in the ResNet paper (He et al., 2016) to implement different variants of the network. 3. For deeper networks, ResNet introduces a ‚Äúbottleneck‚Äù architecture to reduce model complexity. Try to implement it.bubu4. In subsequent versions of ResNet, the authors changed the ‚Äúconvolution, batch normal-
Modern Convolutional Neural Networks
312

ization, and activation‚Äù structure to the ‚Äúbatch normalization, activation, and convolu- tion‚Äù structure. Make this improvement yourself.bubuSee Figure 1 in He et al. (2016) for details.bubu5. Why can‚Äôt we just increase the complexity of functions without bound, even if the func- tion classes are nested? Discussions133. 133

8.7 Densely Connected Networks (DenseNet)
a
ResNet significantly changed the view of how to parametrize the functions in deep net- works. DenseNet (dense convolutional network) is to some extent the logical extension of this (Huang et al., 2017). DenseNet is characterized by both the connectivity pattern where each layer connects to all the preceding layers and the concatenation operation (rather than the addition operator in ResNet) to preserve and reuse features from earlier layers. To un- derstand how to arrive at it, let‚Äôs take a small detour to mathematics. import torch from torch import nn from d2l import torch as d2l
8.7.1 From ResNet to DenseNet
Recall the Taylor expansion for functions. At the point ùë• = 0 it can be written as
The key point is that it decomposes a function into terms of increasingly higher order. In a similar vein, ResNet decomposes functions into
ùëì ‚Äûx‚Äù = x ‚Äö ùëî‚Äûx‚Äù. (8.7.2)
That is, ResNet decomposes ùëì into a simple linear term and a more complex nonlinear one. What if we wanted to capture (not necessarily add) information beyond two terms? One such solution is DenseNet (Huang et al., 2017). ¬Æ 7 A A
tFig. 8.7.1
The main difference between ResNet (left) and DenseNet (right) in cross-layer connections: use of addition and use of concatenation. ùëì 00‚Äû0‚Äù
ùëì 000‚Äû0‚Äù
Densely Connected Networks (DenseNet)
313

As shown in Fig. 8.7.1, the key difference between ResNet and DenseNet is that in the latter case outputs are concatenated (denoted by ¬ª,‚Ä¶) rather than added. As a result, we perform a mapping from x to its values after applying an increasingly complex sequence of functions:
x !bubu¬ªx, ùëì1‚Äûx‚Äù, ùëì2 ‚Äû¬ªx, ùëì1 ‚Äûx‚Äù‚Ä¶‚Äù , ùëì3 ‚Äû¬ªx, ùëì1 ‚Äûx‚Äù , ùëì2 ‚Äû¬ªx, ùëì1 ‚Äûx‚Äù‚Ä¶‚Äù‚Ä¶‚Äù , .bubu.bubu.‚Ä¶ . (8.7.3)
In the end, all these functions are combined in MLP to reduce the number of features again. In terms of implementation this is quite simple: rather than adding terms, we concatenate them. ThenameDenseNetarisesfromthefactthatthedependencygraphbetweenvariables becomes quite dense. The final layer of such a chain is densely connected to all previous layers. The dense connections are shown in Fig. 8.7.2. x P| fe Fe} 2 Fo} 40 Y Sf,
tFig. 8.7.2
Dense connections in DenseNet. Note how the dimensionality increases with depth. ThemaincomponentsthatcompriseaDenseNetaredenseblocksandtransitionlayers. The former define how the inputs and outputs are concatenated, while the latter control the num- berofchannelssothatitisnottoolarge,sincetheexpansionx ! ¬ªx, ùëì1‚Äûx‚Äù, ùëì2 ‚Äû¬ªx, ùëì1 ‚Äûx‚Äù‚Ä¶‚Äù , .bubu.bubu.‚Ä¶ can be quite high-dimensional. 8.7.2 Dense Blocks
DenseNet uses the modified ‚Äúbatch normalization, activation, and convolution‚Äù structure of ResNet (see the exercise in Section 8.6). First, we implement this convolution block structure. def conv_block(num_channels): return nn.Sequential( nn.LazyBatchNorm2d(), nn.ReLU(), nn.LazyConv2d(num_channels, kernel_size=3, padding=1))
A dense block consists of multiple convolution blocks, each using the same number of output channels. In the forward propagation, however, we concatenate the input and output of each convolution block on the channel dimension. Lazy evaluation allows us to adjust the dimensionality automatically. class DenseBlock(nn.Module): def __init__(self, num_convs, num_channels): super(DenseBlock, self).__init__() layer = [] for i in range(num_convs): layer.append(conv_block(num_channels)) self.net = nn.Sequential(*layer)
(continues on next page)
Modern Convolutional Neural Networks
314

def forward(self, X): for blk in self.net: Y = blk(X) # Concatenate input and output of each block along the channels X = torch.cat((X, Y), dim=1) return X
In the following example, we define a DenseBlock instance with two convolution blocks of 10 output channels. When using an input with three channels, we will get an output with 3 ‚Äö 10 ‚Äö 10 = 23 channels. The number of convolution block channels controls the growth in the number of output channels relative to the number of input channels. This is also referred to as the growth rate. blk = DenseBlock(2, 10) X = torch.randn(4, 3, 8, 8) Y = blk(X) Y.shape
torch.Size([4, 23, 8, 8])
8.7.3 Transition Layers
Since each dense block will increase the number of channels, adding too many of them will lead to an excessively complex model. A transition layer is used to control the complexity of the model. It reduces the number of channels by using a 1 x 1 convolution. Moreover, it halves the height and width via average pooling with a stride of 2. def transition_block(num_channels): return nn.Sequential( nn.LazyBatchNorm2d(), nn.ReLU(), nn.LazyConv2d(num_channels, kernel_size=1), nn.AvgPool2d(kernel_size=2, stride=2))
Apply a transition layer with 10 channels to the output of the dense block in the previous example. This reduces the number of output channels to 10, and halves the height and width. blk = transition_block(10) blk(Y).shape
torch.Size([4, 10, 4, 4])
8.7.4 DenseNet Model
(continued from previous page)
Densely Connected Networks (DenseNet)
315

Next, we will construct a DenseNet model. DenseNet first uses the same single convolu- tional layer and max-pooling layer as in ResNet. class DenseNet(d2l.Classifier): def b1(self): return nn.Sequential( nn.LazyConv2d(64, kernel_size=7, stride=2, padding=3), nn.LazyBatchNorm2d(), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))
Then, similar to the four modules made up of residual blocks that ResNet uses, DenseNet uses four dense blocks. As with ResNet, we can set the number of convolutional layers used in each dense block. Here, we set it to 4, consistent with the ResNet-18 model in Section 8.6. Furthermore, we set the number of channels (i.e., growth rate) for the convolutional layers in the dense block to 32, so 128 channels will be added to each dense block. In ResNet, the height and width are reduced between each module by a residual block with a stride of 2. Here, we use the transition layer to halve the height and width and halve the number of channels. Similar to ResNet, a global pooling layer and a fully connected layer are connected at the end to produce the output. @d2l.add_to_class(DenseNet) def __init__(self, num_channels=64, growth_rate=32, arch=(4, 4, 4, 4), lr=0.1, num_classes=10): super(DenseNet, self).__init__() self.save_hyperparameters() self.net = nn.Sequential(self.b1()) for i, num_convs in enumerate(arch): self.net.add_module(f'dense_blk{i+1}', DenseBlock(num_convs, growth_rate)) # The number of output channels in the previous dense block num_channels += num_convs * growth_rate # A transition layer that halves the number of channels is added # between the dense blocks if i != len(arch) - 1: num_channels //= 2 self.net.add_module(f'tran_blk{i+1}', transition_block( num_channels)) self.net.add_module('last', nn.Sequential( nn.LazyBatchNorm2d(), nn.ReLU(), nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(), nn.LazyLinear(num_classes))) self.net.apply(d2l.init_cnn)
8.7.5 Training
Since we are using a deeper network here, in this section, we will reduce the input height and width from 224 to 96 to simplify the computation. Modern Convolutional Neural Networks
316

model = DenseNet(lr=0.01) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128, resize=(96, 96)) trainer.fit(model, data)
ee et 085) 7 0.6 ‚Äî train_loss --- val_loss 04 . ‚Äî-- val_acce > F wo! ‚Äú~ 0.2 0 2 4 6 8 10
8.7.6 Summary and Discussion
The main components that comprise DenseNet are dense blocks and transition layers. For the latter, we need to keep the dimensionality under control when composing the net- work by adding transition layers that shrink the number of channels again. In terms of cross-layer connections, in contrast to ResNet, where inputs and outputs are added to- gether, DenseNet concatenates inputs and outputs on the channel dimension. Although these concatenation operations reuse features to achieve computational efficiency, unfortu- nately they lead to heavy GPU memory consumption. As a result, applying DenseNet may require more memory-efficient implementations that may increase training time (Pleiss et al., 2017). 8.7.7 Exercises
1. Why do we use average pooling rather than max-pooling in the transition layer? 2. One of the advantages mentioned in the DenseNet paper is that its model parameters are smaller than those of ResNet. Why is this the case?bubu3. One problem for which DenseNet has been criticized is its high memory consumption. 1.bubuIs this really the case? Try to change the input shape to 224 x 224 to compare the
actual GPU memory consumption empirically. 2. Can you think of an alternative means of reducing the memory consumption? How would you need to change the framework?bubu4. Implement the various DenseNet versions presented in Table 1 of the DenseNet paper (Huang et al., 2017). 5. Design an MLP-based model by applying the DenseNet idea. Apply it to the housing price prediction task in Section 5.7. 134
Discussions134. Designing Convolution Network Architectures
317

8.8 Designing Convolution Network Architectures
a
The previous sections have taken us on a tour of modern network design for computer vision. Common to all the work we covered was that it greatly relied on the intuition of scientists. Many of the architectures are heavily informed by human creativity and to a much lesser extent by systematic exploration of the design space that deep networks offer. Nonetheless, this network engineering approach has been tremendously successful. Ever since AlexNet (Section 8.1) beat conventional computer vision models on ImageNet, it has become popular to construct very deep networks by stacking blocks of convolutions, all designed according to the same pattern. In particular, 3 x 3 convolutions were popular- ized by VGG networks (Section 8.2). NiN (Section 8.3) showed that even 1 x 1 convolu- tions could be beneficial by adding local nonlinearities. Moreover, NiN solved the problem of aggregating information at the head of a network by aggregating across all locations. GoogLeNet (Section 8.4) added multiple branches of different convolution width, combin- ing the advantages of VGG and NiN in its Inception block. ResNets (Section 8.6) changed the inductive bias towards the identity mapping (from f(x) = 0). This allowed for very deep networks. Almost a decade later, the ResNet design is still popular, a testament to its design. Lastly, ResNeXt (Section 8.6.5) added grouped convolutions, offering a better trade-off between parameters and computation. A precursor to Transformers for vision, the Squeeze-and-Excitation Networks (SENets) allow for efficient information transfer be- tween locations (Hu et al., 2018). This was accomplished by computing a per-channel global attention function. Up to now we have omitted networks obtained via neural architecture search (NAS) (Liu et al., 2018, Zoph and Le, 2016). We chose to do so since their cost is usually enormous, relying on brute-force search, genetic algorithms, reinforcement learning, or some other form of hyperparameter optimization. Given a fixed search space, NAS uses a search strat- egy to automatically select an architecture based on the returned performance estimation. The outcome of NAS is a single network instance. EfficientNets are a notable outcome of this search (Tan and Le, 2019). In the following we discuss an idea that is quite different to the quest for the single best network. It is computationally relatively inexpensive, it leads to scientific insights on the way, and it is quite effective in terms of the quality of outcomes. Let‚Äôs review the strategy by Radosavovic et al. (2020) to design network design spaces. The strategy combines the strength of manual design and NAS. It accomplishes this by operating on distributions of networks and optimizing the distributions in a way to obtain good performance for entire families of networks. The outcome of it are RegNets, specifically RegNetX and RegNetY, plus a range of guiding principles for the design of performant CNNs. import torch from torch import nn
(continues on next page)
Modern Convolutional Neural Networks
318

from torch.nn import functional as F from d2l import torch as d2l
8.8.1 The AnyNet Design Space
Thedescriptionbelowcloselyfollowsthe reasoninginRadosavovicetal. (2020)withsome abbreviations to make it fit in the scope of the book.bubuTo begin, we need a template for the family of networks to explore. One of the commonalities of the designs in this chapter is that the networks consist of a stem, a body and a head. The stem performs initial image processing, often through convolutions with a larger window size. The body consists of multiple blocks, carrying out the bulk of the transformations needed to go from raw images to object representations. Lastly, the head converts this into the desired outputs, such as via a softmax regressor for multiclass classification. The body, in turn, consists of multiple stages, operating on the image at decreasing resolutions. In fact, both the stem and each subsequent stage quarter the spatial resolution. Lastly, each stage consists of one or more blocks. This pattern is common to all networks, from VGG to ResNeXt. Indeed, for the design of generic AnyNet networks, Radosavovic et al. (2020) used the ResNeXt block of Fig.bubu8.6.5. eq 32 on ‚Äô 4 Stage4 | [ Block g, + 7 ¬©-‚Äî, nl f cy r/l6 opr, cpr, Head Stage 3 ue 4.x 1 Cony, stride 1 1x 1 Conv, stride 1 + 7 ' 7 ey 1132 er cor, elk, ofkr, opr 3x 3 Conv 3x 3Conv as @am Body SE 2 Sleek 2 ‚Äò¬¢, groups, stride 1 , groups, stride 2 stride 2 HD ey, rd pt, olka, f ¬© Jk anh Stem Stage 1 | | Block 4 1x4 Cony, stride 4 1x1 Cony, stride 1 7 ¬• ¬• t t Br ey 112 Cj 2h, opr, en 2, AnyNet Body Stage i ResNeXt block ResNext block with downsampling
tFig. 8.8.1
The AnyNet design space. The numbers (c, 7) along each arrow indicate the number of channels c and the resolution r x r of the images at that point. From left to right: generic network structure composed of stem, body, and head; body composed of four stages; detailed structure of a stage; two alternative structures for blocks, one without downsampling and one that halves the resolution in each dimension. Design choices include depth d;, the number of output channels c;, the number of groups g;, and bottleneck ratio k; for any stage 7. Let‚Äôs review the structure outlined in Fig.bubu8.8.1 in detail. As mentioned, an AnyNet consists of a stem, body, and head. The stem takes as its input RGB images (3 channels), using a 3 x 3 convolution with a stride of 2, followed by a batch norm, to halve the resolution from rxrtor/2xr/2. Moreover, it generates co channels that serve as input to the body. (continued from previous page)
Designing Convolution Network Architectures
319

Since the network is designed to work well with ImageNet images of shape 224 x 224 x 3,
Since the network is designed to work well with ImageNet images of shape 224 x 224 x 3, the body serves to reduce this to 7 x 7 x cq through 4 stages (recall that 224/2!*4 = 7), each with an eventual stride of 2. Lastly, the head employs an entirely standard design via global average pooling, similar to NiN (Section 8.3), followed by a fully connected layer to emit an n-dimensional vector for n-class classification. Most of the relevant design decisions are inherent to the body of the network. It proceeds in stages, where each stage is composed of the same type of ResNeXt blocks as we discussed in Section 8.6.5. The design there is again entirely generic: we begin with a block that halves the resolution by using a stride of 2 (the rightmost in Fig. 8.8.1). To match this, the residual branch of the ResNeXt block needs to pass through a | x 1 convolution. This block is followed by a variable number of additional ResNeXt blocks that leave both resolution and the number of channels unchanged. Note that a common design practice is to add a slight bottleneck in the design of convolutional blocks. As such, with bottleneck ratio k; = 1 we afford some number of channels, c;/k;, within each block for stage i (as the experiments show, this is not really effective and should be skipped). Lastly, since we are dealing with ResNeXt blocks, we also need to pick the number of groups g; for grouped convolutions at stage i. This seemingly generic design space provides us nonetheless with many parameters: we can set the block width (number of channels) ùëê0, . .bubu. ùëê4, the depth (number of blocks) per stage ùëë1, . .bubu. ùëë4, the bottleneck ratios ùëò1, . .bubu. ùëò4, and the group widths (numbers of groups) ùëî1, . .bubu.bubuùëî4. In total this adds up to 17 parameters, resulting in an unreasonably large number of configurations that would warrant exploring. We need some tools to reduce this huge design space effectively. This is where the conceptual beauty of design spaces comes in.bubuBefore we do so, let‚Äôs implement the generic design first. class AnyNet(d2l.Classifier): def stem(self, num_channels): return nn.Sequential( nn.LazyConv2d(num_channels, kernel_size=3, stride=2, padding=1), nn.LazyBatchNorm2d(), nn.ReLU())
Each stage consists of depth ResNeXt blocks, where num_channels specifies the block width. Note that the first block halves the height and width of input images. @d2l.add_to_class(AnyNet) def stage(self, depth, num_channels, groups, bot_mul): blk = [] for i in range(depth): if i == 0: blk.append(d2l.ResNeXtBlock(num_channels, groups, bot_mul, use_1x1conv=True, strides=2)) else: blk.append(d2l.ResNeXtBlock(num_channels, groups, bot_mul)) return nn.Sequential(*blk)
Putting the network stem, body, and head together, we complete the implementation of
AnyNet. Modern Convolutional Neural Networks
320

@d2l.add_to_class(AnyNet) def __init__(self, arch, stem_channels, lr=0.1, num_classes=10): super(AnyNet, self).__init__() self.save_hyperparameters() self.net = nn.Sequential(self.stem(stem_channels)) for i, s in enumerate(arch): self.net.add_module(f'stage{i+1}', self.stage(*s)) self.net.add_module('head', nn.Sequential( nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(), nn.LazyLinear(num_classes))) self.net.apply(d2l.init_cnn)
8.8.2 Distributions and Parameters of Design Spaces
As just discussed in Section 8.8.1, parameters of a design space are hyperparameters of networks in that design space. Consider the problem of identifying good parameters in the AnyNet design space. We could try finding the single best parameter choice for a given amount of computation (e.g., FLOPs and compute time). If we allowed for even only two possible choices for each parameter, we would have to explore 217 = 131072 combinations to find the best solution. This is clearly infeasible because of its exorbitant cost. Even worse, we do not really learn anything from this exercise in terms of how one should design a network. Next time we add, say, an X-stage, or a shift operation, or similar, we would need to start from scratch. Even worse, due to the stochasticity in training (rounding, shuffling, bit errors), no two runs are likely to produce exactly the same results. A better strategy would be to try to determine general guidelines of how the choices of parameters should be related. For instance, the bottleneck ratio, the number of channels, blocks, groups, or their change between layers should ideally be governed by a collection of simple rules. The approach in Radosavovic et al. (2019) relies on the following four assumptions:
1. We assume that general design principles actually exist, so that many networks satis- fying these requirements should offer good performance. Consequently, identifying a distribution over networks can be a sensible strategy. In other words, we assume that there are many good needles in the haystack. 2. We need not train networks to convergence before we can assess whether a network is good. Instead, it is sufficient to use the intermediate results as reliable guidance for final accuracy. Using (approximate) proxies to optimize an objective is referred to as multi-fidelityoptimization(Forresteretal., 2007). Consequently, designoptimizationis carried out, based on the accuracy achieved after only a few passes through the dataset, reducing the cost significantly. 3. Results obtained at a smaller scale (forsmaller networks) generalizeto largerones. Con- sequently, optimization is carried out for networks that are structurally similar, but with a smaller number of blocks, fewer channels, etc. Only in the end will we need to verify that the so-found networks also offer good performance at scale. 4. Aspects of the design can be approximately factorized so that it is possible to infer
Designing Convolution Network Architectures
321

their effect on the quality of the outcome somewhat independently. In other words, the optimization problem is moderately easy. These assumptions allow us to test many networks cheaply. In particular, we can sample uniformly from the space of configurations and evaluate their performance. Subsequently, we can evaluate the quality of the choice of parameters by reviewing the distribution of error/accuracy that can be achieved with said networks. Denote by ùêπ‚Äûùëí‚Äù the cumulative distribution function (CDF) for errors committed by networks of a given design space, drawn using probability disribution ùëù. That is,
ùêπ‚Äûùëí, ùëù‚Äù def
F(e,p) ¬© Prep {e(net) < e}. (8.8.1)
Our goal is now to find a distribution ùëù over networks such that most networks have a very
low error rate and where the support of ùëù is concise. Of course, this is computationally infeasible to perform accurately. We resort to a sample of networks Z def = fnet1, . .bubu.netùëõg (witherrorsùëí1, .bubu. ., ùëíùëõ,respectively)from ùëù andusetheempiricalCDF ÀÜùêπ‚Äûùëí,Z‚Äù instead:
n F(e,Z) = ty 1(e: <e). n (8.8.2) i=l
Whenever the CDF for one set of choices majorizes (or matches) another CDF it follows that its choice of parameters is superior (or indifferent). Accordingly Radosavovic et al. (2020) experimented with a shared network bottleneck ratio ùëòùëñ = ùëò for all stages ùëñ of the network. This gets rid of three of the four parameters governing the bottleneck ratio. To assess whether this (negatively) affects the performance one can draw networks from the constrained and from the unconstrained distribution and compare the corresonding CDFs. It turns out that this constraint does not affect the accuracy of the distribution of networks at all, as can be seen in the first panel of Fig. 8.8.2. Likewise, we could choose to pick the same group width ùëîùëñ = ùëî occurring at the various stages of the network. Again, this does not affect performance, as can be seen in the second panel of Fig.bubu8.8.2. Both steps combined reduce the number of free parameters by six. cumulative prob. '‚Äî [39.0/49.0] AnyNetX, ‚Äî [39.0/49.2] AnyNetXs ‚Äî 139.0/49.2] AnyNetXs ‚Äî [38.9]49.4] AnyNetXe ‚Äî 138.9149.4] AnyNetXe ‚Äî 138.7/43.2) + wie ew ‚Äî [47.5|56.1] + wie = ‚Äî 152.2|63.2] + wie sm J ‚Äî‚Äî [38.7/43.2] AnyNetXo [38.7/42.7] + dy. 24) ‚Äî [39,0/46.6] + ds.bubu=0) ‚Äî 141.0/48.8) + din sd 40 45 ¬´50 55 60 65 70 error 40 50 60 70 error 40 50 60 70 error 45 50 35 error
tFig. 8.8.2
Comparing error empirical distribution functions of design spaces. AnyNetA is the original design space; AnyNetB ties the bottleneck ratios, AnyNetC also ties group widths, AnyNetD increases the network depth across stages. From left to right: (i) tying bottleneck ratios has no effect on performance; (ii) tying group widths has no effect on performance; (iii) increasing network widths (channels) across stages improves performance; (iv) increasing network depths across stages improves performance. Figure courtesy of Radosavovic et al.bubu(2020). Nextwelookforwaystoreducethemultitudeofpotentialchoicesforwidthanddepthofthe
n
Modern Convolutional Neural Networks
322

stages. It is a reasonable assumption that, as we go deeper, the number of channels should increase, i.e., cj > Cj-1 (Wi+1 = Wi per their notation in Fig. 8.8.2), yielding AnyNetXp. Likewise, it is equally reasonable to assume that as the stages progress, they should become deeper, i.e., dj > dj-1, yielding AnyNetX,,. This can be experimentally verified in the third and fourth panel of Fig. 8.8.2, respectively. 8.8.3 RegNet
TheresultingAnyNetXùê∏ designspaceconsistsofsimplenetworksfollowingeasy-to-interpret design principles:
e Share the bottleneck ratio k; = k for all stages i;
e Share the group width g; = g for all stages 7;
e Increase network width across stages: cj < Ci+13
e Increase network depth across stages: dj < dj+1. This leaves us with a final set of choices: how to pick the specific values for the above parameters of the eventual AnyNetX, design space. By studying the best-performing networks from the distribution in AnyNetX, one can observe the following: the width of the network ideally increases linearly with the block index across the network, i.e., cj ¬© Co +CaJ, where j is the block index and slope cq > 0. Given that we get to choose a different block width only per stage, we arrive at a piecewise constant function, engineered to match this dependence. Furthermore, experiments also show that a bottleneck ratio of k = 1 performs best, i.e., we are advised not to use bottlenecks at all. We recommend the interested reader reviews further details in the design of specific net- works for different amounts of computation by perusing Radosavovic et al. (2020). For instance, an effective 32-layer RegNetX variant is given by ùëò = 1 (no bottleneck), ùëî = 16 (group width is 16), ùëê1 = 32 and ùëê2 = 80 channels for the first and second stage, respec- tively, chosen to be ùëë1 = 4 and ùëë2 = 6 blocks deep. The astonishing insight from the design is that it still applies, even when investigating networks at a larger scale. Even bet- ter, it even holds for Squeeze-and-Excitation (SE) network designs (RegNetY) that have a global channel activation (Hu et al., 2018). class RegNetX32(AnyNet): def __init__(self, lr=0.1, num_classes=10): stem_channels, groups, bot_mul = 32, 16, 1 depths, channels = (4, 6), (32, 80) super().__init__( ((depths[0], channels[0], groups, bot_mul), (depths[1], channels[1], groups, bot_mul)), stem_channels, lr, num_classes)
We can see that each RegNetX stage progressively reduces resolution and increases output channels. Designing Convolution Network Architectures
323

RegNetX32().layer_summary((1, 1, 96, 96))
Sequential output shape:
torch.Size([1, 32, 48, 48])
Sequential output shape: torch.Size([1, 32, 24, 24]) Sequential output shape: torch.Size([1, 80, 12, 12]) Sequential output shape: torch.Size([1, 10])
8.8.4 Training
Training the 32-layer RegNetX on the Fashion-MNIST dataset is just like before. model = RegNetX32(lr=0.05) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128, resize=(96, 96)) trainer.fit(model, data)
0.8 0.6 ‚Äî train_loss ‚Äî-- val_loss . ‚Äî-- val_ace 0.4 ran ete et 0.2 0 2 4 6 8 10
8.8.5 Discussion
With desirable inductive biases (assumptions or preferences) like locality and translation invariance (Section 7.1) for vision, CNNs have been the dominant architectures in this area. This remained the case from LeNet up until Transformers (Section 11.7) (Dosovitskiy et al., 2021, Touvron et al., 2021) started surpassing CNNs in terms of accuracy. While much of the recent progress in terms of vision Transformers can be backported into CNNs (Liu et al., 2022), it is only possible at a higher computational cost. Just as importantly, recent hardware optimizations (NVIDIA Ampere and Hopper) have only widened the gap in favor of Transformers. It is worth noting that Transformers have a significantly lower degree of inductive bias to- wards locality and translation invariance than CNNs. That learned structures prevailed is due, not least, to the availability of large image collections, such as LAION-400m and LAION-5B (Schuhmann et al., 2022) with up to 5 billion images. Quite surprisingly, some of the more relevant work in this context even includes MLPs (Tolstikhin et al., 2021). In sum, vision Transformers (Section 11.8) by now lead in terms of state-of-the-art perfor- mance in large-scale image classification, showing that scalability trumps inductive biases
Modern Convolutional Neural Networks
324

(Dosovitskiy et al., 2021). This includes pretraining large-scale Transformers (Section 11.9) with multi-head self-attention (Section 11.5). We invite the readers to dive into these chapters for a much more detailed discussion.bubu8.8.6 Exercises
1. Increase the number of stages to four. Can you design a deeper RegNetX that performs better? 2. De-ResNeXt-ify RegNets by replacing the ResNeXt block with the ResNet block. How does your new model perform?bubu3. Implement multiple instances of a ‚ÄúVioNet‚Äù family by violating the design principles of RegNetX. How do they perform?bubuWhich of (ùëëùëñ, ùëêùëñ, ùëîùëñ, ùëèùëñ) is the most important factor? 4. Your goal is to design the ‚Äúperfect‚Äù MLP. Can you use the design principles introduced above to find good architectures? Is it possible to extrapolate from small to large net- works?bubuDiscussions135. 135
9
Recurrent Neural Networks
Up until now, we have focused primarily on fixed-length data. When introducing linear and logistic regression in Chapter 3 and Chapter 4 and multilayer perceptrons in Chapter 5, we werehappytoassumethateachfeaturevectorxùëñ consistedofafixednumberofcomponents ùë•1, . .bubu.,ùë•ùëë, where each numerical feature ùë• ùëó corresponded to a particular attribute. These datasets are sometimes called tabular, because they can be arranged in tables, where each example ùëñ gets its own row, and each attribute gets its own column. Crucially, with tabular data, we seldom assume any particular structure over the columns. Subsequently, in Chapter 7, we moved on to image data, where inputs consist of the raw pixel values at each coordinate in an image. Image data hardly fitted the bill of a protypical tabular dataset. There, we needed to call upon convolutional neural networks (CNNs) to handle the hierarchical structure and invariances. However, our data were still of fixed length. Every Fashion-MNIST image is represented as a 28 x 28 grid of pixel values. Moreover, our goal was to develop a model that looked at just one image and then outputted a single prediction. But what should we do when faced with a sequence of images, as in a video, or when tasked with producing a sequentially structured prediction, as in the case of image captioning? A great many learning tasks require dealing with sequential data. Image captioning, speech synthesis, and music generation all require that models produce outputs consisting of se- quences. In other domains, such as time series prediction, video analysis, and musical information retrieval, a model must learn from inputs that are sequences. These demands often arise simultaneously: tasks such as translating passages of text from one natural lan- guage to another, engaging in dialogue, or controlling a robot, demand that models both ingest and output sequentially structured data. Recurrent neural networks (RNNs) are deep learning models that capture the dynamics of sequences via recurrent connections, which can be thought of as cycles in the network of nodes. This might seem counterintuitive at first. After all, it is the feedforward nature of neural networks that makes the order of computation unambiguous. However, recurrent edges are defined in a precise way that ensures that no such ambiguity can arise. Recurrent neural networks are unrolled across time steps (or sequence steps), with the same under- lying parameters applied at each step. While the standard connections are applied syn- chronously to propagate each layer‚Äôs activations to the subsequent layer at the same time step, therecurrentconnectionsaredynamic, passinginformationacrossadjacenttimesteps. As the unfolded view in Fig. 9.1 reveals, RNNs can be thought of as feedforward neural
325
Recurrent Neural Networks
326

networks where each layer‚Äôs parameters (both conventional and recurrent) are shared across time steps. Output Output 4 Output 2 Output Output T a | Jt [ J / !bubuHidden Hidden |_| Hidden |_| |_| Hidden | layers layers 1 layers 2 = layers T \ Input Input 1 Input 2 Input ... Input 7
tFig. 9.1
On the left recurrent connections are depicted via cyclic edges. On the right, we unfold the RNN over time steps. Here, recurrent edges span adjacent time steps, while conventional connections are computed synchronously. Like neural networks more broadly, RNNs have a long discipline-spanning history, origi- nating as models of the brain popularized by cognitive scientists and subsequently adopted as practical modeling tools employed by the machine learning community. As we do for deep learning more broadly, in this book we adopt the machine learning perspective, focus- ing on RNNs as practical tools that rose to popularity in the 2010s owing to breakthrough results on such diverse tasks as handwriting recognition (Graves et al., 2008), machine translation(Sutskeveretal.,2014),andrecognizingmedicaldiagnoses(Liptonetal.,2016). We point the reader interested in more background material to a publicly available compre- hensive review (Lipton et al., 2015). We also note that sequentiality is not unique to RNNs. For example, the CNNs that we already introduced can be adapted to handle data of varying length, e.g., images of varying resolution. Moreover, RNNs have recently ceded consider- able market share to Transformer models, which will be covered in Chapter 11. However, RNNs rose to prominence as the default models for handling complex sequential structure in deep learning, and remain staple models for sequential modeling to this day. The stories of RNNs and of sequence modeling are inextricably linked, and this is as much a chapter about the ABCs of sequence modeling problems as it is a chapter about RNNs. One key insight paved the way for a revolution in sequence modeling. While the inputs and targets for many fundamental tasks in machine learning cannot easily be represented as fixed-length vectors, they can often nevertheless be represented as varying-length se- quences of fixed-length vectors. For example, documents can be represented as sequences of words; medical records can often be represented as sequences of events (encounters, medications, procedures, lab tests, diagnoses); videos can be represented as varying-length sequences of still images. Whilesequencemodelshavepoppedupinnumerousapplicationareas, basicresearchinthe area has been driven predominantly by advances on core tasks in natural language process- ing. Thus, throughout this chapter, we will focus our exposition and examples on text data. If you get the hang of these examples, then applying the models to other data modalities should be relatively straightforward. In the next few sections, we introduce basic notation for sequences and some evaluation measures for assessing the quality of sequentially struc- tured model outputs. After that, we discuss basic concepts of a language model and use this
Working with Sequences
327

discussion to motivate our first RNN models. Finally, we describe the method for calculat- ing gradients when backpropagating through RNNs and explore some challenges that are often encountered when training such networks, motivating the modern RNN architectures that will follow in Chapter 10. 9.1 Working with Sequences

Up until now, we have focused on models whose inputs consisted of a single feature vector x 2 Rùëë. The main change of perspective when developing models capable of processing sequences is that we now focus on inputs that consist of an ordered list of feature vec- tors x1, . . .,xùëá, where each feature vector xùë° is indexed by a time step ùë° 2 Z‚Äö lying in Rùëë. Some datasets consist of a single massive sequence. Consider, for example, the extremely long streams of sensor readings that might be available to climate scientists. In such cases, we might create training datasets by randomly sampling subsequences of some predeter- mined length. More often, our data arrives as a collection of sequences. Consider the following examples: (i) a collection of documents, each represented as its own sequence of words, and each having its own lengthùëáùëñ; (ii) sequence representation of patient stays in the hospital, where each stay consists of a number of events and the sequence length depends roughly on the length of the stay. Previously, when dealing with individual inputs, we assumed that they were sampled inde- pendently from the same underlying distribution ùëÉ‚Äûùëã‚Äù. While we still assume that entire sequences (e.g., entire documents or patient trajectories) are sampled independently, we cannot assume that the data arriving at each time step are independent of each other. For example, the words that likely to appear later in a document depend heavily on words oc- curring earlier in the document. The medicine a patient is likely to receive on the 10th day of a hospital visit depends heavily on what transpired in the previous nine days. This should come as no surprise.bubuIf we did not believe that the elements in a sequence were related, we would not have bothered to model them as a sequence in the first place. Consider the usefulness of the auto-fill features that are popular on search tools and modern email clients. They are useful precisely because it is often possible to predict (imperfectly, but better than random guessing) what the likely continuations of a sequence might be, given some initial prefix. For most sequence models, we do not require independence, or even stationarity, of our sequences. Instead, we require only that the sequences themselves are sampled from some fixed underlying distribution over entire sequences. This flexible approach allows for such phenomena as (i) documents looking significantly different at the beginning than at the end; or (ii) patient status evolving either towards recov- eryortowardsdeathoverthecourseofahospitalstay; or(iii)customertasteevolvinginpre- dictable ways over the course of continued interaction with a recommender system. Recurrent Neural Networks
328

We sometimes wish to predict a fixed target ùë¶ given sequentially structured input (e.g., sen-
timent classification based on a movie review). At other times, we wish to predict a sequen- tially structured target (ùë¶1, . . ., ùë¶ùëá) given a fixed input (e.g., image captioning). Still other times, our goal is to predict sequentially structured targets based on sequentially structured inputs (e.g., machine translation or video captioning). Such sequence-to-sequence tasks take two forms: (i) aligned: where the input at each time step aligns with a correspond- ing target (e.g., part of speech tagging); (ii) unaligned: where the input and target do not necessarily exhibit a step-for-step correspondence (e.g., machine translation). Before we worry about handling targets of any kind, we can tackle the most straightforward problem: unsupervised density modeling (also called sequence modeling). Here, given a collection of sequences, our goal is to estimate the probability mass function that tells us how likely we are to see any given sequence, i.e., ùëù‚Äûx1, . .bubu.,xùëá‚Äù. %matplotlib inline import torch from torch import nn from d2l import torch as d2l
9.1.1 Autoregressive Models
Before introducing specialized neural networks designed to handle sequentially structured data, let‚Äôs take a look at some actual sequence data and build up some basic intuitions and statistical tools. In particular, we will focus on stock price data from the FTSE 100 index (Fig.bubu9.1.1). At each time step ùë° 2 Z‚Äö, we observe the price, ùë•ùë°, of the index at that time. FTSE 100 Index 1983 1983 ase 1s 2008 2008 2018
tFig. 9.1.1
FTSE 100 index over about 30 years. Now suppose that a trader would like to make short-term trades, strategically getting into or out of the index, depending on whether they believe that it will rise or decline in the subsequent time step. Absent any other features (news, financial reporting data, etc.), the
Working with Sequences
329

only available signal for predicting the subsequent value is the history of prices to date. The trader is thus interested in knowing the probability distribution
P(x; | Xt-1,---5%1)
(9.1.1)
overpricesthattheindexmighttakeinthesubsequenttimestep. Whileestimatingtheentire distribution over a continuously valued random variable can be difficult, the trader would be happy to focus on a few key statistics of the distribution, particularly the expected value and the variance. One simple strategy for estimating the conditional expectation
El(y | 4r-1,---.*1)],
(9.1.2)
would be to apply a linear regression model (recall Section 3.1). Such models that regress the value of a signal on the previous values of that same signal are naturally called au- toregressive models. There is just one major problem: the number of inputs, x;-1,...,x1 varies, depending on f. In other words, the number of inputs increases with the amount of data that we encounter. Thus if we want to treat our historical data as a training set, we are left with the problem that each example has a different number of features. Much of what follows in this chapter will revolve around techniques for overcoming these challenges when engaging in such autoregressive modeling problems where the object of interest is P(x; | Xt-1,---,X1) or some statistic(s) of this distribution. A few strategies recur frequently. First of all, we might believe that although long sequences Xt-1,.-.-,X1 are available, it may not be necessary to look back so far in the history when predicting the near future. In this case we might content ourselves to condition on some window of length 7 and only use x;_1,...,X;-7 observations. The immediate benefit is that now the number of arguments is always the same, at least for t > t. This allows us to train any linear model or deep network that requires fixed-length vectors as inputs. Second, we might develop models that maintain some summary /; of the past observations (see Fig. 9.1.2) and at the same time update h; in addition to the prediction ¬£;. This leads to models that estimate not only x, with ¬£, = P(x; | fr) but also updates of the form h; = g(hr-1,X1-1). Since h; is never observed, these models are also called latent autoregressive models. ‚ÄúAEE h, >| hh, >| h, Hidden state
tFig. 9.1.2
A latent autoregressive model. To construct training data from historical data, one typically creates examples by sampling windows randomly. In general, we do not expect time to stand still. However, we often assume that while the specific values of ùë•ùë° might change, the dynamics according to which each subsequent observation is generated given the previous observations do not. Statisti- cians call dynamics that do not change stationary. Recurrent Neural Networks
330

9.1.2 Sequence Models
Sometimes, especially when working with language, we wish to estimate the joint probabil- ity of an entire sequence. This is a common task when working with sequences composed of discrete tokens, such as words. Generally, these estimated functions are called sequence models and for natural language data, they are called language models. The field of se- quence modeling has been driven so much by natural language processing, that we often describe sequence models as ‚Äúlanguage models‚Äù, even when dealing with non-language data. Language models prove useful for all sorts of reasons. Sometimes we want to evalu- ate the likelihood of sentences. For example, we might wish to compare the naturalness of two candidate outputs generated by a machine translation system or by a speech recognition system. But language modeling gives us not only the capacity to evaluate likelihood, but the ability to sample sequences, and even to optimize for the most likely sequences. While language modeling might not, at first glance, look like an autoregressive problem, we can reduce language modeling to autoregressive prediction by decomposing the joint density of a sequence ùëù‚Äûùë•1, . . .,ùë•ùëá‚Äù into the product of conditional densities in a left-to- right fashion by applying the chain rule of probability:
T P(x1,..-.X7) = Poa) |] PG | Xpotse-. 5X1). (9.1.3) t=2
Note that if we are working with discrete signals such as words, then the autoregressive model must be a probabilistic classifier, outputting a full probability distribution over the vocabulary for whatever word will come next, given the leftwards context. Markov Models
Now suppose that we wish to employ the strategy mentioned above, where we condition only on the t previous time steps, i.e., x;-1,... ,X;-7, rather than the entire sequence history X+-1,...,X1. Whenever we can throw away the history beyond the previous Tt steps without any loss in predictive power, we say that the sequence satisfies a Markov condition, i.e., that the future is conditionally independent of the past, given the recent history. When t = 1, we say that the data is characterized by a first-order Markov model, and when t = k, we say that the data is characterized by a k'*-order Markov model. For when the first-order Markov condition holds (t = 1) the factorization of our joint probability becomes a product of probabilities of each word given the previous word:
T P(x1,...,X7) = P(x) | [PG | x7-1). (9.1.4) t=2
We often find it useful to work with models that proceed as though a Markov condition were satisfied, even when we know that this is only approximately true. With real text documents we continue to gain information as we include more and more leftwards context. But these gains diminish rapidly. Thus, sometimes we compromise, obviating computational and statistical difficulties by training models whose validity depends on a ùëòth-order Markov condition. Even today‚Äôs massive RNN- and Transformer-based language models seldom incorporate more than thousands of words of context. T
T
Working with Sequences
331

With discrete data, a true Markov model simply counts the number of times that each word has occurred in each context, producing the relative frequency estimate of P(x; | x;-1). Whenever the data assumes only discrete values (as in language), the most likely sequence of words can be computed efficiently using dynamic programming. The Order of Decoding
Youmaybewonderingwhywerepresentedthefactorizationofatextsequence ùëÉ‚Äûùë•1, . . .,ùë•ùëá‚Äù as a left-to-right chain of conditional probabilities. Why not right-to-left or some other, seeminglyrandomorder? Inprinciple, thereisnothingwrongwithunfolding ùëÉ‚Äûùë•1, . .bubu.,ùë•ùëá‚Äù in reverse order. The result is a valid factorization:
1 P(x1,...,Xr) = P(xr) I] P(x; | Xt41,---,X7)- (9.1.5) t=T-1
However, there are many reasons why factorizing text in the same direction in which we readit(left-to-rightformostlanguages, butright-to-leftforArabicandHebrew)ispreferred for the task of language modeling. First, this is just a more natural direction for us to think about.bubuAfter all we all read text every day, and this process is guided by our ability to anticipate which words and phrases are likely to come next. Just think of how many times you have completed someone else‚Äôs sentence. Thus, even if we had no other reason to prefer such in-order decodings, they would be useful if only because we have better intuitions for what should be likely when predicting in this order. Second, by factorizing in order, we can assign probabilities to arbitrarily long sequences using the same language model. To convert a probability over steps 1 through ¬¢ into one that extends to word t+ 1 we simply multiply by the conditional probability of the additional to- ken given the previous ones: P(x;41,...,%1) = P(xp,..-,%1)* P(xr41 | X2,---5%1)-
Third, we have stronger predictive models for predicting adjacent words than words at ar- bitrary other locations. While all orders of factorization are valid, they do not necessarily all represent equally easy predictive modeling problems. This is true not only for language, but for other kinds of data as well, e.g., when the data is causally structured. For example, we believe that future events cannot influence the past. Hence, if we change ùë•ùë°, we may be able to influence what happens for ùë•ùë°‚Äö1 going forward but not the converse. That is, if we change ùë•ùë°, the distribution over past events will not change. In some contexts, this makes it easier to predict ùëÉ‚Äûùë•ùë°‚Äö1 j ùë•ùë°‚Äù than to predict ùëÉ‚Äûùë•ùë° j ùë•ùë°‚Äö1‚Äù. For instance, in some cases, we can find ùë•ùë°‚Äö1 = ùëì ‚Äûùë•ùë°‚Äù ‚Äö ùúñ for some additive noise ùúñ, whereas the converse is not true (Hoyer et al., 2009). This is great news, since it is typically the forward direction that we are interested in estimating. The book by Peters et al. (2017) contains more on this topic.bubuWe barely scratch the surface of it. 9.1.3 Training
Before we focus our attention on text data, let‚Äôs first try this out with some continuous- valued synthetic data. Here, our 1000 synthetic data will follow the trigonometric sin function, applied to 0.01
1
Recurrent Neural Networks
332

times the time step. To make the problem a little more interesting, we corrupt each sample with additive noise.bubuFrom this sequence we extract training examples, each consisting of features and a label. class Data(d2l.DataModule): def __init__(self, batch_size=16, T=1000, num_train=600, tau=4): self.save_hyperparameters() self.time = torch.arange(1, T + 1, dtype=torch.float32) self.x = torch.sin(0.01 * self.time) + torch.randn(T) * 0.2
data = Data() d2l.plot(data.time, data.x, 'time', 'x', xlim=[1, 1000], figsize=(6, 3))
200 400 600 800 1000 time
To begin, we try a model that acts as if the data satisfied a t""-order Markov condition, and thus predicts x, using only the past t observations. Thus for each time step we have an example with label y = x, and features x, = [x;_7,...,;-1]. The astute reader might have noticed that this results in 1000‚Äî7 examples, since we lack sufficient history for y,..., yr. While we could pad the first t sequences with zeros, to keep things simple, we drop them for now. The resulting dataset contains T ‚Äî tT examples, where each input to the model has sequence length tr. We create a data iterator on the first 600 examples, covering a period of the sin function. @d2l.add_to_class(Data) def get_dataloader(self, train): features = [self.x[i : self.T-self.tau+i] for i in range(self.tau)] self.features = torch.stack(features, 1) self.labels = self.x[self.tau:].reshape((-1, 1)) i = slice(0, self.num_train) if train else slice(self.num_train, None) return self.get_tensorloader([self.features, self.labels], train, i)
In this example our model will be a standard linear regression. model = d2l.LinearRegression(lr=0.01) trainer = d2l.Trainer(max_epochs=5) trainer.fit(model, data)
Working with Sequences
333

0.30 0.25 0.20 0.15 0.10 0.05 ‚Äî train_loss ‚Äî-- val_loss
9.1.4 Prediction
Toevaluateourmodel,wefirstcheckhowwellitperformsatone-step-aheadprediction. onestep_preds = model(data.features).detach().numpy() d2l.plot(data.time[data.tau:], [data.labels, onestep_preds], 'time', 'x', legend=['labels', '1-step preds'], figsize=(6, 3))
1.54 1.05 0.54 0.05 -0.54 -1.0-.‚Äî labels --- 1-step preds 0 200 400 600 800 1000 time
These predictions look good, even near the end at ùë° = 1000. But what if we only observed sequence data up until time step 604 (n_train + tau) and wished to make predictions several steps into the future? Unfortunately, we cannot directly compute the one-step-ahead prediction for time step 609, because we do not know the cor- responding inputs, having seen only up to ùë•604. We can address this problem by plugging in our earlier predictions as inputs to our model for making subsequent predictions, projecting forward, one step at a time, until reaching the desired time step:
ÀÜùë•605 = ùëì ‚Äûùë•601,ùë•602,ùë•603,ùë•604‚Äù, ÀÜùë•606 = ùëì ‚Äûùë•602,ùë•603,ùë•604, ÀÜùë•605‚Äù, ÀÜùë•607 = ùëì ‚Äûùë•603,ùë•604, ÀÜùë•605, ÀÜùë•606‚Äù, ÀÜùë•608 = ùëì ‚Äûùë•604, ÀÜùë•605, ÀÜùë•606, ÀÜùë•607‚Äù, ÀÜùë•609 = ùëì ‚ÄûÀÜùë•605, ÀÜùë•606, ÀÜùë•607, ÀÜùë•608‚Äù, (9.1.6)
... Generally, for an observed sequence ùë•1, . . .,ùë•ùë°, its predicted output ÀÜùë•ùë°‚Äöùëò at time step ùë° ‚Äö ùëò
Recurrent Neural Networks
334

is called the ùëò-step-ahead prediction. Since we have observed up to ùë•604, its ùëò-step-ahead
prediction is ÀÜùë•604‚Äöùëò. In other words, we will have to keep on using our own predictions to make multistep-ahead predictions. Let‚Äôs see how well this goes. multistep_preds = torch.zeros(data.T) multistep_preds[:] = data.x for i in range(data.num_train + data.tau, data.T): multistep_preds[i] = model( multistep_preds[i - data.tau:i].reshape((1, -1))) multistep_preds = multistep_preds.detach().numpy()
d2l.plot([data.time[data.tau:], data.time[data.num_train+data.tau:]], [onestep_preds, multistep_preds[data.num_train+data.tau:]], 'time', 'x', legend=['1-step preds', 'multistep preds'], figsize=(6, 3))
1.04 0.54 <x 0.04 =0.5 4} Hp t= ~~ ‚Äî step preds -1.07___ multistep preds 0 200 400 600 800 1000 time
Unfortunately, in this case we fail spectacularly. The predictions decay to a constant pretty quickly after a few steps. Why did the algorithm perform so much worse when predicting further into the future? Ultimately, this is down to the fact that errors build up. Let‚Äôs say that after step 1 we have some error ùúñ1 = ¬Øùúñ. Now the input for step 2 is perturbed by ùúñ1, hence we suffer some error in the order of ùúñ2 = ¬Øùúñ ‚Äöùëêùúñ1 for some constant ùëê, and so on. The predictions can diverge rapidly from the true observations. You may already be familiar with this common phenomenon. For instance, weather forecasts for the next 24 hours tend to be pretty accurate but beyond that, accuracy declines rapidly. We will discuss methods
for improving this throughout this chapter and beyond. Let‚Äôs take a closer look at the difficulties in ùëò-step-ahead predictions by computing predic-
tions on the entire sequence for ùëò = 1,4,16,64. def k_step_pred(k): features = [] for i in range(data.tau): features.append(data.x[i : i+data.T-data.tau-k+1]) # The (i+tau)-th element stores the (i+1)-step-ahead predictions for i in range(k): preds = model(torch.stack(features[i : i+data.tau], 1)) features.append(preds.reshape(-1)) return features[data.tau:]
Working with Sequences
335

steps = (1, 4, 16, 64) preds = k_step_pred(steps[-1]) d2l.plot(data.time[data.tau+steps[-1]-1:], [preds[k - 1].detach().numpy() for k in steps], 'time', 'x', legend=[f'{k}-step preds' for k in steps], figsize=(6, 3))
‚Äî l-step preds 1.04 =-- 4-step preds - 16-step preds 0.54 a: 64-step preds x 0.04 -0.54 -1.04 200 400 600 800 1000 time
This clearly illustrates how the quality of the prediction changes as we try to predict further into the future. While the 4-step-ahead predictions still look good, anything beyond that is almost useless. 9.1.5 Summary
There is quite a difference in difficulty between interpolation and extrapolation. Conse- quently, if you have a sequence, always respect the temporal order of the data when training, i.e., never train on future data. Given this kind of data, sequence models require specialized statistical tools for estimation. Two popular choices are autoregressive models and latent- variable autoregressive models. For causal models (e.g., time going forward), estimating the forward direction is typically a lot easier than the reverse direction. For an observed sequence up to time step ùë°, its predicted output at time step ùë° ‚Äöùëò is the ùëò-step-ahead predic- tion. As we predict further in time by increasing ùëò, the errors accumulate and the quality of the prediction degrades, often dramatically. 9.1.6 Exercises
1. Improve the model in the experiment of this section. 1. Incorporate more than the past four observations? How many do you really need? 2. How many past observations would you need if there was no noise? Hint: you can write sin and cos as a differential equation. 3. Can you incorporate older observations while keeping the total number of features constant? Does this improve accuracy?bubuWhy?bubu4. Change the neural network architecture and evaluate the performance. You may train the new model with more epochs. What do you observe? Recurrent Neural Networks
336

2. An investor wants to find a good security to buy. They look at past returns to decide which one is likely to do well. What could possibly go wrong with this strategy?bubu3. Does causality also apply to text? To which extent?bubu4. Give an example for when a latent autoregressive model might be needed to capture the dynamic of the data. Discussions136. 136

9.2 Converting Raw Text into Sequence Data
es
Throughout this book, we will often work with text data represented as sequences of words, characters, or word pieces. To get going, we will need some basic tools for converting raw text into sequences of the appropriate form. Typical preprocessing pipelines execute the following steps:
1. Load text as strings into memory. 2. Split the strings into tokens (e.g., words or characters). 3. Build a vocabulary dictionary to associate each vocabulary element with a numerical index. 4. Convert the text into sequences of numerical indices. import collections import random import re import torch from d2l import torch as d2l
9.2.1 Reading the Dataset
Here, we will work with H. G. Wells‚Äô The Time Machine137, a book containing just over
30,000 words. While real applications will typically involve significantly larger datasets, this is sufficient to demonstrate the preprocessing pipeline. The following _download method reads the raw text into a string. 137

class TimeMachine(d2l.DataModule): #@save """The Time Machine dataset.""" def _download(self): fname = d2l.download(d2l.DATA_URL + 'timemachine.txt', self.root, '090b5e7e70c295757f55df93cb0a180b9691891a') with open(fname) as f: return f.read()
(continues on next page)
Converting Raw Text into Sequence Data
337

data = TimeMachine() raw_text = data._download() raw_text[:60]
'The Time Machine, by H. G. Wells [1898]nnnnnInnnThe Time Tra'
Forsimplicity,weignorepunctuationandcapitalizationwhenpreprocessingtherawtext. @d2l.add_to_class(TimeMachine) #@save def _preprocess(self, text): return re.sub('[^A-Za-z]+', ' ', text).lower() text = data._preprocess(raw_text) text[:60]
'the time machine by h g wells i the time traveller for so it'
9.2.2 Tokenization
Tokens are the atomic (indivisible) units of text. Each time step corresponds to 1 token, but what precisely constitutes a token is a design choice. For example, we could represent the sentence ‚ÄúBaby needs a new pair of shoes‚Äù as a sequence of 7 words, where the set of all words comprise a large vocabulary (typically tens or hundreds of thousands of words). Or we would represent the same sentence as a much longer sequence of 30 characters, using a much smaller vocabulary (there are only 256 distinct ASCII characters). Below, we tokenize our preprocessed text into a sequence of characters. @d2l.add_to_class(TimeMachine) #@save def _tokenize(self, text): return list(text) tokens = data._tokenize(text) ','.join(tokens[:30])
't,h,e, ,t,i,m,e, ,m,a,c,h,i,n,e, ,b,y, ,h, ,g, ,w,e,l,l,s, '
9.2.3 Vocabulary
These tokens are still strings. However, the inputs to our models must ultimately consist of numerical inputs. Next, we introduce a class for constructing vocabularies, i.e., objects that associateeachdistincttokenvaluewithauniqueindex. First, wedeterminethesetofunique tokens in our training corpus. We then assign a numerical index to each unique token. Rare vocabulary elements are often dropped for convenience. Whenever we encounter a token at training or test time that had not been previously seen or was dropped from the vocabulary, we represent it by a special ‚Äú<unk>‚Äù token, signifying that this is an unknown value. (continued from previous page)
Recurrent Neural Networks
338

class Vocab: #@save """Vocabulary for text.""" def __init__(self, tokens=[], min_freq=0, reserved_tokens=[]): # Flatten a 2D list if needed if tokens and isinstance(tokens[0], list): tokens = [token for line in tokens for token in line] # Count token frequencies counter = collections.Counter(tokens) self.token_freqs = sorted(counter.items(), key=lambda x: x[1], reverse=True) # The list of unique tokens self.idx_to_token = list(sorted(set(['<unk>'] + reserved_tokens + [ token for token, freq in self.token_freqs if freq >= min_freq]))) self.token_to_idx = {token: idx for idx, token in enumerate(self.idx_to_token)} def __len__(self): return len(self.idx_to_token) def __getitem__(self, tokens): if not isinstance(tokens, (list, tuple)): return self.token_to_idx.get(tokens, self.unk) return [self.__getitem__(token) for token in tokens] def to_tokens(self, indices): if hasattr(indices, '__len__') and len(indices) > 1: return [self.idx_to_token[int(index)] for index in indices] return self.idx_to_token[indices] @property def unk(self): # Index for the unknown token return self.token_to_idx['<unk>']
We now construct a vocabulary for our dataset, converting the sequence of strings into a list of numerical indices. Note that we have not lost any information and can easily convert our dataset back to its original (string) representation. vocab = Vocab(tokens) indices = vocab[tokens[:10]] print('indices:', indices) print('words:', vocab.to_tokens(indices))
indices: [21, 9, 6, 0, 21, 10, 14, 6, 0, 14] words: ['t', 'h', 'e', ' ', 't', 'i', 'm', 'e', ' ', 'm']
9.2.4 Putting It All Together
Using the above classes and methods, we package everything into the following build method of the TimeMachine class, which returns corpus, a list of token indices, and vocab, the vocabulary of The Time Machine corpus. The modifications we did here are: (i) we tokenizetextintocharacters, notwords, tosimplifythetraininginlatersections; (ii)corpus
Converting Raw Text into Sequence Data
339

is a single list, not a list of token lists, since each text line in The Time Machine dataset is not necessarily a sentence or paragraph. @d2l.add_to_class(TimeMachine) #@save def build(self, raw_text, vocab=None): tokens = self._tokenize(self._preprocess(raw_text)) if vocab is None: vocab = Vocab(tokens) corpus = [vocab[token] for token in tokens] return corpus, vocab corpus, vocab = data.build(raw_text) len(corpus), len(vocab)
(173428, 28)
9.2.5 Exploratory Language Statistics
Using the real corpus and the Vocab class defined over words, we can inspect basic statistics concerning word use in our corpus. Below, we construct a vocabulary from words used in The Time Machine and print the ten most frequently occurring of them. words = text.split() vocab = Vocab(words) vocab.token_freqs[:10]
[('the', 2261), ('i', 1267), ('and', 1245), ('of', 1155), ('a', 816), ('to', 695), ('was', 552), ('in', 541), ('that', 443), ('my', 440)]
Note that the ten most frequent words are not all that descriptive. You might even imagine that we might see a very similar list if we had chosen any book at random. Articles like i‚Äù and ‚Äúmy‚Äù, and prepositions like ‚Äúof‚Äù, ‚Äúto‚Äù, and ‚Äúin‚Äù occur often because they serve common syntactic roles. Such words that are common but not ‚Äúthe‚Äù and ‚Äò‚Äú‚Äòa‚Äù, pronouns like particularly descriptive are often called stop words and, in previous generations of text classifiers based on so-called bag-of-words representations, they were most often filtered out. However, they carry meaning and it is not necessary to filter them out when working with modern RNN- and Transformer-based neural models. If you look further down the list, you will notice that word frequency decays quickly. The 10" most frequent word is less than 1/5 as common as the most popular. Word frequency tends to follow a power law distribution (specifically the Zipfian) as we go down the ranks. To get a better idea, we plot the figure of the word frequency. Recurrent Neural Networks
340

freqs = [freq for token, freq in vocab.token_freqs] d2l.plot(freqs, xlabel='token: x', ylabel='frequency: n(x)', xscale='log', yscale='log')
103 10? frequency: n(x) 101 10¬∞ 10¬∞ 10? 10? 103 token: x
After dealing with the first few words as exceptions, all the remaining words roughly follow a straight line on a log‚Äìlog plot. This phenomenon is captured by Zipf‚Äôs law, which states that the frequency ùëõùëñ of the ùëñth most frequent word is:
which is equivalent to
logn; = ‚Äîalogi+c,
(9.2.2)
where ùõº is the exponent that characterizes the distribution and ùëê is a constant. This should
already give us pause for thought if we want to model words by counting statistics. After all, we will significantly overestimate the frequency of the tail, also known as the infre- quent words. But what about the other word combinations, such as two consecutive words (bigrams), three consecutive words (trigrams), and beyond? Let‚Äôs see whether the bigram frequency behaves in the same manner as the single word (unigram) frequency. bigram_tokens = ['--'.join(pair) for pair in zip(words[:-1], words[1:])] bigram_vocab = Vocab(bigram_tokens) bigram_vocab.token_freqs[:10]
[('of--the', 309), ('in--the', 169), ('i--had', 130), ('i--was', 112), ('and--the', 109), ('the--time', 102), ('it--was', 99), ('to--the', 85), ('as--i', 78), ('of--a', 73)]
One thing is notable here. Out of the ten most frequent word pairs, nine are composed of both stop words and only one is relevant to the actual book‚Äî‚Äúthe time‚Äù. Furthermore, let‚Äôs see whether the trigram frequency behaves in the same manner. ùëõùëñ / 1 ùëñùõº , (9.2.1)
Converting Raw Text into Sequence Data
341

trigram_tokens = ['--'.join(triple) for triple in zip( words[:-2], words[1:-1], words[2:])] trigram_vocab = Vocab(trigram_tokens) trigram_vocab.token_freqs[:10]
[('the--time--traveller', 59), ('the--time--machine', 30), ('the--medical--man', 24), ('it--seemed--to', 16), ('it--was--a', 15), ('here--and--there', 15), ('seemed--to--me', 14), ('i--did--not', 14), ('i--saw--the', 13), ('i--began--to', 13)]
Now, let‚Äôs visualize the token frequency among these three models: unigrams, bigrams,
and trigrams. bigram_freqs = [freq for token, freq in bigram_vocab.token_freqs] trigram_freqs = [freq for token, freq in trigram_vocab.token_freqs] d2l.plot([freqs, bigram_freqs, trigram_freqs], xlabel='token: x', ylabel='frequency: n(x)', xscale='log', yscale='log', legend=['unigram', 'bigram', 'trigram'])
10? ‚Äî unigram a --- bigram = L_ ‚Äî-- trigram 5 10?bubuFs go 2 ‚Äúen.bubu¬© 107 10¬∞ +. 10¬∞ 107 10?bubu103 104 token: x
This figure is quite exciting. First, beyond unigram words, sequences of words also appear to be following Zipf‚Äôs law, albeit with a smaller exponent ùõº in (9.2.1), depending on the sequence length. Second, the number of distinct ùëõ-grams is not that large. This gives us hope that there is quite a lot of structure in language. Third, many ùëõ-grams occur very rarely. This makes certain methods unsuitable for language modeling and motivates the use of deep learning models. We will discuss this in the next section. 9.2.6 Summary
Text is among the most common forms of sequence data encountered in deep learning. Common choices for what constitutes a token are characters, words, and word pieces. To preprocess text, we usually (i) split text into tokens; (ii) build a vocabulary to map token strings to numerical indices; and (iii) convert text data into token indices for models to
Recurrent Neural Networks
342

manipulate. In practice, the frequency of words tends to follow Zipf‚Äôs law. This is true not just for individual words (unigrams), but also for ùëõ-grams. 9.2.7 Exercises
1. In the experiment of this section, tokenize text into words and vary the min_freq argu- ment value of the Vocab instance. Qualitatively characterize how changes in min_freq impact the size of the resulting vocabulary. 2. Estimate the exponent of Zipfian distribution for unigrams, bigrams, and trigrams in this corpus. 3.bubuFind some other sources of data (download a standard machine learning dataset, pick another public domain book, scrape a website, etc). For each, tokenize the data at both the word and character levels. How do the vocabulary sizes compare with The Time Machine corpus at equivalent values of min_freq. Estimate the exponent of the Zipfian distribution corresponding to the unigram and bigram distributions for these corpora. How do they compare with the values that you observed for The Time Machine corpus?bubuDiscussions138. 138
9.3 Language Models
es
In Section 9.2, we saw how to map text sequences into tokens, where these tokens can be viewed as a sequence of discrete observations such as words or characters. Assume that the tokens in a text sequence of length ùëá are in turn ùë•1,ùë•2, . .bubu.,ùë•ùëá. The goal of language models is to estimate the joint probability of the whole sequence:
ùëÉ‚Äûùë•1,ùë•2, . . .,ùë•ùëá‚Äù,
(9.3.1)
where statistical tools in Section 9.1 can be applied. Language models are incredibly useful. For instance, an ideal language model should generate natural text on its own, simply by drawing one token at a time x, ~ P(x, | X;-1,-+-¬ª%1). Quite unlike the monkey using a typewriter, all text emerging from such a model would pass as natural language, e.g., English text. Furthermore, it would be suffi- cient for generating a meaningful dialog, simply by conditioning the text on previous dialog fragments. Clearly we are still very far from designing such a system, since it would need to understand the text rather than just generate grammatically sensible content. Nonetheless, language models are of great service even in their limited form. For instance, the phrases ‚Äúto recognize speech‚Äù and ‚Äúto wreck a nice beach‚Äù sound very similar. This can cause ambiguity in speech recognition, which is easily resolved through a language model that rejects the second translation as outlandish. Likewise, in a document summarization algorithm it is worthwhile knowing that ‚Äúdog bites man‚Äù is much more frequent than ‚Äúman
Language Models
343

bites dog‚Äù, or that ‚ÄúI want to eat grandma‚Äù is a rather disturbing statement, whereas ‚ÄúI want to eat, grandma‚Äù is much more benign. import torch from d2l import torch as d2l
9.3.1 Learning Language Models
The obvious question is how we should model a document, or even a sequence of tokens. Supposethatwetokenizetextdataatthewordlevel. Let‚Äôsstartbyapplyingbasicprobability rules:
T P(x1,X2,...,X7) = I] P(x; | X1,-+-5%7-1)- (9.3.2) t=1
For example, the probability of a text sequence containing four words would be given as:
ùëÉ‚Äûdeep,learning,is,fun‚Äù
=ùëÉ‚Äûdeep‚ÄùùëÉ‚Äûlearning j deep‚ÄùùëÉ‚Äûis j deep,learning‚ÄùùëÉ‚Äûfun j deep,learning,is‚Äù. Markov Models and ùëõ-grams
Among those sequence model analyses in Section 9.1, let‚Äôs apply Markov models to lan- guage modeling. A distribution over sequences satisfies the Markov property of first order if ùëÉ‚Äûùë•ùë°‚Äö1 j ùë•ùë°, . .bubu.,ùë•1‚Äù = ùëÉ‚Äûùë•ùë°‚Äö1 j ùë•ùë°‚Äù. Higher orders correspond to longer dependencies. This leads to a number of approximations that we could apply to model a sequence:
ùëÉ‚Äûùë•1,ùë•2,ùë•3,ùë•4‚Äù = ùëÉ‚Äûùë•1‚ÄùùëÉ‚Äûùë•2‚ÄùùëÉ‚Äûùë•3‚ÄùùëÉ‚Äûùë•4‚Äù, ùëÉ‚Äûùë•1,ùë•2,ùë•3,ùë•4‚Äù = ùëÉ‚Äûùë•1‚ÄùùëÉ‚Äûùë•2 j ùë•1‚ÄùùëÉ‚Äûùë•3 j ùë•2‚ÄùùëÉ‚Äûùë•4 j ùë•3‚Äù, ùëÉ‚Äûùë•1,ùë•2,ùë•3,ùë•4‚Äù = ùëÉ‚Äûùë•1‚ÄùùëÉ‚Äûùë•2 j ùë•1‚ÄùùëÉ‚Äûùë•3 j ùë•1,ùë•2‚ÄùùëÉ‚Äûùë•4 j ùë•2,ùë•3‚Äù. (9.3.4)
The probability formulae that involve one, two, and three variables are typically referred to as unigram, bigram, and trigram models, respectively. In order to compute the language model, we need to calculate the probability of words and the conditional probability of a word given the previous few words. Note that such probabilities are language model parameters. Word Frequency
139 
Here, weassumethatthetrainingdatasetisalargetextcorpus, suchasallWikipediaentries, Project Gutenberg 139 , and all text posted on the web. The probability of words can be calculated from the relative word frequency of a given word in the training dataset. For example, the estimate ÀÜùëÉ‚Äûdeep‚Äù can be calculated as the probability of any sentence starting with the word ‚Äúdeep‚Äù. A slightly less accurate approach would be to count all occurrences
T
(9.3.3)
Recurrent Neural Networks
344

of the word ‚Äúdeep‚Äù and divide it by the total number of words in the corpus. This works fairlywell, particularlyforfrequentwords. Movingon, wecouldattempttoestimate
ÀÜùëÉ‚Äûlearning j deep‚Äù = ùëõ‚Äûdeep‚Äù , (9.3.5)
where ùëõ‚Äûùë•‚Äù and ùëõ‚Äûùë•,ùë•0‚Äù are the number of occurrences of singletons and consecutive word
pairs, respectively. Unfortunately, estimating the probability of a word pair is somewhat more difficult, since the occurrences of ‚Äúdeep learning‚Äù are a lot less frequent. In particular, for some unusual word combinations it may be tricky to find enough occurrences to get accurate estimates. As suggested by the empirical results in Section 9.2.5, things take a turn for the worse for three-word combinations and beyond. There will be many plausible three-word combinations that we likely will not see in our dataset. Unless we provide some solution to assign such word combinations a nonzero count, we will not be able to use them in a language model. If the dataset is small or if the words are very rare, we might not find even a single one of them. Laplace Smoothing
A common strategy is to perform some form of Laplace smoothing. The solution is to add a small constant to all counts.bubuDenote by ùëõ the total number of words in the training set and ùëö the number of unique words. This solution helps with singletons, e.g., via
P(x) = mre /m ay _ n(x, x‚Äô) + ¬© P(x‚Äô) a P(x‚Äô |x) = Taw@+te (9.3.6) ~ oy ry M(x, x0") + 63P(x‚Äô) POM [x)= n(x, x‚Äô) + &
Here ‚Ç¨|, ‚Ç¨2, and ‚Ç¨3 are hyperparameters. Take e; as an example: when ‚Ç¨; = 0, no smoothing is applied; when ‚Ç¨, approaches positive infinity, P(x) approaches the uniform probability 1/m. The above is a rather primitive variant of what other techniques can accomplish (Wood et al., 2011). Unfortunately, models like this get unwieldy rather quickly for the following reasons. First, as discussed in Section 9.2.5, many ùëõ-grams occur very rarely, making Laplace smoothing rather unsuitable for language modeling. Second, we need to store all counts. Third, this entirely ignores the meaning of the words. For instance, ‚Äúcat‚Äù and ‚Äúfeline‚Äù should occur in related contexts. It is quite difficult to adjust such models to additional contexts, whereas, deep learning based language models are well suited to take this into account. Last, long word sequences are almost certain to be novel, hence a model that simply counts the fre- quency of previously seen word sequences is bound to perform poorly there. Therefore, we focus on using neural networks for language modeling in the rest of the chapter. 9.3.2 Perplexity
ùëõ‚Äûdeep, learning‚Äù
Language Models
345

Next, let‚Äôs discuss about how to measure the quality of the language model, which we will then use to evaluate our models in the subsequent sections. One way is to check how surprising the text is. A good language model is able to predict, with high accuracy, the tokens that come next. Consider the following continuations of the phrase ‚ÄúIt is raining‚Äù, as proposed by different language models:
1. ‚ÄúIt is raining outside‚Äù
2. ‚ÄúIt is raining banana tree‚Äù
3. ‚ÄúIt is raining piouw;kcj pwepoiut‚Äù
In terms of quality, Example 1 is clearly the best. The words are sensible and logically co- herent. Whileit mightnotquiteaccuratelyreflect which wordfollowssemantically(‚ÄúinSan Francisco‚Äù and ‚Äúin winter‚Äù would have been perfectly reasonable extensions), the model is able to capture which kind of word follows. Example 2 is considerably worse by producing a nonsensical extension. Nonetheless, at least the model has learned how to spell words and some degree of correlation between words. Last, Example 3 indicates a poorly trained model that does not fit data properly. We might measure the quality of the model by computing the likelihood of the sequence. Unfortunately this is a number that is hard to understand and difficult to compare. After all, shorter sequences are much more likely to occur than the longer ones, hence evaluating the model on Tolstoy‚Äôs magnum opus War and Peace will inevitably produce a much smaller likelihood than, say, on Saint-Exupery‚Äôs novella The Little Prince. What is missing is the equivalent of an average.bubuInformation theory comes handy here. We defined entropy, surprisal, and cross-entropy when we introduced the softmax regression (Section 4.1.3). If we want to compress text, wecanaskaboutpredictingthenexttokengiventhecurrentsetoftokens. Abetterlanguage model should allow us to predict the next token more accurately. Thus, it should allow us to spend fewer bits in compressing the sequence. So we can measure it by the cross-entropy loss averaged over all the ùëõ tokens of a sequence:
ie ‚Äî log Pr arise), (9.3.7) t=1
ùë°=1
where ùëÉ is given by a language model and ùë•ùë° is the actual token observed at time step ùë° from
the sequence. This makes the performance on documents of different lengths comparable. For historical reasons, scientists in natural language processing prefer to use a quantity called perplexity. In a nutshell, it is the exponential of (9.3.7):
1 exp Dy low Pls | X-1,---,x1)] - (9.3.8)
Perplexity can be best understood as the reciprocal of the geometric mean of the number of real choices that we have when deciding which token to pick next. Let‚Äôs look at a number of cases:
! Recurrent Neural Networks
346

e In the best case scenario, the model always perfectly estimates the probability of the
target token as 1. In this case the perplexity of the model is 1. e In the worst case scenario, the model always predicts the probability of the target token
as 0. In this situation, the perplexity is positive infinity. e At the baseline, the model predicts a uniform distribution over all the available tokens of
the vocabulary. In this case, the perplexity equals the number of unique tokens of the vocabulary. In fact, if we were to store the sequence without any compression, this would be the best we could do for encoding it. Hence, this provides a nontrivial upper bound that any useful model must beat. 9.3.3 Partitioning Sequences
We will design language models using neural networks and use perplexity to evaluate how good the model is at predicting the next token given the current set of tokens in text se- quences. Before introducing the model, let‚Äôs assume that it processes a minibatch of se- quences with predefined length at a time. Now the question is how to read minibatches of input sequences and target sequences at random. Suppose that the dataset takes the form of a sequence of ùëá token indices in corpus. We
Suppose that the dataset takes the form of a sequence of T token indices in corpus. We will partition it into subsequences, where each subsequence has n tokens (time steps). To iterate over (almost) all the tokens of the entire dataset for each epoch and obtain all possible length-n subsequences, we can introduce randomness. More concretely, at the beginning of each epoch, discard the first d tokens, where d ‚Ç¨ [0, 7) is uniformly sampled at random. The rest of the sequence is then partitioned into m = |(T‚Äîd)/n] subsequences. Denote by Xr = [X7,...,Xr+n-1] the length-n subsequence starting from token x; at time step t. The resulting m partitioned subsequences are Xq, Xd4n, - ¬´ -¬ª Xd+n(m-1). Each subsequence will be used as an input sequence into the language model. For language modeling, the goal is to predict the next token based on the tokens we have seen so far; hence the targets (labels) are the original sequence, shifted by one token. The target sequence for any input sequence xùë° is xùë°‚Äö1 with length ùëõ. Input sequences: thle tine machine by h wellls Target sequences: the| time| machline bly h_g| wells
tFig. 9.3.1
Obtaining Ô¨Åve pairs of input sequences and target sequences from partitioned length-5 subsequences. Fig. 9.3.1 shows an example of obtaining five pairs of input sequences and target sequences with ùëõ = 5 and ùëë = 2. @d2l.add_to_class(d2l.TimeMachine) #@save def __init__(self, batch_size, num_steps, num_train=10000, num_val=5000): super(d2l.TimeMachine, self).__init__() self.save_hyperparameters() corpus, self.vocab = self.build(self._download())
(continues on next page)
Language Models
347

array = torch.tensor([corpus[i:i+num_steps+1] for i in range(len(corpus)-num_steps)]) self.X, self.Y = array[:,:-1], array[:,1:]
To train language models, we will randomly sample pairs of input sequences and target sequences in minibatches. The following data loader randomly generates a minibatch from the dataset each time. The argument batch_size specifies the number of subsequence examples in each minibatch and num_steps is the subsequence length in tokens. @d2l.add_to_class(d2l.TimeMachine) #@save def get_dataloader(self, train): idx = slice(0, self.num_train) if train else slice( self.num_train, self.num_train + self.num_val) return self.get_tensorloader([self.X, self.Y], train, idx)
As we can see in the following, a minibatch of target sequences can be obtained by shifting the input sequences by one token. data = d2l.TimeMachine(batch_size=2, num_steps=10) for X, Y in data.train_dataloader(): print('X:', X, '\nY:', Y) break
Downloading ../data/timemachine.txt from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/timemachine.txt... X: tensor([[10, 4, 2, 21, 10, 16, 15, 0, 20, 2], [21, 9, 6, 19, 0, 24, 2, 26, 0, 16]]) Y: tensor([[ 4, 2, 21, 10, 16, 15, 0, 20, 2, 10], [ 9, 6, 19, 0, 24, 2, 26, 0, 16, 9]])
9.3.4 Summary and Discussion
Language models estimate the joint probability of a text sequence. For long sequences, ùëõ-grams provide a convenient model by truncating the dependence. However, there is a lot of structure but not enough frequency to deal efficiently with infrequent word combinations via Laplace smoothing. Thus, we will focus on neural language modeling in subsequent sections. To train language models, we can randomly sample pairs of input sequences and target sequences in minibatches. After training, we will use perplexity to measure the language model quality. Language models can be scaled up with increased data size, model size, and amount in training compute. Large language models can perform desired tasks by predicting output text given input text instructions. As we will discuss later (e.g., Section 11.9), at the present moment large language models form the basis of state-of-the-art systems across diverse tasks. (continued from previous page)
Recurrent Neural Networks
348

9.3.5 Exercises
1. Suppose there are 100,000 words in the training dataset. How much word frequency and multi-word adjacent frequency does a four-gram need to store? 2. How would you model a dialogue? 3. What other methods can you think of for reading long sequence data? 4. Consider our method for discarding a uniformly random number of the first few tokens at the beginning of each epoch. 1. Does it really lead to a perfectly uniform distribution over the sequences on the docu- ment? 2.bubuWhat would you have to do to make things even more uniform?bubu5. If we want a sequence example to be a complete sentence, what kind of problem does this introduce in minibatch sampling? How can we fix it?bubuDiscussions140. 140
Discussions 4¬∞,

9.4 Recurrent Neural Networks
a
In Section 9.3 we described Markov models and ùëõ-grams for language modeling, where
In Section 9.3 we described Markov models and n-grams for language modeling, where the conditional probability of token x, at time step t only depends on the n ‚Äî 1 previous tokens. If we want to incorporate the possible effect of tokens earlier than time step t ‚Äî (n‚Äî 1) on x;, we need to increase n. However, the number of model parameters would also increase exponentially with it, as we need to store |V|‚Äù numbers for a vocabulary set V. Hence, rather than modeling P(x; | x;-1,...,X1‚Äî-n+1) itis preferable to use a latent variable model,
P(x; | Xp-1,-++5%1) ¬© P(x; | At-1),
(9.4.1)
where hh; is a hidden state that stores the sequence information up to time step t ‚Äî 1. In
where hh; is a hidden state that stores the sequence information up to time step t ‚Äî 1. In general, the hidden state at any time step t could be computed based on both the current input x, and the previous hidden state h,_,:
hy = f (X15 hy-1). (9.4.2)
For a sufficiently powerful function ùëì in (9.4.2), the latent variable model is not an approx- imation. After all, ‚Ñéùë° may simply store all the data it has observed so far. However, it could potentially make both computation and storage expensive. Recall that we have discussed hidden layers with hidden units in Chapter 5. It is noteworthy that hidden layers and hidden states refer to two very different concepts. Hidden layers are, as explained, layers that are hidden from view on the path from input to output. Hidden
Recurrent Neural Networks
349

states are technically speaking inputs to whatever we do at a given step, and they can only be computed by looking at data at previous time steps. Recurrent neural networks (RNNs) are neural networks with hidden states. Before intro- ducing the RNN model, we first revisit the MLP model introduced in Section 5.1. import torch from d2l import torch as d2l
9.4.1 Neural Networks without Hidden States
Let‚Äôs take a look at an MLP with a single hidden layer. Let the hidden layer‚Äôs activation function be ¬¢. Given a minibatch of examples X ‚Ç¨ R‚Äù*¬¢ with batch size n and d inputs, the hidden layer output H ‚Ç¨ R‚Äù*" is calculated as
H = ùúô‚ÄûXWxh ‚Äö bh‚Äù. (9.4.3)
In (9.4.3), we have the weight parameter W,n ‚Ç¨ R@*", the bias parameter by, ‚Ç¨ R!*", and the number of hidden units h, for the hidden layer. So armed, we apply broadcasting (see Section 2.1.4) during the summation. Next, the hidden layer output H is used as input of the output layer, which is given by
O = HWhq ‚Äö bq, (9.4.4)
where O ¬¢ R‚Äô*4 is the output variable, Whg ‚Ç¨ R‚Äô*4 is the weight parameter, and by ‚Ç¨ R!*4 is the bias parameter of the output layer. If it is a classification problem, we can use softmax(O) to compute the probability distribution of the output categories. This is entirely analogous to the regression problem we solved previously in Section 9.1, hence we omit details. Suffice it to say that we can pick feature-label pairs at random and learn the parameters of our network via automatic differentiation and stochastic gradient descent. 9.4.2 Recurrent Neural Networks with Hidden States
Matters are entirely different when we have hidden states. Let‚Äôs look at the structure in some more detail.bubuAssume that we have a minibatch of inputs X,; ‚Ç¨ R‚Äù*@ at time step r. In other words, for
Assume that we have a minibatch of inputs X,; ‚Ç¨ R‚Äù*@ at time step r. In other words, for a minibatch of n sequence examples, each row of X; corresponds to one example at time step t from the sequence. Next, denote by H, ‚Ç¨ R‚Äù*‚Äô the hidden layer output of time step t. Unlike with MLP, here we save the hidden layer output H,_; from the previous time step and introduce a new weight parameter Wpn ‚Ç¨ R‚Äô*" to describe how to use the hidden layer output of the previous time step in the current time step. Specifically, the calculation of the hidden layer output of the current time step is determined by the input of the current time step together with the hidden layer output of the previous time step:
Hy, = 6(X Wxn + He-1 Wan + bn). (9.4.5)
Recurrent Neural Networks
350

Compared with (9.4.3), (9.4.5) adds one more term H;‚Äî; Whpn and thus instantiates (9.4.2). From the relationship between hidden layer outputs H,; and H;-; of adjacent time steps, we know that these variables captured and retained the sequence‚Äôs historical information up to their current time step, just like the state or memory of the neural network‚Äôs current time step. Therefore, such a hidden layer output is called a hidden state. Since the hidden state uses the same definition of the previous time step in the current time step, the compu- tation of (9.4.5) is recurrent. Hence, as we said, neural networks with hidden states based on recurrent computation are named recurrent neural networks. Layers that perform the computation of (9.4.5) in RNNs are called recurrent layers. There are many different ways for constructing RNNs. Those with a hidden state defined by (9.4.5) are very common. For time step ùë°, the output of the output layer is similar to the computation in the MLP:
Oùë° = Hùë°Whq ‚Äö bq. (9.4.6)
Parameters of the RNN include the weights Wx, ‚Ç¨ R¬¢%‚Äù, Wan ‚Ç¨ R‚Äù*", and the bias by ‚Ç¨ R!** of the hidden layer, together with the weights Wng ‚Ç¨ R‚Äô*4 and the bias by ‚Ç¨ R!*4 of the output layer. It is worth mentioning that even at different time steps, RNNs always use these model parameters. Therefore, the parametrization cost of an RNN does not grow as the number of time steps increases. Fig. 9.4.1 illustrates the computational logic of an RNN at three adjacent time steps. At any time step r, the computation of the hidden state can be treated as: (i) concatenating the input X, at the current time step ¬¢ and the hidden state H;_, at the previous time step t ‚Äî 1; (ii) feeding the concatenation result into a fully connected layer with the activation function ¬¢. The output of such a fully connected layer is the hidden state H, of the current time step t. In this case, the model parameters are the concatenation of W xn and Whp, and a bias of bp, all from (9.4.5). The hidden state of the current time step t, H;, will participate in computing the hidden state H,+ of the next time step t + 1. What is more, H; will also be fed into the fully connected output layer to compute the output O, of the current time step t. Output layer = [ | s| |¬ª | [. Hidden state | : | | I I x, x, Input Xx 4 TD) ccivatertoneton Li. Copy 7 Concatenate
tFig. 9.4.1
An RNN with a hidden state. We just mentioned that the calculation of X;W n+ H,‚Äî1 Whn for the hidden state is equiv- alent to matrix multiplication of the concatenation of X,; and H;_; and the concatenation of W,, and Wh. Though this can be proven mathematically, in the following we just use
>
Recurrent Neural Networks
351

a simple code snippet as a demonstration. To begin with, we define matrices X, W_xh, H, and W_hh, whose shapes are (3, 1), (1, 4), (3, 4), and (4, 4), respectively. Multiplying X by W_xh, and H by W_hh, and then adding these two products, we obtain a matrix of shape (3, 4). X, W_xh = torch.randn(3, 1), torch.randn(1, 4) H, W_hh = torch.randn(3, 4), torch.randn(4, 4) torch.matmul(X, W_xh) + torch.matmul(H, W_hh)
tensor([[ 1.2526, 0.0580, -3.3460, -0.2519], [-1.3064, 1.4132, -0.1435, 0.3482], [ 3.1495, 0.8172, 1.5167, -0.9038]])
Now we concatenate the matrices X and H along columns (axis 1), and the matrices W_xh and W_hh along rows (axis 0). These two concatenations result in matrices of shape (3, 5) and of shape (5, 4), respectively. Multiplying these two concatenated matrices, we obtain the same output matrix of shape (3, 4) as above. torch.matmul(torch.cat((X, H), 1), torch.cat((W_xh, W_hh), 0))
tensor([[ 1.2526, 0.0580, -3.3460, -0.2519], [-1.3064, 1.4132, -0.1435, 0.3482], [ 3.1495, 0.8172, 1.5167, -0.9038]])
9.4.3 RNN-Based Character-Level Language Models
Recall that for language modeling in Section 9.3, we aim to predict the next token based on the current and past tokens; thus we shift the original sequence by one token as the targets (labels). Bengio et al. (2003) first proposed to use a neural network for language modeling. In the following we illustrate how RNNs can be used to build a language model. Let the minibatch size be one, and the sequence of the text be ‚Äúmachine‚Äù. To simplify training in subsequent sections, we tokenize text into characters rather than words and consider a character-level language model. Fig. 9.4.2 demonstrates how to predict the next charac- ter based on the current and previous characters via an RNN for character-level language modeling. During the training process, we run a softmax operation on the output from the output layer for each time step, and then use the cross-entropy loss to compute the error between the model output and the target. Because of the recurrent computation of the hidden state in the hidden layer, the output, O3, of time step 3 in Fig. 9.4.2 is determined by the text sequence ‚Äúm‚Äù, ‚Äúa‚Äù, and ‚Äúc‚Äù. Since the next character of the sequence in the training data is ‚Äúh‚Äù, the lossoftimestep3willdependontheprobabilitydistributionofthenextcharactergenerated based on the feature sequence ‚Äúm‚Äù, ‚Äúa‚Äù, ‚Äúc‚Äù and the target ‚Äúh‚Äù of this time step. In practice, each token is represented by a ùëë-dimensional vector, and we use a batch size
Recurrent Neural Networks
352

Time step 1 2 3 4 5 6 Target sequence a c h i n e nm Fea BA layer ‚ÄúoF tT tt tf 4 layer iH, >| H, >| H, >| H, >| H, >| H, t t t t t t Input sequence m a c h i n
tFig. 9.4.2
A character-level language model based on the RNN. The input and target sequences are ‚Äúmachin‚Äù and ‚Äúachine‚Äù, respectively.bubun > 1. Therefore, the input X;, at time step ¬¢ will be an n x d matrix, which is identical to
what we discussed in Section 9.4.2. In the following sections, we will implement RNNs for character-level language mod- els. 9.4.4 Summary
A neural network that uses recurrent computation for hidden states is called a recurrent neural network (RNN). The hidden state of an RNN can capture historical information of the sequence up to the current time step. With recurrent computation, the number of RNN model parameters does not grow as the number of time steps increases. As for applications, an RNN can be used to create character-level language models. 9.4.5 Exercises
1. If we use an RNN to predict the next character in a text sequence, what is the required dimension for any output? 2. Why can RNNs express the conditional probability of a token at some time step based on all the previous tokens in the text sequence? 3. What happens to the gradient if you backpropagate through a long sequence? 4. What are some of the problems associated with the language model described in this section? Discussions141. 141
(Oba) ic
9.5 Recurrent Neural Network Implementation from Scratch

We are now ready to implement an RNN from scratch. In particular, we will train this RNN to function as a character-level language model (see Section 9.4) and train it on a
Recurrent Neural Network Implementation from Scratch
353

corpus consisting of the entire text of H. G.bubuWells‚Äô The Time Machine, following the data processing steps outlined in Section 9.2. We start by loading the dataset. %matplotlib inline import math import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
9.5.1 RNN Model
We begin by defining a class to implement the RNN model (Section 9.4.2). Note that the number of hidden units num_hiddens is a tunable hyperparameter. class RNNScratch(d2l.Module): #@save """The RNN model implemented from scratch.""" def __init__(self, num_inputs, num_hiddens, sigma=0.01): super().__init__() self.save_hyperparameters() self.W_xh = nn.Parameter( torch.randn(num_inputs, num_hiddens) * sigma) self.W_hh = nn.Parameter( torch.randn(num_hiddens, num_hiddens) * sigma) self.b_h = nn.Parameter(torch.zeros(num_hiddens))
The forward method below defines how to compute the output and hidden state at any time step, given the current input and the state of the model at the previous time step. Note that the RNN model loops through the outermost dimension of inputs, updating the hidden state one time step at a time. The model here uses a tanh activation function (Section 5.1.2). @d2l.add_to_class(RNNScratch) #@save def forward(self, inputs, state=None): if state is None: # Initial state with shape: (batch_size, num_hiddens) state = torch.zeros((inputs.shape[1], self.num_hiddens), device=inputs.device) else: state, = state outputs = [] for X in inputs: # Shape of inputs: (num_steps, batch_size, num_inputs) state = torch.tanh(torch.matmul(X, self.W_xh) + torch.matmul(state, self.W_hh) + self.b_h) outputs.append(state) return outputs, state
We can feed a minibatch of input sequences into an RNN model as follows. batch_size, num_inputs, num_hiddens, num_steps = 2, 16, 32, 100
(continues on next page)
Recurrent Neural Networks
354

rnn = RNNScratch(num_inputs, num_hiddens) X = torch.ones((num_steps, batch_size, num_inputs)) outputs, state = rnn(X)
Let‚Äôs check whether the RNN model produces results of the correct shapes to ensure that the dimensionality of the hidden state remains unchanged. def check_len(a, n): #@save """Check the length of a list.""" assert len(a) == n, f'list\'s length {len(a)} != expected length {n}' def check_shape(a, shape): #@save """Check the shape of a tensor.""" assert a.shape == shape, \ f'tensor\'s shape {a.shape} != expected shape {shape}' check_len(outputs, num_steps) check_shape(outputs[0], (batch_size, num_hiddens)) check_shape(state, (batch_size, num_hiddens))
9.5.2 RNN-Based Language Model
The following RNNLMScratch class defines an RNN-based language model, where we pass in our RNN via the rnn argument of the __init__ method. When training language mod- els, the inputs and outputs are from the same vocabulary.bubuHence, they have the same di- mension, which is equal to the vocabulary size. Note that we use perplexity to evaluate the model.bubuAs discussed in Section 9.3.2, this ensures that sequences of different length are comparable. class RNNLMScratch(d2l.Classifier): #@save """The RNN-based language model implemented from scratch.""" def __init__(self, rnn, vocab_size, lr=0.01): super().__init__() self.save_hyperparameters() self.init_params() def init_params(self): self.W_hq = nn.Parameter( torch.randn( self.rnn.num_hiddens, self.vocab_size) * self.rnn.sigma) self.b_q = nn.Parameter(torch.zeros(self.vocab_size)) def training_step(self, batch): l = self.loss(self(*batch[:-1]), batch[-1]) self.plot('ppl', torch.exp(l), train=True) return l def validation_step(self, batch): l = self.loss(self(*batch[:-1]), batch[-1]) self.plot('ppl', torch.exp(l), train=False)
(continued from previous page)
Recurrent Neural Network Implementation from Scratch
355

One-Hot Encoding
Recall that each token is represented by a numerical index indicating the position in the vocabularyofthecorrespondingword/character/wordpiece. Youmightbetemptedtobuild a neural network with a single input node (at each time step), where the index could be fed in as a scalar value.bubuThis works when we are dealing with numerical inputs like price or temperature, where any two values sufficiently close together should be treated similarly.bubuBut this does not quite make sense. The 45th and 46th words in our vocabulary happen to be ‚Äútheir‚Äù and ‚Äúsaid‚Äù, whose meanings are not remotely similar. When dealing with such categorical data, the most common strategy is to represent each item by a one-hot encoding (recall from Section 4.1.1). A one-hot encoding is a vector whose length is given by the size of the vocabulary ùëÅ, where all entries are set to 0, except for the entry corresponding to our token, which is set to 1. For example, if the vocabulary had five elements, then the one-hot vectors corresponding to indices 0 and 2 would be the following. F.one_hot(torch.tensor([0, 2]), 5)
tensor([[1, 0, 0, 0, 0], [0, 0, 1, 0, 0]])
The minibatches that we sample at each iteration will take the shape (batch size, number of time steps). Once representing each input as a one-hot vector, we can think of each minibatch as a three-dimensional tensor, where the length along the third axis is given by the vocabulary size (len(vocab)). We often transpose the input so that we will obtain an output of shape (number of time steps, batch size, vocabulary size). This will allow us to loop more conveniently through the outermost dimension for updating hidden states of a minibatch, time step by time step (e.g., in the above forward method). @d2l.add_to_class(RNNLMScratch) #@save def one_hot(self, X): # Output shape: (num_steps, batch_size, vocab_size) return F.one_hot(X.T, self.vocab_size).type(torch.float32)
Transforming RNN Outputs
The language model uses a fully connected output layer to transform RNN outputs into token predictions at each time step. @d2l.add_to_class(RNNLMScratch) #@save def output_layer(self, rnn_outputs): outputs = [torch.matmul(H, self.W_hq) + self.b_q for H in rnn_outputs] return torch.stack(outputs, 1) @d2l.add_to_class(RNNLMScratch) #@save
(continues on next page)
Recurrent Neural Networks
356

def forward(self, X, state=None): embs = self.one_hot(X) rnn_outputs, _ = self.rnn(embs, state) return self.output_layer(rnn_outputs)
Let‚Äôscheckwhethertheforwardcomputationproducesoutputswiththecorrectshape. model = RNNLMScratch(rnn, num_inputs) outputs = model(torch.ones((batch_size, num_steps), dtype=torch.int64)) check_shape(outputs, (batch_size, num_steps, num_inputs))
9.5.3 Gradient Clipping
While you are already used to thinking of neural networks as ‚Äúdeep‚Äù in the sense that many layers separate the input and output even within a single time step, the length of the se- quence introduces a new notion of depth. In addition to the passing through the network in the input-to-output direction, inputs at the first time step must pass through a chain of ùëá layers along the time steps in order to influence the output of the model at the final time step. Taking the backwards view, in each iteration, we backpropagate gradients through time, resulting in a chain of matrix-products of length O‚Äûùëá‚Äù. As mentioned in Section 5.4, this can result in numerical instability, causing the gradients either to explode or vanish, depending on the properties of the weight matrices. Dealing with vanishing and exploding gradients is a fundamental problem when designing RNNs and has inspired some of the biggest advances in modern neural network architec- tures. In the next chapter, we will talk about specialized architectures that were designed in hopes of mitigating the vanishing gradient problem. However, even modern RNNs often suffer from exploding gradients. One inelegant but ubiquitous solution is to simply clip the gradients forcing the resulting ‚Äúclipped‚Äù gradients to take smaller values. Generally speaking, when optimizing some objective by gradient descent, we iteratively update the parameter of interest, say a vector x, but pushing it in the direction of the negative gradient g (in stochastic gradient descent, we calculate this gradient on a randomly sampled minibatch). For example, with learning rate 7 > 0, each update takes the form x ‚Äî x-7ng. Let‚Äôs further assume that the objective function f is sufficiently smooth. Formally, we say that the objective is Lipschitz continuous with constant L, meaning that for any x and y, we have
If) ‚Äî FV) < Lilx- yl. (9.5.1)
As you can see, when we update the parameter vector by subtracting ùúÇg, the change in
the value of the objective depends on the learning rate, the norm of the gradient and ùêø as follows:
If) - f(x- 7g) < Lallgll. (9.5.2)
In other words, the objective cannot change by more than ùêøùúÇkgk. Having a small value for
(continued from previous page)
Recurrent Neural Network Implementation from Scratch
357

this upper bound might be viewed as good or bad. On the downside, we are limiting the speed at which we can reduce the value of the objective. On the bright side, this limits by just how much we can go wrong in any one gradient step. When we say that gradients explode, we mean that kgk becomes excessively large. In this
worst case, we might do so much damage in a single gradient step that we could undo all of the progress made over the course of thousands of training iterations. When gradients can be so large, neural network training often diverges, failing to reduce the value of the objective. At other times, training eventually converges but is unstable owing to massive spikes in the loss. One way to limit the size of ùêøùúÇkgk is to shrink the learning rate ùúÇ to tiny values. This
has the advantage that we do not bias the updates. But what if we only rarely get large gradients? This drastic move slows down our progress at all steps, just to deal with the rare exploding gradient events. A popular alternative is to adopt a gradient clipping heuristic projecting the gradients g onto a ball of some given radius ùúÉ as follows:
g min 1, kgk g. (9.5.3)
This ensures that the gradient norm never exceeds ùúÉ and that the updated gradient is entirely
aligned with the original direction of g. It also has the desirable side-effect of limiting the influence any given minibatch (and within it any given sample) can exert on the parameter vector. This bestows a certain degree of robustness to the model. To be clear, it is a hack. Gradient clipping means that we are not always following the true gradient and it is hard to reason analytically about the possible side effects. However, it is a very useful hack, and is widely adopted in RNN implementations in most deep learning frameworks. Below we define a method to clip gradients, which is invoked by the fit_epoch method of the d2l.Trainer class (see Section 3.4). Note that when computing the gradient norm, we are concatenating all model parameters, treating them as a single giant parameter vec- tor. @d2l.add_to_class(d2l.Trainer) #@save def clip_gradients(self, grad_clip_val, model): params = [p for p in model.parameters() if p.requires_grad] norm = torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params)) if norm > grad_clip_val: for param in params: param.grad[:] *= grad_clip_val / norm
9.5.4 Training
Using The Time Machine dataset (data), we train a character-level language model (model) based on the RNN (rnn) implemented from scratch. Note that we first calculate the gra- dients, then clip them, and finally update the model parameters using the clipped gradi- ents. ùúÉ
Recurrent Neural Networks
358

data = d2l.TimeMachine(batch_size=1024, num_steps=32) rnn = RNNScratch(num_inputs=len(data.vocab), num_hiddens=32) model = RNNLMScratch(rnn, vocab_size=len(data.vocab), lr=1) trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
‚Äî train_ppl ‚Äî-- val_ppl
9.5.5 Decoding
Once a language model has been learned, we can use it not only to predict the next token but to continue predicting each subsequent one, treating the previously predicted token as though it were the next in the input. Sometimes we will just want to generate text as though we were starting at the beginning of a document.bubuHowever, it is often useful to condition the language model on a user-supplied prefix. For example, if we were developing an autocom- plete feature for a search engine or to assist users in writing emails, we would want to feed in what they had written so far (the prefix), and then generate a likely continuation. The following predict method generates a continuation, one character at a time, after ingesting a user-provided prefix. When looping through the characters in prefix, we keep passing the hidden state to the next time step but do not generate any output. This is called the warm-up period. After ingesting the prefix, we are now ready to begin emitting the subsequent characters, each of which will be fed back into the model as the input at the next time step. @d2l.add_to_class(RNNLMScratch) #@save def predict(self, prefix, num_preds, vocab, device=None): state, outputs = None, [vocab[prefix[0]]] for i in range(len(prefix) + num_preds - 1): X = torch.tensor([[outputs[-1]]], device=device) embs = self.one_hot(X) rnn_outputs, state = self.rnn(embs, state) if i < len(prefix) - 1: # Warm-up period outputs.append(vocab[prefix[i + 1]]) else: # Predict num_preds steps Y = self.output_layer(rnn_outputs) outputs.append(int(Y.argmax(axis=2).reshape(1))) return ''.join([vocab.idx_to_token[i] for i in outputs])
In the following, we specify the prefix and have it generate 20 additional characters. Recurrent Neural Network Implementation from Scratch
359

model.predict('it has', 20, data.vocab, d2l.try_gpu())
'it has in the the the the '
While implementing the above RNN model from scratch is instructive, it is not convenient. In the next section, we will see how to leverage deep learning frameworks to whip up RNNs using standard architectures, and to reap performance gains by relying on highly optimized library functions. 9.5.6 Summary
We can train RNN-based language models to generate text following the user-provided text prefix. A simple RNN language model consists of input encoding, RNN modeling, and output generation. During training, gradient clipping can mitigate the problem of explod- ing gradients but does not address the problem of vanishing gradients. In the experiment, we implemented a simple RNN language model and trained it with gradient clipping on se- quences of text, tokenized at the character level. By conditioning on a prefix, we can use a language model to generate likely continuations, which proves useful in many applications, e.g., autocomplete features. 9.5.7 Exercises
1. Doestheimplementedlanguagemodelpredictthenexttokenbasedonallthepasttokens up to the very first token in The Time Machine? 2. Which hyperparameter controls the length of history used for prediction? 3. Show that one-hot encoding is equivalent to picking a different embedding for each object. 4. Adjust the hyperparameters (e.g., number of epochs, number of hidden units, number of time steps in a minibatch, and learning rate) to improve the perplexity. How low can you go while sticking with this simple architecture?bubu5. Replace one-hot encoding with learnable embeddings. Does this lead to better perfor- mance?bubu6. Conduct an experiment to determine how well this language model trained on The Time Machine works on other books by H. G.bubuWells, e.g., The War of the Worlds. 7. Conduct another experiment to evaluate the perplexity of this model on books written by other authors. 8. Modify the prediction method so as to use sampling rather than picking the most likely next character. e What happens? Recurrent Neural Networks
360

e Bias the model towards more likely outputs, e.g., by sampling from q(x; | xr-1,--.,%1) &
e Bias the model towards more likely outputs, e.g., by sampling from q(x; | xr-1,--.,%1) & P(x; | Xt-1,---,X1)% fora > 1. 9.bubuRun the code in this section without clipping the gradient. What happens?bubu10. Replace the activation function used in this section with ReLU and repeat the experi- ments in this section. Do we still need gradient clipping? Why?bubuDiscussions142. 142
9.6 Concise Implementation of Recurrent Neural Networks

Like most of our from-scratch implementations, Section 9.5 was designed to provide in- sight into how each component works. But when you are using RNNs every day or writing production code, you will want to rely more on libraries that cut down on both implemen- tation time (by supplying library code for common models and functions) and computation time (by optimizing the heck out of these library implementations). This section will show you how to implement the same language model more efficiently using the high-level API provided by your deep learning framework. We begin, as before, by loading The Time Machine dataset. import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
9.6.1 Defining the Model
We define the following class using the RNN implemented by high-level APIs. class RNN(d2l.Module): #@save """The RNN model implemented with high-level APIs.""" def __init__(self, num_inputs, num_hiddens): super().__init__() self.save_hyperparameters() self.rnn = nn.RNN(num_inputs, num_hiddens) def forward(self, inputs, H=None): return self.rnn(inputs, H)
Inheriting from the RNNLMScratch class in Section 9.5, the following RNNLM class defines a complete RNN-based language model. Note that we need to create a separate fully con- nected output layer. Concise Implementation of Recurrent Neural Networks
361

class RNNLM(d2l.RNNLMScratch): #@save """The RNN-based language model implemented with high-level APIs.""" def init_params(self): self.linear = nn.LazyLinear(self.vocab_size) def output_layer(self, hiddens): return self.linear(hiddens).swapaxes(0, 1)
9.6.2 Training and Predicting
Before training the model, let‚Äôs make a prediction with a model initialized with random weights. Given that we have not trained the network, it will generate nonsensical predic- tions. data = d2l.TimeMachine(batch_size=1024, num_steps=32) rnn = RNN(num_inputs=len(data.vocab), num_hiddens=32) model = RNNLM(rnn, vocab_size=len(data.vocab), lr=1) model.predict('it has', 20, data.vocab)
'it hasoadd dd dd dd dd dd '
Next, we train our model, leveraging the high-level API. trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
‚Äî train_ppl == val_ppl
Compared with Section 9.5, this model achieves comparable perplexity, but runs faster due to the optimized implementations. As before, we can generate predicted tokens following the specified prefix string. model.predict('it has', 20, data.vocab, d2l.try_gpu())
'it has and the trave the t'
9.6.3 Summary
Recurrent Neural Networks
362

High-level APIs in deep learning frameworks provide implementations of standard RNNs. These libraries help you to avoid wasting time reimplementing standard models. Moreover, framework implementations are often highly optimized, leading to significant (computa- tional) performance gains when compared with implementations from scratch. 9.6.4 Exercises
1. Can you make the RNN model overfit using the high-level APIs? 2. Implement the autoregressive model of Section 9.1 using an RNN. Discussions143. 143

9.7 Backpropagation Through Time
es
If you completed the exercises in Section 9.5, you would have seen that gradient clipping is vital for preventing the occasional massive gradients from destabilizing training. We hinted that the exploding gradients stem from backpropagating across long sequences. Before in- troducing a slew of modern RNN architectures, let‚Äôs take a closer look at how backprop- agation works in sequence models in mathematical detail. Hopefully, this discussion will bring some precision to the notion of vanishing and exploding gradients. If you recall our discussion of forward and backward propagation through computational graphs when we introduced MLPs in Section 5.3, then forward propagation in RNNs should be relatively straightforward. Applying backpropagation in RNNs is called backpropagation through time (Werbos, 1990). This procedure requires us to expand (or unroll) the computational graph of an RNN one time step at a time. The unrolled RNN is essentially a feedforward neural network with the special property that the same parameters are repeated throughout the unrolled network, appearing at each time step. Then, just as in any feedforward neural network, we can apply the chain rule, backpropagating gradients through the unrolled net. The gradient with respect to each parameter must be summed across all places that the pa- rameter occurs in the unrolled net. Handling such weight tying should be familiar from our chapters on convolutional neural networks. Complications arise because sequences can be rather long. It is not unusual to work with text sequences consisting of over a thousand tokens. Note that this poses problems both from a computational (too much memory) and optimization (numerical instability) stand- point. Input from the first step passes through over 1000 matrix products before arriving at the output, and another 1000 matrix products are required to compute the gradient. We now analyze what can go wrong and how to address it in practice. 9.7.1 Analysis of Gradients in RNNs
We start with a simplified model of how an RNN works. This model ignores details about the specifics of the hidden state and how it is updated. The mathematical notation here does
Backpropagation Through Time
363

not explicitly distinguish scalars, vectors, and matrices. We are just trying to develop some intuition. In this simplified model, we denote ‚Ñéùë° as the hidden state, ùë•ùë° as input, and ùëúùë° as output at time step ùë°. Recall our discussions in Section 9.4.2 that the input and the hidden statecanbeconcatenatedbeforebeingmultipliedbyoneweightvariableinthehiddenlayer. Thus, we use ùë§h and ùë§o to indicate the weights of the hidden layer and the output layer, respectively. As a result, the hidden states and outputs at each time step are
hy = f (Xt, ht-1, Wn),
ùëúùë° = ùëî‚Äû‚Ñéùë°, ùë§o‚Äù, (9.7.1)
where ùëì and ùëî are transformations of the hidden layer and the output layer, respectively. where f and g are transformations of the hidden layer and the output layer, respectively. Hence, we have a chain of values {..., (X+-1, Ar-1, Or-1), (Xr, Ar, Or), .. .} that depend on each other via recurrent computation. The forward propagation is fairly straightforward. All we need is to loop through the (x;, /;,0;) triples one time step at a time. The discrep- ancy between output 0; and the desired target y; is then evaluated by an objective function across all the T time steps as
1 T L(x1,.-- XT Vis +++ YT, Why Wo) = 7 ¬ª I(yr, 01). (9.7.2) t=1
For backpropagation, matters are a bit trickier, especially when we compute the gradients with regard to the parameters ùë§h of the objective function ùêø. To be specific, by the chain rule,
Al(y;, 01) ome ty Mgaw ie _1 x 1 (Yr, Or) O(N, Wo) Oht ‚ÄùT dor Oh; Own (9.7.3)
The first and the second factors of the product in (9.7.3) are easy to compute. The third factor Oh; /OWp is where things get tricky, since we need to recurrently compute the effect of the parameter wy, on h;. According to the recurrent computation in (9.7.1), h, depends on both /;_; and wp, where computation of h;-; also depends on wp. Thus, evaluating the total derivate of h, with respect to wp using the chain rule yields
oh = Of (Xt, Mr-1, Wh) + Of (Xt, Mr-1, Wh) Ohy-1 7A Own OWn Ohy-1 Own (9 74)
To derive the above gradient, assume that we have three sequences fùëéùë°g, fùëèùë°g, fùëêùë°g satisfy-
To derive the above gradient, assume that we have three sequences {a;}, {br}, {cr} satisfy- ing ap = O and a; = b; +c;a;-; fort = 1,2,.... Then for t > 1, it is easy to show
a = 45) Il cj | bi. (9.7.5) i=l j=i+l
Recurrent Neural Networks
364

By substituting ùëéùë°, ùëèùë°, and ùëêùë° according to
a = ol t= Own‚Äô Of (Xt, Mr-1, Wh) by = ‚Äî‚Äî‚Äî‚Äî 7.6 t Ow, ; (9.7.6) oa Of (Xt, Mr-1, Wh) t aha ,
the gradient computation in (9.7.4) satisfies a; = b; + cya;‚Äî1. Thus, per (9.7.5), we can remove the recurrent computation in (9.7.4) with
-1[ 1 hy _ Of (thorn) AF (xj, hj-1, Wh) | Of Oi, hi-, Wn) = : 1.7 awn mT dhj-1 awn (9-7-7) i=l \j=i+l
While we can use the chain rule to compute 0h;/dwy recursively, this chain can get very
long whenever ùë° is large. Let‚Äôs discuss a number of strategies for dealing with this prob- lem. Full Computation
One idea might be to compute the full sum in (9.7.7). However, this is very slow and gradients can blow up, since subtle changes in the initial conditions can potentially affect the outcome a lot. That is, we could see things similar to the butterfly effect, where minimal changes in the initial conditions lead to disproportionate changes in the outcome. This is generally undesirable. After all, we are looking for robust estimators that generalize well. Hence this strategy is almost never used in practice. Truncating Time Steps
Alternatively, we can truncate the sum in (9.7.7) after ùúè steps. This is what we have been
Alternatively, we can truncate the sum in (9.7.7) after 7 steps. This is what we have been discussing so far. This leads to an approximation of the true gradient, simply by terminating the sum at 0/;~,/Owp. In practice this works quite well. It is what is commonly referred to as truncated backpropgation through time (Jaeger, 2002). One of the consequences of this is that the model focuses primarily on short-term influence rather than long-term con- sequences. This is actually desirable, since it biases the estimate towards simpler and more stable models. Randomized Truncation
Last, we can replace 0h;/dwy by a random variable which is correct in expectation but
Last, we can replace 0h;/dwy by a random variable which is correct in expectation but truncates the sequence. This is achieved by using a sequence of &; with predefined 0 < m‚Ñ¢, < 1, where P(√©, = 0) = 1-7, and P(√©, = a!) = 7, thus E[√©,] = 1. We use this to replace the gradient 0h; /Owp in (9.7.4) with
= Of (Xt, Mr-1, Wh) +√© Of (Xt, Mr-1, Wh) Ohy-1 Own ‚Äò Ohy-1 Own ¬© (9.7.8) Zr
ùúï‚Ñéùë°
Backpropagation Through Time
365

It follows from the definition of √©, that E[z,;] = 0h;/Owp. Whenever ‚Ç¨, = 0 the recurrent computation terminates at that time step t. This leads to a weighted sum of sequences of varying lengths, where long sequences are rare but appropriately overweighted. This idea was proposed by Tallec and Ollivier (2017). Comparing Strategies
the time machine by h g wells
tFig. 9.7.1
Comparing strategies for computing gradients in RNNs. From top to bottom: randomized truncation, regular truncation, and full computation. Fig. 9.7.1 illustrates the three strategies when analyzing the first few characters of The Time Machine using backpropagation through time for RNNs:
e The first row is the randomized truncation that partitions the text into segments of varying
lengths. e The second row is the regular truncation that breaks the text into subsequences of the
same length. This is what we have been doing in RNN experiments. e The third row is the full backpropagation through time that leads to a computationally
infeasible expression. Unfortunately, while appealing in theory, randomized truncation does not work much bet- ter than regular truncation, most likely due to a number of factors. First, the effect of an observation after a number of backpropagation steps into the past is quite sufficient to cap- ture dependencies in practice. Second, the increased variance counteracts the fact that the gradient is more accurate with more steps. Third, we actually want models that have only a short range of interactions. Hence, regularly truncated backpropagation through time has a slight regularizing effect that can be desirable. 9.7.2 Backpropagation Through Time in Detail
After discussing the general principle, let‚Äôs discuss backpropagation through time in detail. IncontrasttotheanalysisinSection9.7.1, inthefollowingwewillshowhowtocomputethe gradients of the objective function with respect to all the decomposed model parameters. To keep things simple, we consider an RNN without bias parameters, whose activation function in the hidden layer uses the identity mapping (ùúô‚Äûùë•‚Äù = ùë•). For time step ùë°, let the single example input and the target be xùë° 2 Rùëë and ùë¶ùë°, respectively. The hidden state hùë° 2 R‚Ñé and the output oùë° 2 Rùëû are computed as
hy, = Woxx, + Winhy-1, (9.7.9) Or = Wahi,
Recurrent Neural Networks
366

where Whx ‚Ç¨ R‚Äô*4, Wan ‚Ç¨ R‚Äô‚Ñ¢", and Wan ‚Ç¨ RY xh are the weight parameters. Denote by /(0;, yr) the loss at time step ¬¢. Our objective function, the loss over T time steps from the beginning of the sequence is thus
ùêø = 1 ùëá ùë°=1 ùëô‚Äûoùë°, ùë¶ùë°‚Äù. (9.7.10)
In order to visualize the dependencies among model variables and parameters during com- putation of the RNN, we can draw a computational graph for the model, as shown in Fig. 9.7.2. For example, the computation of the hidden states of time step 3, h3, depends on the model parameters Whx and Whh, the hidden state of the previous time step h2, and the input of the current time step x3. 0,
tFig. 9.7.2
Computational graph showing dependencies for an RNN model with three time steps. Boxes represent variables (not shaded) or parameters (shaded) and circles represent operators. As just mentioned, the model parameters in Fig.bubu9.7.2 are Whx, Whn, and Wan. Gen- erally, training this model requires gradient computation with respect to these parameters OL/OWhpx, OL/OWpn, and OL/AW gn. According to the dependencies in Fig. 9.7.2, we can traverse in the opposite direction of the arrows to calculate and store the gradients in turn. To flexibly express the multiplication of matrices, vectors, and scalars of different shapes in the chain rule, we continue to use the prod operator as described in Section 5.3. First of all, differentiating the objective function with respect to the model output at any time step ùë° is fairly straightforward:
OL _ Al(Or, yr) ‚Äî = ER‚Äô. -TAL do; T -do; (9.7.11)
Now we can calculate the gradient of the objective with respect to the parameter Wn in the output layer: 0L/OWon ‚Ç¨ R¬´*, Based on Fig. 9.7.2, the objective L depends on Wan via 01,...,07. Using the chain rule yields
OL OL 00, OL = > d | ‚Äî‚Äî = > ‚Äîh)} 7.12 IW Pro (so awa) Oo!‚Äù (9.7.12)
where OL/00, is given by (9.7.11). Next, as shown in Fig. 9.7.2, at the final time step ùëá, the objective function ùêø depends on
Next, as shown in Fig. 9.7.2, at the final time step T, the objective function L depends on the hidden state hy only via or. Therefore, we can easily find the gradient 0L/Ohr ‚Ç¨ Ri
T
Backpropagation Through Time
367

using the chain rule:
ùúïùêø ùúïhùëá = prod ùúïùêø ùúïoùëá , ùúïoùëá ùúïhùëá = W> qh ùúïùêø ùúïoùëá . (9.7.13)
It gets trickier for any time step ùë° < ùëá, where the objective function ùêø depends on hùë° via
It gets trickier for any time step t < T, where the objective function L depends on h, via h,41 and o;. According to the chain rule, the gradient of the hidden state 0L/Oh;, ‚Ç¨ R" at any time step t < T can be recurrently computed as:
ùúïùêø ùúïhùë° = prod ùúïùêø ùúïhùë°‚Äö1 , ùúïhùë°‚Äö1 ùúïhùë° ‚Äö prod ùúïùêø ùúïoùë° , ùúïoùë° ùúïhùë° = W> hh ùúïùêø ùúïhùë°‚Äö1 ‚Äö W> qh ùúïùêø ùúïoùë° . (9.7.14)
For analysis, expanding the recurrent computation for any time step 1 < t < T gives
T
T OL T-i OL > = Wi wi : dh, 2, (Win) 9 Bors:-i (9.7.15) i=t
We can see from (9.7.15) that this simple linear example already exhibits some key prob- lems of long sequence models: it involves potentially very large powers of W> hh. In it, eigenvalues smaller than 1 vanish and eigenvalues larger than 1 diverge. This is numer- ically unstable, which manifests itself in the form of vanishing and exploding gradients. One way to address this is to truncate the time steps at a computationally convenient size as discussed in Section 9.7.1. In practice, this truncation can also be effected by detaching the gradient after a given number of time steps. Later on, we will see how more sophisticated sequence models such as long short-term memory can alleviate this further. Finally, Fig. 9.7.2 shows that the objective function ùêø depends on model parameters Whx
Finally, Fig. 9.7.2 shows that the objective function L depends on model parameters Whx and Whn in the hidden layer via hidden states hi,..., hr. To compute gradients with respect to such parameters 0L/@Whpx ‚Ç¨ R‚Äô*4 and OL/OWhn ‚Ç¨ R'‚Ñ¢", we apply the chain tule giving
oe oS OL oh, I aL = (22 -\\ 2x7 dWin 2 Pr (se awe] Dy, ft ml cl (9.7.16) oe 6 OL oh, YOL = d | ‚Äî‚Äî = ‚Äîh‚Ñ¢ dWin PO (sn awe) 2. a, m1
where 0L/dh, which is recurrently computed by (9.7.13) and (9.7.14) is the key quantity
that affects the numerical stability. Since backpropagation through time is the application of backpropagation in RNNs, as we have explained in Section 5.3, training RNNs alternates forward propagation with back- propagation through time. Moreover, backpropagation through time computes and stores the above gradients in turn. Specifically, stored intermediate values are reused to avoid du- plicate calculations, such as storing 0L/0h, to be used in computation of both 0L/OWhx and 0L/OWpn-
9.7.3 Summary
Recurrent Neural Networks
368

Backpropagation through time is merely an application of backpropagation to sequence models with a hidden state. Truncation, such as regular or randomized, is needed for com- putational convenience and numerical stability.bubuHigh powers of matrices can lead to diver- gent or vanishing eigenvalues. This manifests itself in the form of exploding or vanishing gradients. For efficient computation, intermediate values are cached during backpropaga- tion through time. 9.7.4 Exercises
1.bubuAssume that we have a symmetric matrix M ‚Ç¨ R‚Äù*" with eigenvalues A; whose cor-
1. Assume that we have a symmetric matrix M ‚Ç¨ R‚Äù*" with eigenvalues A; whose cor- responding eigenvectors are v; (i = 1,...,). Without loss of generality, assume that they are ordered in the order |A;| > |Ai+1|-
1. Show that Mùëò has eigenvalues ùúÜùëò
ùëñ . 2. Prove that for a random vector x 2 Rùëõ, with high probabilityMùëòx will be very much
aligned with the eigenvector v1 of M. Formalize this statement.bubu3. What does the above result mean for gradients in RNNs? 2. Besides gradient clipping, can you think of any other methods to cope with gradient explosion in recurrent neural networks? Discussions144. 144

10
Modern Recurrent Neural Networks
The previous chapter introduced the key ideas behind recurrent neural networks (RNNs). However, just as with convolutional neural networks, there has been a tremendous amount of innovation in RNN architectures, culminating in several complex designs that have proven successful in practice. In particular, the most popular designs feature mechanisms for mitigating the notorious numerical instability faced by RNNs, as typified by vanishing and exploding gradients. Recall that in Chapter 9 we dealt with exploding gradients by ap- plying a blunt gradient clipping heuristic. Despite the efficacy of this hack, it leaves open the problem of vanishing gradients. Inthischapter, weintroducethekeyideasbehindthemostsuccessfulRNNarchitecturesfor sequences, which stem from two papers. The first, Long Short-Term Memory (Hochreiter and Schmidhuber, 1997), introduces the memory cell, a unit of computation that replaces traditional nodes in the hidden layer of a network. With these memory cells, networks are able to overcome difficulties with training encountered by earlier recurrent networks. Intuitively, the memory cell avoids the vanishing gradient problem by keeping values in each memory cell‚Äôs internal state cascading along a recurrent edge with weight 1 across many successive time steps. A set of multiplicative gates help the network to determine not only the inputs to allow into the memory state, but when the content of the memory state should influence the model‚Äôs output. The second paper, Bidirectional Recurrent Neural Networks (Schuster and Paliwal, 1997), introducesanarchitectureinwhichinformationfromboththefuture(subsequenttimesteps) and the past (preceding time steps) are used to determine the output at any point in the se- quence. This is in contrast to previous networks, in which only past input can affect the output. Bidirectional RNNs have become a mainstay for sequence labeling tasks in natu- ral language processing, among a myriad of other tasks. Fortunately, the two innovations arenotmutuallyexclusive, andhavebeensuccessfullycombinedforphonemeclassification (Graves and Schmidhuber, 2005) and handwriting recognition (Graves et al., 2008). ThefirstsectionsinthischapterwillexplaintheLSTMarchitecture,alighter-weightversion called the gated recurrent unit (GRU), the key ideas behind bidirectional RNNs and a brief explanation of how RNN layers are stacked together to form deep RNNs. Subsequently, we will explore the application of RNNs in sequence-to-sequence tasks, introducing ma- chine translation along with key ideas such as encoder‚Äìdecoder architectures and beam search. 369
Modern Recurrent Neural Networks
370

10.1 Long Short-Term Memory (LSTM)
i ‚ÄîCSsSCSC‚ÄòC‚ÄòsC‚Äò
ShortlyafterthefirstElman-styleRNNsweretrainedusingbackpropagation(Elman,1990), the problems of learning long-term dependencies (owing to vanishing and exploding gra- dients) became salient, with Bengio and Hochreiter discussing the problem (Bengio et al., 1994, Hochreiter et al., 2001). Hochreiter had articulated this problem as early as 1991 in his Master‚Äôs thesis, although the results were not widely known because the thesis was writ- ten in German. While gradient clipping helps with exploding gradients, handling vanishing gradients appears to require a more elaborate solution. One of the first and most successful techniquesforaddressingvanishinggradientscameintheformofthelongshort-termmem- ory (LSTM) model due to Hochreiter and Schmidhuber (1997). LSTMs resemble standard recurrent neural networks but here each ordinary recurrent node is replaced by a memory cell. Each memory cell contains an internal state, i.e., a node with a self-connected re- current edge of fixed weight 1, ensuring that the gradient can pass across many time steps without vanishing or exploding. The term ‚Äúlong short-term memory‚Äù comes from the following intuition. Simple recurrent neural networks have long-term memory in the form of weights. The weights change slowly during training, encoding general knowledge about the data. They also have short-term memory in the form of ephemeral activations, which pass from each node to successive nodes. The LSTM model introduces an intermediate type of storage via the memory cell. A memory cell is a composite unit, built from simpler nodes in a specific connectivity pattern, with the novel inclusion of multiplicative nodes. import torch from torch import nn from d2l import torch as d2l
10.1.1 Gated Memory Cell
Each memory cell is equipped with an internal state and a number of multiplicative gates that determine whether (i) a given input should impact the internal state (the input gate), (ii) the internal state should be flushed to 0 (the forget gate), and (iii) the internal state of a given neuron should be allowed to impact the cell‚Äôs output (the output gate). Gated Hidden State
The key distinction between vanilla RNNs and LSTMs is that the latter support gating of the hidden state. This means that we have dedicated mechanisms for when a hidden state should be updated and also for when it should be reset. These mechanisms are learned and they address the concerns listed above. For instance, if the first token is of great importance we will learn not to update the hidden state after the first observation. Likewise, we will learn to skip irrelevant temporary observations. Last, we will learn to reset the latent state whenever needed.bubuWe discuss this in detail below. Long Short-Term Memory (LSTM)
371

Input Gate, Forget Gate, and Output Gate
The data feeding into the LSTM gates are the input at the current time step and the hidden state of the previous time step, as illustrated in Fig. 10.1.1. Three fully connected layers with sigmoid activation functions compute the values of the input, forget, and output gates. As a result of the sigmoid activation, all values of the three gates are in the range of ‚Äû0,1‚Äù. Additionally, we require an input node, typically computed with a tanh activation func- tion. Intuitively, the input gate determines how much of the input node‚Äôs value should be added to the current memory cell internal state. The forget gate determines whether to keep the current value of the memory or flush it. And the output gate determines whether the memory cell should influence the output at the current time step. Forget Input Output gate gate gate Fr, 1 9, Hidden state H., T Input X, TED ccivaton tinction } copy 7 Concatenate
tFig. 10.1.1 Computing the input gate, the forget gate, and the output gate in an LSTM model. Mathematically, suppose that there are ‚Ñé hidden units, the batch size is ùëõ, and the number
Mathematically, suppose that there are h hidden units, the batch size is n, and the number of inputs is d. Thus, the input is X; ‚Ç¨ R‚Äù* and the hidden state of the previous time step is H,_; ‚Ç¨ R‚Äô*". Correspondingly, the gates at time step f are defined as follows: the input gate is I, ‚Ç¨ R‚Äù*", the forget gate is F, ¬¢ R‚Äù*‚Äô, and the output gate is O, ‚Ç¨ R‚Äô*". They are calculated as follows:
I, = 0 (X, W,; + H,-) Whi + bi), F, = 0 (X, War + Hy-1 Woe + be), (10.1.1) O; = 0 (X; Wyo + Hr-1 Who + bo),
where Wi, Wxr, Wyxo ‚Ç¨ R2*" and Whi, Wir, Who ‚Ç¨ R‚Äù*‚Äù are weight parameters and bi, br, by ‚Ç¨ R!*" are bias parameters. Note that broadcasting (see Section 2.1.4) is trig- gered during the summation. We use sigmoid functions (as introduced in Section 5.1) to map the input values to the interval (0, 1). Next we design the memory cell. Since we have not specified the action of the various gates yet, we first introduce the input node C, ‚Ç¨ R‚Äù*". Its computation is similar to that of the three gates described above, but uses a tanh function with a value range for (‚Äî1, 1) as the activation function. This leads to the following equation at time step f:
C, = tanh(X;Wy. + Hy-1 Whe + be),
(10.1.2)
Input Node
Modern Recurrent Neural Networks
372

where Wx. ‚Ç¨ R¬¢*" and Whe ‚Ç¨ R‚Äù*" are weight parameters and b, ‚Ç¨ R!*" is a bias
parameter. A quick illustration of the input node is shown in Fig.bubu10.1.2. Input Forget Input Output gate gate node gate F, LS C, 9, Hidden state Bi H, \ Input X, FC layer with [ED cctivaton function $ cory [* Concatenate
tFig. 10.1.2 Computing the input node in an LSTM model. Memory Cell Internal State
In LSTMs, the input gate Iùë° governs how much we take new data into account via ÀúCùë° and
In LSTMs, the input gate I, governs how much we take new data into account via C; and the forget gate F, addresses how much of the old cell internal state C,_; ‚Ç¨ R"‚Ñ¢*" we retain. Using the Hadamard (elementwise) product operator ¬© we arrive at the following update equation:
C, =F,0C,-1+L0CG,. (10.1.3)
If the forget gate is always | and the input gate is always 0, the memory cell internal state C,_, will remain constant forever, passing unchanged to each subsequent time step. How- ever, input gates and forget gates give the model the flexibility of being able to learn when to keep this value unchanged and when to perturb it in response to subsequent inputs. In practice, this design alleviates the vanishing gradient problem, resulting in models that are much easier to train, especially when facing datasets with long sequence lengths. We thus arrive at the flow diagram in Fig.bubu10.1.3. Hidden State
Last, we need to define how to compute the output of the memory cell, i.e., the hidden state H, ‚Ç¨ R‚Äù*", as seen by other layers. This is where the output gate comes into play. In LSTMs, we first apply tanh to the memory cell internal state and then apply another point- wise multiplication, this time with the output gate. This ensures that the values of H; are always in the interval (‚Äî1, 1):
H, = O, ¬© tanh(C,). (10.1.4)
Whenever the output gate is close to 1, we allow the memory cell internal state to impact the subsequent layers uninhibited, whereas for output gate values close to 0, we prevent the
Long Short-Term Memory (LSTM)
373

Memory cell internal state a -c Ca Output gate oO, Forget Input gate gate F, 1, Hidden state A, i} Input X, FC layer with Elementwise activation function operator 3 Copy [~~ Concatenate
tFig. 10.1.3 Computing the memory cell internal state in an LSTM model. current memory from impacting other layers of the network at the current time step. Note that a memory cell can accrue information across many time steps without impacting the rest of the network (as long as the output gate takes values close to 0), and then suddenly impact the network at a subsequent time step as soon as the output gate flips from values closeto0tovaluescloseto1. Fig.10.1.4hasagraphicalillustrationofthedataflow. Memory cell internal state -¬¢ C., Forget gate F, Hidden state 1 H, iW ( > H, T Input X, FC layer with Elementwise activation function operator } Copy [‚Äù Concatenate
tFig. 10.1.4 Computing the hidden state in an LSTM model. 10.1.2 Implementation from Scratch
Now let‚Äôs implement an LSTM from scratch. As same as the experiments in Section 9.5, we first load The Time Machine dataset. Initializing Model Parameters
Next, we need to define and initialize the model parameters. As previously, the hyperpa- rameter num_hiddens dictates the number of hidden units. We initialize weights following a Gaussian distribution with 0.01 standard deviation, and we set the biases to 0. class LSTMScratch(d2l.Module): def __init__(self, num_inputs, num_hiddens, sigma=0.01):
tenat
tenat
(continues on next page)
Modern Recurrent Neural Networks
374

super().__init__() self.save_hyperparameters() init_weight = lambda *shape: nn.Parameter(torch.randn(*shape) * sigma) triple = lambda: (init_weight(num_inputs, num_hiddens), init_weight(num_hiddens, num_hiddens), nn.Parameter(torch.zeros(num_hiddens))) self.W_xi, self.W_hi, self.b_i = triple() # Input gate self.W_xf, self.W_hf, self.b_f = triple() # Forget gate self.W_xo, self.W_ho, self.b_o = triple() # Output gate self.W_xc, self.W_hc, self.b_c = triple() # Input node
super().__init__() self.save_hyperparameters()
The actual model is defined as described above, consisting of three gates and an input node. Note that only the hidden state is passed to the output layer. @d2l.add_to_class(LSTMScratch) def forward(self, inputs, H_C=None): if H_C is None: # Initial state with shape: (batch_size, num_hiddens) H = torch.zeros((inputs.shape[1], self.num_hiddens), device=inputs.device) C = torch.zeros((inputs.shape[1], self.num_hiddens), device=inputs.device) else: H, C = H_C outputs = [] for X in inputs: I = torch.sigmoid(torch.matmul(X, self.W_xi) + torch.matmul(H, self.W_hi) + self.b_i) F = torch.sigmoid(torch.matmul(X, self.W_xf) + torch.matmul(H, self.W_hf) + self.b_f) O = torch.sigmoid(torch.matmul(X, self.W_xo) + torch.matmul(H, self.W_ho) + self.b_o) C_tilde = torch.tanh(torch.matmul(X, self.W_xc) + torch.matmul(H, self.W_hc) + self.b_c) C = F * C + I * C_tilde H = O * torch.tanh(C) outputs.append(H) return outputs, (H, C)
Training and Prediction
Let‚ÄôstrainanLSTMmodelbyinstantiatingtheRNNLMScratchclassfromSection9.5. data = d2l.TimeMachine(batch_size=1024, num_steps=32) lstm = LSTMScratch(num_inputs=len(data.vocab), num_hiddens=32) model = d2l.RNNLMScratch(lstm, vocab_size=len(data.vocab), lr=4) trainer = d2l.Trainer(max_epochs=50, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
10.1.3 Concise Implementation
(continued from previous page)
Long Short-Term Memory (LSTM)
375

‚Äî train_ppl val_ppl epoch
Using high-level APIs, we can directly instantiate an LSTM model. This encapsulates all the configuration details that we made explicit above. The code is significantly faster as it uses compiled operators rather than Python for many details that we spelled out be- fore. class LSTM(d2l.RNN): def __init__(self, num_inputs, num_hiddens): d2l.Module.__init__(self) self.save_hyperparameters() self.rnn = nn.LSTM(num_inputs, num_hiddens) def forward(self, inputs, H_C=None): return self.rnn(inputs, H_C)
lstm = LSTM(num_inputs=len(data.vocab), num_hiddens=32) model = d2l.RNNLM(lstm, vocab_size=len(data.vocab), lr=4) trainer.fit(model, data)
‚Äî train_ppl --- val_ppl 10 20 30 40 50 epoch
model.predict('it has', 20, data.vocab, d2l.try_gpu())
'it has a the time travelly'
LSTMs are the prototypical latent variable autoregressive model with nontrivial state con- trol. Many variants thereof have been proposed over the years, e.g., multiple layers, resid- ual connections, different types of regularization. However, training LSTMs and other
Modern Recurrent Neural Networks
376

sequence models (such as GRUs) is quite costly because of the long range dependency of the sequence. Later we will encounter alternative models such as Transformers that can be used in some cases. 10.1.4 Summary
WhileLSTMswerepublishedin1997, theyrosetogreatprominencewithsomevictoriesin prediction competitions in the mid-2000s, and became the dominant models for sequence learning from 2011 until the rise of Transformer models, starting in 2017. Even Tran- formers owe some of their key ideas to architecture design innovations introduced by the LSTM. LSTMs have three types of gates: input gates, forget gates, and output gates that control the flow of information. The hidden layer output of LSTM includes the hidden state and the memory cell internal state. Only the hidden state is passed into the output layer while the memory cell internal state remains entirely internal. LSTMs can alleviate vanishing and exploding gradients. 10.1.5 Exercises
1. Adjust the hyperparameters and analyze their influence on running time, perplexity, and the output sequence. 2. How would you need to change the model to generate proper words rather than just sequences of characters? 3. Compare the computational cost for GRUs, LSTMs, and regular RNNs for a given hid- den dimension. Pay special attention to the training and inference cost.bubu4. Since the candidate memory cell ensures that the value range is between ‚Äî1 and | by
4. Since the candidate memory cell ensures that the value range is between ‚Äî1 and | by using the tanh function, why does the hidden state need to use the tanh function again to ensure that the output value range is between ‚Äî1 and 1? 5. Implement an LSTM model for time series prediction rather than character sequence prediction. 145 
Discussions145. 10.2 Gated Recurrent Units (GRU)
a
As RNNs and particularly the LSTM architecture (Section 10.1) rapidly gained popularity during the 2010s, a number of researchers began to experiment with simplified architec- tures in hopes of retaining the key idea of incorporating an internal state and multiplicative gating mechanisms but with the aim of speeding up computation. The gated recurrent unit
Gated Recurrent Units (GRU)
377

(GRU) (Cho et al., 2014) offered a streamlined version of the LSTM memory cell that of- ten achieves comparable performance but with the advantage of being faster to compute (Chung et al., 2014). import torch from torch import nn from d2l import torch as d2l
10.2.1 Reset Gate and Update Gate
Here, the LSTM‚Äôs three gates are replaced by two: the reset gate and the update gate. As with LSTMs, these gates are given sigmoid activations, forcing their values to lie in the interval ‚Äû0,1‚Äù. Intuitively, the reset gate controls how much of the previous state we might still want to remember. Likewise, an update gate would allow us to control how much of the new state is just a copy of the old one. Fig. 10.2.1 illustrates the inputs for both the reset and update gates in a GRU, given the input of the current time step and the hidden state of the previous time step. The outputs of the gates are given by two fully connected layers with a sigmoid activation function. Hidden state HL, Reset Update gate gate Input X, FC layer with c Coneatenat AD ccivatentuncton 1, Soy ‚Äòeneatenale
tFig. 10.2.1 Computing the reset gate and the update gate in a GRU model. Mathematically, for a given time step f, suppose that the input is a minibatch X, ‚Ç¨ R‚Äù*¬¢
Mathematically, for a given time step f, suppose that the input is a minibatch X, ‚Ç¨ R‚Äù*¬¢ (number of examples = n; number of inputs = d) and the hidden state of the previous time step is H;-1 ‚Ç¨ Rxh (number of hidden units = h). Then the reset gate R; ‚Ç¨ R"‚Ñ¢" and update gate Z; ‚Ç¨ R‚Äù*" are computed as follows:
Ri = 0(X) Wor + Hy-1 Wor + by), (10.2.1) Z, = 0 (Xt Wz + Hr-1 Wiz + bz),
where Wx;, Wx, ‚Ç¨ R¬¢*" and War, Whz ‚Ç¨ R‚Äô*" are weight parameters and b,, b, ‚Ç¨ R!*" are bias parameters. 10.2.2 Candidate Hidden State
Modern Recurrent Neural Networks
378

Next, we integrate the reset gate R, with the regular updating mechanism in (9.4.5), leading to the following candidate hidden state H, ‚Ç¨ R"*" at time step t:
Hy, = tanh(X,Wy, + (R; ¬© H,_1) Wan + by), (10.2.2)
where W,,, ‚Ç¨ R2*" and Wop ‚Ç¨ R‚Äù*‚Äù are weight parameters, b, ‚Ç¨ R!*" is the bias, and the symbol ¬© is the Hadamard (elementwise) product operator. Here we use a tanh activation function. The result is a candidate, since we still need to incorporate the action of the update gate. Comparing with (9.4.5), the influence of the previous states can now be reduced with the elementwise multiplication of R, and H,-| in (10.2.2). Whenever the entries in the reset gate R, are close to 1, we recover a vanilla RNN such as that in (9.4.5). For all entries of the reset gate R, that are close to 0, the candidate hidden state is the result of an MLP with X; as input. Any pre-existing hidden state is thus reset to defaults. Fig. 10.2.2 illustrates the computational flow after applying the reset gate. Hidden state Candidate Reset Update | gate gate‚Äù ‚Äòidden state R 4, iH, Co T Input X, layer with Elementwise activation function operator Copy 7
FC
tFig. 10.2.2 Computing the candidate hidden state in a GRU model. 10.2.3 Hidden State
Finally, we need to incorporate the effect of the update gate Z;. This determines the extent to which the new hidden state H, ‚Ç¨ R‚Äù*" matches the old state H,_1 compared with how much it resembles the new candidate state H,. The update gate Z, can be used for this purpose, simply by taking elementwise convex combinations of H;_; and H;. This leads to the final update equation for the GRU:
H, = Z; 0 H,_-; + (1- Z,;) oH. (10.2.3)
Whenever the update gate Zùë° is close to 1, we simply retain the old state. In this case the information from Xùë° is ignored, effectively skipping time step ùë° in the dependency chain. By contrast, whenever Zùë° is close to 0, the new latent state Hùë° approaches the candidate latent state ÀúHùë°. Fig.bubu10.2.3 shows the computational flow after the update gate is in action. In summary, GRUs have the following two distinguishing features:
Concatenate
Gated Recurrent Units (GRU)
379

Hidden state i, Update gate Z, Candidate ¬´ |qanh | --4-- hidden state Input X, FC layer with Elementwise activation function operator 3 Copy [‚Äù Concatenate
tFig. 10.2.3 Computing the hidden state in a GRU model. e Reset gates help capture short-term dependencies in sequences. e Update gates help capture long-term dependencies in sequences. 10.2.4 Implementation from Scratch
To gain a better understanding of the GRU model, let‚Äôs implement it from scratch. Initializing Model Parameters
The first step is to initialize the model parameters. We draw the weights from a Gaussian distribution with standard deviation to be sigma and set the bias to 0. The hyperparameter num_hiddens defines the number of hidden units. We instantiate all weights and biases relating to the update gate, the reset gate, and the candidate hidden state. class GRUScratch(d2l.Module): def __init__(self, num_inputs, num_hiddens, sigma=0.01): super().__init__() self.save_hyperparameters() init_weight = lambda *shape: nn.Parameter(torch.randn(*shape) * sigma) triple = lambda: (init_weight(num_inputs, num_hiddens), init_weight(num_hiddens, num_hiddens), nn.Parameter(torch.zeros(num_hiddens))) self.W_xz, self.W_hz, self.b_z = triple() # Update gate self.W_xr, self.W_hr, self.b_r = triple() # Reset gate self.W_xh, self.W_hh, self.b_h = triple() # Candidate hidden state
Defining the Model
Now we are ready to define the GRU forward computation. Its structure is the same as that of the basic RNN cell, except that the update equations are more complex. @d2l.add_to_class(GRUScratch) def forward(self, inputs, H=None):
tenat
(continues on next page)
Modern Recurrent Neural Networks
380

if H is None: # Initial state with shape: (batch_size, num_hiddens) H = torch.zeros((inputs.shape[1], self.num_hiddens), device=inputs.device) outputs = [] for X in inputs: Z = torch.sigmoid(torch.matmul(X, self.W_xz) + torch.matmul(H, self.W_hz) + self.b_z) R = torch.sigmoid(torch.matmul(X, self.W_xr) + torch.matmul(H, self.W_hr) + self.b_r) H_tilde = torch.tanh(torch.matmul(X, self.W_xh) + torch.matmul(R * H, self.W_hh) + self.b_h) H = Z * H + (1 - Z) * H_tilde outputs.append(H) return outputs, H
Training a language model on The Time Machine dataset works in exactly the same manner as in Section 9.5. data = d2l.TimeMachine(batch_size=1024, num_steps=32) gru = GRUScratch(num_inputs=len(data.vocab), num_hiddens=32) model = d2l.RNNLMScratch(gru, vocab_size=len(data.vocab), lr=4) trainer = d2l.Trainer(max_epochs=50, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
‚Äî train_ppl == val_ppl
10.2.5 Concise Implementation
In high-level APIs, we can directly instantiate a GRU model. This encapsulates all the configuration detail that we made explicit above. class GRU(d2l.RNN): def __init__(self, num_inputs, num_hiddens): d2l.Module.__init__(self) self.save_hyperparameters() self.rnn = nn.GRU(num_inputs, num_hiddens)
(continued from previous page)
Training
Gated Recurrent Units (GRU)
381

ThecodeissignificantlyfasterintrainingasitusescompiledoperatorsratherthanPython. gru = GRU(num_inputs=len(data.vocab), num_hiddens=32) model = d2l.RNNLM(gru, vocab_size=len(data.vocab), lr=4) trainer.fit(model, data)
‚Äî train_ppl =-- val_ppl
After training, we print out the perplexity on the training set and the predicted sequence following the provided prefix. model.predict('it has', 20, data.vocab, d2l.try_gpu())
'it has so it and the time '
10.2.6 Summary
Compared with LSTMs, GRUs achieve similar performance but tend to be lighter com- putationally. Generally, compared with simple RNNs, gated RNNS, just like LSTMs and GRUs, can better capture dependencies for sequences with large time step distances. GRUs contain basic RNNs as their extreme case whenever the reset gate is switched on. They can also skip subsequences by turning on the update gate. 10.2.7 Exercises
1. Assume that we only want to use the input at time step ùë°0 to predict the output at time
step ùë° > ùë°0. What are the best values for the reset and update gates for each time step? 2. Adjust the hyperparameters and analyze their influence on running time, perplexity, and the output sequence. 3. Compare runtime, perplexity, and the output strings for rnn.RNN and rnn.GRU imple- mentations with each other. 4. What happens if you implement only parts of a GRU, e.g., with only a reset gate or only an update gate? 146
Discussions146. Modern Recurrent Neural Networks
382

10.3 Deep Recurrent Neural Networks
|
Up until now, we have focused on defining networks consisting of a sequence input, a single hidden RNN layer, and an output layer. Despite having just one hidden layer between the inputatanytimestepandthecorresponding output, thereisasenseinwhichthesenetworks are deep. Inputs from the first time step can influence the outputs at the final time step ùëá (often 100s or 1000s of steps later). These inputs pass through ùëá applications of the recurrent layer before reaching the final output. However, we often also wish to retain the ability to express complex relationships between the inputs at a given time step and the outputs at that same time step. Thus we often construct RNNs that are deep not only in the time direction but also in the input-to-output direction. This is precisely the notion of depth that we have already encountered in our development of MLPs and deep CNNs. The standard method for building this sort of deep RNN is strikingly simple: we stack the RNNs on top of each other. Given a sequence of length ùëá, the first RNN produces a sequence of outputs, also of length ùëá. These, in turn, constitute the inputs to the next RNN layer. In this short section, we illustrate this design pattern and present a simple example for how to code up such stacked RNNs. Below, in Fig. 10.3.1, we illustrate a deep RNN with ùêø hidden layers. Each hidden state operates on a sequential input and produces a sequential output. Moreover, any RNN cell (white box in Fig. 10.3.1) at each time step depends on both the same layer‚Äôs value at the previous time step and the previous layer‚Äôs value at the same time step. 0, 0, 0, 0, Lt f I HO |?bubua a?bubuf f f f t t t t
tFig. 10.3.1 Architecture of a deep RNN. Formally, suppose that we have a minibatch input X, ‚Ç¨ R‚Äù* (number of examples = n; number of inputs in each example = d) at time step r. At the same time step, let the hidden state of the /"" hidden layer (J = 1,...,L) be Hw ‚Ç¨ R‚Ñ¢h (number of hidden units = h) and the output layer variable be O, ‚Ç¨ R"*4 (number of outputs: g). Setting HO = X,, the hidden state of the /"" hidden layer that uses the activation function ¬¢; is calculated as follows:
HY? = 6H PW +H? We +b(‚Äù), (10.3.1)
Deep Recurrent Neural Networks
383

‚Äûùëô‚Äù
where the weights wi) eR‚Äô and wi? ‚Ç¨ R'‚Ñ¢*", together with the bias bi? e‚Ç¨R!*", are the model parameters of the /'" hidden layer. At the end, the calculation of the output layer is only based on the hidden state of the final ùêøth hidden layer:
Oùë° = H ùë° Whq ‚Äö bq, (10.3.2)
where the weight Whg ‚Ç¨ R'*4 and the bias bg ‚Ç¨ R!*4 are the model parameters of the
output layer. Just as with MLPs, the number of hidden layers ùêø and the number of hidden units ‚Ñé are hy-
perparametersthatwecantune. CommonRNNlayerwidths(‚Ñé)areintherange ‚Äû64,2056‚Äù, and common depths (ùêø) are in the range ‚Äû1,8‚Äù. In addition, we can easily get a deep-gated RNN by replacing the hidden state computation in (10.3.1) with that from an LSTM or a GRU. import torch from torch import nn from d2l import torch as d2l
10.3.1 Implementation from Scratch
To implement a multilayer RNN from scratch, we can treat each layer as an RNNScratch instance with its own learnable parameters. class StackedRNNScratch(d2l.Module): def __init__(self, num_inputs, num_hiddens, num_layers, sigma=0.01): super().__init__() self.save_hyperparameters() self.rnns = nn.Sequential(*[d2l.RNNScratch( num_inputs if i==0 else num_hiddens, num_hiddens, sigma) for i in range(num_layers)])
Themultilayerforwardcomputationsimplyperformsforwardcomputationlayerbylayer. @d2l.add_to_class(StackedRNNScratch) def forward(self, inputs, Hs=None): outputs = inputs if Hs is None: Hs = [None] * self.num_layers for i in range(self.num_layers): outputs, Hs[i] = self.rnns[i](outputs, Hs[i]) outputs = torch.stack(outputs, 0) return outputs, Hs
As an example, we train a deep GRU model on The Time Machine dataset (same as in Section 9.5). To keep things simple we set the number of layers to 2. ‚Äûùëô‚Äù
‚Äûùëô‚Äù
‚Äûùêø‚Äù
Modern Recurrent Neural Networks
384

data = d2l.TimeMachine(batch_size=1024, num_steps=32) rnn_block = StackedRNNScratch(num_inputs=len(data.vocab), num_hiddens=32, num_layers=2) model = d2l.RNNLMScratch(rnn_block, vocab_size=len(data.vocab), lr=2) trainer = d2l.Trainer(max_epochs=100, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
‚Äî train_ppl == val_ppl epoch
10.3.2 Concise Implementation
Fortunately many of the logistical details required to implement multiple layers of an RNN are readily available in high-level APIs. Our concise implementation will use such built- in functionalities. The code generalizes the one we used previously in Section 10.2, let- ting us specify the number of layers explicitly rather than picking the default of only one layer. class GRU(d2l.RNN): #@save """The multilayer GRU model.""" def __init__(self, num_inputs, num_hiddens, num_layers, dropout=0): d2l.Module.__init__(self) self.save_hyperparameters() self.rnn = nn.GRU(num_inputs, num_hiddens, num_layers, dropout=dropout)
The architectural decisions such as choosing hyperparameters are very similar to those of Section 10.2. We pick the same number of inputs and outputs as we have distinct tokens, i.e., vocab_size. The number of hidden units is still 32. The only difference is that we now select a nontrivial number of hidden layers by specifying the value of num_layers. gru = GRU(num_inputs=len(data.vocab), num_hiddens=32, num_layers=2) model = d2l.RNNLM(gru, vocab_size=len(data.vocab), lr=2) trainer.fit(model, data)
model.predict('it has', 20, data.vocab, d2l.try_gpu())
'it has for and the time th'
Bidirectional Recurrent Neural Networks
385

‚Äî train_ppl ‚Äî-- val_ppl
10.3.3 Summary
In deep RNNs, the hidden state information is passed to the next time step of the current layer and the current time step of the next layer. There exist many different flavors of deep RNNs, such as LSTMs, GRUs, or vanilla RNNs. Conveniently, these models are all available as parts of the high-level APIs of deep learning frameworks. Initialization of models requires care. Overall, deep RNNs require considerable amount of work (such as learning rate and clipping) to ensure proper convergence. 10.3.4 Exercises
1. Replace the GRU by an LSTM and compare the accuracy and training speed. 2.bubuIncrease the training data to include multiple books. How low can you go on the per- plexity scale? 3. Would you want to combine sources of different authors when modeling text? Why is this a good idea?bubuWhat could go wrong?bubuDiscussions147. 147
Discussions !47,
10.4 Bidirectional Recurrent Neural Networks
ae
Sofar, ourworkingexampleofasequencelearningtaskhasbeenlanguagemodeling, where we aim to predict the next token given all previous tokens in a sequence. In this scenario, we wish only to condition upon the leftward context, and thus the unidirectional chaining of a standard RNN seems appropriate. However, there are many other sequence learning tasks contexts where it is perfectly fine to condition the prediction at every time step on both the leftward and the rightward context. Consider, for example, part of speech detection. Why shouldn‚Äôt we take the context in both directions into account when assessing the part of speech associated with a given word? Another common task‚Äîoften useful as a pretraining exercise prior to fine-tuning a model on an actual task of interest‚Äîis to mask out random tokens in a text document and then
Modern Recurrent Neural Networks
386

to train a sequence model to predict the values of the missing tokens. Note that depend- ing on what comes after the blank, the likely value of the missing token changes dramati- cally:
e lam __.bubue Tam ___ hungry. e Tam ___ hungry, and I can eat half a pig. In the first sentence ‚Äúhappy‚Äù seems to be a likely candidate. The words ‚Äúnot‚Äù and ‚Äúvery‚Äù seem plausible in the second sentence, but ‚Äúnot‚Äù seems incompatible with the third sen- tences. Fortunately, a simple technique transforms any unidirectional RNN into a bidirectional RNN (Schuster and Paliwal, 1997). We simply implement two unidirectional RNN layers chained together in opposite directions and acting on the same input (Fig. 10.4.1). For the first RNN layer, the first input is x1 and the last input is xùëá, but for the second RNN layer, the first input is xùëá and the last input is x1. To produce the output of this bidirectional RNNlayer, wesimplyconcatenatetogetherthecorrespondingoutputsofthetwounderlying unidirectional RNN layers. ¬© ntL| o ot nt LI Ethel! o Bibel ¬© 7" ‚Äî V3 1 m ¬• al ¬• wh) om |¬ª| KEL = BE ‚Äú
tFig. 10.4.1 Architecture of a bidirectional RNN. Formally for any time step r, we consider a minibatch input X,; ‚Ç¨ R‚Äù*‚Äú (number of exam-
Formally for any time step r, we consider a minibatch input X,; ‚Ç¨ R‚Äù*‚Äú (number of exam- ples = n; number of inputs in each example = d) and let the hidden layer activation function be ¬¢. In the bidirectional architecture, the forward and backward hidden states for this time step are , e‚Ç¨ R"‚Ñ¢‚Äù and H, ‚Ç¨ R"*", respectively, where / is the number of hidden units. The forward and backward hidden state updates are as follows:
H, = (XW) + HW +b), fiL- (b+) & (b) (b) (10.4.1) 1= O(X, Wy + Hai Wi +b, ),
where the weights wi) ‚Ç¨ Re WP ‚Ç¨ Rich Ww?) e RIX", and w) e‚Ç¨ R‚Äô*! and the biases pi?bubu‚Ç¨ R!*" and pb‚Äù? ‚Ç¨ R!*" are all the model parameters. h
h
Next, we concatenate the forward and backward hidden states H, and Hy, to obtain the hidden state H, ‚Ç¨ R‚Äô*2‚Äù for feeding into the output layer. In deep bidirectional RNNs with multiple hidden layers, such information is passed on as input to the next bidirectional layer. >
Bidirectional Recurrent Neural Networks
387

Last, the output layer computes the output O, ‚Ç¨ R‚Äù*% (number of outputs = q):
Oùë° = Hùë°Whq ‚Äö bq. (10.4.2)
Here, the weight matrix Whq ‚Ç¨ R24 and the bias bg ‚Ç¨ R!*4 are the model parameters
of the output layer. While technically, the two directions can have different numbers of hidden units, this design choice is seldom made in practice. We now demonstrate a simple implementation of a bidirectional RNN. import torch from torch import nn from d2l import torch as d2l
10.4.1 Implementation from Scratch
ToimplementabidirectionalRNNfromscratch,wecanincludetwounidirectionalRNNScratch instances with separate learnable parameters. class BiRNNScratch(d2l.Module): def __init__(self, num_inputs, num_hiddens, sigma=0.01): super().__init__() self.save_hyperparameters() self.f_rnn = d2l.RNNScratch(num_inputs, num_hiddens, sigma) self.b_rnn = d2l.RNNScratch(num_inputs, num_hiddens, sigma) self.num_hiddens *= 2 # The output dimension will be doubled
States of forward and backward RNNs are updated separately, while outputs of these two RNNs are concatenated. @d2l.add_to_class(BiRNNScratch) def forward(self, inputs, Hs=None): f_H, b_H = Hs if Hs is not None else (None, None) f_outputs, f_H = self.f_rnn(inputs, f_H) b_outputs, b_H = self.b_rnn(reversed(inputs), b_H) outputs = [torch.cat((f, b), -1) for f, b in zip( f_outputs, reversed(b_outputs))] return outputs, (f_H, b_H)
10.4.2 Concise Implementation
Using the high-level APIs, we can implement bidirectional RNNs more concisely. Here we take a GRU model as an example. class BiGRU(d2l.RNN): def __init__(self, num_inputs, num_hiddens): d2l.Module.__init__(self) self.save_hyperparameters() self.rnn = nn.GRU(num_inputs, num_hiddens, bidirectional=True) self.num_hiddens *= 2
Modern Recurrent Neural Networks
388

10.4.3 Summary
In bidirectional RNNs, the hidden state for each time step is simultaneously determined by the data prior to and after the current time step. Bidirectional RNNs are mostly use- ful for sequence encoding and the estimation of observations given bidirectional context. Bidirectional RNNs are very costly to train due to long gradient chains. 10.4.4 Exercises
1. If the different directions use a different number of hidden units, how will the shape of Hùë° change? 2. Design a bidirectional RNN with multiple hidden layers. 3.bubuPolysemy is common in natural languages. For example, the word ‚Äúbank‚Äù has different meanings in contexts ‚Äúi went to the bank to deposit cash‚Äù and ‚Äúi went to the bank to sit down‚Äù. How can we design a neural network model such that given a context sequence and a word, a vector representation of the word in the correct context will be returned? What type of neural architectures is preferred for handling polysemy? Discussions148. 148
10.5 Machine Translation and the Dataset
ae
Among the major breakthroughs that prompted widespread interest in modern RNNs was a major advance in the applied field of statistical machine translation. Here, the model is presented with a sentence in one language and must predict the corresponding sentence in another. Note that here the sentences may be of different lengths, and that corresponding words in the two sentences may not occur in the same order, owing to differences in the two language‚Äôs grammatical structure. Many problems have this flavor of mapping between two such ‚Äúunaligned‚Äù sequences. Examples include mapping from dialog prompts to replies or from questions to answers. Broadly, such problems are called sequence-to-sequence (seq2seq) problems and they are our focus for both the remainder of this chapter and much of Chapter 11. In this section, we introduce the machine translation problem and an example dataset that we will use in the subsequent examples. For decades, statistical formulations of translation between languages had been popular (Brown et al., 1990, Brown et al., 1988), even before researchers got neural network approaches working (methods were often lumped together under the term neural machine translation). First we will need some new code to process our data. Unlike the language modeling that we saw in Section 9.3, here each example consists of two separate text sequences, one in the source language and another (the translation) in the target language. The following code snippets will show how to load the preprocessed data into minibatches for training. Machine Translation and the Dataset
389

import os import torch from d2l import torch as d2l
10.5.1 Downloading and Preprocessing the Dataset
To begin, we download an English‚ÄìFrench dataset that consists of bilingual sentence pairs from the Tatoeba Project 149 . Each line in the dataset is a tab-delimited pair consisting of an English text sequence (the source) and the translated French text sequence (the tar- get). Note that each text sequence can be just one sentence, or a paragraph of multiple sentences. 149

class MTFraEng(d2l.DataModule): #@save """The English-French dataset.""" def _download(self): d2l.extract(d2l.download( d2l.DATA_URL+'fra-eng.zip', self.root, '94646ad1522d915e7b0f9296181140edcf86a4f5')) with open(self.root + '/fra-eng/fra.txt', encoding='utf-8') as f: return f.read()
data = MTFraEng() raw_text = data._download() print(raw_text[:75])
Downloading ../data/fra-eng.zip from http://d2l-data.s3-accelerate.amazonaws. ‚Ü©!com/fra-eng.zip...bubuGo. Va ! Hi. Salut ! Run! Cours ! Run! Courez ! Who? Qui ? Wow!bubu√áa alors ! After downloading the dataset, we proceed with several preprocessing steps for the raw text data. For instance, we replace non-breaking space with space, convert uppercase letters to lowercase ones, and insert space between words and punctuation marks. @d2l.add_to_class(MTFraEng) #@save def _preprocess(self, text): # Replace non-breaking space with space text = text.replace('\u202f', ' ').replace('\xa0', ' ') # Insert space between words and punctuation marks no_space = lambda char, prev_char: char in ',.!?' and prev_char != ' ' out = [' ' + char if i > 0 and no_space(char, text[i - 1]) else char for i, char in enumerate(text.lower())] return ''.join(out)
Modern Recurrent Neural Networks
390

text = data._preprocess(raw_text) print(text[:80])
go . va !bubuhi . salut ! run ! cours ! run ! courez ! who ? qui ? wow !bubu√ßa alors ! 10.5.2 Tokenization
Unlike the character-level tokenization in Section 9.3, for machine translation we prefer word-level tokenization here (today‚Äôs state-of-the-art models use more complex tokeniza- tion techniques). The following _tokenize method tokenizes the first max_examples text sequence pairs, where each token is either a word or a punctuation mark. We append the special ‚Äú<eos>‚Äù token to the end of every sequence to indicate the end of the sequence. When a model is predicting by generating a sequence token after token, the generation of the ‚Äú<eos>‚Äù token can suggest that the output sequence is complete. In the end, the method below returns two lists of token lists: src and tgt. Specifically, src[i] is a list of tokens from the ùëñth text sequence in the source language (English here) and tgt[i] is that in the target language (French here). @d2l.add_to_class(MTFraEng) #@save def _tokenize(self, text, max_examples=None): src, tgt = [], [] for i, line in enumerate(text.split('\n')): if max_examples and i > max_examples: break parts = line.split('\t') if len(parts) == 2: # Skip empty tokens src.append([t for t in f'{parts[0]} <eos>'.split(' ') if t]) tgt.append([t for t in f'{parts[1]} <eos>'.split(' ') if t]) return src, tgt
src, tgt = data._tokenize(text) src[:6], tgt[:6]
([['go', '.', '<eos>'], ['hi', '.', '<eos>'], ['run', '!', '<eos>'], ['run', '!', '<eos>'], ['who', '?', '<eos>'], ['wow', '!', '<eos>']], [['va', '!', '<eos>'], ['salut', '!', '<eos>'], ['cours', '!', '<eos>'], ['courez', '!', '<eos>'],
(continues on next page)
Machine Translation and the Dataset
391

['qui', '?', '<eos>'], ['√ßa', 'alors', '!', '<eos>']])
Let‚Äôs plot the histogram of the number of tokens per text sequence. In this simple English‚Äì French dataset, most of the text sequences have fewer than 20 tokens. #@save def show_list_len_pair_hist(legend, xlabel, ylabel, xlist, ylist): """Plot the histogram for list length pairs.""" d2l.set_figsize() _, _, patches = d2l.plt.hist( [[len(l) for l in xlist], [len(l) for l in ylist]]) d2l.plt.xlabel(xlabel) d2l.plt.ylabel(ylabel) for patch in patches[1].patches: patch.set_hatch('/') d2l.plt.legend(legend)
show_list_len_pair_hist(['source', 'target'], '# tokens per sequence', 'count', src, tgt);
100000 Mm source ‚Ñ¢@~ target 80000 60000 40000 20000 te) 20 40 60 # tokens per sequence
¬ß 3 &
10.5.3 Loading Sequences of Fixed Length
Recall that in language modeling each example sequence, either a segment of one sentence or a span over multiple sentences, had a fixed length. This was specified by the num_steps (number of time steps or tokens) argument from Section 9.3.bubuIn machine translation, each example is a pair of source and target text sequences, where the two text sequences may have different lengths. For computational efficiency, we can still process a minibatch of text sequences at one time bytruncationandpadding. Supposethatevery sequenceinthesameminibatchshouldhave the same length num_steps. If a text sequence has fewer than num_steps tokens, we will keep appending the special ‚Äú<pad>‚Äù token to its end until its length reaches num_steps. Otherwise, we will truncate the text sequence by only taking its first num_steps tokens and discarding the remaining. In this way, every text sequence will have the same length to be loaded in minibatches of the same shape. Furthermore, we also record length of the source
(continued from previous page)
Modern Recurrent Neural Networks
392

sequence excluding padding tokens. This information will be needed by some models that we will cover later. Since the machine translation dataset consists of pairs of languages, we can build two vo- cabularies for both the source language and the target language separately. With word-level tokenization, the vocabulary size will be significantly larger than that using character-level tokenization. To alleviate this, here we treat infrequent tokens that appear less than twice as the same unknown (‚Äú<unk>‚Äù) token. As we will explain later (Fig. 10.7.1), when train- ing with target sequences, the decoder output (label tokens) can be the same decoder input (target tokens), shifted by one token; and the special beginning-of-sequence ‚Äú<bos>‚Äù token will be used as the first input token for predicting the target sequence (Fig. 10.7.3). @d2l.add_to_class(MTFraEng)
#@save
def __init__(self, batch_size, num_steps=9, num_train=512, num_val=128): super(MTFraEng, self).__init__() self.save_hyperparameters() self.arrays, self.src_vocab, self.tgt_vocab = self._build_arrays( self._download())
@d2l.add_to_class(MTFraEng)
#@save
def _build_arrays(self, raw_text, src_vocab=None, tgt_vocab=None): def _build_array(sentences, vocab, is_tgt=False): pad_or_trim = lambda seq, t: ( seq[:t] if len(seq) > t else seq + ['<pad>'] * (t - len(seq))) sentences = [pad_or_trim(s, self.num_steps) for s in sentences] if is_tgt: sentences = [['<bos>'] + s for s in sentences] if vocab is None: vocab = d2l.Vocab(sentences, min_freq=2) array = torch.tensor([vocab[s] for s in sentences]) valid_len = (array != vocab['<pad>']).type(torch.int32).sum(1) return array, vocab, valid_len src, tgt = self._tokenize(self._preprocess(raw_text), self.num_train + self.num_val) src_array, src_vocab, src_valid_len = _build_array(src, src_vocab) tgt_array, tgt_vocab, _ = _build_array(tgt, tgt_vocab, True) return ((src_array, tgt_array[:,:-1], src_valid_len, tgt_array[:,1:]), src_vocab, tgt_vocab)
10.5.4 Reading the Dataset
Finally, we define the get_dataloader method to return the data iterator. @d2l.add_to_class(MTFraEng) #@save def get_dataloader(self, train): idx = slice(0, self.num_train) if train else slice(self.num_train, None) return self.get_tensorloader(self.arrays, train, idx)
Let‚Äôs read the first minibatch from the English‚ÄìFrench dataset. Machine Translation and the Dataset
393

data = MTFraEng(batch_size=3) src, tgt, src_valid_len, label = next(iter(data.train_dataloader())) print('source:', src.type(torch.int32)) print('decoder input:', tgt.type(torch.int32)) print('source len excluding pad:', src_valid_len.type(torch.int32)) print('label:', label.type(torch.int32))
source: tensor([[117, 182, 0, 3, 4, 4, 4, 4, 4], [ 62, 72, 2, 3, 4, 4, 4, 4, 4], [ 57, 124, 0, 3, 4, 4, 4, 4, 4]], dtype=torch.int32) decoder input: tensor([[ 3, 37, 100, 58, 160, 0, 4, 5, 5], [ 3, 6, 2, 4, 5, 5, 5, 5, 5], [ 3, 180, 0, 4, 5, 5, 5, 5, 5]], dtype=torch.int32) source len excluding pad: tensor([4, 4, 4], dtype=torch.int32) label: tensor([[ 37, 100, 58, 160, 0, 4, 5, 5, 5], [ 6, 2, 4, 5, 5, 5, 5, 5, 5], [180, 0, 4, 5, 5, 5, 5, 5, 5]], dtype=torch.int32)
We show a pair of source and target sequences processed by the above _build_arrays
method (in the string format). @d2l.add_to_class(MTFraEng) #@save def build(self, src_sentences, tgt_sentences): raw_text = '\n'.join([src + '\t' + tgt for src, tgt in zip( src_sentences, tgt_sentences)]) arrays, _, _ = self._build_arrays( raw_text, self.src_vocab, self.tgt_vocab) return arrays
src, tgt, _, _ = data.build(['hi .'], ['salut .']) print('source:', data.src_vocab.to_tokens(src[0].type(torch.int32))) print('target:', data.tgt_vocab.to_tokens(tgt[0].type(torch.int32)))
source: ['hi', '.', '<eos>', '<pad>', '<pad>', '<pad>', '<pad>', '<pad>', ' ‚Ü©!<pad>'] target: ['<bos>', 'salut', '.', '<eos>', '<pad>', '<pad>', '<pad>', '<pad>', ' ‚Ü©!<pad>']
10.5.5 Summary
In natural language processing, machine translation refers to the task of automatically map- ping from a sequence representing a string of text in a source language to a string represent- ing a plausible translation in a target language. Using word-level tokenization, the vocab- ulary size will be significantly larger than that using character-level tokenization, but the sequence lengths will be much shorter.bubuTo mitigate the large vocabulary size, we can treat infrequent tokens as some ‚Äúunknown‚Äù token. We can truncate and pad text sequences so that all of them will have the same length to be loaded in minibatches. Modern implemen-
Modern Recurrent Neural Networks
394

tations often bucket sequences with similar lengths to avoid wasting excessive computation on padding. 10.5.6 Exercises
1.bubuTry different values of the max_examples argument in the _tokenize method. How does this affect the vocabulary sizes of the source language and the target language?bubu2. Text in some languages such as Chinese and Japanese does not have word boundary indicators (e.g., space). Is word-level tokenization still a good idea for such cases? Why or why not?bubuDiscussions150. 150
10.6 The Encoder‚ÄîDecoder Architecture
a
In general sequence-to-sequence problems like machine translation (Section 10.5), inputs and outputs are of varying lengths that are unaligned. The standard approach to handling this sort of data is to design an encoder‚Äìdecoder architecture (Fig. 10.6.1) consisting of two major components: an encoder that takes a variable-length sequence as input, and a decoder that acts as a conditional language model, taking in the encoded input and the leftwards context of the target sequence and predicting the subsequent token in the target sequence. Input [>| Encoder |¬ª) State |-¬ª| Decoder [>] Output
tFig. 10.6.1
The encoder‚Äìdecoder architecture. Let‚Äôs take machine translation from English to French as an example. Given an input sequence in English: ‚ÄúThey‚Äù, ‚Äúare‚Äù, ‚Äúwatching‚Äù, ‚Äú.‚Äù, this encoder‚Äìdecoder architecture first encodes the variable-length input into a state, then decodes the state to generate the translated sequence, token by token, as output: ‚ÄúIls‚Äù, ‚Äúregardent‚Äù, ‚Äú.‚Äù. Since the encoder‚Äì decoder architecture forms the basis of different sequence-to-sequence models in subse- quent sections, this section will convert this architecture into an interface that will be im- plemented later. from torch import nn from d2l import torch as d2l
10.6.1 Encoder
In the encoder interface, we just specify that the encoder takes variable-length sequences as input X. The implementation will be provided by any model that inherits this base Encoder class. The Encoder‚ÄîDecoder Architecture
395

class Encoder(nn.Module): #@save """The base encoder interface for the encoder--decoder architecture.""" def __init__(self): super().__init__()
# Later there can be additional arguments (e.g., length excluding padding) def forward(self, X, *args): raise NotImplementedError
10.6.2 Decoder
In the following decoder interface, we add an additional init_state method to convert the encoder output (enc_all_outputs) into the encoded state. Note that this step may require extra inputs, such as the valid length of the input, which was explained in Section 10.5. To generate a variable-length sequence token by token, every time the decoder may map an input (e.g., the generated token at the previous time step) and the encoded state into an output token at the current time step. class Decoder(nn.Module): #@save """The base decoder interface for the encoder--decoder architecture.""" def __init__(self): super().__init__() # Later there can be additional arguments (e.g., length excluding padding) def init_state(self, enc_all_outputs, *args): raise NotImplementedError def forward(self, X, state): raise NotImplementedError
10.6.3 Putting the Encoder and Decoder Together
In the forward propagation, the output of the encoder is used to produce the encoded state, and this state will be further used by the decoder as one of its input. class EncoderDecoder(d2l.Classifier): #@save """The base class for the encoder--decoder architecture.""" def __init__(self, encoder, decoder): super().__init__() self.encoder = encoder self.decoder = decoder def forward(self, enc_X, dec_X, *args): enc_all_outputs = self.encoder(enc_X, *args) dec_state = self.decoder.init_state(enc_all_outputs, *args) # Return decoder output only return self.decoder(dec_X, dec_state)[0]
In the next section, we will see how to apply RNNs to design sequence-to-sequence models based on this encoder‚Äìdecoder architecture. Modern Recurrent Neural Networks
396

10.6.4 Summary
Encoder-decoder architectures can handle inputs and outputs that both consist of variable- length sequences and thus are suitable for sequence-to-sequence problems such as machine translation. The encoder takes a variable-length sequence as input and transforms it into a state with a fixed shape. The decoder maps the encoded state of a fixed shape to a variable- length sequence. 10.6.5 Exercises
1. Suppose that we use neural networks to implement the encoder‚Äìdecoder architecture. Do the encoder and the decoder have to be the same type of neural network? 2. Besides machine translation, can you think of another application where the encoder‚Äì decoder architecture can be applied? Discussions151. 151 
10.7 Sequence-to-Sequence Learning for Machine Translation

In so-called sequence-to-sequence problems such as machine translation (as discussed in Section10.5),whereinputsandoutputseachconsistofvariable-lengthunalignedsequences, we generally rely on encoder‚Äìdecoder architectures (Section 10.6). In this section, we will demonstrate the application of an encoder‚Äìdecoder architecture, where both the encoder and decoder are implemented as RNNs, to the task of machine translation (Cho et al., 2014, Sutskever et al., 2014). Here, the encoder RNN will take a variable-length sequence as input and transform it into a fixed-shape hidden state. Later, in Chapter 11, we will introduce attention mechanisms, which allow us to access encoded inputs without having to compress the entire input into a single fixed-length representation. Then to generate the output sequence, one token at a time, the decoder model, consisting of a separate RNN, will predict each successive target token given both the input sequence and the preceding tokens in the output. During training, the decoder will typically be con- ditioned upon the preceding tokens in the official ‚Äúground truth‚Äù label. However, at test time, we will want to condition each output of the decoder on the tokens already predicted. Note that if we ignore the encoder, the decoder in a sequence-to-sequence architecture be- haves just like a normal language model. Fig. 10.7.1 illustrates how to use two RNNs for sequence-to-sequence learning in machine translation. In Fig. 10.7.1, the special ‚Äú<eos>‚Äù token marks the end of the sequence. Our model can stop making predictions once this token is generated. At the initial time step of the RNN decoder, there are two special design decisions to be aware of: First, we begin every input
Sequence-to-Sequence Learning for Machine Translation
397

Encoder Decoder lls regardent <eos> Lf fH | {Lo t t t + + + t t t They are watching <eos> 7 7 7 <bos> lis regardent
tFig. 10.7.1
Sequence-to-sequence learning with an RNN encoder and an RNN decoder. with a special beginning-of-sequence ‚Äú<bos>‚Äù token. Second, we may feed the final hidden state of the encoder into the decoder at every single decoding time step (Cho et al., 2014). In some other designs, such as that of Sutskever et al. (2014), the final hidden state of the RNN encoder is used to initiate the hidden state of the decoder only at the first decoding step. import collections import math import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
10.7.1 Teacher Forcing
While running the encoder on the input sequence is relatively straightforward, handling the input and output of the decoder requires more care. The most common approach is sometimes called teacher forcing. Here, the original target sequence (token labels) is fed into the decoder as input. More concretely, the special beginning-of-sequence token and the original target sequence, excluding the final token, are concatenated as input to the decoder, whilethedecoderoutput(labelsfortraining)istheoriginaltargetsequence, shifted by one token: ‚Äú<bos>‚Äù, ‚ÄúIls‚Äù, ‚Äúregardent‚Äù, ‚Äú.‚Äù ! ‚ÄúIls‚Äù, ‚Äúregardent‚Äù, ‚Äú.‚Äù, ‚Äú<eos>‚Äù (Fig.bubu10.7.1). Our implementation in Section 10.5.3 prepared training data for teacher forcing, where shifting tokens for self-supervised learning is similar to the training of language models in Section 9.3. An alternative approach is to feed the predicted token from the previous time step as the current input to the decoder. In the following, we explain the design depicted in Fig.bubu10.7.1 in greater detail. We will train this model for machine translation on the English‚ÄìFrench dataset as introduced in Section 10.5. 10.7.2 Encoder
Recall that the encoder transforms an input sequence of variable length into a fixed-shape context variable c (see Fig. 10.7.1). Considerasinglesequenceexample(batchsize1). Supposetheinputsequenceisùë•1, .bubu.bubu.,ùë•ùëá,
such that ùë•ùë° is the ùë°th token. At time step ùë°, the RNN transforms the input feature vector xùë°
Modern Recurrent Neural Networks
398

for x; and the hidden state h;_; from the previous time step into the current hidden state h,. We can use a function ùëì to express the transformation of the RNN‚Äôs recurrent layer:
hy = f(x, hy-1). (10.7.1)
In general, the encoder transforms the hidden states at all time steps into a context variable through a customized function ùëû:
c = ùëû‚Äûh1, . .bubu.,hùëá‚Äù.bubu(10.7.2)
For example, in Fig. 10.7.1, the context variable is just the hidden state hùëá correspond- ing to the encoder RNN‚Äôs representation after processing the final token of the input se- quence. Inthisexample, wehaveusedaunidirectionalRNNtodesigntheencoder, wherethehidden state only depends on the input subsequence at and before the time step of the hidden state. We can also construct encoders using bidirectional RNNs. In this case, a hidden state depends on the subsequence beforeand after the time step (including the inputat the current time step), which encodes the information of the entire sequence. Now let‚Äôs implement the RNN encoder. Note that we use an embedding layer to obtain the feature vector for each token in the input sequence. The weight of an embedding layer is a matrix, where the number of rows corresponds to the size of the input vocab- ulary (vocab_size) and number of columns corresponds to the feature vector‚Äôs dimension (embed_size). For any input token indexùëñ, the embedding layer fetches theùëñth row (starting from 0) of the weight matrix to return its feature vector. Here we implement the encoder with a multilayer GRU. def init_seq2seq(module): #@save """Initialize weights for sequence-to-sequence learning.""" if type(module) == nn.Linear: nn.init.xavier_uniform_(module.weight) if type(module) == nn.GRU: for param in module._flat_weights_names: if "weight" in param: nn.init.xavier_uniform_(module._parameters[param])
class Seq2SeqEncoder(d2l.Encoder): #@save
"""The RNN encoder for sequence-to-sequence learning.""" def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, dropout=0): super().__init__() self.embedding = nn.Embedding(vocab_size, embed_size) self.rnn = d2l.GRU(embed_size, num_hiddens, num_layers, dropout) self.apply(init_seq2seq) def forward(self, X, *args): # X shape: (batch_size, num_steps) embs = self.embedding(X.t().type(torch.int64)) # embs shape: (num_steps, batch_size, embed_size) outputs, state = self.rnn(embs)
(continues on next page)
Sequence-to-Sequence Learning for Machine Translation
399

# outputs shape: (num_steps, batch_size, num_hiddens) # state shape: (num_layers, batch_size, num_hiddens) return outputs, state
Let‚Äôs use a concrete example to illustrate the above encoder implementation. Below, we instantiateatwo-layerGRUencoderwhosenumberofhiddenunitsis16. Givenaminibatch of sequence inputs X (batch size = 4; number of time steps = 9), the hidden states of the final layer at all the time steps (enc_outputs returned by the encoder‚Äôs recurrent layers) are a tensor of shape (number of time steps, batch size, number of hidden units). vocab_size, embed_size, num_hiddens, num_layers = 10, 8, 16, 2 batch_size, num_steps = 4, 9 encoder = Seq2SeqEncoder(vocab_size, embed_size, num_hiddens, num_layers) X = torch.zeros((batch_size, num_steps)) enc_outputs, enc_state = encoder(X) d2l.check_shape(enc_outputs, (num_steps, batch_size, num_hiddens))
Since we are using a GRU here, the shape of the multilayer hidden states at the final time step is (number of hidden layers, batch size, number of hidden units). d2l.check_shape(enc_state, (num_layers, batch_size, num_hiddens))
10.7.3 Decoder
Givenatargetoutputsequence ùë¶1, ùë¶2, . . ., ùë¶ùëá0 foreachtimestepùë°0 (weuseùë°0 todifferentiate
from the input sequence time steps), the decoder assigns a predicted probability to each possible token occurring at step ùë¶ùë°0‚Äö1 conditioned upon the previous tokens in the target ùë¶1, . .bubu., ùë¶ùë°0 and the context variable c, i.e., ùëÉ‚Äûùë¶ùë°0‚Äö1 j ùë¶1, . .bubu., ùë¶ùë°0,c‚Äù. To predict the subsequent token ùë°0 ‚Äö 1 in the target sequence, the RNN decoder takes the
To predict the subsequent token 7‚Äô + 1 in the target sequence, the RNN decoder takes the previous step‚Äôs target token y;‚Äô, the hidden RNN state from the previous time step s;‚Äô-1, and the context variable c as its input, and transforms them into the hidden state s,‚Äô at the current time step. We can use a function g to express the transformation of the decoder‚Äôs hidden layer:
Sy = 8(Yr-1,‚Ç¨,Sy'-1). (10.7.3)
After obtaining the hidden state of the decoder, we can use an output layer and the softmax operation to compute the predictive distribution ùëù‚Äûùë¶ùë°0‚Äö1 j ùë¶1, . .bubu., ùë¶ùë°0,c‚Äù over the subse- quent output token ùë°0 ‚Äö 1.bubuFollowing Fig. 10.7.1, when implementing the decoder as follows, we directly use the hid- den state at the final time step of the encoder to initialize the hidden state of the decoder. This requires that the RNN encoder and the RNN decoder have the same number of lay- ers and hidden units. To further incorporate the encoded input sequence information, the context variable is concatenated with the decoder input at all the time steps. To predict the
(continued from previous page)
Modern Recurrent Neural Networks
400

probability distribution of the output token, we use a fully connected layer to transform the hidden state at the final layer of the RNN decoder. class Seq2SeqDecoder(d2l.Decoder): """The RNN decoder for sequence to sequence learning.""" def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, dropout=0): super().__init__() self.embedding = nn.Embedding(vocab_size, embed_size) self.rnn = d2l.GRU(embed_size+num_hiddens, num_hiddens, num_layers, dropout) self.dense = nn.LazyLinear(vocab_size) self.apply(init_seq2seq) def init_state(self, enc_all_outputs, *args): return enc_all_outputs def forward(self, X, state): # X shape: (batch_size, num_steps) # embs shape: (num_steps, batch_size, embed_size) embs = self.embedding(X.t().type(torch.int32)) enc_output, hidden_state = state # context shape: (batch_size, num_hiddens) context = enc_output[-1] # Broadcast context to (num_steps, batch_size, num_hiddens) context = context.repeat(embs.shape[0], 1, 1) # Concat at the feature dimension embs_and_context = torch.cat((embs, context), -1) outputs, hidden_state = self.rnn(embs_and_context, hidden_state) outputs = self.dense(outputs).swapaxes(0, 1) # outputs shape: (batch_size, num_steps, vocab_size) # hidden_state shape: (num_layers, batch_size, num_hiddens)
return outputs, [enc_output, hidden_state]
To illustrate the implemented decoder, below we instantiate it with the same hyperparam- eters from the aforementioned encoder. As we can see, the output shape of the decoder becomes (batch size, number of time steps, vocabulary size), where the final dimension of the tensor stores the predicted token distribution. decoder = Seq2SeqDecoder(vocab_size, embed_size, num_hiddens, num_layers) state = decoder.init_state(encoder(X)) dec_outputs, state = decoder(X, state) d2l.check_shape(dec_outputs, (batch_size, num_steps, vocab_size)) d2l.check_shape(state[1], (num_layers, batch_size, num_hiddens))
ThelayersintheaboveRNNencoder‚ÄìdecodermodelaresummarizedinFig.10.7.2. 10.7.4 Encoder‚ÄìDecoder for Sequence-to-Sequence Learning
Putting it all together in code yields the following:
Sequence-to-Sequence Learning for Machine Translation
401

Encoder Decoder Fc nx Recurrent [|‚Äî‚Äî+| =__ xn ‚Äî_ ‚Äî_ seces Targets
tFig. 10.7.2
Layers in an RNN encoder‚Äìdecoder model. class Seq2Seq(d2l.EncoderDecoder): #@save """The RNN encoder--decoder for sequence to sequence learning.""" def __init__(self, encoder, decoder, tgt_pad, lr): super().__init__(encoder, decoder) self.save_hyperparameters() def validation_step(self, batch): Y_hat = self(*batch[:-1]) self.plot('loss', self.loss(Y_hat, batch[-1]), train=False) def configure_optimizers(self): # Adam optimizer is used here return torch.optim.Adam(self.parameters(), lr=self.lr)
10.7.5 Loss Function with Masking
At each time step, the decoder predicts a probability distribution for the output tokens. As with language modeling, we can apply softmax to obtain the distribution and calculate the cross-entropy loss for optimization. Recall from Section 10.5 that the special padding tokens are appended to the end of sequences and so sequences of varying lengths can be efficiently loaded in minibatches of the same shape. However, prediction of padding tokens should be excluded from loss calculations. To this end, we can mask irrelevant entries with zero values so that multiplication of any irrelevant prediction with zero equates to zero. @d2l.add_to_class(Seq2Seq) def loss(self, Y_hat, Y): l = super(Seq2Seq, self).loss(Y_hat, Y, averaged=False) mask = (Y.reshape(-1) != self.tgt_pad).type(torch.float32) return (l * mask).sum() / mask.sum()
10.7.6 Training
Now we can create and train an RNN encoder‚Äìdecoder model for sequence-to-sequence learning on the machine translation dataset. data = d2l.MTFraEng(batch_size=128) embed_size, num_hiddens, num_layers, dropout = 256, 256, 2, 0.2
(continues on next page)
Modern Recurrent Neural Networks
402

encoder = Seq2SeqEncoder(
len(data.src_vocab), embed_size, num_hiddens, num_layers, dropout) decoder = Seq2SeqDecoder(
len(data.tgt_vocab), embed_size, num_hiddens, num_layers, dropout) model = Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['<pad>'], lr=0.005)
trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
‚Äî train_loss 4 =-- val_loss yy ‚Äî‚Äî 3 ‚Äò. en ene Nee 0 5 10 15 20 25 30 epoch
10.7.7 Prediction
To predict the output sequence at each step, the predicted token from the previous time step is fed into the decoder as an input. One simple strategy is to sample whichever token that has been assigned by the decoder the highest probability when predicting at each step. As in training, at the initial time step the beginning-of-sequence (‚Äú<bos>‚Äù) token is fed into the decoder. This prediction process is illustrated in Fig. 10.7.3. When the end-of-sequence (‚Äú<eos>‚Äù) token is predicted, the prediction of the output sequence is complete. Encoder Decoder Ils regardent <eos> Lt RP LP t t LU t t They are watching <eos> <bos>
tFig. 10.7.3
Predicting the output sequence token by token using an RNN encoder‚Äìdecoder. In the next section, we will introduce more sophisticated strategies based on beam search (Section 10.8). @d2l.add_to_class(d2l.EncoderDecoder) #@save def predict_step(self, batch, device, num_steps, save_attention_weights=False): batch = [a.to(device) for a in batch] src, tgt, src_valid_len, _ = batch enc_all_outputs = self.encoder(src, src_valid_len) dec_state = self.decoder.init_state(enc_all_outputs, src_valid_len)
(continued from previous page)
(continues on next page)
Sequence-to-Sequence Learning for Machine Translation
403

outputs, attention_weights = [tgt[:, (0)].unsqueeze(1), ], [] for _ in range(num_steps): Y, dec_state = self.decoder(outputs[-1], dec_state) outputs.append(Y.argmax(2)) # Save attention weights (to be covered later) if save_attention_weights: attention_weights.append(self.decoder.attention_weights) return torch.cat(outputs[1:], 1), attention_weights
10.7.8 Evaluation of Predicted Sequences
We can evaluate a predicted sequence by comparing it with the target sequence (the ground truth). But what precisely is the appropriate measure for comparing similarity between two sequences?bubuBilingual Evaluation Understudy (BLEU), though originally proposed for evaluating ma- chine translation results (Papineni et al., 2002), has been extensively used in measuring the quality of output sequences for different applications. In principle, for any ùëõ-gram (Section 9.3.1) in the predicted sequence, BLEU evaluates whether this ùëõ-gram appears in the target sequence. Denote by ùëùùëõ the precision of an ùëõ-gram, defined as the ratio of the number of matched
Denote by p,, the precision of an n-gram, defined as the ratio of the number of matched n-grams in the predicted and target sequences to the number of n-grams in the predicted sequence. To explain, given a target sequence A, B, C, D, E, F, and a predicted sequence A, B, B, C, D, we have p; = 4/5, p2 = 3/4, p3 = 1/3, and p4 = 0. Now let lemaber and lenprea be the numbers of tokens in the target sequence and the predicted sequence, respectively. Then, BLEU is defined as
k len, n exp (min (0 1- =) | px‚Äù ; (10.7.4) lenprea |} 1}
where ùëò is the longest ùëõ-gram for matching. Based on the definition of BLEU in (10.7.4), whenever the predicted sequence is the same as the target sequence, BLEU is 1. Moreover, since matching longer n-grams is more diffi- cult, BLEU assigns a greater weight when a longer n-gram has high precision. Specifically, when py, is fixed, DE 2" increases as n grows (the original paper uses pil "). Furthermore, since predicting shorter sequences tends to yield a higher p, value, the coefficient before the multiplication term in (10.7.4) penalizes shorter predicted sequences. For example, when k = 2, given the target sequence A, B, C, D, E, F and the predicted sequence A, B, although p; = p2 = 1, the penalty factor exp(1 ‚Äî 6/2) = 0.14 lowers the BLEU. We implement the BLEU measure as follows. def bleu(pred_seq, label_seq, k): #@save """Compute the BLEU.""" pred_tokens, label_tokens = pred_seq.split(' '), label_seq.split(' ')
(continued from previous page)
(continues on next page)
Modern Recurrent Neural Networks
404

len_pred, len_label = len(pred_tokens), len(label_tokens) score = math.exp(min(0, 1 - len_label / len_pred)) for n in range(1, min(k, len_pred) + 1): num_matches, label_subs = 0, collections.defaultdict(int) for i in range(len_label - n + 1): label_subs[' '.join(label_tokens[i: i + n])] += 1 for i in range(len_pred - n + 1): if label_subs[' '.join(pred_tokens[i: i + n])] > 0: num_matches += 1 label_subs[' '.join(pred_tokens[i: i + n])] -= 1 score *= math.pow(num_matches / (len_pred - n + 1), math.pow(0.5, n)) return score
In the end, we use the trained RNN encoder‚Äìdecoder to translate a few English sentences into French and compute the BLEU of the results. engs = ['go .', 'i lost .', 'he\'s calm .', 'i\'m home .'] fras = ['va !', 'j\'ai perdu .', 'il est calme .', 'je suis chez moi .'] preds, _ = model.predict_step( data.build(engs, fras), d2l.try_gpu(), data.num_steps) for en, fr, p in zip(engs, fras, preds): translation = [] for token in data.tgt_vocab.to_tokens(p): if token == '<eos>': break translation.append(token) print(f'{en} => {translation}, bleu,' f'{bleu(" ".join(translation), fr, k=2):.3f}')
go . => ['va', '!'], bleu,1.000 i lost . => ["j'ai", 'perdu', '.'], bleu,1.000 he's calm . => ['elle', 'court', '.'], bleu,0.000 i'm home . => ['je', 'suis', 'chez', 'moi', '.'], bleu,1.000
10.7.9 Summary
Following the design of the encoder‚Äìdecoder architecture, we can use two RNNs to design a model for sequence-to-sequence learning. In encoder‚Äìdecoder training, the teacher forc- ing approach feeds original output sequences (in contrast to predictions) into the decoder. When implementing the encoder and the decoder, we can use multilayer RNNs. We can use masks to filter out irrelevant computations, such as when calculating the loss. For eval- uating output sequences, BLEU is a popular measure that matches ùëõ-grams between the predicted sequence and the target sequence. 10.7.10 Exercises
1.bubuCan you adjust the hyperparameters to improve the translation results? 2. Rerun the experiment without using masks in the loss calculation. What results do you observe?bubuWhy?bubu(continued from previous page)
405

3. If the encoder and the decoder differ in the number of layers or the number of hidden units, how can we initialize the hidden state of the decoder? 4. In training, replace teacher forcing with feeding the prediction at the previous time step into the decoder. How does this influence the performance?bubu5. Rerun the experiment by replacing GRU with LSTM. 6. Are there any other ways to design the output layer of the decoder? Discussions152. 152
10.8 Beam Search
a
In Section 10.7, we introduced the encoder‚Äìdecoder architecture, and the standard tech- niques for training them end-to-end. However, when it came to test-time prediction, we mentioned only the greedy strategy, where we select at each time step the token given the highest predicted probability of coming next, until, at some time step, we find that we have predicted the special end-of-sequence ‚Äú<eos>‚Äù token. In this section, we will begin by for- malizing this greedy search strategy and identifying some problems that practitioners tend toruninto. Subsequently, wecomparethisstrategywithtwoalternatives: exhaustivesearch (illustrative but not practical) and beam search (the standard method in practice). Let‚Äôs begin by setting up our mathematical notation, borrowing conventions from Section 10.7. At any time step ùë°0, the decoder outputs predictions representing the probability of each token in the vocabulary coming next in the sequence (the likely value of ùë¶ùë°0‚Äö1), con- ditioned on the previous tokens ùë¶1, . . ., ùë¶ùë°0 and the context variable c, produced by the encoder to represent the input sequence. To quantify computational cost, denote by Y the output vocabulary (including the special end-of-sequence token ‚Äú<eos>‚Äù). Let‚Äôs also spec- ify the maximum number of tokens of an output sequence as ùëá0. Our goal is to search for an ideal output from all O‚ÄûjYjùëá0‚Äù possible output sequences. Note that this slightly over- estimates the number of distinct outputs because there are no subsequent tokens once the ‚Äú<eos>‚Äù token occurs. However, for our purposes, this number roughly captures the size of the search space. 10.8.1 Greedy Search
Consider the simple greedy search strategy from Section 10.7. Here, at any time step ùë°0,
we simply select the token with the highest conditional probability from Y, i.e.,
yr = argmax P(y | yi,---,Y1-1,‚Ç¨)- (10.8.1) yey
Once our model outputs ‚Äú<eos>‚Äù (or we reach the maximum lengthùëá0) the output sequence
is completed. Beam Search
Modern Recurrent Neural Networks
406

This strategy might look reasonable, and in fact it is not so bad! Considering how computa- tionally undemanding it is, you‚Äôd be hard pressed to get more bang for your buck. However, if we put aside efficiency for a minute, it might seem more reasonable to search for the most likely sequence, not the sequence of (greedily selected) most likely tokens. It turns out that these two objects can be quite different. The most likely sequence is the one that maximizes the expression Mm, P(yy | y1,.--,¬•r-1,‚Ç¨). In our machine translation example, if the decoder truly recovered the probabilities of the underlying generative process, then this would give us the most likely translation. Unfortunately, there is no guarantee that greedy search will give us this sequence. Let‚Äôs illustrate it with an example. Suppose that there are four tokens ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù, and ‚Äú<eos>‚Äù in the output dictionary. In Fig. 10.8.1, the four numbers under each time step rep- resent the conditional probabilities of generating ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù, and ‚Äú<eos>‚Äù respectively, at that time step. Timestep 12 3 4 A |05]]01]|0.2]]0.0 B fo2}}o4}}o2}/o2 c |02]]03]|04]]0.2 <eos> |0.1]]0.2]| 0.2] [06
tFig. 10.8.1 At each time step, greedy search selects the token with the highest conditional probability. At each time step, greedy search selects the token with the highest conditional probability. Therefore, the output sequence ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù, and ‚Äú<eos>‚Äù will be predicted (Fig. 10.8.1). The conditional probability of this output sequence is 0.5 x 0.4.x 0.4.x 0.6 = 0.048. Next, let‚Äôs look at another example in Fig.bubu10.8.2.bubuUnlike in Fig. 10.8.1, at time step 2 we select the token ‚ÄúC‚Äù, which has the second highest conditional probability. Timestep 1 2 3 4 A {05]]0.1]]0.1] [0.1 B | 0.2}}04] 0.6} | 0.2 c {02]]03]/02]]o.1 <eos> |0.1]}0.2]|0.1]]06
tFig. 10.8.2
The four numbers under each time step represent the conditional probabilities of
generating ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù, and ‚Äú<eos>‚Äù at that time step. At time step 2, the token ‚ÄúC‚Äù, which has the second highest conditional probability, is selected. Since the output subsequences at time steps | and 2, on which time step 3 is based, have changed from ‚ÄúA‚Äù and ‚ÄúB‚Äù in Fig. 10.8.1 to ‚ÄúA‚Äù and ‚ÄúC‚Äù in Fig. 10.8.2, the conditional probability of each token at time step 3 has also changed in Fig. 10.8.2. Suppose that we choose the token ‚ÄúB‚Äù at time step 3. Now time step 4 is conditional on the output subsequence at the first three time steps ‚ÄúA‚Äù, ‚ÄúC‚Äù, and ‚ÄúB‚Äù, which has changed from ‚ÄúA‚Äù, ‚ÄúB‚Äù, and ‚ÄúC‚Äù in Fig. 10.8.1. Therefore, the conditional probability of generating each token at time step 4 in Fig. 10.8.2 is also different from that in Fig. 10.8.1. As a result, the conditional probability of the output sequence ‚ÄúA‚Äù, ‚ÄúC‚Äô‚Äù, ‚ÄúB‚Äù, and ‚Äú<eos>‚Äù in Fig. 10.8.2 is 0.5 x 0.3 x 0.6 x 0.6 = 0.054, which is greater than that of greedy search in Fig. 10.8.1. 407

In this example, the output sequence ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù, and ‚Äú<eos>‚Äù obtained by the greedy search is not optimal. 10.8.2 Exhaustive Search
If the goal is to obtain the most likely sequence, we may consider using exhaustive search: enumerate all the possible output sequences with their conditional probabilities, and then output the one that scores the highest predicted probability. While this would certainly give us what we desire, it would come at a prohibitive com- putational cost of O(|Y I"), exponential in the sequence length and with an enormous base given by the vocabulary size. For example, when |¬•| = 10000 and 7‚Äô = 10, both small numbers when compared with ones in real applications, we will need to evaluate 10000!¬∞ = 10% sequences, which is already beyond the capabilities of any foreseeable computers. On the other hand, the computational cost of greedy search is O(|Y| T‚Äô): mirac- ulously cheap but far from optimal. For example, when |Y¬•| = 10000 and 7‚Äô = 10, we only need to evaluate 10000 x 10 = 10¬∞ sequences. 10.8.3 Beam Search
You could view sequence decoding strategies as lying on a spectrum, with beam search striking a compromise between the efficiency of greedy search and the optimality of ex- haustive search. The most straightforward version of beam search is characterized by a single hyperparameter, the beam size, ùëò. Let‚Äôs explain this terminology.bubuAt time step 1, we select the ùëò tokens with the highest predicted probabilities. Each of them will be the first token of ùëò candidate output sequences, respectively. At each subsequent time step, based on the ùëò candidate output sequences at the previous time step, we continue to select ùëò candidate output sequences with the highest predicted probabilities from ùëò jYj possible choices. Time step 1 Time step 2 Time step Candidates Candidates Candidates A A Z¬Æ.. Za B --4=are ‚Äúyp = + _. ABD Za 8 e E a Q
tFig. 10.8.3
The process of beam search (beam size = 2; maximum length of an output sequence = 3). The candidate output sequences are A, C, AB, CE, ABD, and CED. Fig. 10.8.3 demonstrates the process of beam search with an example. Suppose that the output vocabulary contains only five elements: Y = fùê¥, ùêµ,ùê∂, ùê∑, ùê∏g, where one of them is
Beam Search
3
Modern Recurrent Neural Networks
408

‚Äú<eos>‚Äù. Let the beam size be two and the maximum length of an output sequence be three. At time step 1, suppose that the tokens with the highest conditional probabilities ùëÉ‚Äûùë¶1 j c‚Äù are ùê¥ and ùê∂. At time step 2, for all ùë¶2 2 Y, we compute
ùëÉ‚Äûùê¥, ùë¶2 j c‚Äù = ùëÉ‚Äûùê¥ j c‚ÄùùëÉ‚Äûùë¶2 j ùê¥,c‚Äù, ùëÉ‚Äûùê∂, ùë¶2 j c‚Äù = ùëÉ‚Äûùê∂ j c‚ÄùùëÉ‚Äûùë¶2 j ùê∂,c‚Äù, (10.8.2)
and pick the largest two among these ten values, say ùëÉ‚Äûùê¥, ùêµ j c‚Äù and ùëÉ‚Äûùê∂, ùê∏ j c‚Äù. Then at
time step 3, for all ùë¶3 2 Y, we compute
ùëÉ‚Äûùê¥, ùêµ, ùë¶3 j c‚Äù = ùëÉ‚Äûùê¥, ùêµ j c‚ÄùùëÉ‚Äûùë¶3 j ùê¥, ùêµ,c‚Äù, ùëÉ‚Äûùê∂, ùê∏, ùë¶3 j c‚Äù = ùëÉ‚Äûùê∂, ùê∏ j c‚ÄùùëÉ‚Äûùë¶3 j ùê∂, ùê∏,c‚Äù, (10.8.3)
and pick the largest two among these ten values, say ùëÉ‚Äûùê¥, ùêµ, ùê∑ j c‚Äù and ùëÉ‚Äûùê∂, ùê∏, ùê∑ j c‚Äù. As a result, we get six candidates output sequences: (i) ùê¥; (ii) ùê∂; (iii) ùê¥, ùêµ; (iv) ùê∂, ùê∏; (v) ùê¥, ùêµ, ùê∑; and (vi) ùê∂, ùê∏, ùê∑. In the end, we obtain the set of final candidate output sequences based on these six se- quences (e.g., discard portions including and after ‚Äú<eos>‚Äù). Then we choose the output sequence which maximizes the following score:
L 1 1 za SPO. YL | c)= fe log POve [Yis-...dr-1.¬©)5 (10.8.4) v=l
here ùêø is the length of the final candidate sequence and ùõº is usually set to 0.75. Since a
longer sequence has more logarithmic terms in the summation of (10.8.4), the term ùêøùõº in the denominator penalizes long sequences. The computational cost of beam search is O‚Äûùëò jYjùëá0‚Äù. This result is in between that of
greedy search and that of exhaustive search. Greedy search can be treated as a special case of beam search arising when the beam size is set to 1. 10.8.4 Summary
Sequence searching strategies include greedy search, exhaustive search, and beam search. Beam search provides a trade-off between accuracy and computational cost via the flexible choice of the beam size. 10.8.5 Exercises
1. Can we treat exhaustive search as a special type of beam search? Why or why not? 2. Apply beam search in the machine translation problem in Section 10.7. How does the beam size affect the translation results and the prediction speed? 3. We used language modeling for generating text following user-provided prefixes in Sec- tion 9.5. Which kind of search strategy does it use? Can you improve it?bubuDiscussions153. 153

L
11 Attention Mechanisms and Transformers
The earliest years of the deep learning boom were driven primarily by results produced us- ing the multilayer perceptron, convolutional network, and recurrent network architectures. Remarkably, the model architectures that underpinned many of deep learning‚Äôs break- throughs in the 2010s had changed remarkably little relative to their antecedents despite the lapse of nearly 30 years. While plenty of new methodological innovations made their way into most practitioner‚Äôs toolkits‚ÄîReLU activations, residual layers, batch normalization, dropout, and adaptive learning rate schedules come to mind‚Äîthe core underlying archi- tectures were clearly recognizable as scaled-up implementations of classic ideas. Despite thousands of papers proposing alternative ideas, models resembling classical convolutional neural networks (Chapter 7) retained state-of-the-art status in computer vision and models resembling Sepp Hochreiter‚Äôs original design for the LSTM recurrent neural network (Sec- tion 10.1), dominated most applications in natural language processing. Arguably, to that point, the rapid emergence of deep learning appeared to be primarily attributable to shifts in the available computational resources (thanks to innovations in parallel computing with GPUs) and the availability of massive data resources (thanks to cheap storage and Internet services). While these factors may indeed remain the primary drivers behind this technol- ogy‚Äôs increasing power we are also witnessing, at long last, a sea change in the landscape of dominant architectures. At the present moment, the dominant models for nearly all natural language processing tasks are based on the Transformer architecture. Given any new task in natural language processing, the default first-pass approach is to grab a large Transformer-based pretrained model, (e.g., BERT (Devlin et al., 2018), ELECTRA (Clark et al., 2020), RoBERTa (Liu et al., 2019), or Longformer (Beltagy et al., 2020)) adapting the output layers as neces- sary, and fine-tuning the model on the available data for the downstream task. If you have been paying attention to the last few years of breathless news coverage centered on Ope- nAI‚Äôs large language models, then you have been tracking a conversation centered on the GPT-2 and GPT-3 Transformer-based models (Brown et al., 2020, Radford et al., 2019). Meanwhile, the vision Transformer has emerged as a default model for diverse vision tasks, including image recognition, object detection, semantic segmentation, and superresolution (Dosovitskiy et al., 2021, Liu et al., 2021). Transformers also showed up as competitive methods for speech recognition (Gulati et al., 2020), reinforcement learning (Chen et al., 2021), and graph neural networks (Dwivedi and Bresson, 2020). The core idea behind the Transformer model is the attention mechanism, an innovation that was originally envisioned as an enhancement for encoder‚Äìdecoder RNNs applied to
409
Attention Mechanisms and Transformers
410

sequence-to-sequence applications, such as machine translations (Bahdanau et al., 2014). You might recall that in the first sequence-to-sequence models for machine translation (Sutskever et al., 2014), the entire input was compressed by the encoder into a single fixed- length vector to be fed into the decoder. The intuition behind attention is that rather than compressing the input, it might be better for the decoder to revisit the input sequence at every step. Moreover, rather than always seeing the same representation of the input, one might imagine that the decoder should selectively focus on particular parts of the input se- quence at particular decoding steps. Bahdanau‚Äôs attention mechanism provided a simple means by which the decoder could dynamically attend to different parts of the input at each decoding step. The high-level idea is that the encoder could produce a representation of length equal to the original input sequence. Then, at decoding time, the decoder can (via some control mechanism) receive as input a context vector consisting of a weighted sum of the representations on the input at each time step. Intuitively, the weights determine the extent to which each step‚Äôs context ‚Äúfocuses‚Äù on each input token, and the key is to make this process for assigning the weights differentiable so that it can be learned along with all of the other neural network parameters. Initially, the idea was a remarkably successful enhancement to the recurrent neural net- works that already dominated machine translation applications. The models performed betterthantheoriginalencoder‚Äìdecodersequence-to-sequencearchitectures. Furthermore, researchers noted that some nice qualitative insights sometimes emerged from inspecting the pattern of attention weights. In translation tasks, attention models often assigned high attention weights to cross-lingual synonyms when generating the corresponding words in the target language. For example, when translating the sentence ‚Äúmy feet hurt‚Äù to ‚Äúj‚Äôai mal au pieds‚Äù, the neural network might assign high attention weights to the representation of ‚Äúfeet‚Äù when generating the corresponding French word ‚Äúpieds‚Äù. These insights spurred claims that attention models confer ‚Äúinterpretability‚Äù although what precisely the atten- tion weights mean‚Äîi.e., how, if at all, they should be interpreted remains a hazy research topic. However, attention mechanisms soon emerged as more significant concerns, beyond their usefulness as an enhancement for encoder‚Äìdecoder recurrent neural networks and their pu- tative usefulness for picking out salient inputs. Vaswani et al. (2017) proposed the Trans- former architecture for machine translation, dispensing with recurrent connections alto- gether, and instead relying on cleverly arranged attention mechanisms to capture all rela- tionships among input and output tokens. The architecture performed remarkably well, and by 2018 the Transformer began showing up in the majority of state-of-the-art natural lan- guageprocessingsystems. Moreover, atthesametime, thedominantpracticeinnaturallan- guage processing became to pretrain large-scale models on enormous generic background corpora to optimize some self-supervised pretraining objective, and then to fine-tune these modelsusingtheavailable downstreamdata. ThegapbetweenTransformersandtraditional architectures grew especially wide when applied in this pretraining paradigm, and thus the ascendance of Transformers coincided with the ascendence of such large-scale pretrained models, now sometimes called foundation models (Bommasani et al., 2021). In this chapter, we introduce attention models, starting with the most basic intuitions and
Queries, Keys, and Values
411

the simplest instantiations of the idea. We then work our way up to the Transformer archi- tecture, the vision Transformer, and the landscape of modern Transformer-based pretrained models. 11.1 Queries, Keys, and Values

So far all the networks we have reviewed crucially relied on the input being of a well- defined size. For instance, the images in ImageNet are of size 224 x 224 pixels and CNNs are specifically tuned to this size. Even in natural language processing the input size for RNNs is well defined and fixed. Variable size is addressed by sequentially processing one token at a time, or by specially designed convolution kernels (Kalchbrenner et al., 2014). This approach can lead to significant problems when the input is truly of varying size with varying information content, such as in Section 10.7 in the transformation of text (Sutskever et al., 2014). In particular, for long sequences it becomes quite difficult to keep track of everything that has already been generated or even viewed by the network. Even explicit tracking heuristics such as proposed by Yang ef al. (2016) only offer limited benefit.bubuCompare this to databases. In their simplest form they are collections of keys (ùëò) and values
(ùë£). For instance, our database D might consist of tuples {(‚ÄúZhang‚Äù, ‚ÄúAston‚Äù), (‚ÄúLipton‚Äù, ‚ÄúZachary‚Äù), (‚ÄúLi‚Äù, ‚ÄúMu‚Äù), (‚ÄúSmola‚Äù, ‚ÄúAlex‚Äù), (‚ÄúHu‚Äù, ‚ÄúRachel‚Äù), (‚ÄúWerness‚Äù, ‚ÄúBrent‚Äù)} with the last name being the key and the first name being the value. We can operate on D, for instance with the exact query (ùëû) for ‚ÄúLi‚Äù which would return the value ‚ÄúMu‚Äù. If (‚ÄúLi‚Äù, ‚ÄúMu‚Äù) was not a record in D, there would be no valid answer. If we also allowed for approximate matches, we would retrieve (‚ÄúLipton‚Äù, ‚ÄúZachary‚Äù) instead. This quite simple and trivial example nonetheless teaches us a number of useful things:
e We can design queries qg that operate on (k,v) pairs in such a manner as to be valid
regardless of the database size. e The same query can receive different answers, according to the contents of the database. e The ‚Äúcode‚Äù being executed for operating on a large state space (the database) can be quite
simple (e.g., exact match, approximate match, top-ùëò). e There is no need to compress or simplify the database to make the operations effective. Clearly we would not have introduced a simple database here if it wasn‚Äôt for the purpose of explaining deep learning. Indeed, this leads to one of the most exciting concepts introduced in deep learning in the past decade: the attention mechanism (Bahdanau et al., 2014). We will cover the specifics of its application to machine translation later. For now, simply consider the following: denote by D def = f‚Äûk1,v1‚Äù, . .bubu. ‚Äûkùëö,vùëö‚Äùg a database of ùëö tuples of keys and values. Moreover, denote by q a query. Then we can define the attention over D
Attention Mechanisms and Transformers
412

as
Attention‚Äûq, D‚Äù def = ùõº‚Äûq,kùëñ‚Äùvùëñ, (11.1.1) ùëñ=1
where ùõº‚Äûq,kùëñ‚Äù 2 R (ùëñ = 1, . . .,ùëö) are scalar attention weights. The operation itself is
typically referred to as attention pooling. The name attention derives from the fact that the operation pays particular attention to the terms for which the weight ùõº is significant (i.e., large). As such, the attention over D generates a linear combination of values contained in the database. In fact, this contains the above example as a special case where all but one weight is zero. We have a number of special cases:
The weights a(q, k;) are nonnegative. In this case the output of the attention mechanism
is contained in the convex cone spanned by the values vùëñ. The weights a(q, k;) form a convex combination, i.e.,
for all ùëñ. This is the most common setting in deep learning. Exactly one of the weights a(q, k;) is 1, while all others are 0. This is akin to a traditional
database query. All weights are equal, i.e., @(q, ki) = x for all i. This amounts to averaging across the entire database, also called average pooling in deep learning. Acommonstrategyforensuringthattheweightssumupto1istonormalizethemvia
ùõº‚Äûq,kùëñ‚Äù = Àù ùëóùõº‚Äûq,kùëó‚Äù . (11.1.2)
In particular, to ensure that the weights are also nonnegative, one can resort to exponenti- ation. This means that we can now pick any function ùëé‚Äûq,k‚Äù and then apply the softmax operation used for multinomial models to it via
ùõº‚Äûq,kùëñ‚Äù = Àù ùëó exp‚Äûùëé‚Äûq,kùëó‚Äù‚Äù . (11.1.3)
This operation is readily available in all deep learning frameworks. It is differentiable and its gradient never vanishes, all of which are desirable properties in a model. Note though, the attention mechanism introduced above is not the only option. For instance, we can design a non-differentiable attention model that can be trained using reinforcementlearning methods (Mnih et al., 2014). As one would expect, training such a model is quite complex. Consequently the bulk of modern attention research follows the framework outlined in Fig. 11.1.1.bubuWe thus focus our exposition on this family of differentiable mechanisms. Whatisquiteremarkableisthattheactual‚Äúcode‚Äùforexecutingonthesetofkeysandvalues, namely the query, can be quite concise, even though the space to operate on is significant. This is a desirable property for a network layer as it does not require too many parameters to learn. Just as convenient is the fact that attention can operate on arbitrarily large databases without the need to change the way the attention pooling operation is performed. m
Àù
a(q, k;) = 1 and a(q, k;) > 0
ùõº‚Äûq,kùëñ‚Äù
exp‚Äûùëé‚Äûq,kùëñ‚Äù‚Äù
Queries, Keys, and Values
413

Keys wets Values Output ‚Äòaa. k)\- - +[% oak) b-+f = _4I wa oak) p-‚Äî+[%, t Attention Query 4 Pooling
tFig. 11.1.1
The attention mechanism computes a linear combination over values vi via attention pooling, where weights are derived according to the compatibility between a query q and keys ki. import torch from d2l import torch as d2l
11.1.1 Visualization
One of the benefits of the attention mechanism is that it can be quite intuitive, particularly when the weights are nonnegative and sum to 1. In this case we might interpret large weights as a way for the model to select components of relevance. While this is a good intuition, it is important to remember that it is just that, an intuition. Regardless, we may want to visualize its effect on the given set of keys when applying a variety of different queries. This function will come in handy later.bubuWethusdefinetheshow_heatmapsfunction. Notethatitdoesnottakeamatrix(ofattention weights) as its input but rather a tensor with four axes, allowing for an array of different queries and weights. Consequently the input matrices has the shape (number of rows for display, number of columns for display, number of queries, number of keys). This will come in handy later on when we want to visualize the workings that are to design Transformers. #@save def show_heatmaps(matrices, xlabel, ylabel, titles=None, figsize=(2.5, 2.5), cmap='Reds'): """Show heatmaps of matrices.""" d2l.use_svg_display() num_rows, num_cols, _, _ = matrices.shape fig, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize, sharex=True, sharey=True, squeeze=False) for i, (row_axes, row_matrices) in enumerate(zip(axes, matrices)): for j, (ax, matrix) in enumerate(zip(row_axes, row_matrices)): pcm = ax.imshow(matrix.detach().numpy(), cmap=cmap) if i == num_rows - 1: ax.set_xlabel(xlabel) if j == 0: ax.set_ylabel(ylabel) if titles:
(continues on next page)
Attention Mechanisms and Transformers
414

ax.set_title(titles[j]) fig.colorbar(pcm, ax=axes, shrink=0.6);
As a quick sanity check let‚Äôs visualize the identity matrix, representing a case where the attention weight is 1 only when the query and the key are the same. attention_weights = torch.eye(10).reshape((1, 1, 10, 10)) show_heatmaps(attention_weights, xlabel='Keys', ylabel='Queries')

2
r 54 g o6
8
0
11.1.2 Summary
The attention mechanism allows us to aggregate data from many (key, value) pairs. So far our discussion was quite abstract, simply describing a way to pool data. We have not explained yet where those mysterious queries, keys, and values might arise from. Some intuition might help here: for instance, in a regression setting, the query might correspond to the location where the regression should be carried out. The keys are the locations where past data was observed and the values are the (regression) values themselves. This is the so-called Nadaraya‚ÄìWatson estimator (Nadaraya, 1964, Watson, 1964) that we will be studying in the next section. By design, the attention mechanism provides a differentiable means of control by which a neural network can select elements from a set and to construct an associated weighted sum over representations. 11.1.3 Exercises
1. Suppose that you wanted to reimplement approximate (key, query) matches as used in classical databases, which attention function would you pick? 2. Suppose that the attention function is given by ùëé‚Äûq,kùëñ‚Äù = q>kùëñ and that kùëñ = vùëñ for
ùëñ = 1, . .bubu.,ùëö. Denote by ùëù‚Äûkùëñ;q‚Äù the probability distribution over keys when using the softmax normalization in (11.1.3). Prove that rq Attention‚Äûq, D‚Äù = Covùëù‚Äûkùëñ;q‚Äù¬ªkùëñ‚Ä¶. 3. Design a differentiable search engine using the attention mechanism. 4. ReviewthedesignoftheSqueezeandExcitationNetworks(Huetal.,2018)andinterpret them through the lens of the attention mechanism. (continued from previous page)
1.00

0.75
0.50
0.25
0.00
5
Keys
Attention Pooling by Similarity
415

Discussions154. 154
11.2 Attention Pooling by Similarity
es
Now that we have introduced the primary components of the attention mechanism, let‚Äôs use them in a rather classical setting, namely regression and classification via kernel den- sity estimation (Nadaraya, 1964, Watson, 1964). This detour simply provides additional background: it is entirely optional and can be skipped if needed.bubuAt their core, Nadaraya‚Äì Watsonestimatorsrelyonsomesimilaritykernelùõº‚Äûq,k‚Äù relatingqueriesqtokeysk. Some common kernels are
1 a(q, k) = exp (10 - Ki?) Gaussian; a(q,k) = Lif |lq‚Äîkl| <1 Boxcar; (11.2.1) a(q, k) = max (0, 1 - ||q‚Äîk||) Epanechikov. There are many more choices that we could pick. See a Wikipedia article155 for a more extensivereviewandhowthechoiceofkernelsisrelatedtokerneldensityestimation, some- times also called Parzen Windows (Parzen, 1957). All of the kernels are heuristic and can be tuned.bubuFor instance, we can adjust the width, not only on a global basis but even on a per-coordinate basis. Regardless, all of them lead to the following equation for regression and classification alike:
155
ùëì ‚Äûq‚Äù = ùëñ vùëñ Àù ùëó ùõº‚Äûq,kùëó‚Äù . (11.2.2)
In the case of a (scalar) regression with observations ‚Äûxùëñ, ùë¶ùëñ‚Äù for features and labels respec-
tively, vùëñ = ùë¶ùëñ are scalars, kùëñ = xùëñ are vectors, and the query q denotes the new location where ùëì should be evaluated. In the case of (multiclass) classification, we use one-hot- encoding of ùë¶ùëñ to obtain vùëñ. One of the convenient properties of this estimator is that it re- quires no training. Even more so, if we suitably narrow the kernel with increasing amounts of data, the approach is consistent (Mack and Silverman, 1982), i.e., it will converge to some statistically optimal solution. Let‚Äôs start by inspecting some kernels. import numpy as np import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l d2l.use_svg_display()
d2l.use_svg_display()
11.2.1 Kernels and Data
All the kernels ùõº‚Äûk,q‚Äù defined in this section are translation and rotation invariant; that
is, if we shift and rotate k and q in the same manner, the value of ùõº remains unchanged. ùõº‚Äûq,kùëñ‚Äù
Attention Mechanisms and Transformers
416

For simplicity we thus pick scalar arguments ùëò, ùëû 2 R and pick the key ùëò = 0 as the origin. This yields:
# Define some kernels def gaussian(x): return torch.exp(-x**2 / 2) def boxcar(x): return torch.abs(x) < 1.0 def constant(x): return 1.0 + 0 * x def epanechikov(x): return torch.max(1 - torch.abs(x), torch.zeros_like(x))
fig, axes = d2l.plt.subplots(1, 4, sharey=True, figsize=(12, 3))
kernels = (gaussian, boxcar, constant, epanechikov) names = ('Gaussian', 'Boxcar', 'Constant', 'Epanechikov') x = torch.arange(-2.5, 2.5, 0.1) for kernel, name, ax in zip(kernels, names, axes): ax.plot(x.detach().numpy(), kernel(x).detach().numpy()) ax.set_xlabel(name)
d2l.plt.show()
10 08 06 0.4 0.0 -2 t) 2 -2 0 2 -2 ¬∞ 2 -2 0 2 Gaussian Boxcar Constant Epanechikov
Different kernels correspond to different notions of range and smoothness. For instance, the boxcar kernel only attends to observations within a distance of 1 (or some otherwise defined hyperparameter) and does so indiscriminately. To see Nadaraya‚ÄìWatson estimation in action, let‚Äôs define some training data. In the fol- lowing we use the dependency
ùë¶ùëñ = 2sin‚Äûùë•ùëñ‚Äù ‚Äö ùë•ùëñ ‚Äö ùúñ,
(11.2.3)
where ùúñ is drawn from a normal distribution with zero mean and unit variance. We draw
40 training examples. Attention Pooling by Similarity
417

def f(x): return 2 * torch.sin(x) + x n = 40 x_train, _ = torch.sort(torch.rand(n) * 5) y_train = f(x_train) + torch.randn(n) x_val = torch.arange(0, 5, 0.1) y_val = f(x_val)
11.2.2 Attention Pooling via Nadaraya‚ÄìWatson Regression
Now that we have data and kernels, all we need is a function that computes the kernel regression estimates. Note that we also want to obtain the relative kernel weights in order to perform some minor diagnostics. Hence we first compute the kernel between all training features (covariates) x_train and all validation features x_val. This yields a matrix, which we subsequently normalize. When multiplied with the training labels y_train we obtain the estimates. Recall attention pooling in (11.1.1). Let each validation feature be a query, and each training feature‚Äìlabel pair be a key‚Äìvalue pair. As a result, the normalized relative ker- nel weights (attention_w below) are the attention weights. def nadaraya_watson(x_train, y_train, x_val, kernel): dists = x_train.reshape((-1, 1)) - x_val.reshape((1, -1)) # Each column/row corresponds to each query/key k = kernel(dists).type(torch.float32) # Normalization over keys for each query attention_w = k / k.sum(0) y_hat = y_train@attention_w return y_hat, attention_w
Let‚Äôs have a look at the kind of estimates that the different kernels produce. def plot(x_train, y_train, x_val, y_val, kernels, names, attention=False): fig, axes = d2l.plt.subplots(1, 4, sharey=True, figsize=(12, 3)) for kernel, name, ax in zip(kernels, names, axes): y_hat, attention_w = nadaraya_watson(x_train, y_train, x_val, kernel) if attention: pcm = ax.imshow(attention_w.detach().numpy(), cmap='Reds') else: ax.plot(x_val, y_hat) ax.plot(x_val, y_val, 'm--') ax.plot(x_train, y_train, 'o', alpha=0.5); ax.set_xlabel(name) if not attention: ax.legend(['y_hat', 'y']) if attention: fig.colorbar(pcm, ax=axes, shrink=0.7)
Attention Mechanisms and Transformers
418

plot(x_train, y_train, x_val, y_val, kernels, names)
4 / ¬∞ fs ‚Äî ‚Äî ¬•-hat fo vhat ‚Äî e y ¬∞ y ¬∞ y 0 2 4 0 2 4 fy 2 4 0 2 4 Gaussian Boxcar Constant Epanechikov
The first thing that stands out is that all three nontrivial kernels (Gaussian, Boxcar, and Epanechikov) produce fairly workable estimates that are not too far from the true function. Àù Only the constant kernel that leads to the trivial estimate ùëì ‚Äûùë•‚Äù = 1 ùëñ ùë¶ùëñ produces a rather ùëõ unrealistic result. Let‚Äôs inspect the attention weighting a bit more closely:
plot(x_train, y_train, x_val, y_val, kernels, names, attention=True)
0


10
20
30
0
20 40 Gaussian
0
20
40
Boxcar
The visualization clearly shows why the estimates for Gaussian, Boxcar, and Epanechikov are very similar: after all, they are derived from very similar attention weights, despite the different functional form of the kernel. This raises the question as to whether this is always the case. 11.2.3 Adapting Attention Pooling
We could replace the Gaussian kernel with one of a different width. That is, we could use a(q,k) = exp (-sblla - KI?) where o? determines the width of the kernel. Let‚Äôs see whether this affects the outcomes. sigmas = (0.1, 0.2, 0.5, 1) names = ['Sigma ' + str(sigma) for sigma in sigmas] def gaussian_with_width(sigma): return (lambda x: torch.exp(-x**2 / (2*sigma**2)))
kernels = [gaussian_with_width(sigma) for sigma in sigmas] plot(x_train, y_train, x_val, y_val, kernels, names)



0.2
0.1
0
20 40 Constant
0
20
40
0.0
Epanechikov
Attention Pooling by Similarity
419

‚Äô i ‚Äî y_hat e 0 2 4 Sigma 0.1 Sigma 0.2 Sigma 0.5 Sigma 1
Clearly, the narrower the kernel, the less smooth the estimate. At the same time, it adapts better to the local variations. Let‚Äôs look at the corresponding attention weights. plot(x_train, y_train, x_val, y_val, kernels, names, attention=True)
O
~. 10
20
30
0
20
40
0
20
40
Sigma 0.1
Sigma 0.2
As we would expect, the narrower the kernel, the narrower the range of large attention weights. It is also clear that picking the same width might not be ideal. In fact, Silverman (1986) proposed a heuristic that depends on the local density. Many more such ‚Äútricks‚Äù have been proposed.bubuFor instance, Norelli et al. (2022) used a similar nearest-neighbor interpolation technique for designing cross-modal image and text representations. Theastutereadermightwonderwhyweareprovidingthisdeepdiveforamethodthatisover half a century old. First, it is one of the earliest precursors of modern attention mechanisms. Second, itisgreatforvisualization. Third, andjustasimportantly, itdemonstratesthelimits of hand-crafted attention mechanisms. A much better strategy is to learn the mechanism, by learning the representations for queries and keys. This is what we will embark on in the following sections. 11.2.4 Summary
Nadaraya‚ÄìWatson kernel regression is an early precursor of the current attention mecha- nisms. It can be used directly with little to no training or tuning, either for classification or regression.bubuThe attention weight is assigned according to the similarity (or distance) be- tween query and key, and according to how many similar observations are available. 11.2.5 Exercises

0.100


0.075
0.050
0.025
0
20
40
0
20
40
Sigma 0.5
Sigma 1
Attention Mechanisms and Transformers
420

1. Parzen windows density estimates are given by ÀÜùëù‚Äûx‚Äù = 1
1. Parzen windows density estimates are given by p(x) = i >, k(x, x;). Prove that for binary classification the function f(x, y = 1) ‚Äî p(x, y = ‚Äî1), as obtained by Parzen windows is equivalent to Nadaraya‚ÄîWatson classification. 2. ImplementstochasticgradientdescenttolearnagoodvalueforkernelwidthsinNadaraya‚Äì Watson regression. 1. What happens if you just use the above estimates to minimize (f (x;) ‚Äî y;)? directly? Hint: ùë¶ùëñ is part of the terms used to compute ùëì. 2. Remove ‚Äûxùëñ, ùë¶ùëñ‚Äù from the estimate for ùëì ‚Äûxùëñ‚Äù and optimize over the kernel widths. Do you still observe overfitting?bubu3. Assume that all x lie on the unit sphere, i.e., all satisfy kxk = 1. Can you simplify the
3. Assume that all x lie on the unit sphere, i.e., all satisfy ||x|| = 1. Can you simplify the ||x‚Äîx;||? term in the exponential? Hint: we will later see that this is very closely related to dot product attention. 4. Recall that Mack and Silverman (1982) proved that Nadaraya‚ÄìWatson estimation is con- sistent. How quickly should you reduce the scale for the attention mechanism as you get more data? Provide some intuition for your answer. Does it depend on the dimension- ality of the data? How?bubu156
Discussions156. 156
11.3 Attention Scoring Functions
a
In Section 11.2, we used a number of different distance-based kernels, including a Gaussian kernel to model interactions between queries and keys. As it turns out, distance functions are slightly more expensive to compute than dot products. As such, with the softmax op- eration to ensure nonnegative attention weights, much of the work has gone into attention scoring functions ùëé in (11.1.3) and Fig. 11.3.1 that are simpler to compute. Attention ¬© Output weights Attention scoring function Keys = Values Query
tFig. 11.3.1 Computing the output of attention pooling as a weighted average of values, where weights
are computed with the attention scoring function a and the softmax operation. Àù
ùëñ ùëò‚Äûx,xùëñ‚Äù. Prove that for
Attention Scoring Functions
421

import math import torch from torch import nn from d2l import torch as d2l
11.3.1 Dot Product Attention
Let‚Äôs review the attention function (without exponentiation) from the Gaussian kernel for a moment:
1 1 1 4 a(a.ki) = ~5 lla - kill? = aks ~ 5llki IP ~ 5 lla.bubu(11.3.1)
First, note that the final term depends on q only. As such it is identical for all ‚Äûq,kùëñ‚Äù
pairs. Normalizing the attention weights to 1, as is done in (11.1.3), ensures that this term disappears entirely. Second, note that both batch and layer normalization (to be discussed later) lead to activations that have well-bounded, and often constant, norms kkùëñk. This is the case, for instance, whenever the keys kùëñ were generated by a layer norm. As such, we can drop it from the definition of ùëé without any major change in the outcome. Last, we need to keep the order of magnitude of the arguments in the exponential function under control. Assume that all the elements of the query q ‚Ç¨ R@ and the key k; ‚Ç¨ R? are independent and identically drawn random variables with zero mean and unit variance. The dot product between both vectors has zero mean and a variance of d. To ensure that the variance of the dot product still remains | regardless of vector length, we use the scaled dot product attention scoring function. That is, we rescale the dot product by 1/Vd. We thus arrive at the first commonly used attention function that is used, e.g., in Transformers (Vaswani et al., 2017):
a(q,k;) = q"k;/Vd. ùëë. (11.3.2)
Note that attention weights ùõº still need normalizing. We can simplify this further via
(11.1.3) by using the softmax operation:
exp(q"k;/Vd) Dj-1 exp(q‚Ñ¢k;/Va) a(q, k;) = softmax(a(q, k;)) = (11.3.3)
As it turns out, all popular attention mechanisms use the softmax, hence we will limit ourselves to that in the remainder of this chapter. 11.3.2 Convenience Functions
We need a few functions to make the attention mechanism efficient to deploy. This includes tools for dealing with strings of variable lengths (common for natural language processing) and tools for efficient evaluation on minibatches (batch matrix multiplication). Masked Softmax Operation
One of the most popular applications of the attention mechanism is to sequence models. Hence we need to be able to deal with sequences of different lengths. In some cases, such
p
p
Attention Mechanisms and Transformers
422

sequences may end up in the same minibatch, necessitating padding with dummy tokens for shorter sequences (see Section 10.5 for an example). These special tokens do not carry meaning. For instance, assume that we have the following three sentences:
Dive into Deep
Learning
Learn to code <blank> Hello world <blank> <blank>
Since we do not want blanks in our attention model we simply need to limit Dan a(q, kj) vi to an a(q, k;)v; for however long, / < n, the actual sentence is. Since it is such acommon problem, it has a name: the masked softmax operation. Let‚Äôs implement it. Actually, the implementation cheats ever so slightly by setting the values of v;, fori > 1, to zero. Moreover, it sets the attention weights to a large negative number, such as ‚Äî10¬∞, in order to make their contribution to gradients and values vanish in practice. This is done since linear algebra kernels and operators are heavily optimized for GPUs and it is faster to be slightly wasteful in computation rather than to have code with conditional (if then else) statements. def masked_softmax(X, valid_lens): #@save """Perform softmax operation by masking elements on the last axis.""" # X: 3D tensor, valid_lens: 1D or 2D tensor def _sequence_mask(X, valid_len, value=0): maxlen = X.size(1) mask = torch.arange((maxlen), dtype=torch.float32, device=X.device)[None, :] < valid_len[:, None] X[~mask] = value return X if valid_lens is None: return nn.functional.softmax(X, dim=-1) else: shape = X.shape if valid_lens.dim() == 1: valid_lens = torch.repeat_interleave(valid_lens, shape[1]) else: valid_lens = valid_lens.reshape(-1) # On the last axis, replace masked elements with a very large negative # value, whose exponentiation outputs 0 X = _sequence_mask(X.reshape(-1, shape[-1]), valid_lens, value=-1e6) return nn.functional.softmax(X.reshape(shape), dim=-1)
To illustrate how this function works, consider a minibatch of two examples of size 2 x 4,
where their valid lengths are 2 and 3, respectively. As a result of the masked softmax oper- ation, values beyond the valid lengths for each pair of vectors are all masked as zero. masked_softmax(torch.rand(2, 2, 4), torch.tensor([2, 3]))
tensor([[[0.4448, 0.5552, 0.0000, 0.0000], [0.4032, 0.5968, 0.0000, 0.0000]],
Àùùëõ
ùõº‚Äûq,kùëñ‚Äùvùëñ
(continues on next page)
Attention Scoring Functions
423

[[0.2795, 0.2805, 0.4400, 0.0000], [0.2798, 0.3092, 0.4110, 0.0000]]])
If we need more fine-grained control to specify the valid length for each of the two vec- tors of every example, we simply use a two-dimensional tensor of valid lengths. This yields:
masked_softmax(torch.rand(2, 2, 4), torch.tensor([[1, 3], [2, 4]]))
tensor([[[1.0000, 0.0000, 0.0000, 0.0000], [0.4109, 0.2794, 0.3097, 0.0000]], [[0.3960, 0.6040, 0.0000, 0.0000], [0.2557, 0.1833, 0.2420, 0.3190]]])
Batch Matrix Multiplication
Another commonly used operation is to multiply batches of matrices by one another. This comes in handy when we have minibatches of queries, keys, and values. More specifically, assume that
Q = [Q),Q2,..., Qn] ‚Ç¨ RUXaxd 11.3.4 K = [Ky, Kp,...,K,] ‚Ç¨ R"‚Ñ¢2*¬∞. ( )
Then the batch matrix multiplication (BMM) computes the elementwise product
BMM(Q, K) = [Qi Ki, Q2K2,..., QnKn] ‚Ç¨ R‚Ñ¢. (11.3.5)
Let‚Äôs see this in action in a deep learning framework. Q = torch.ones((2, 3, 4))
K = torch.ones((2, 4, 6))
d2l.check_shape(torch.bmm(Q, K), (2, 3, 6))
11.3.3 Scaled Dot Product Attention
Let‚Äôs return to the dot product attention introduced in (11.3.2). In general, it requires that both the query and the key have the same vector length, say ùëë, even though this can be addressed easily by replacing q>k with q>Mk where M is a matrix suitably chosen for translating between both spaces. For now assume that the dimensions match. In practice, we often think of minibatches for efficiency, such as computing attention for n queries and m key-value pairs, where queries and keys are of length d and values are of length v. The scaled dot product attention of queries Q ¬¢ R‚Äù*¬¢, keys K ‚Ç¨ R‚Äù*4, and
(continued from previous page)
Attention Mechanisms and Transformers
424

values V ‚Ç¨ R‚Äù*‚Äù thus can be written as
+ Vd softmax VeR‚Ñ¢, (11.3.6)
Note that when applying this to a minibatch, we need the batch matrix multiplication intro- duced in (11.3.5). In the following implementation of the scaled dot product attention, we use dropout for model regularization. class DotProductAttention(nn.Module): #@save """Scaled dot product attention.""" def __init__(self, dropout): super().__init__() self.dropout = nn.Dropout(dropout) # Shape of queries: (batch_size, no. of queries, d) # Shape of keys: (batch_size, no.bubuof key-value pairs, d) # Shape of values: (batch_size, no. of key-value pairs, value dimension) # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries) def forward(self, queries, keys, values, valid_lens=None): d = queries.shape[-1] # Swap the last two dimensions of keys with keys.transpose(1, 2) scores = torch.bmm(queries, keys.transpose(1, 2)) / math.sqrt(d) self.attention_weights = masked_softmax(scores, valid_lens) return torch.bmm(self.dropout(self.attention_weights), values)
To illustrate how the DotProductAttention class works, we use the same keys, values, and valid lengths from the earlier toy example for additive attention. For the purpose of our example we assume that we have a minibatch size of 2, a total of 10 keys and values, and that the dimensionality of the values is 4.bubuLastly, we assume that the valid length per observation is 2 and 6 respectively. Given that, we expect the output to be a 2x 1 x 4 tensor, i.e., one row per example of the minibatch. i.e., one row per example of the minibatch. queries = torch.normal(0, 1, (2, 1, 2)) keys = torch.normal(0, 1, (2, 10, 2)) values = torch.normal(0, 1, (2, 10, 4)) valid_lens = torch.tensor([2, 6])
attention = DotProductAttention(dropout=0.5) attention.eval() d2l.check_shape(attention(queries, keys, values, valid_lens), (2, 1, 4))
Let‚Äôs check whether the attention weights actually vanish for anything beyond the second and sixth column respectively (because of setting the valid length to 2 and 6). d2l.show_heatmaps(attention.attention_weights.reshape((1, 1, 2, 10)), xlabel='Keys', ylabel='Queries')
11.3.4 Additive Attention
When queries q and keys k are vectors of different dimension, we can either use a matrix to address the mismatch via q>Mk, or we can use additive attention as the scoring function. Attention Scoring Functions
425

2 o

6
Another benefit is that, as its name indicates, the attention is additive. This can lead to some minor computational savings. Given a query q 2 Rùëû and a key k 2 Rùëò, the additive attention scoring function (Bahdanau et al., 2014) is given by
ùëé‚Äûq,k‚Äù = w>
ùë£ tanh‚ÄûWùëûq ‚Äö Wùëòk‚Äù 2 R, (11.3.7)
where Wg ‚Ç¨ R'*4, W, ‚Ç¨ R"**, and wy ‚Ç¨ R" are the learnable parameters. This term
is then fed into a softmax to ensure both nonnegativity and normalization. An equivalent interpretation of (11.3.7) is that the query and key are concatenated and fed into an MLP with a single hidden layer. Using tanh as the activation function and disabling bias terms, we implement additive attention as follows:
class AdditiveAttention(nn.Module): #@save """Additive attention."""
def __init__(self, num_hiddens, dropout, **kwargs): super(AdditiveAttention, self).__init__(**kwargs) self.W_k = nn.LazyLinear(num_hiddens, bias=False) self.W_q = nn.LazyLinear(num_hiddens, bias=False) self.w_v = nn.LazyLinear(1, bias=False) self.dropout = nn.Dropout(dropout)
self.w_v = nn.LazyLinear(1, bias=False) self.dropout = nn.Dropout(dropout) def forward(self, queries, keys, values, valid_lens): queries, keys = self.W_q(queries), self.W_k(keys) # After dimension expansion, shape of queries: (batch_size, no. of # queries, 1, num_hiddens) and shape of keys: (batch_size, 1, no.bubuof # key-value pairs, num_hiddens). Sum them up with broadcasting features = queries.unsqueeze(2) + keys.unsqueeze(1) features = torch.tanh(features) # There is only one output of self.w_v, so we remove the last # one-dimensional entry from the shape. Shape of scores: (batch_size, # no. of queries, no. of key-value pairs) scores = self.w_v(features).squeeze(-1) self.attention_weights = masked_softmax(scores, valid_lens) # Shape of values: (batch_size, no. of key-value pairs, value # dimension)
return torch.bmm(self.dropout(self.attention_weights), values)
Let‚Äôs see how AdditiveAttention works. In our toy example we pick queries, keys and valuesofsize ‚Äû2,1,20‚Äù, ‚Äû2,10,2‚Äù and ‚Äû2,10,4‚Äù, respectively. Thisisidenticaltoourchoice for DotProductAttention, except that now the queries are 20-dimensional. Likewise, we pick ‚Äû2,6‚Äù as the valid lengths for the sequences in the minibatch. queries = torch.normal(0, 1, (2, 1, 20))

0.4
0.2
5
Keys
00
(continues on next page)
Attention Mechanisms and Transformers
426

attention = AdditiveAttention(num_hiddens=8, dropout=0.1) attention.eval() d2l.check_shape(attention(queries, keys, values, valid_lens), (2, 1, 4))
When reviewing the attention function we see a behavior that is qualitatively quite similar to that of DotProductAttention. That is, only terms within the chosen valid length ‚Äû2,6‚Äù are nonzero. d2l.show_heatmaps(attention.attention_weights.reshape((1, 1, 2, 10)), xlabel='Keys', ylabel='Queries')
fo ¬∞

0
11.3.5 Summary
In this section we introduced the two key attention scoring functions: dot product and addi- tive attention. They are effective tools for aggregating across sequences of variable length. In particular, the dot product attention is the mainstay of modern Transformer architectures. When queries and keys are vectors of different lengths, we can use the additive attention scoring function instead. Optimizing these layers is one of the key areas of advance in re- cent years. For instance, NVIDIA‚Äôs Transformer Library157 and Megatron (Shoeybi et al., 2019) crucially rely on efficient variants of the attention mechanism. We will dive into this in quite a bit more detail as we review Transformers in later sections.bubu157
11.3.6 Exercises
1. Implementdistance-basedattentionbymodifyingtheDotProductAttentioncode. Note that you only need the squared norms of the keys kkùëñk2 for an efficient implementation. 2. Modify the dot product attention to allow for queries and keys of different dimension- alities by employing a matrix to adjust dimensions. 158
3. How does the computational cost scale with the dimensionality of the keys, queries, values, and their number? What about the memory bandwidth requirements?bubuDiscussions158. (continued from previous page)

0.4
0.2
5 Keys
0.0
The Bahdanau Attention Mechanism
427

11.4 The Bahdanau Attention Mechanism

WhenweencounteredmachinetranslationinSection10.7,wedesignedanencoder‚Äìdecoder architectureforsequence-to-sequencelearningbasedontwoRNNs(Sutskeveretal., 2014). Specifically, the RNN encoder transforms a variable-length sequence into a fixed-shape context variable. Then, the RNN decoder generates the output (target) sequence token by token based on the generated tokens and the context variable. Recall Fig.bubu10.7.2 which we repeat (Fig.bubu11.4.1) with some additional detail. Convention- ally, in an RNN all relevant information about a source sequence is translated into some internal fixed-dimensional state representation by the encoder. It is this very state that is used by the decoder as the complete and exclusive source of information for generating the translated sequence. In other words, the sequence-to-sequence mechanism treats the inter- mediate state as a sufficient statistic of whatever string might have served as input. Encoder Decoder FC t = = seutces Targets
tFig. 11.4.1
Sequence-to-sequence model. The state, as generated by the encoder, is the only piece of information shared between the encoder and the decoder. Whilethisisquitereasonableforshortsequences,itisclearthatitisinfeasibleforlongones, such as a book chapter or even just a very long sentence. After all, before too long there will simplynotbeenough‚Äúspace‚Äùintheintermediaterepresentationtostoreallthatisimportant in the source sequence. Consequently the decoder will fail to translate long and complex sentences. One of the first to encounter this was Graves (2013) who tried to design an RNNtogeneratehandwrittentext. Sincethesourcetexthasarbitrarylengththeydesigneda differentiable attention model to align text characters with the much longer pen trace, where the alignment moves only in one direction. This, in turn, draws on decoding algorithms in speech recognition, e.g., hidden Markov models (Rabiner and Juang, 1993). Inspired by the idea of learning to align, Bahdanau et al. (2014) proposed a differentiable attention model without the unidirectional alignment limitation. When predicting a token, if not all the input tokens are relevant, the model aligns (or attends) only to parts of the input sequence that are deemed relevant to the current prediction. This is then used to update the current state before generating the next token. While quite innocuous in its description, this Bahdanau attention mechanism has arguably turned into one of the most influential ideas of the past decade in deep learning, giving rise to Transformers (Vaswani et al., 2017) and many related new architectures. Attention Mechanisms and Transformers
428

import torch from torch import nn from d2l import torch as d2l
11.4.1 Model
We follow the notation introduced by the sequence-to-sequence architecture of Section 10.7, in particular (10.7.3). The key idea is that instead of keeping the state, i.e., the con- text variable c summarizing the source sentence, as fixed, we dynamically update it, as a function of both the original text (encoder hidden states h,) and the text that was already generated (decoder hidden states s;'_;). This yields c;, which is updated after any decod- ing time step t‚Äô. Suppose that the input sequence is of length T. In this case the context variable is the output of attention pooling:
T Cy = 9) (sp1, hy) by. (11.4.1) t=1
We used s;‚Äô_; as the query, and h, as both the key and the value. Note that c, is then used to generate the state s, and to generate a new token: see (10.7.3). In particular, the attention weight a is computed as in (11.3.3) using the additive attention scoring function defined by (11.3.7). This RNN encoder‚Äîdecoder architecture using attention is depicted in Fig. 11.4.2. Note that later this model was modified so as to include the already generated tokens in the decoder as further context (i.e., the attention sum does not stop at T but rather it proceeds up to t‚Äô ‚Äî 1). For instance, see Chan et al. (2015) for a description of this strategy, as applied to speech recognition. Encoder Decoder nx Recurrent. [+ _ Recurrent xn Embedding Embedding Sources Targets
tFig. 11.4.2
Layers in an RNN encoder‚Äìdecoder model with the Bahdanau attention mechanism. 11.4.2 Defining the Decoder with Attention
To implement the RNN encoder‚Äìdecoder with attention, we only need to redefine the de- coder (omitting the generated symbols from the attention function simplifies the design). Let‚Äôs begin with the base interface for decoders with attention by defining the quite unsur- prisingly named AttentionDecoder class. T
The Bahdanau Attention Mechanism
429

class AttentionDecoder(d2l.Decoder): #@save """The base attention-based decoder interface.""" def __init__(self): super().__init__() @property def attention_weights(self): raise NotImplementedError
We need to implement the RNN decoder in the Seq2SeqAttentionDecoder class. The state of the decoder is initialized with (i) the hidden states of the last layer of the encoder at all time steps, used as keys and values for attention; (ii) the hidden state of the encoder at all layers at the final time step, which serves to initialize the hidden state of the decoder; and (iii) the valid length of the encoder, to exclude the padding tokens in attention pooling. At each decoding time step, the hidden state of the final layer of the decoder, obtained at the previous time step, is used as the query of the attention mechanism. Both the output of the attention mechanism and the input embedding are concatenated to serve as the input of the RNN decoder. class Seq2SeqAttentionDecoder(AttentionDecoder):
def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, dropout=0): super().__init__() self.attention = d2l.AdditiveAttention(num_hiddens, dropout) self.embedding = nn.Embedding(vocab_size, embed_size) self.rnn = nn.GRU( embed_size + num_hiddens, num_hiddens, num_layers, dropout=dropout) self.dense = nn.LazyLinear(vocab_size) self.apply(d2l.init_seq2seq) def init_state(self, enc_outputs, enc_valid_lens): # Shape of outputs: (num_steps, batch_size, num_hiddens). # Shape of hidden_state: (num_layers, batch_size, num_hiddens) outputs, hidden_state = enc_outputs return (outputs.permute(1, 0, 2), hidden_state, enc_valid_lens) def forward(self, X, state): # Shape of enc_outputs: (batch_size, num_steps, num_hiddens). # Shape of hidden_state: (num_layers, batch_size, num_hiddens) enc_outputs, hidden_state, enc_valid_lens = state # Shape of the output X: (num_steps, batch_size, embed_size) X = self.embedding(X).permute(1, 0, 2) outputs, self._attention_weights = [], [] for x in X: # Shape of query: (batch_size, 1, num_hiddens) query = torch.unsqueeze(hidden_state[-1], dim=1) # Shape of context: (batch_size, 1, num_hiddens) context = self.attention( query, enc_outputs, enc_outputs, enc_valid_lens) # Concatenate on the feature dimension x = torch.cat((context, torch.unsqueeze(x, dim=1)), dim=-1)
(continues on next page)
Attention Mechanisms and Transformers
430

# Reshape x as (1, batch_size, embed_size + num_hiddens) out, hidden_state = self.rnn(x.permute(1, 0, 2), hidden_state) outputs.append(out) self._attention_weights.append(self.attention.attention_weights) # After fully connected layer transformation, shape of outputs: # (num_steps, batch_size, vocab_size) outputs = self.dense(torch.cat(outputs, dim=0)) return outputs.permute(1, 0, 2), [enc_outputs, hidden_state, enc_valid_lens] @property def attention_weights(self): return self._attention_weights
In the following, we test the implemented decoder with attention using a minibatch of four sequences, each of which are seven time steps long. vocab_size, embed_size, num_hiddens, num_layers = 10, 8, 16, 2 batch_size, num_steps = 4, 7 encoder = d2l.Seq2SeqEncoder(vocab_size, embed_size, num_hiddens, num_layers) decoder = Seq2SeqAttentionDecoder(vocab_size, embed_size, num_hiddens, num_layers) X = torch.zeros((batch_size, num_steps), dtype=torch.long) state = decoder.init_state(encoder(X), None) output, state = decoder(X, state) d2l.check_shape(output, (batch_size, num_steps, vocab_size)) d2l.check_shape(state[0], (batch_size, num_steps, num_hiddens)) d2l.check_shape(state[1][0], (batch_size, num_hiddens))
11.4.3 Training
Now that we specified the new decoder we can proceed analogously to Section 10.7.6: specify the hyperparameters, instantiate a regular encoder and a decoder with attention, and train this model for machine translation. data = d2l.MTFraEng(batch_size=128) embed_size, num_hiddens, num_layers, dropout = 256, 256, 2, 0.2 encoder = d2l.Seq2SeqEncoder( len(data.src_vocab), embed_size, num_hiddens, num_layers, dropout) decoder = Seq2SeqAttentionDecoder( len(data.tgt_vocab), embed_size, num_hiddens, num_layers, dropout) model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['<pad>'], lr=0.005) trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
After the model is trained, we use it to translate a few English sentences into French and compute their BLEU scores. (continued from previous page)
The Bahdanau Attention Mechanism
431

‚Äî train_loss ‚Äî-- val_loss
engs = ['go .', 'i lost .', 'he\'s calm .', 'i\'m home .'] fras = ['va !', 'j\'ai perdu .', 'il est calme .', 'je suis chez moi .'] preds, _ = model.predict_step( data.build(engs, fras), d2l.try_gpu(), data.num_steps) for en, fr, p in zip(engs, fras, preds): translation = [] for token in data.tgt_vocab.to_tokens(p): if token == '<eos>': break translation.append(token) print(f'{en} => {translation}, bleu,' f'{d2l.bleu(" ".join(translation), fr, k=2):.3f}')
go . => ['va', '!'], bleu,1.000 i lost . => ["j'ai", 'perdu', '.'], bleu,1.000 he's calm . => ['il', 'court', '.'], bleu,0.000 i'm home . => ['je', 'suis', 'chez', 'moi', '.'], bleu,1.000
Let‚Äôs visualize the attention weights when translating the last English sentence. We see that each query assigns non-uniform weights over key‚Äìvalue pairs. It shows that at each decod- ing step, different parts of the input sequences are selectively aggregated in the attention pooling. _, dec_attention_weights = model.predict_step( data.build([engs[-1]], [fras[-1]]), d2l.try_gpu(), data.num_steps, True) attention_weights = torch.cat( [step[0][0][0] for step in dec_attention_weights], 0) attention_weights = attention_weights.reshape((1, 1, -1, data.num_steps))
# Plus one to include the end-of-sequence token d2l.show_heatmaps( attention_weights[:, :, :, :len(engs[-1].split()) + 1].cpu(), xlabel='Key positions', ylabel='Query positions')
11.4.4 Summary
When predicting a token, if not all the input tokens are relevant, the RNN encoder‚Äìdecoder with the Bahdanau attention mechanism selectively aggregates different parts of the input
Attention Mechanisms and Transformers
432

2 g F a4 > o 36
sequence. This is achieved by treating the state (context variable) as an output of additive attention pooling. In the RNN encoder‚Äìdecoder, the Bahdanau attention mechanism treats the decoder hidden state at the previous time step as the query, and the encoder hidden states at all the time steps as both the keys and values. 11.4.5 Exercises
1.bubuReplace GRU with LSTM in the experiment. 2. Modify the experiment to replace the additive attention scoring function with the scaled dot-product. How does it influence the training efficiency?bubuDiscussions159. 159
Eres
11.5 Multi-Head Attention
a
In practice, given the same set of queries, keys, and values we may want our model to combine knowledge from different behaviors of the same attention mechanism, such as capturing dependencies of various ranges (e.g., shorter-range vs. longer-range) within a se- quence. Thus, it may be beneficial to allow our attention mechanism to jointly use different representation subspaces of queries, keys, and values. To this end, instead of performing a single attention pooling, queries, keys, and values can be transformed with ‚Ñé independently learned linear projections. Then these ‚Ñé projected queries, keys, and values are fed into attention pooling in parallel. In the end, ‚Ñé attention- pooling outputs are concatenated and transformed with another learned linear projection to produce the final output. This design is called multi-head attention, where each of the ‚Ñé attention pooling outputs is a head (Vaswani et al., 2017). Using fully connected layers to performlearnablelineartransformations,Fig.11.5.1describesmulti-headattention. import math import torch from torch import nn from d2l import torch as d2l


0.30
0.25
0.20
o Key positions
2
Multi-Head Attention
433

FC f = Concat _ f f f - f f f FC FC FC FC FC FC ‚Äî‚Äî‚Äî‚Äî‚Äî Queries Keys Values
tFig. 11.5.1 Multi-head attention, where multiple heads are concatenated then linearly transformed. 11.5.1 Model
Before providing the implementation of multi-head attention, let‚Äôs formalize this model mathematically. Given a query q 2 Rùëëùëû, a key k 2 Rùëëùëò, and a value v 2 Rùëëùë£, each attention head hùëñ (ùëñ = 1, . . ., ‚Ñé) is computed as
‚Äûùëû‚Äù
hùëñ = ùëì ‚ÄûW ùëñ q,W ùëñ k,W ùëñ v‚Äù 2 Rùëùùë£, (11.5.1)
‚Äûùëû‚Äù
‚Äûùëò‚Äù
where wi? ‚Ç¨ RPaX4q, wi) ‚Ç¨ RPKXdk and wi‚Äù? ‚Ç¨ R?¬ª*4y are learnable parameters and f is attention pooling, such as additive attention and scaled dot product attention in Section 11.3. The multi-head attention output is another linear transformation via learnable parameters W, ‚Ç¨ R?¬∞*"P¬ª of the concatenation of h heads:
Wùëú 6 6 6 6 6 h1 ... 7 7 7 7 7 2 Rùëùùëú. (11.5.2)
Based on this design, each head may attend to different parts of the input. More sophisti- cated functions than the simple weighted average can be expressed. 11.5.2 Implementation
In our implementation, we choose the scaled dot product attention for each head of the multi-head attention. To avoid significant growth of computational cost and parametriza- tion cost, we set pg = Pk = Py = Po/h. Note that h heads can be computed in parallel if we set the number of outputs of linear transformations for the query, key, and value to Pgh = pxh = pyh = po. In the following implementation, p, is specified via the argument num_hiddens. class MultiHeadAttention(d2l.Module): #@save """Multi-head attention."""
def __init__(self, num_hiddens, num_heads, dropout, bias=False, **kwargs): super().__init__()
self.num_heads = num_heads
self.attention = d2l.DotProductAttention(dropout)
self.W_q = nn.LazyLinear(num_hiddens, bias=bias)
self.W_k = nn.LazyLinear(num_hiddens, bias=bias)
self.W_v = nn.LazyLinear(num_hiddens, bias=bias)
‚Äûùëò‚Äù
‚Äûùë£‚Äù
‚Äûùë£‚Äù
2
3
h‚Ñé
4
5
(continues on next page)
Attention Mechanisms and Transformers
434

self.W_o = nn.LazyLinear(num_hiddens, bias=bias)
def forward(self, queries, keys, values, valid_lens): # Shape of queries, keys, or values: # (batch_size, no. of queries or key-value pairs, num_hiddens) # Shape of valid_lens: (batch_size,) or (batch_size, no. of queries) # After transposing, shape of output queries, keys, or values: # (batch_size * num_heads, no. of queries or key-value pairs, # num_hiddens / num_heads) queries = self.transpose_qkv(self.W_q(queries)) keys = self.transpose_qkv(self.W_k(keys)) values = self.transpose_qkv(self.W_v(values)) if valid_lens is not None: # On axis 0, copy the first item (scalar or vector) for num_heads # times, then copy the next item, and so on valid_lens = torch.repeat_interleave( valid_lens, repeats=self.num_heads, dim=0) # Shape of output: (batch_size * num_heads, no. of queries, # num_hiddens / num_heads) output = self.attention(queries, keys, values, valid_lens) # Shape of output_concat: (batch_size, no. of queries, num_hiddens) output_concat = self.transpose_output(output) return self.W_o(output_concat)
To allow for parallel computation of multiple heads, the above MultiHeadAttention class uses two transposition methods as defined below. Specifically, the transpose_output method reverses the operation of the transpose_qkv method. @d2l.add_to_class(MultiHeadAttention) #@save def transpose_qkv(self, X): """Transposition for parallel computation of multiple attention heads.""" # Shape of input X: (batch_size, no. of queries or key-value pairs, # num_hiddens). Shape of output X: (batch_size, no. of queries or # key-value pairs, num_heads, num_hiddens / num_heads) X = X.reshape(X.shape[0], X.shape[1], self.num_heads, -1) # Shape of output X: (batch_size, num_heads, no. of queries or key-value # pairs, num_hiddens / num_heads) X = X.permute(0, 2, 1, 3) # Shape of output: (batch_size * num_heads, no. of queries or key-value # pairs, num_hiddens / num_heads) return X.reshape(-1, X.shape[2], X.shape[3]) @d2l.add_to_class(MultiHeadAttention) #@save def transpose_output(self, X): """Reverse the operation of transpose_qkv.""" X = X.reshape(-1, self.num_heads, X.shape[1], X.shape[2]) X = X.permute(0, 2, 1, 3) return X.reshape(X.shape[0], X.shape[1], -1)
Let‚Äôs test our implemented MultiHeadAttention class using a toy example where keys
(continued from previous page)
Self-Attention and Positional Encoding
435

and values are the same. As a result, the shape of the multi-head attention output is (batch_size, num_queries, num_hiddens). num_hiddens, num_heads = 100, 5 attention = MultiHeadAttention(num_hiddens, num_heads, 0.5) batch_size, num_queries, num_kvpairs = 2, 4, 6 valid_lens = torch.tensor([3, 2]) X = torch.ones((batch_size, num_queries, num_hiddens)) Y = torch.ones((batch_size, num_kvpairs, num_hiddens)) d2l.check_shape(attention(X, Y, Y, valid_lens), (batch_size, num_queries, num_hiddens))
11.5.3 Summary
Multi-head attention combines knowledge of the same attention pooling via different repre- sentation subspaces of queries, keys, and values. To compute multiple heads of multi-head attention in parallel, proper tensor manipulation is needed. 11.5.4 Exercises
1. Visualize attention weights of multiple heads in this experiment. 2. Suppose that we have a trained model based on multi-head attention and we want to prune less important attention heads to increase the prediction speed. How can we de- sign experiments to measure the importance of an attention head? 160
Discussions160. 11.6 Self-Attention and Positional Encoding
es
In deep learning, we often use CNNs or RNNs to encode sequences. Now with attention mechanisms in mind, imagine feeding a sequence of tokens into an attention mechanism such that at every step, each token has its own query, keys, and values. Here, when comput- ing the value of a token‚Äôs representation at the next layer, the token can attend (via its query vector) to any other‚Äôs token (matching based on their key vectors). Using the full set of query-key compatibility scores, we can compute, for each token, a representation by build- ing the appropriate weighted sum over the other tokens. Because every token is attending to each other token (unlike the case where decoder steps attend to encoder steps), such architectures are typically described as self-attention models (Lin et al., 2017, Vaswani et al., 2017), and elsewhere described as intra-attention model (Cheng et al., 2016, Parikh et al., 2016, Paulus et al., 2017). In this section, we will discuss sequence encoding using self-attention, including using additional information for the sequence order. Attention Mechanisms and Transformers
436

import math import torch from torch import nn from d2l import torch as d2l
11.6.1 Self-Attention
Given a sequence of input tokens x),...,X, Where any x; ‚Ç¨ R?¬¢ (1 <i < n), its self-
attention outputs a sequence of the same length y1, . .bubu.,yùëõ, where
yùëñ = ùëì ‚Äûxùëñ, ‚Äûx1,x1‚Äù, . . ., ‚Äûxùëõ,xùëõ‚Äù‚Äù 2 Rùëë (11.6.1)
according to the definition of attention pooling in (11.1.1). Using multi-head attention, the following code snippet computes the self-attention of a tensor with shape (batch size, number of time steps or sequence length in tokens, ùëë). The output tensor has the same shape. num_hiddens, num_heads = 100, 5 attention = d2l.MultiHeadAttention(num_hiddens, num_heads, 0.5) batch_size, num_queries, valid_lens = 2, 4, torch.tensor([3, 2]) X = torch.ones((batch_size, num_queries, num_hiddens)) d2l.check_shape(attention(X, X, X, valid_lens), (batch_size, num_queries, num_hiddens))
11.6.2 Comparing CNNs, RNNs, and Self-Attention
Let‚Äôs compare architectures for mapping a sequence of ùëõ tokens to another one of equal
length, where each input or output token is represented by a ùëë-dimensional vector. Specif- ically, we will consider CNNs, RNNs, and self-attention. We will compare their computa- tional complexity, sequential operations, and maximum path lengths. Note that sequential operations prevent parallel computation, while a shorter path between any combination of sequence positions makes it easier to learn long-range dependencies within the sequence (Hochreiter et al., 2001). Let‚Äôs regard any text sequence as a ‚Äúone-dimensional image‚Äù. Similarly, one-dimensional CNNs can process local features such as n-grams in text. Given a sequence of length n, con- sider a convolutional layer whose kernel size is k, and whose numbers of input and output channels are both d. The computational complexity of the convolutional layer is O(knd?). As Fig. 11.6.1 shows, CNNs are hierarchical, so there are O(1) sequential operations and the maximum path length is O(n/k). For example, x; and xs are within the receptive field of a two-layer CNN with kernel size 3 in Fig. 11.6.1. When updating the hidden state of RNNs, multiplication of the d x d weight matrix and the
ùëë-dimensional hidden state has a computational complexity of O‚Äûùëë2‚Äù. Since the sequence length is ùëõ, the computational complexity of the recurrent layer is O‚Äûùëõùëë2‚Äù. According to Fig. 11.6.1, there are O‚Äûùëõ‚Äù sequential operations that cannot be parallelized and the maximum path length is also O‚Äûùëõ‚Äù. Self-Attention and Positional Encoding
437

RNN
tFig. 11.6.1 Comparing CNN (padding tokens are omitted), RNN, and self-attention architectures. In self-attention, the queries, keys, and values are all n x d matrices. Consider the scaled dot product attention in (11.3.6), where an nx d matrix is multiplied by a dn matrix, then the output n x n matrix is multiplied by an nx d matrix. As a result, the self-attention has a O(n?d) computational complexity. As we can see from Fig. 11.6.1, each token is directly connected to any other token via self-attention. Therefore, computation can be parallel with O(1) sequential operations and the maximum path length is also O(1). All in all, both CNNs and self-attention enjoy parallel computation and self-attention has the shortest maximum path length. However, the quadratic computational complexity with respect to the sequence length makes self-attention prohibitively slow for very long se- quences. 11.6.3 Positional Encoding
Unlike RNNs, which recurrently process tokens of a sequence one-by-one, self-attention ditches sequential operations in favor of parallel computation. Note that self-attention by itself does not preserve the order of the sequence. What do we do if it really matters that the model knows in which order the input sequence arrived? The dominant approach for preserving information about the order of tokens is to represent this to the model as an additional input associated with each token. These inputs are called positional encodings, and they can either be learned or fixed a priori. We now describe a simple scheme for fixed positional encodings based on sine and cosine functions (Vaswani et al., 2017). Suppose that the input representation X ‚Ç¨ R‚Äù*¬¢ contains the d-dimensional embeddings for n tokens of a sequence. The positional encoding outputs X + P using a positional embedding matrix P ‚Ç¨ R‚Äù*¬¢ of the same shape, whose element on the i" row and the
Attention Mechanisms and Transformers
438

‚Äû2ùëó‚Äùth or the ‚Äû2ùëó ‚Äö 1‚Äùth column is
. i Pi,2j = si Sama] .bubu. (11.6.2) U Pi,2j+1 = COS (camera) . At first glance, this trigonometric function design looks weird. Before we give explanations of this design, let‚Äôs first implement it in the following PositionalEncoding class. class PositionalEncoding(nn.Module): #@save """Positional encoding.""" def __init__(self, num_hiddens, dropout, max_len=1000): super().__init__() self.dropout = nn.Dropout(dropout) # Create a long enough P self.P = torch.zeros((1, max_len, num_hiddens)) X = torch.arange(max_len, dtype=torch.float32).reshape( -1, 1) / torch.pow(10000, torch.arange( 0, num_hiddens, 2, dtype=torch.float32) / num_hiddens) self.P[:, :, 0::2] = torch.sin(X) self.P[:, :, 1::2] = torch.cos(X) def forward(self, X): X = X + self.P[:, :X.shape[1], :].to(X.device) return self.dropout(X)
In the positional embedding matrix P, rows correspond to positions within a sequence and columns represent different positional encoding dimensions. In the example below, we can see that the 6th and the 7th columns of the positional embedding matrix have a higher frequency than the 8th and the 9th columns. The offset between the 6th and the 7th (same for the 8th and the 9th) columns is due to the alternation of sine and cosine functions. encoding_dim, num_steps = 32, 60 pos_encoding = PositionalEncoding(encoding_dim, 0) X = pos_encoding(torch.zeros((1, num_steps, encoding_dim))) P = pos_encoding.P[:, :X.shape[1], :] d2l.plot(torch.arange(num_steps), P[0, :, 6:10].T, xlabel='Row (position)', figsize=(6, 2.5), legend=["Col %d" % d for d in torch.arange(6, 10)])
1.0 0.5 0.0 * ‚Äî Col6, --- Col7 5, -0.5 x -1.0 0 10 20 30 40 50 60 Row (position)
Self-Attention and Positional Encoding
439

Absolute Positional Information
To see how the monotonically decreased frequency along the encoding dimension relates to absolute positional information, let‚Äôs print out the binary representations of 0,1, . .bubu.,7. As we can see, the lowest bit, the second-lowest bit, and the third-lowest bit alternate on every number, every two numbers, and every four numbers, respectively. for i in range(8): print(f'{i} in binary is {i:>03b}')
0 in binary is 000
NOMAORWNHOS
1 in binary is 001
2 in binary is 010
3 in binary is 011
4 in binary is 100
5 in binary is 101
6 in binary is 110
7 in binary is 111
In binary representations, a higher bit has a lower frequency than a lower bit. Similarly, as demonstrated in the heat map below, the positional encoding decreases frequencies along the encoding dimension by using trigonometric functions. Since the outputs are float numbers, such continuous representations are more space-efficient than binary representa- tions. P = P[0, :, :].unsqueeze(0).unsqueeze(0) d2l.show_heatmaps(P, xlabel='Column (encoding dimension)', ylabel='Row (position)', figsize=(3.5, 4), cmap='Blues')

220 S 5 8 304
= 3g ¬© ay
Column (encoding dimension)
Relative Positional Information
Besides capturing absolute positional information, the above positional encoding also al- lows a model to easily learn to attend by relative positions. This is because for any fixed
1.0

0.5
0.0
0.5
1.0
Attention Mechanisms and Transformers
440

position offset ùõø, the positional encoding at position ùëñ ‚Äö ùõø can be represented by a linear
projection of that at position ùëñ. This projection can be explained mathematically. Denoting w; = 1/ 100007//4, any pair
of ‚Äûùëùùëñ,2ùëó, ùëùùëñ,2ùëó‚Äö1‚Äù in (11.6.2) can be linearly projected to ‚Äûùëùùëñ‚Äöùõø,2ùëó, ùëùùëñ‚Äöùõø,2ùëó‚Äö1‚Äù for any fixed offset ùõø:
cos(dw;) sin(dw;)|| pia; | _ | cos(dw,) sin(iw;) + sin(6w;) cos(iw;) -sin(dw;) cos(dw;)} |pi2j+1| [- sin(6w,) sin(iw;) + cos(dw;) cos(iw;) _ [sin (i+ 6)wj) ~ [ Ken -| Pi+6,2j7 | Pi+6,2j+1 ,
where the 2 x 2 projection matrix does not depend on any position index 7. 11.6.4 Summary
In self-attention, the queries, keys, and values all come from the same place. Both CNNs and self-attention enjoy parallel computation and self-attention has the shortest maximum path length. However, the quadratic computational complexity with respect to the sequence length makes self-attention prohibitively slow for very long sequences. To use the sequence order information, we can inject absolute or relative positional information by adding po- sitional encoding to the input representations. 11.6.5 Exercises
1. Suppose that we design a deep architecture to represent a sequence by stacking self- attention layers with positional encoding. What could the possible issues be? 2. Can you design a learnable positional encoding method? 3. Canweassigndifferentlearnedembeddingsaccordingtodifferentoffsetsbetweenqueries and keys that are compared in self-attention? Hint: you may refer to relative position embeddings (Huang et al., 2018, Shaw et al., 2018). 161 Discussions161. igre
11.7 The Transformer Architecture
a
We have compared CNNs, RNNs, and self-attention in Section 11.6.2. Notably, self- attention enjoys both parallel computation and the shortest maximum path length. There- fore, it is appealing to design deep architectures by using self-attention. Unlike earlier self-attention models that still rely on RNNs for input representations (Cheng et al., 2016,
(11.6.3)
The Transformer Architecture
441

Lin et al., 2017, Paulus et al., 2017), the Transformer model is solely based on attention mechanisms without any convolutional or recurrent layer (Vaswani et al., 2017). Though originallyproposedforsequence-to-sequencelearningontextdata, Transformershavebeen pervasive in a wide range of modern deep learning applications, such as in areas to do with language, vision, speech, and reinforcement learning. import math import pandas as pd import torch from torch import nn from d2l import torch as d2l
11.7.1 Model
As an instance of the encoder‚Äìdecoder architecture, the overall architecture of the Trans- former is presented in Fig. 11.7.1. As we can see, the Transformer is composed of an en- coder and a decoder. In contrast to Bahdanau attention for sequence-to-sequence learning in Fig. 11.4.2, the input (source) and output (target) sequence embeddings are added with positional encoding before being fed into the encoder and the decoder that stack modules based on self-attention. Now we provide an overview of the Transformer architecture in Fig. 11.7.1. At a high level, the Transformer encoder is a stack of multiple identical layers, where each layer has two sublayers (either is denoted as sublayer). The first is a multi-head self-attention pooling and the second is a positionwise feed-forward network. Specifically, in the encoder self- attention, queries, keys, and values are all from the outputs of the previous encoder layer. Inspired by the ResNet design of Section 8.6, a residual connection is employed around both sublayers. In the Transformer, for any input x 2 Rùëë at any position of the sequence, we require that sublayer‚Äûx‚Äù 2 Rùëë so that the residual connection x ‚Äö sublayer‚Äûx‚Äù 2 Rùëë is feasible. This addition from the residual connection is immediately followed by layer nor- malization (Ba et al., 2016). As a result, the Transformer encoder outputs a ùëë-dimensional vector representation for each position of the input sequence. The Transformer decoder is also a stack of multiple identical layers with residual connec- tions and layer normalizations. As well as the two sublayers described in the encoder, the decoder inserts a third sublayer, known as the encoder‚Äìdecoder attention, between these two. In the encoder‚Äìdecoder attention, queries are from the outputs of the decoder‚Äôs self- attention sublayer, and the keys and values are from the Transformer encoder outputs. In the decoder self-attention, queries, keys, and values are all from the outputs of the previous decoder layer. However, each position in the decoder is allowed only to attend to all posi- tions in the decoder up to that position. This masked attention preserves the autoregressive property, ensuring that the prediction only depends on those output tokens that have been generated. We have already described and implemented multi-head attention based on scaled dot prod- ucts in Section 11.5 and positional encoding in Section 11.6.3. In the following, we will implement the rest of the Transformer model. Attention Mechanisms and Transformers
442

Add & norm Positionwise FFN Encoder iis hina Add & norm Add & norm ry Positionwise FFN nx Add & norm x = \----- ee Positional n encoding Embedding } Sources Targets Embedding
tFig. 11.7.1
The Transformer architecture. 11.7.2 Positionwise Feed-Forward Networks
The positionwise feed-forward network transforms the representation at all the sequence positions using the same MLP. This is why we call it positionwise. In the implementation below, theinputXwithshape(batchsize, numberoftimestepsorsequencelengthintokens, number of hidden units or feature dimension) will be transformed by a two-layer MLP into an output tensor of shape (batch size, number of time steps, ffn_num_outputs). class PositionWiseFFN(nn.Module): #@save """The positionwise feed-forward network.""" def __init__(self, ffn_num_hiddens, ffn_num_outputs): super().__init__() self.dense1 = nn.LazyLinear(ffn_num_hiddens) self.relu = nn.ReLU() self.dense2 = nn.LazyLinear(ffn_num_outputs) def forward(self, X): return self.dense2(self.relu(self.dense1(X)))
The following example shows that the innermost dimension of a tensor changes to the num-
Decoder
The Transformer Architecture
443

ber of outputs in the positionwise feed-forward network. Since the same MLP transforms at all the positions, when the inputs at all these positions are the same, their outputs are also identical. ffn = PositionWiseFFN(4, 8) ffn.eval() ffn(torch.ones((2, 3, 4)))[0]
tensor([[ 0.6300, 0.7739, 0.0278, 0.2508, -0.0519, 0.4881, -0.4105, 0. ‚Ü©!5163], [ 0.6300, 0.7739, 0.0278, 0.2508, -0.0519, 0.4881, -0.4105, 0.bubu‚Ü©!5163], [ 0.6300, 0.7739, 0.0278, 0.2508, -0.0519, 0.4881, -0.4105, 0. ‚Ü©!5163]], grad_fn=<SelectBackward0>)
11.7.3 Residual Connection and Layer Normalization
Now let‚Äôs focus on the ‚Äúadd & norm‚Äù component in Fig. 11.7.1. As we described at the beginning of this section, this is a residual connection immediately followed by layer nor- malization. Both are key to effective deep architectures. In Section 8.5, we explained how batch normalization recenters and rescales across the exampleswithinaminibatch. AsdiscussedinSection8.5.2, layernormalizationisthesame as batch normalization except that the former normalizes across the feature dimension, thus enjoying benefits of scale independence and batch size independence. Despite its pervasive applications in computer vision, batch normalization is usually empirically less effective than layer normalization in natural language processing tasks, where the inputs are often variable-length sequences. The following code snippet compares the normalization across different dimensions by layer normalization and batch normalization. ln = nn.LayerNorm(2) bn = nn.LazyBatchNorm1d() X = torch.tensor([[1, 2], [2, 3]], dtype=torch.float32) # Compute mean and variance from X in the training mode print('layer norm:', ln(X), '\nbatch norm:', bn(X))
layer norm: tensor([[-1.0000, 1.0000], [-1.0000, 1.0000]], grad_fn=<NativeLayerNormBackward0>) batch norm: tensor([[-1.0000, -1.0000], [ 1.0000, 1.0000]], grad_fn=<NativeBatchNormBackward0>)
Now we can implement the AddNorm class using a residual connection followed by layer normalization. Dropout is also applied for regularization. Attention Mechanisms and Transformers
444

class AddNorm(nn.Module): #@save """The residual connection followed by layer normalization.""" def __init__(self, norm_shape, dropout): super().__init__() self.dropout = nn.Dropout(dropout) self.ln = nn.LayerNorm(norm_shape) def forward(self, X, Y): return self.ln(self.dropout(Y) + X)
The residual connection requires that the two inputs are of the same shape so that the output tensor also has the same shape after the addition operation. add_norm = AddNorm(4, 0.5) shape = (2, 3, 4) d2l.check_shape(add_norm(torch.ones(shape), torch.ones(shape)), shape)
11.7.4 Encoder
With all the essential components to assemble the Transformer encoder, let‚Äôs start by im- plementing a single layer within the encoder. The following TransformerEncoderBlock class contains two sublayers: multi-head self-attention and positionwise feed-forward net- works, where a residual connection followed by layer normalization is employed around both sublayers. class TransformerEncoderBlock(nn.Module): #@save """The Transformer encoder block.""" def __init__(self, num_hiddens, ffn_num_hiddens, num_heads, dropout, use_bias=False): super().__init__() self.attention = d2l.MultiHeadAttention(num_hiddens, num_heads, dropout, use_bias) self.addnorm1 = AddNorm(num_hiddens, dropout) self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens) self.addnorm2 = AddNorm(num_hiddens, dropout) def forward(self, X, valid_lens): Y = self.addnorm1(X, self.attention(X, X, X, valid_lens)) return self.addnorm2(Y, self.ffn(Y))
As we can see, no layer in the Transformer encoder changes the shape of its input. X = torch.ones((2, 100, 24)) valid_lens = torch.tensor([3, 2]) encoder_blk = TransformerEncoderBlock(24, 48, 8, 0.5) encoder_blk.eval() d2l.check_shape(encoder_blk(X, valid_lens), X.shape)
In the following Transformer encoder implementation, we stack num_blks instances of the above TransformerEncoderBlock classes. Since we use the fixed positional encoding
The Transformer Architecture
445

whose values are always between ‚Äî1 and 1, we multiply values of the learnable input em-
beddings by the square root of the embedding dimension to rescale before summing up the input embedding and the positional encoding. class TransformerEncoder(d2l.Encoder): #@save """The Transformer encoder.""" def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout, use_bias=False): super().__init__() self.num_hiddens = num_hiddens self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_blks): self.blks.add_module("block"+str(i), TransformerEncoderBlock( num_hiddens, ffn_num_hiddens, num_heads, dropout, use_bias)) def forward(self, X, valid_lens): # Since positional encoding values are between -1 and 1, the embedding # values are multiplied by the square root of the embedding dimension # to rescale before they are summed up X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self.attention_weights = [None] * len(self.blks) for i, blk in enumerate(self.blks): X = blk(X, valid_lens) self.attention_weights[ i] = blk.attention.attention.attention_weights return X
Belowwespecifyhyperparametersto createatwo-layerTransformerencoder. Theshapeof the Transformer encoder output is (batch size, number of time steps, num_hiddens). encoder = TransformerEncoder(200, 24, 48, 8, 2, 0.5) d2l.check_shape(encoder(torch.ones((2, 100), dtype=torch.long), valid_lens), (2, 100, 24))
11.7.5 Decoder
As shown in Fig. 11.7.1, the Transformer decoder is composed of multiple identical lay- ers. Each layer is implemented in the following TransformerDecoderBlock class, which contains three sublayers: decoder self-attention, encoder‚Äìdecoder attention, and position- wise feed-forward networks. These sublayers employ a residual connection around them followed by layer normalization. As we described earlier in this section, in the masked multi-head decoder self-attention (the first sublayer), queries, keys, and values all come from the outputs of the previous decoder layer. When training sequence-to-sequence models, tokens at all the positions (time steps) of the output sequence are known. However, during prediction the output sequence is generated token by token; thus, at any decoder time step only the generated tokens can be used in the decoder self-attention. To preserve autoregression in the decoder,
Attention Mechanisms and Transformers
446

its masked self-attention specifies dec_valid_lens so that any query only attends to all positions in the decoder up to the query position. class TransformerDecoderBlock(nn.Module): # The i-th block in the Transformer decoder def __init__(self, num_hiddens, ffn_num_hiddens, num_heads, dropout, i): super().__init__() self.i = i self.attention1 = d2l.MultiHeadAttention(num_hiddens, num_heads, dropout) self.addnorm1 = AddNorm(num_hiddens, dropout) self.attention2 = d2l.MultiHeadAttention(num_hiddens, num_heads, dropout) self.addnorm2 = AddNorm(num_hiddens, dropout) self.ffn = PositionWiseFFN(ffn_num_hiddens, num_hiddens) self.addnorm3 = AddNorm(num_hiddens, dropout) def forward(self, X, state): enc_outputs, enc_valid_lens = state[0], state[1] # During training, all the tokens of any output sequence are processed # at the same time, so state[2][self.i] is None as initialized. When # decoding any output sequence token by token during prediction, # state[2][self.i] contains representations of the decoded output at # the i-th block up to the current time step if state[2][self.i] is None: key_values = X else: key_values = torch.cat((state[2][self.i], X), dim=1) state[2][self.i] = key_values if self.training: batch_size, num_steps, _ = X.shape # Shape of dec_valid_lens: (batch_size, num_steps), where every # row is [1, 2, ..., num_steps] dec_valid_lens = torch.arange( 1, num_steps + 1, device=X.device).repeat(batch_size, 1) else: dec_valid_lens = None # Self-attention X2 = self.attention1(X, key_values, key_values, dec_valid_lens) Y = self.addnorm1(X, X2) # Encoder-decoder attention. Shape of enc_outputs: # (batch_size, num_steps, num_hiddens) Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens) Z = self.addnorm2(Y, Y2) return self.addnorm3(Z, self.ffn(Z)), state
To facilitate scaled dot product operations in the encoder‚Äìdecoder attention and addition operationsintheresidualconnections, thefeaturedimension(num_hiddens)ofthedecoder is the same as that of the encoder. is the same as that of the encoder. decoder_blk = TransformerDecoderBlock(24, 48, 8, 0.5, 0) X = torch.ones((2, 100, 24)) state = [encoder_blk(X, valid_lens), valid_lens, [None]] d2l.check_shape(decoder_blk(X, state)[0], X.shape)
The Transformer Architecture
447

Now we construct the entire Transformer decoder composed of num_blks instances of TransformerDecoderBlock. In the end, a fully connected layer computes the prediction for all the vocab_size possible output tokens. Both of the decoder self-attention weights and the encoder‚Äìdecoder attention weights are stored for later visualization. class TransformerDecoder(d2l.AttentionDecoder): def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout): super().__init__() self.num_hiddens = num_hiddens self.num_blks = num_blks self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_blks): self.blks.add_module("block"+str(i), TransformerDecoderBlock( num_hiddens, ffn_num_hiddens, num_heads, dropout, i)) self.dense = nn.LazyLinear(vocab_size) def init_state(self, enc_outputs, enc_valid_lens): return [enc_outputs, enc_valid_lens, [None] * self.num_blks] def forward(self, X, state): X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self._attention_weights = [[None] * len(self.blks) for _ in range (2)] for i, blk in enumerate(self.blks): X, state = blk(X, state) # Decoder self-attention weights self._attention_weights[0][ i] = blk.attention1.attention.attention_weights # Encoder-decoder attention weights self._attention_weights[1][ i] = blk.attention2.attention.attention_weights return self.dense(X), state @property def attention_weights(self):
return self._attention_weights
11.7.6 Training
Let‚Äôs instantiate an encoder‚Äìdecoder model by following the Transformer architecture. Here we specify that both the Transformer encoder and the Transformer decoder have two layers using 4-head attention. As in Section 10.7.6, we train the Transformer model for sequence-to-sequence learning on the English‚ÄìFrench machine translation dataset. data = d2l.MTFraEng(batch_size=128) num_hiddens, num_blks, dropout = 256, 2, 0.2 ffn_num_hiddens, num_heads = 64, 4 encoder = TransformerEncoder( len(data.src_vocab), num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout) decoder = TransformerDecoder(
(continues on next page)
Attention Mechanisms and Transformers
448

len(data.tgt_vocab), num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout)
model = d2l.Seq2Seq(encoder, decoder, tgt_pad=data.tgt_vocab['<pad>'],
lr=0.001)
trainer = d2l.Trainer(max_epochs=30, gradient_clip_val=1, num_gpus=1) trainer.fit(model, data)
‚Äî train_loss ==~ val_loss epoch
After training, we use the Transformer model to translate a few English sentences into French and compute their BLEU scores. engs = ['go .', 'i lost .', 'he\'s calm .', 'i\'m home .'] fras = ['va !', 'j\'ai perdu .', 'il est calme .', 'je suis chez moi .'] preds, _ = model.predict_step( data.build(engs, fras), d2l.try_gpu(), data.num_steps) for en, fr, p in zip(engs, fras, preds): translation = [] for token in data.tgt_vocab.to_tokens(p): if token == '<eos>': break translation.append(token) print(f'{en} => {translation}, bleu,' f'{d2l.bleu(" ".join(translation), fr, k=2):.3f}')
go . => ['va', '!'], bleu,1.000 i lost . => ['je', 'perdu', '.'], bleu,0.687 he's calm . => ['il', 'est', 'mouill√©', '.'], bleu,0.658 i'm home . => ['je', 'suis', 'chez', 'moi', '.'], bleu,1.000
Let‚Äôs visualize the Transformer attention weights when translating the final English sen- tence into French. The shape of the encoder self-attention weights is (number of encoder layers, number of attention heads, num_steps or number of queries, num_steps or number of key-value pairs). _, dec_attention_weights = model.predict_step( data.build([engs[-1]], [fras[-1]]), d2l.try_gpu(), data.num_steps, True) enc_attention_weights = torch.cat(model.encoder.attention_weights, 0) shape = (num_blks, num_heads, -1, data.num_steps) enc_attention_weights = enc_attention_weights.reshape(shape)
(continued from previous page)
(continues on next page)
The Transformer Architecture
449

d2l.check_shape(enc_attention_weights, (num_blks, num_heads, data.num_steps, data.num_steps))
In the encoder self-attention, both queries and keys come from the same input sequence. Since padding tokens do not carry meaning, with specified valid length of the input se- quence no query attends to positions of padding tokens. In the following, two layers of multi-head attention weights are presented row by row. Each head independently attends based on a separate representation subspace of queries, keys, and values. d2l.show_heatmaps( enc_attention_weights.cpu(), xlabel='Key positions', ylabel='Query positions', titles=['Head %d' % i for i in range(1, 5)], figsize=(7, 3.5))
d21.show_heatmaps(
Head 1
Head 2
o 50 = 8 2 $ &
LJ
-
Head 1
Head 2
o 50 = 3 >5 & S o


i
0
5
0
Key positions Key positions Key positions Key positions
To visualize the decoder self-attention weights and the encoder‚Äìdecoder attention weights, we need more data manipulations. For example, we fill the masked attention weights with zero. Note that the decoder self-attention weights and the encoder‚Äìdecoder atten- tion weights both have the same queries: the beginning-of-sequence token followed by the output tokens and possibly end-of-sequence tokens. dec_attention_weights_2d = [head[0].tolist() for step in dec_attention_weights for attn in step for blk in attn for head in blk] dec_attention_weights_filled = torch.tensor( pd.DataFrame(dec_attention_weights_2d).fillna(0.0).values) shape = (-1, 2, num_blks, num_heads, data.num_steps) dec_attention_weights = dec_attention_weights_filled.reshape(shape) dec_self_attention_weights, dec_inter_attention_weights = \ dec_attention_weights.permute(1, 2, 3, 0, 4)
d2l.check_shape(dec_self_attention_weights,
(num_blks, num_heads, data.num_steps, data.num_steps)) d2l.check_shape(dec_inter_attention_weights, (num_blks, num_heads, data.num_steps, data.num_steps))
(continued from previous page)
Head 3
Head 4

i

0.8
0.6
Head 3
Head 4
0.4


0.2
0.0
5
0
5
0
5
Attention Mechanisms and Transformers
450

Because of the autoregressive property of the decoder self-attention, no query attends to key‚Äìvalue pairs after the query position. dec_self_attention_weights[:, :, :, :], xlabel='Key positions', ylabel='Query positions', titles=['Head %d' % i for i in range(1, 5)], figsize=(7, 3.5))
d2l.show_heatmaps(
o Head 1 50 or 2m Pal 5 5
Head 2
PLU
lh, ‚Äù
1.0 71 0.8 bpd 0.6
Head 1
Head 2
o
a
=
2 & 5 i
t) 0) Key positions Key positions Key positions _Key positions
5
5
Similar to the case in the encoder self-attention, via the specified valid length of the input sequence, noqueryfromtheoutputsequenceattends tothosepaddingtokensfromtheinput sequence. dec_inter_attention_weights, xlabel='Key positions', ylabel='Query positions', titles=['Head %d' % i for i in range(1, 5)], figsize=(7, 3.5))
d2l.show_heatmaps(
Head 1
Head 2
0 Query positions wu
=

Head 1
Head 2
Query positions w


te) Key positions Key positions Key positions Key positions
5
0
5
Although the Transformer architecture was originally proposed for sequence-to-sequence learning, as we will discover later in the book, either the Transformer encoder or the Trans- former decoder is often individually used for different deep learning tasks. 11.7.7 Summary
Head 3
Head 4
lth r I
|F ."

Head 3
Head 4
0.4

+f
0.2
0.0
0
5
0
5
Head 3
Head 4
] : P|
1

J
0.8
0.6
Head 3
Head 4
0.4

|
0.2
¬∞
o
0
5
O
5
Transformers for Vision
451

The Transformer is an instance of the encoder‚Äìdecoder architecture, though either the en- coder or the decoder can be used individually in practice. In the Transformer architec- ture, multi-head self-attention is used for representing the input sequence and the output sequence, though the decoder has to preserve the autoregressive property via a masked version. Both the residual connections and the layer normalization in the Transformer are important for training a very deep model. The positionwise feed-forward network in the Transformer model transforms the representation at all the sequence positions using the same MLP. 11.7.8 Exercises
1. Train a deeper Transformer in the experiments. How does it affect the training speed and the translation performance? 2. Is it a good idea to replace scaled dot product attention with additive attention in the Transformer? Why?bubu3. For language modeling, should we use the Transformer encoder, decoder, or both? How would you design this method? 4. What challenges can Transformers face if input sequences are very long? Why? 5. How would you improve the computational and memory efficiency of Transformers? Hint: you may refer to the survey paper by Tay et al.bubu(2020).bubuDiscussions162. 162

11.8 Transformers for Vision
eC
The Transformer architecture was initially proposed for sequence-to-sequence learning, with a focus on machine translation. Subsequently, Transformers emerged as the model of choice in various natural language processing tasks (Brown et al., 2020, Devlin et al., 2018, Radford et al., 2018, Radford et al., 2019, Raffel et al., 2020). However, in the field of computer vision the dominant architecture has remained the CNN (Chapter 8). Naturally, researchers started to wonder if it might be possible to do better by adapting Transformer models to image data. This question sparked immense interest in the computer vision com- munity. Recently, Ramachandran et al. (2019) proposed a scheme for replacing convolu- tion with self-attention. However, its use of specialized patterns in attention makes it hard to scale up models on hardware accelerators. Then, Cordonnier et al. (2020) theoretically proved that self-attention can learn to behave similarly to convolution. Empirically, 2 x 2 patches were taken from images as inputs, but the small patch size makes the model only applicable to image data with low resolutions. Without specific constraints on patch size, vision Transformers (ViTs) extract patches from images and feed them into a Transformer encoder to obtain a global representation, which
Attention Mechanisms and Transformers
452

willfinallybetransformedforclassification(Dosovitskiyetal., 2021). Notably, Transform- ers show better scalability than CNNs: and when training larger models on larger datasets, vision Transformers outperform ResNets by a significant margin. Similar to the landscape of network architecture design in natural language processing, Transformers have also be- come a game-changer in computer vision. import torch from torch import nn from d2l import torch as d2l
11.8.1 Model
Fig.11.8.1depictsthemodelarchitectureofvisionTransformers. Thisarchitectureconsists of a stem that patchifies images, a body based on the multilayer Transformer encoder, and a head that transforms the global representation into the output label. Reais¬ª Rep,
nx
Eee Positional embedding On Patch Embedding eT Lol
a
2

<>


ys
‚Äî_‚Äî_



tFig. 11.8.1
The vision Transformer architecture. In this example, an image is split into nine patches. A special ‚Äú<cls>‚Äù token and the nine Ô¨Çattened image patches are transformed via patch embedding and n Transformer encoder blocks into ten representations, respectively. The ‚Äú<cls>‚Äù representation is further transformed into the output label. Consider an input image with height ‚Ñé, width ùë§, and ùëê channels. Specifying the patch
Consider an input image with height 4, width w, and c channels. Specifying the patch height and width both as p, the image is split into a sequence of m = hw/p? patches, where each patch is flattened to a vector of length cp. In this way, image patches can be
Repy
Rep) Rep,
Reps
Rep,
Rep,
Repy
Rep







Transformers for Vision
453

treated similarly to tokens in text sequences by Transformer encoders. A special ‚Äú<cls>‚Äù (class) token and the ùëö flattened image patches are linearly projected into a sequence of ùëö ‚Äö1 vectors, summed with learnable positional embeddings. The multilayer Transformer encoder transforms ùëö ‚Äö 1 input vectors into the same number of output vector representa- tions of the same length. It works exactly the same way as the original Transformer encoder in Fig. 11.7.1, only differing in the position of normalization. Since the ‚Äú<cls>‚Äù token at- tends to all the image patches via self-attention (see Fig. 11.6.1), its representation from the Transformer encoder output will be further transformed into the output label. 11.8.2 Patch Embedding
To implement a vision Transformer, let‚Äôs start with patch embedding in Fig. 11.8.1. Split- ting an image into patches and linearly projecting these flattened patches can be simplified as a single convolution operation, where both the kernel size and the stride size are set to the patch size. class PatchEmbedding(nn.Module): def __init__(self, img_size=96, patch_size=16, num_hiddens=512): super().__init__() def _make_tuple(x): if not isinstance(x, (list, tuple)): return (x, x) return x img_size, patch_size = _make_tuple(img_size), _make_tuple(patch_size) self.num_patches = (img_size[0] // patch_size[0]) * ( img_size[1] // patch_size[1]) self.conv = nn.LazyConv2d(num_hiddens, kernel_size=patch_size, stride=patch_size) def forward(self, X): # Output shape: (batch size, no. of patches, no. of channels) return self.conv(X).flatten(2).transpose(1, 2)
In the following example, taking images with height and width of img_size as inputs, the patchembeddingoutputs(img_size//patch_size)**2patchesthatarelinearlyprojected to vectors of length num_hiddens. to vectors of length num_hiddens. img_size, patch_size, num_hiddens, batch_size = 96, 16, 512, 4 patch_emb = PatchEmbedding(img_size, patch_size, num_hiddens) X = torch.zeros(batch_size, 3, img_size, img_size) d2l.check_shape(patch_emb(X), (batch_size, (img_size//patch_size)**2, num_hiddens))
11.8.3 Vision Transformer Encoder
The MLP of the vision Transformer encoder is slightly different from the positionwise FFN of the original Transformer encoder (see Section 11.7.2). First, here the activation function uses the Gaussian error linear unit (GELU), which can be considered as a smoother version of the ReLU (Hendrycks and Gimpel, 2016). Second, dropout is applied to the output of each fully connected layer in the MLP for regularization. Attention Mechanisms and Transformers
454

class ViTMLP(nn.Module): def __init__(self, mlp_num_hiddens, mlp_num_outputs, dropout=0.5): super().__init__() self.dense1 = nn.LazyLinear(mlp_num_hiddens) self.gelu = nn.GELU() self.dropout1 = nn.Dropout(dropout) self.dense2 = nn.LazyLinear(mlp_num_outputs) self.dropout2 = nn.Dropout(dropout) def forward(self, x): return self.dropout2(self.dense2(self.dropout1(self.gelu( self.dense1(x)))))
The vision Transformer encoder block implementation just follows the pre-normalization design in Fig. 11.8.1, where normalization is applied right before multi-head attention or the MLP. In contrast to post-normalization (‚Äúadd & norm‚Äù in Fig. 11.7.1), where normal- ization is placed right after residual connections, pre-normalization leads to more effective or efficient training for Transformers (Baevski and Auli, 2018, Wang et al., 2019, Xiong et al., 2020). class ViTBlock(nn.Module): def __init__(self, num_hiddens, norm_shape, mlp_num_hiddens, num_heads, dropout, use_bias=False): super().__init__() self.ln1 = nn.LayerNorm(norm_shape) self.attention = d2l.MultiHeadAttention(num_hiddens, num_heads, dropout, use_bias) self.ln2 = nn.LayerNorm(norm_shape) self.mlp = ViTMLP(mlp_num_hiddens, num_hiddens, dropout) def forward(self, X, valid_lens=None): X = X + self.attention(*([self.ln1(X)] * 3), valid_lens) return X + self.mlp(self.ln2(X))
JustasinSection11.7.4,novisionTransformerencoderblockchangesitsinputshape. X = torch.ones((2, 100, 24)) encoder_blk = ViTBlock(24, 24, 48, 8, 0.5) encoder_blk.eval() d2l.check_shape(encoder_blk(X), X.shape)
11.8.4 Putting It All Together
The forward pass of vision Transformers below is straightforward. First, input images are fed into an PatchEmbedding instance, whose output is concatenated with the ‚Äú<cls>‚Äù token embedding. They are summed with learnable positional embeddings before dropout. Then the output is fed into the Transformer encoder that stacks num_blks instances of the ViT- Block class. Finally, the representation of the ‚Äú<cls>‚Äù token is projected by the network head. Transformers for Vision
455

class ViT(d2l.Classifier): """Vision Transformer.""" def __init__(self, img_size, patch_size, num_hiddens, mlp_num_hiddens, num_heads, num_blks, emb_dropout, blk_dropout, lr=0.1, use_bias=False, num_classes=10): super().__init__() self.save_hyperparameters() self.patch_embedding = PatchEmbedding( img_size, patch_size, num_hiddens) self.cls_token = nn.Parameter(torch.zeros(1, 1, num_hiddens)) num_steps = self.patch_embedding.num_patches + 1 # Add the cls token # Positional embeddings are learnable self.pos_embedding = nn.Parameter( torch.randn(1, num_steps, num_hiddens)) self.dropout = nn.Dropout(emb_dropout) self.blks = nn.Sequential() for i in range(num_blks): self.blks.add_module(f"{i}", ViTBlock( num_hiddens, num_hiddens, mlp_num_hiddens, num_heads, blk_dropout, use_bias)) self.head = nn.Sequential(nn.LayerNorm(num_hiddens), nn.Linear(num_hiddens, num_classes)) def forward(self, X): X = self.patch_embedding(X) X = torch.cat((self.cls_token.expand(X.shape[0], -1, -1), X), 1) X = self.dropout(X + self.pos_embedding) for blk in self.blks: X = blk(X) return self.head(X[:, 0])
11.8.5 Training
Training a vision Transformer on the Fashion-MNIST dataset is just like how CNNs were trained in Chapter 8. img_size, patch_size = 96, 16 num_hiddens, mlp_num_hiddens, num_heads, num_blks = 512, 2048, 8, 2 emb_dropout, blk_dropout, lr = 0.1, 0.1, 0.1 model = ViT(img_size, patch_size, num_hiddens, mlp_num_hiddens, num_heads, num_blks, emb_dropout, blk_dropout, lr) trainer = d2l.Trainer(max_epochs=10, num_gpus=1) data = d2l.FashionMNIST(batch_size=128, resize=(img_size, img_size)) trainer.fit(model, data)
11.8.6 Summary and Discussion
You may have noticed that for small datasets like Fashion-MNIST, our implemented vision Transformer does not outperform the ResNet in Section 8.6. Similar observations can be made even on the ImageNet dataset (1.2 million images). This is because Transformers lack those useful principles in convolution, such as translation invariance and locality (Section 7.1). However, the picture changes when training larger models on larger datasets (e.g.,
Attention Mechanisms and Transformers
456

3.0 ‚Äî train_loss 25 ‚Äî-- val_loss ‚Äî-- val_acc 2.0 15 1.0 0.5
300 million images), where vision Transformers outperform ResNets by a large margin in image classification, demonstrating intrinsic superiority of Transformers in scalability (Dosovitskiy et al., 2021). The introduction of vision Transformers has changed the land- scape of network design for modeling image data. They were soon shown to be effective on the ImageNet dataset with data-efficient training strategies of DeiT (Touvron et al., 2021). However, the quadratic complexity of self-attention (Section 11.6) makes the Transformer architecture less suitable for higher-resolution images. Towards a general-purpose back- bone network in computer vision, Swin Transformers addressed the quadratic computa- tional complexity with respect to image size (Section 11.6.2) and reinstated convolution- like priors, extending the applicability of Transformers to a range of computer vision tasks
beyond image classification with state-of-the-art results (Liu et al., 2021). 11.8.7 Exercises
1. How does the value of img_size affect training time? 2. Instead of projecting the ‚Äú<cls>‚Äù token representation to the output, how would you projecttheaveragedpatchrepresentations? Implementthischangeandseehowitaffects the accuracy.bubu3. Can you modify hyperparameters to improve the accuracy of the vision Transformer? Discussions163. Discussions !¬Æ
163 
11.9 Large-Scale Pretraining with Transformers
es
So far in our image classification and machine translation experiments, models have been trained on datasets with input‚Äìoutput examples from scratch to perform specific tasks. For example, a Transformer was trained with English‚ÄìFrench pairs (Section 11.7) so that this model can translate input English text into French. As a result, each model becomes a specific expert that is sensitive to even a slight shift in data distribution (Section 4.7). For better generalized models, or even more competent generalists that can perform multiple tasks with or without adaptation, pretraining models on large data has been increasingly common. Large-Scale Pretraining with Transformers
457

Given larger data for pretraining, the Transformer architecture performs better with an in- creased model size and training compute, demonstrating superior scaling behavior. Specif- ically, performance of Transformer-based language models scales as a power law with the amount of model parameters, training tokens, and training compute (Kaplan et al., 2020). The scalability of Transformers is also evidenced by the significantly boosted performance from larger vision Transformers trained on larger data (discussed in Section 11.8). More recent success stories include Gato, a generalist model that can play Atari, caption im- ages, chat, and act as a robot (Reed et al., 2022). Gato is a single Transformer that scales well when pretrained on diverse modalities, including text, images, joint torques, and but- ton presses. Notably, all such multimodal data is serialized into a flat sequence of tokens, which can be processed akin to text tokens (Section 11.7) or image patches (Section 11.8) by Transformers. Prior to the compelling success of pretraining Transformers for multimodal data, Trans- formers were extensively pretrained with a wealth of text. Originally proposed for machine translation, the Transformer architecture in Fig. 11.7.1 consists of an encoder for represent- ing input sequences and a decoder for generating target sequences. Primarily, Transformers can be used in three different modes: encoder-only, encoder‚Äìdecoder, and decoder-only. To conclude this chapter, we will review these three modes and explain the scalability in pretraining Transformers. 11.9.1 Encoder-Only
Whenonlythe Transformerencoder isused, asequenceofinputtokensisconvertedintothe same number of representations that can be further projected into output (e.g., classifica- tion). A Transformer encoder consists of self-attention layers, where all input tokens attend to each other. For example, vision Transformers depicted in Fig. 11.8.1 are encoder-only, converting a sequence of input image patches into the representation of a special ‚Äú<cls>‚Äù token. Since this representation depends on all input tokens, it is further projected into classification labels. This design was inspired by an earlier encoder-only Transformer pre- trained on text: BERT (Bidirectional Encoder Representations from Transformers) (Devlin et al., 2018). Pretraining BERT
BERT is pretrained on text sequences using masked language modeling: input text with randomly masked tokens is fed into a Transformer encoder to predict the masked tokens. As illustrated in Fig. 11.9.1, an original text sequence ‚ÄúI‚Äù, ‚Äúlove‚Äù, ‚Äúthis‚Äù, ‚Äúred‚Äù, ‚Äúcar‚Äù is prepended with the ‚Äú<cls>‚Äù token, and the ‚Äú<mask>‚Äù token randomly replaces ‚Äúlove‚Äù; then the cross-entropy loss between the masked token ‚Äúlove‚Äù and its prediction is to be minimized during pretraining. Note that there is no constraint in the attention pattern of Transformer encoders (right of Fig. 11.9.1) so all tokens can attend to each other. Thus, prediction of ‚Äúlove‚Äù depends on input tokens before and after it in the sequence. This is why BERT is a ‚Äúbidirectional encoder‚Äù. Without need for manual labeling, large-scale text data from books and Wikipedia can be used for pretraining BERT. Attention Mechanisms and Transformers
458

<cls> iF love this red car + + + +f f ¬´a OOO000 se OOOO0O Transformer encoder 3 tis 0 0 O O z~ OO OoOoono *: 900000 T T T T T T ‚Äúoe 0 S) S) S) <cls> iF <mask> this red car <cls> | <mask>this red car Attention
tFig. 11.9.1
Left: Pretraining BERT with masked language modeling. Prediction of the masked ‚Äúlove‚Äù token depends on all input tokens before and after ‚Äúlove‚Äù. Right: Attention pattern in the Transformer encoder. Each token along the vertical axis attends to all input tokens along the horizontal axis. Fine-Tuning BERT
The pretrained BERT can be fine-tuned to downstream encoding tasks involving single text or text pairs. During fine-tuning, additional layers can be added to BERT with randomized parameters: these parameters and those pretrained BERT parameters will be updated to fit training data of downstream tasks. Positive Transformer encoder <cls> This show is not bad. tFig. 11.9.2
Fine-tuning BERT for sentiment analysis. Fig.11.9.2illustratesfine-tuningofBERTforsentimentanalysis. TheTransformerencoder is a pretrained BERT, which takes a text sequence as input and feeds the ‚Äú<cls>‚Äù represen- tation (global representation of the input) into an additional fully connected layer to predict the sentiment. During fine-tuning, the cross-entropy loss between the prediction and the label on sentiment analysis data is minimized via gradient-based algorithms, where the additional layer is trained from scratch while pretrained parameters of BERT are updated. BERT does more than sentiment analysis. The general language representations learned by the 350-million-parameter BERT from 250 billion training tokens advanced the state of the art for natural language tasks such as single text classification, text pair classification or regression, text tagging, and question answering. You may note that these downstream tasks include text pair understanding. BERT pretrain- ing has another loss for predicting whether one sentence immediately follows the other. However, this loss was later found to be less useful when pretraining RoBERTa, a BERT variant of the same size, on 2000 billion tokens (Liu et al., 2019). Other derivatives of
input
Large-Scale Pretraining with Transformers
459

BERT improved model architectures or pretraining objectives, such as ALBERT (enforc- ing parameter sharing) (Lan et al., 2019), SpanBERT (representing and predicting spans of text) (Joshi et al., 2020), DistilBERT (lightweight via knowledge distillation) (Sanh et al., 2019), and ELECTRA (replaced token detection) (Clark et al., 2020). Moreover, BERT in- spiredTransformerpretrainingincomputervision, suchaswithvisionTransformers(Doso- vitskiyetal., 2021), SwinTransformers(Liuetal., 2021), andMAE(maskedautoencoders) (He et al., 2022). 11.9.2 Encoder‚ÄìDecoder
Since a Transformer encoder converts a sequence of input tokens into the same number of output representations, the encoder-only mode cannot generate a sequence of arbitrary length as in machine translation. As originally proposed for machine translation, the Trans- former architecture can be outfitted with a decoder that autoregressively predicts the tar- get sequence of arbitrary length, token by token, conditional on both encoder output and decoder output: (i) for conditioning on encoder output, encoder‚Äìdecoder cross-attention (multi-head attention of decoder in Fig. 11.7.1) allows target tokens to attend to all input tokens; (ii) conditioning on decoder output is achieved by a so-called causal attention (this name is common in the literature but is misleading as it has little connection to the proper study of causality) pattern (masked multi-head attention of decoder in Fig. 11.7.1), where any target token can only attend to past and present tokens in the target sequence. Topretrainencoder‚ÄìdecoderTransformersbeyondhuman-labeledmachinetranslationdata, BART (Lewis et al., 2019) and T5 (Raffel et al., 2020) are two concurrently proposed encoder‚Äìdecoder Transformers pretrained on large-scale text corpora. Both attempt to re- construct original text in their pretraining objectives, while the former emphasizes noising input (e.g., masking, deletion, permutation, and rotation) and the latter highlights multitask unification with comprehensive ablation studies. Pretraining T5
As an example of the pretrained Transformer encoder‚Äìdecoder, T5 (Text-to-Text Transfer Transformer) unifies many tasks as the same text-to-text problem: for any task, the input of the encoder is a task description (e.g., ‚ÄúSummarize‚Äù, ‚Äú:‚Äù) followed by task input (e.g., a sequence of tokens from an article), and the decoder predicts the task output (e.g., a sequence of tokens summarizing the input article). To perform as text-to-text, T5 is trained to generate some target text conditional on input text. To obtain input and output from any original text, T5 is pretrained to predict consecu- tive spans. Specifically, tokens from text are randomly replaced by special tokens where each consecutive span is replaced by the same special token. Consider the example in Fig. 11.9.3, where the original text is ‚ÄúI‚Äù, ‚Äúlove‚Äù, ‚Äúthis‚Äù, ‚Äúred‚Äù, ‚Äúcar‚Äù. Tokens ‚Äúlove‚Äù, ‚Äúred‚Äù, ‚Äúcar‚Äù are randomly replaced by special tokens. Since ‚Äúred‚Äù and ‚Äúcar‚Äù are a consecutive span, they are replaced by the same special token. As a result, the input sequence is ‚ÄúI‚Äù, ‚Äú<X>‚Äù, ‚Äúthis‚Äù, ‚Äú<Y>‚Äù, and the target sequence is ‚Äú<X>‚Äù, ‚Äúlove‚Äù, ‚Äú<Y>‚Äù, ‚Äúred‚Äù, ‚Äúcar‚Äù, ‚Äú<Z>‚Äù, where ‚Äú<Z>‚Äù is another special token marking the end. As shown in Fig. 11.9.3,
Attention Mechanisms and Transformers
460

<X> love <Y> red car <Z> Transformer encoder 1 <X> this <Y> | <X>this<Y> <X>love<Y>red car <Z> Attention input
tFig. 11.9.3
Left: Pretraining T5 by predicting consecutive spans. The original sentence is ‚ÄúI‚Äù, ‚Äúlove‚Äù, ‚Äúthis‚Äù, ‚Äúred‚Äù, ‚Äúcar‚Äù, where ‚Äúlove‚Äù is replaced by a special ‚Äú<X>‚Äù token, and consecutive ‚Äúred‚Äù, ‚Äúcar‚Äù are replaced by a special ‚Äú<Y>‚Äù token. The target sequence ends with a special ‚Äú<Z>‚Äù token. Right: Attention pattern in the Transformer encoder‚Äìdecoder. In the encoder self-attention (lower square), all input tokens attend to each other; In the encoder‚Äìdecoder cross-attention (upper rectangle), each target token attends to all input tokens; In the decoder self-attention (upper triangle), each target token attends to present and past target tokens only (causal). the decoder has a causal attention pattern to prevent itself from attending to future tokens during sequence prediction. In T5, predicting consecutive span is also referred to as reconstructing corrupted text. With this objective, T5 is pretrained with 1000 billion tokens from the C4 (Colossal Clean Crawled Corpus) data, which consists of clean English text from the web (Raffel et al., 2020). Fine-Tuning T5
Similar to BERT, T5 needs to be fine-tuned (updating T5 parameters) on task-specific train- ing data to perform this task. Major differences from BERT fine-tuning include: (i) T5 input includes task descriptions; (ii) T5 can generate sequences with arbitrary length with its Transformer decoder; (iii) No additional layers are required. Fig. 11.9.4 explains fine-tuning T5 using text summarization as an example. In this down- stream task, the task description tokens ‚ÄúSummarize‚Äù, ‚Äú:‚Äù followed by the article tokens are input to the encoder. After fine-tuning, the 11-billion-parameter T5 (T5-11B) achieved state-of-the-art results on multiple encoding (e.g., classification) and generation (e.g., summarization) benchmarks. Since released, T5 has been extensively used in later research. For example, switch Trans- formers are designed based on T5 to activate a subset of the parameters for better computa- tional efficiency (Fedus et al., 2022). In a text-to-image model called Imagen, text is input to a frozen T5 encoder (T5-XXL) with 4.6 billion parameters (Saharia et al., 2022). The
Large-Scale Pretraining with Transformers
461

Summary Oil prices extend ‚Äî slides } ft ¬¢t f ft + f Ff Transformer encoder T TTT T T T T Summarize: Oil prices slipped ... diesel taxes eoen-e HHH eee > Task description Article
tFig. 11.9.4
Fine-tuning T5 for text summarization. Both the task description and article tokens are fed into the Transformer encoder for predicting the summary. photorealistic text-to-image examples in Fig. 11.9.5 suggest that the T5 encoder alone may effectively represent text even without fine-tuning. ‚ÄòTeddy bears swimming at the Olympics 400m Butter-__A cute corgi lives in a house made out of sushi. A cute sloth holding a small treasure chest.bubuA bright fly event. golden glow is coming from the chest. tFig. 11.9.5
Text-to-image examples by the Imagen model, whose text encoder is from T5 (Ô¨Ågures taken from Saharia et al. (2022)). 11.9.3 Decoder-Only
Wehavereviewedencoder-onlyandencoder‚ÄìdecoderTransformers. Alternatively,decoder- only Transformers remove the entire encoder and the decoder sublayer with the encoder‚Äì decoder cross-attention from the original encoder‚Äìdecoder architecture depicted in Fig. 11.7.1. Nowadays, decoder-only Transformers have been the de facto architecture in large- scalelanguagemodeling (Section9.3), which leverages the world‚Äôs abundant unlabeled text corpora via self-supervised learning. GPT and GPT-2
Usinglanguagemodelingasthetrainingobjective, theGPT(generativepre-training)model chooses a Transformer decoder as its backbone (Radford et al., 2018). Following the autoregressive language model training as described in Section 9.3.3, Fig. 11.9.6 illustrates GPT pretraining with a Transformer encoder, where the target sequence is the input sequence shifted by one token. Note that the attention pattern in the Transformer
Attention Mechanisms and Transformers
462

iF like this book <eos> + + t + + ¬´- 90000 s ‚Äî_ io. OOOO Transformer decoder 5 this Ol = ‚Äî 2 like < 0 1 T T T T T <bos> i} like this book <bos> I like this book Attention input
tFig. 11.9.6
Left: Pretraining GPT with language modeling. The target sequence is the input sequence shifted by one token. Both ‚Äú<bos>‚Äù and ‚Äú<eos>‚Äù are special tokens marking the beginning and end of sequences, respectively. Right: Attention pattern in the Transformer decoder. Each token along the vertical axis attends to only its past tokens along the horizontal axis (causal). decoder enforces that each token can only attend to its past tokens (future tokens cannot be attended to because they have not yet been chosen). GPT has 100 million parameters and needs to be fine-tuned for individual downstream tasks. A much larger Transformer-decoder language model, GPT-2, was introduced one year later (Radford et al., 2019). Compared with the original Transformer decoder in GPT, pre-normalization (discussed in Section 11.8.3) and improved initialization and weight- scalingwereadoptedinGPT-2. Pretrainedon40GBoftext, the1.5-billion-parameterGPT- 2 obtained the state-of-the-art results on language modeling benchmarks and promising results on multiple other tasks without updating the parameters or architecture. GPT-3 and Beyond
GPT-2 demonstrated potential of using the same language model for multiple tasks without updating the model. This is more computationally efficient than fine-tuning, which requires model updates via gradient computation. Before explaining the more computationally efficient use of language models without pa- rameter update, recall Section 9.5 that a language model can be trained to generate a text sequence conditional on some prefix text sequence. Thus, a pretrained language model may generate the task output as a sequence without parameter update, conditional on an input sequence with the task description, task-specific input‚Äìoutput examples, and a prompt (task input). This learning paradigm is called in-context learning (Brown et al., 2020), which can be further categorized into zero-shot, one-shot, and few-shot, when there is no, one, and a few task-specific input‚Äìoutput examples (Fig. 11.9.7).bubuThese three settings were tested in GPT-3 (Brown et al., 2020), whose largest version uses data and model size about two orders of magnitude larger than those in GPT-2. GPT-3 uses the same Transformer decoder architecture as its direct predecessor GPT-2 except that attention patterns (at the right in Fig. 11.9.6) are sparser at alternating layers. Pretrained
Large-Scale Pretraining with Transformers
463

Zero-shot One-shot Output je suis malade je suis malade Transformer decoder Transformer decoder (no parameter update) {no parameter update) Input Translate English to French: i'm home -> Translate English to French: go > va | 'm home -> Task description Prompt Task description One ‚Äî Prompt example Few-shot Output je suis malade Transformer decoder (no parameter update) Input Translate English to French: go > va | i lost > jai perdu | he‚Äôs calm -> elle court | i'm home -> Task description A few examples Prompt
tFig. 11.9.7
Zero-shot, one-shot, few-shot in-context learning with language models (Transformer decoders). No parameter update is needed. 100 Aggregate Performance Across Benchmarks ‚Äîe‚Äî Few Shot ‚Äî* One Shot 80 ‚Äî*‚Äî Zero Shot Accuracy for) o & 20 02 = 0.1B 04B 0.88 13B 26B 6.7B 13B 175B Parameters in LM (Billions)
tFig. 11.9.8 Aggregate performance of GPT-3 for all 42 accuracy-denominated benchmarks (caption
adapted and Ô¨Ågure taken from Brown et al. (2020)). with 300 billion tokens, GPT-3 performs better with larger model size, where few-shot performance increases most rapidly (Fig. 11.9.8). The subsequent GPT-4 model did not fully disclose technical details in its report (OpenAI, 2023). By contrast with its predecessors, GPT-4 is a large-scale, multimodal model that can take both text and images as input and generate text output. 11.9.4 Scalability
Fig. 11.9.8 empirically demonstrates scalability of Transformers in the GPT-3 language model. For language modeling, more comprehensive empirical studies on the scalability
Attention Mechanisms and Transformers
464

of Transformers have led researchers to see promise in training larger Transformers with more data and compute (Kaplan et al., 2020). 7 TN 42 6 \ ‚Äî L=(D/5.4-1023)-9.09 | 5.6 ‚Äî‚Äî L=(N/8.8 1019)-0.076 3.9 48 3 3.6 Sa , ‚Äú0 o 3.3 3.2 Es 3.0 nn=+ L= (Crin/2.3 + 108)70-059 7 24 2 2.7 1o-¬Æ 10-7 10-5 10781071 10! 10¬∞ 10¬∞ 10¬∞ 107 10¬∞ Compute Dataset Size Parameters PF-days, non-embedding tokens non-embedding
tFig. 11.9.9
Transformer language model performance improves smoothly as we increase the model size, dataset size, and amount of compute used for training. For optimal performance all three factors must be scaled up in tandem. Empirical performance has a power-law relationship with each individual factor when not bottlenecked by the other two (caption adapted and Ô¨Ågure taken from Kaplan et al. (2020)).bubuAs shown in Fig. 11.9.9, power-law scaling can be observed in the performance with re- spect to the model size (number of parameters, excluding embedding layers), dataset size (number of training tokens), and amount of training compute (PetaFLOP/s-days, excluding embedding layers). In general, increasing all these three factors in tandem leads to better performance. However, how to increase them in tandem still remains a matter of debate (Hoffmann et al., 2022). Larger models require fewer samples _‚ÄòThe optimal model size grows smoothly to reach the same performance with the loss target and compute budget Line color indicates Test Loss 10 number of parameters _- Compute-efficient training stops far short of convergence 107 10¬∞ 10" 10-2 106 103 10¬∞ Tokens Processed Compute (PF-days)
tFig. 11.9.10 Transformer language model training runs (Ô¨Ågure taken from Kaplan et al. (2020)). As well as increased performance, large models also enjoy better sample efficiency than small models. Fig. 11.9.10 shows that large models need fewer training samples (tokens processed) to perform at the same level achieved by small models, and performance is scaled smoothly with compute. The empirical scaling behaviors in Kaplan et al. (2020) have been tested in subsequent large Transformer models. For example, GPT-3 supported this hypothesis with two more orders of magnitude in Fig. 11.9.11. Large-Scale Pretraining with Transformers
465

\\ y \\\\\ \\ Validation Loss Parameters L=2.57-C-0.088 15 4 4 ‚Äú2 0 2 4 10 10 10 10 10 10 10 Compute (PetaFLOP/s-days)
tFig. 11.9.11 GPT-3 performance (cross-entropy validation loss) follows a power-law trend with the
amount of compute used for training. The power-law behavior observed in Kaplan et al. (2020) continues for an additional two orders of magnitude with only small deviations from the predicted curve. Embedding parameters are excluded from compute and parameter counts (caption adapted and Ô¨Ågure taken from Brown et al. (2020)). 11.9.5 Large Language Models
The scalability of Transformers in the GPT series has inspired subsequent large language models. The GPT-2 Transformer decoder was used for training the 530-billion-parameter Megatron-Turing NLG (Smith et al., 2022) with 270 billion training tokens. Following the GPT-2 design, the 280-billion-parameter Gopher (Rae et al., 2021) pretrained with 300 billion tokens, performed competitively across diverse tasks. Inheriting the same architec- ture and using the same compute budget of Gopher, Chinchilla (Hoffmann et al., 2022) is a substantially smaller (70 billion parameters) model that trains for much longer (1.4 trillion training tokens), outperforming Gopher on many tasks and with more emphasis on the number of tokens than on the number of parameters. To continue the scaling line of language modeling, PaLM (Pathway Language Model) (Chowdhery et al., 2022), a 540- billion-parameter Transformer decoder with modified designs pretrained on 780 billion to- kens, outperformed average human performance on the BIG-Bench benchmark (Srivastava etal., 2022). Itslaterversion, PaLM2(Aniletal., 2023), scaleddataandmodelroughly1:1 and improved multilingual and reasoning capabilities. Other large language models, such as Minerva (Lewkowycz et al., 2022) that further trains a generalist (PaLM) and Galac- tica (Taylor et al., 2022) that is not trained on a general corpus, have shown promising quantitative and scientific reasoning capabilities. Open-sourced releases, such as OPT (Open Pretrained Transformers) (Zhang et al., 2022), BLOOM (Scao et al., 2022), and FALCON (Penedo et al., 2023), democratized research and use of large language models. Focusing on computational efficiency at inference time, the open-sourced Llama 1 (Touvron et al., 2023a) outperformed much larger models by training on more tokens than had been typically used. The updated Llama 2 (Touvron et al., 2023b) further increased the pretraining corpus by 40%, leading to product models that may match the performance of competitive close-sourced models. Attention Mechanisms and Transformers
466

Wei et al. (2022) discussed emergent abilities of large language models that are present in larger models, but not in smaller models. However, simply increasing model size does not inherently make models follow human instructions better. Sanh et al. (2021), Wei et al. (2021) have found that fine-tuning large language models on a range of datasets described via instructions can improve zero-shot performance on held-out tasks. Using reinforcement learning from human feedback, Ouyang et al. (2022) fine-tuned GPT-3 to follow a diverse set of instructions. Following the resultant InstructGPT which aligns language models with human intent via fine-tuning (Ouyang et al., 2022), ChatGPT164 can generate human-like responses (e.g., code debugging and creative writing) based on conversations with humans and can perform many natural language processing tasks zero-shot (Qin et al., 2023). Bai et al. (2022)replaced humaninputs(e.g., human-labeled data)with model outputs topartially automate the instruction tuning process, which is also known as reinforcement learning from AI feedback. 164
Largelanguagemodelsofferanexcitingprospectofformulating textinputtoinducemodels to perform desired tasks via in-context learning, which is also known as prompting. No- tably, chain-of-thought prompting (Wei et al., 2022), an in-context learning method with few-shot ‚Äúquestion, intermediate reasoning steps, answer‚Äù demonstrations, elicits the com- plex reasoning capabilities of large language models in order to solve mathematical, com- monsense, and symbolic reasoning tasks. Sampling multiple reasoning paths (Wang et al., 2023), diversifying few-shot demonstrations (Zhang et al., 2023), and reducing complex problems to sub-problems (Zhou et al., 2023) can all improve the reasoning accuracy. In fact, with simple prompts like ‚ÄúLet‚Äôs think step by step‚Äù just before each answer, large lan- guage models can even perform zero-shot chain-of-thought reasoning with decent accuracy (Kojima et al., 2022). Even for multimodal inputs consisting of both text and images, lan- guage models can perform multimodal chain-of-thought reasoning with higher accuracy than using text input only (Zhang et al., 2023). 11.9.6 Summary and Discussion
Transformers have been pretrained as encoder-only (e.g., BERT), encoder‚Äìdecoder (e.g., T5), and decoder-only (e.g., GPT series). Pretrained models may be adapted to perform different tasks with model update (e.g., fine-tuning) or not (e.g., few-shot). Scalability of Transformers suggests that better performance benefits from larger models, more training data, and more training compute. Since Transformers were first designed and pretrained for text data, this section leans slightly towards natural language processing. Nonetheless, those models discussed above can be often found in more recent models across multiple modalities. For example, (i) Chinchilla (Hoffmann et al., 2022) was further extended to Flamingo (Alayrac et al., 2022), a visual language model for few-shot learning; (ii) GPT-2 (Radford et al., 2019) and the vision Transformer encode text and images in CLIP (Con- trastive Language-Image Pre-training) (Radford et al., 2021), whose image and text em- beddings were later adopted in the DALL-E 2 text-to-image system (Ramesh et al., 2022). Although there have been no systematic studies on Transformer scalability in multimodal pretraining yet, an all-Transformer text-to-image model called Parti (Yu et al., 2022) shows potential of scalability across modalities: a larger Parti is more capable of high-fidelity image generation and content-rich text understanding (Fig. 11.9.12).bubuLarge-Scale Pretraining with Transformers
467

Parti-350M Parti-750M A portrait photo of a kangaroo wearing an orange hoodie and blue sunglasses standing on the grass in front of the Sydney Opera House holding a sign on the chest that says Welcome Friends! tFig. 11.9.12 Image examples generated from the same text by the Parti model of increasing sizes
(350M, 750M, 3B, 20B) (examples taken from Yu et al. (2022)).bubu11.9.7 Exercises
1. Is it possible to fine-tune T5 using a minibatch consisting of different tasks? Why or why not?bubuHow about for GPT-2? 2. Given a powerful language model, what applications can you think of? 3. Say that you are asked to fine-tune a language model to perform text classification by adding additional layers. Where will you add them?bubuWhy?bubu4. Consider sequence-to-sequence problems (e.g., machine translation) where the input sequence is always available throughout the target sequence prediction. What could be limitations of modeling with decoder-only Transformers? Why?bubuDiscussions165. 165
12
Optimization Algorithms
If you read the book in sequence up to this point you already used a number of optimization algorithms to train deep learning models. They were the tools that allowed us to continue updating model parameters and to minimize the value of the loss function, as evaluated on the training set. Indeed, anyone content with treating optimization as a black box device to minimize objective functions in a simple setting might well content oneself with the knowledge that there exists an array of incantations of such a procedure (with names such as ‚ÄúSGD‚Äù and ‚ÄúAdam‚Äù). To do well, however, some deeper knowledge is required. Optimization algorithms are important for deep learning. On the one hand, training a complex deep learning model can take hours, days, or even weeks. The performance of the optimization algorithm directly affects the model‚Äôs training efficiency. On the other hand, understanding the principles of different optimization algorithms and the role of their hyperparameters will enable us to tune the hyperparameters in a targeted manner to improve the performance of deep learning models. In this chapter, we explore common deep learning optimization algorithms in depth. Al- most all optimization problems arising in deep learning are nonconvex. Nonetheless, the design and analysis of algorithms in the context of convex problems have proven to be very instructive. It is for that reason that this chapter includes a primer on convex optimization and the proof for a very simple stochastic gradient descent algorithm on a convex objective function. 12.1 Optimization and Deep Learning

In this section, we will discuss the relationship between optimization and deep learning as well as the challenges of using optimization in deep learning. For a deep learning problem, we will usually define a loss function first. Once we have the loss function, we can use an optimization algorithm in attempt to minimize the loss. In optimization, a loss function is oftenreferredtoastheobjectivefunctionoftheoptimizationproblem. Bytraditionandcon- vention most optimization algorithms are concerned with minimization. If we ever need to maximize an objective there is a simple solution: just flip the sign on the objective. 468
Optimization and Deep Learning
469

12.1.1 Goal of Optimization
Although optimization provides a way to minimize the loss function for deep learning, in essence, the goals of optimization and deep learning are fundamentally different. The former is primarily concerned with minimizing an objective whereas the latter is concerned withfindingasuitablemodel, givenafiniteamountofdata. InSection3.6, wediscussedthe difference between these two goals in detail. For instance, training error and generalization error generally differ: since the objective function of the optimization algorithm is usually a loss function based on the training dataset, the goal of optimization is to reduce the training error. However, thegoalofdeeplearning(ormorebroadly, statisticalinference)istoreduce the generalization error. To accomplish the latter we need to pay attention to overfitting in addition to using the optimization algorithm to reduce the training error. %matplotlib inline import numpy as np import torch from mpl_toolkits import mplot3d from d2l import torch as d2l
To illustrate the aforementioned different goals, let‚Äôs consider the empirical risk and the risk. As described in Section 4.7.3, the empirical risk is an average loss on the training dataset while the risk is the expected loss on the entire population of data. Below we define two functions: the risk function f and the empirical risk function g. Suppose that we have only a finite amount of training data. As a result, here g is less smooth than f. def f(x): return x * torch.cos(np.pi * x) def g(x): return f(x) + 0.2 * torch.cos(5 * np.pi * x)
The graph below illustrates that the minimum of the empirical risk on a training dataset may be at a different location from the minimum of the risk (generalization error). def annotate(text, xy, xytext): #@save d2l.plt.gca().annotate(text, xy=xy, xytext=xytext, arrowprops=dict(arrowstyle='->')) x = torch.arange(0.5, 1.5, 0.01) d2l.set_figsize((4.5, 2.5)) d2l.plot(x, [f(x), g(x)], 'x', 'risk') annotate('min of\nempirical risk', (1.0, -1.2), (0.5, -1.1)) annotate('min of risk', (1.1, -1.05), (0.95, -0.5))
12.1.2 Optimization Challenges in Deep Learning
In this chapter, we are going to focus specifically on the performance of optimization algo- rithms in minimizing the objective function, rather than a model‚Äôs generalization error. In Section 3.1 we distinguished between analytical solutions and numerical solutions in opti-
Optimization Algorithms
470

0.00 -0.25 -0.50 risk -0.75 ~1.00 {min of ‚Äò .bubuempirical risk \ 7 ~ -1.25 0.6 0.8 1.0 1.2 14 x
mization problems. In deep learning, most objective functions are complicated and do not have analytical solutions. Instead, we must use numerical optimization algorithms. The optimization algorithms in this chapter all fall into this category. There are many challenges in deep learning optimization. Some of the most vexing ones are local minima, saddle points, and vanishing gradients. Let‚Äôs have a look at them. Local Minima
For any objective function ùëì ‚Äûùë•‚Äù, if the value of ùëì ‚Äûùë•‚Äù at ùë• is smaller than the values of ùëì ‚Äûùë•‚Äù
at any other points in the vicinity of ùë•, then ùëì ‚Äûùë•‚Äù could be a local minimum. If the value of ùëì ‚Äûùë•‚Äù at ùë• is the minimum of the objective function over the entire domain, then ùëì ‚Äûùë•‚Äù is the global minimum. For example, given the function
f(x) =x-cos(zx) for ‚Äî 1.0 < x < 2.0, (12.1.1)
we can approximate the local minimum and global minimum of this function. x = torch.arange(-1.0, 2.0, 0.01) d2l.plot(x, [f(x), ], 'x', 'f(x)') annotate('local minimum', (-0.3, -0.25), (-0.77, -1.0)) annotate('global minimum', (1.1, -0.95), (0.6, 0.8))
global mininjum \ -1 local minimum -1 0 1 2
The objective function of deep learning models usually has many local optima. When the numerical solution of an optimization problem is near the local optimum, the numerical
Optimization and Deep Learning
471

solution obtained by the final iteration may only minimize the objective function locally, rather than globally, as the gradient of the objective function‚Äôs solutions approaches or becomes zero. Only some degree of noise might knock the parameter out of the local minimum. In fact, this is one of the beneficial properties of minibatch stochastic gradient descent where the natural variation of gradients over minibatches is able to dislodge the parameters from local minima. Saddle Points
Besides local minima, saddle points are another reason for gradients to vanish. A saddle point is any location where all gradients of a function vanish but which is neither a global nor a local minimum. Consider the function ùëì ‚Äûùë•‚Äù = ùë•3. Its first and second derivative van- ishforùë• = 0. Optimizationmightstallatthispoint, eventhoughitisnotaminimum. x = torch.arange(-2.0, 2.0, 0.01) d2l.plot(x, [x**3], 'x', 'f(x)') annotate('saddle point', (0, -0.2), (-0.52, -5.0))
f(x) ¬∞ \ -5 saddle point
Saddle points in higher dimensions are even more insidious, as the example below shows. Consider the function f(x, y) = x?‚Äîy?. Ithas its saddle point at (0, 0). This is a maximum with respect to y and a minimum with respect to x. Moreover, it looks like a saddle, which is where this mathematical property got its name. x, y = torch.meshgrid( torch.linspace(-1.0, 1.0, 101), torch.linspace(-1.0, 1.0, 101)) z = x**2 - y**2 ax = d2l.plt.figure().add_subplot(111, projection='3d') ax.plot_wireframe(x, y, z, **{'rstride': 10, 'cstride': 10}) ax.plot([0], [0], [0], 'rx') ticks = [-1, 0, 1] d2l.plt.xticks(ticks) d2l.plt.yticks(ticks) ax.set_zticks(ticks) d2l.plt.xlabel('x') d2l.plt.ylabel('y');
We assume that the input of a function is a ùëò-dimensional vector and its output is a scalar,
Optimization Algorithms
472


so its Hessian matrix will have ùëò eigenvalues. The solution of the function could be a local
minimum, a local maximum, or a saddle point at a position where the function gradient is zero:
e When the eigenvalues of the function‚Äôs Hessian matrix at the zero-gradient position are
all positive, we have a local minimum for the function. e When the eigenvalues of the function‚Äôs Hessian matrix at the zero-gradient position are
all negative, we have a local maximum for the function. e When the eigenvalues of the function‚Äôs Hessian matrix at the zero-gradient position are
negative and positive, we have a saddle point for the function. For high-dimensional problems the likelihood that at least some of the eigenvalues are neg- ativeisquitehigh. Thismakessaddlepointsmorelikelythanlocalminima. Wewilldiscuss some exceptions to this situation in the next section when introducing convexity. In short, convex functions are those where the eigenvalues of the Hessian are never negative. Sadly, though, most deep learning problems do not fall into this category. Nonetheless it is a great tool to study optimization algorithms. Vanishing Gradients
Probably the most insidious problem to encounter is the vanishing gradient. Recall our commonly-used activation functions and their derivatives in Section 5.1.2. For instance, assume that we want to minimize the function f(x) = tanh(x) and we happen to get started at x = 4. As we can see, the gradient of f is close to nil. More specifically, f‚Äô(x) = 1 ‚Äî tanh?(x) and thus f‚Äô(4) = 0.0013. Consequently, optimization will get stuck for a long time before we make progress. This turns out to be one of the reasons that training deep learning models was quite tricky prior to the introduction of the ReLU activation function. x = torch.arange(-2.0, 5.0, 0.01) d2l.plot(x, [torch.tanh(x)], 'x', 'f(x)') annotate('vanishing gradient', (4, 1), (2, 0.0))
As we saw, optimization for deep learning is full of challenges. Fortunately there exists a robust range of algorithms that perform well and that are easy to use even for beginners. Optimization and Deep Learning
473

1.05 0.54 F(x) 0.07 vanishing gradient -0.54 -1.0-+
Furthermore, it is not really necessary to find the best solution. Local optima or even ap- proximate solutions thereof are still very useful. 12.1.3 Summary
e Minimizing the training error does not guarantee that we find the best set of parameters
to minimize the generalization error. e The optimization problems may have many local minima. e The problem may have even more saddle points, as generally the problems are not convex. e Vanishing gradients can cause optimization to stall. Often a reparametrization of the
problem helps. Good initialization of the parameters can be beneficial, too. 12.1.4 Exercises
1. Consider a simple MLP with a single hidden layer of, say, ùëë dimensions in the hid-
den layer and a single output. Show that for any local minimum there are at least ùëë! equivalent solutions that behave identically. 2. Assume that we have a symmetric random matrix M where the entries ùëÄùëñùëó = ùëÄùëóùëñ are
2. Assume that we have a symmetric random matrix M where the entries M;; = Mj; are each drawn from some probability distribution p;;. Furthermore assume that pj; (x) = pij(‚Äîx), ie., that the distribution is symmetric (see e.g., Wigner (1958) for details). 1. Prove that the distribution over eigenvalues is also symmetric. That is, for any eigen- vector v the probability that the associated eigenvalue ùúÜ satisfies ùëÉ‚ÄûùúÜ > 0‚Äù = ùëÉ‚ÄûùúÜ < 0‚Äù. 2. Why does the above not imply ùëÉ‚ÄûùúÜ > 0‚Äù = 0.5? 3. What other challenges involved in deep learning optimization can you think of? 4. Assume that you want to balance a (real) ball on a (real) saddle. 1.bubuWhy is this hard?bubu166
2. Can you exploit this effect also for optimization algorithms? Discussions166. Optimization Algorithms
474

12.2 Convexity
es
Convexity plays a vital role in the design of optimization algorithms. This is largely due to the fact that it is much easier to analyze and test algorithms in such a context. In other words, if the algorithm performs poorly even in the convex setting, typically we should not hope to see great results otherwise. Furthermore, even though the optimization problems in deep learning are generally nonconvex, they often exhibit some properties of convex ones near local minima. This can lead to exciting new optimization variants such as (Izmailov et al., 2018). %matplotlib inline import numpy as np import torch from mpl_toolkits import mplot3d from d2l import torch as d2l
12.2.1 Definitions
Before convex analysis, we need to define convex sets and convex functions. They lead to mathematical tools that are commonly applied to machine learning. Sets are the basis of convexity. Simply put, a set X in a vector space is convex if for any
ùëé, ùëè 2 X the line segment connecting ùëé and ùëè is also in X. In mathematical terms this means that for all ùúÜ 2 ¬ª0,1‚Ä¶ we have
Aa+(1‚ÄîA)b ‚Ç¨ X whenever a,b ‚Ç¨ X.bubu(12.2.1)
This sounds a bit abstract.bubuConsider Fig.bubu12.2.1. The first set is not convex since there exist line segments that are not contained in it. The other two sets suffer no such problem. tFig. 12.2.1
The Ô¨Årst set is nonconvex and the other two are convex. Definitions on their own are not particularly useful unless you can do something with them.bubuIn this case we can look at intersections as shown in Fig.bubu12.2.2. Assume that X and Y are convex sets. Then X \ Y is also convex. To see this, consider any ùëé, ùëè 2 X \ Y. Since X and Y are convex, the line segments connecting ùëé and ùëè are contained in both X and Y. Given that, they also need to be contained in X \ Y, thus proving our theorem. Convex Sets
475


tFig. 12.2.2
The intersection between two convex sets is convex. We can strengthen this result with little effort: given convex sets Xùëñ, their intersection \ùëñXùëñ
is convex. To see that the converse is not true, consider two disjoint sets X \ Y = ;. Now pick ùëé 2 X and ùëè 2 Y. The line segment in Fig. 12.2.3 connecting ùëé and ùëè needs to contain some part that is neither in X nor in Y, since we assumed that X \ Y = ;. Hence the line segment is not in X [ Y either, thus proving that in general unions of convex sets need not be convex. tFig. 12.2.3
The union of two convex sets need not be convex. Typically the problems in deep learning are defined on convex sets. For instance, Rùëë, the
Typically the problems in deep learning are defined on convex sets. For instance, R@, the set of d-dimensional vectors of real numbers, is a convex set (after all, the line between any two points in R¬¢ remains in R@). In some cases we work with variables of bounded length, such as balls of radius r as defined by {x|x ‚Ç¨ R@ and ||x|| < r}. Convex Functions
Now that we have convex sets we can introduce convex functions ùëì. Given a convex set X,
a function ùëì : X ! R is convex if for all ùë•,ùë•0 2 X and for all ùúÜ 2 ¬ª0,1‚Ä¶ we have
Af(x) + (1 - a) f(x‚Äô) = fax t (1 -a)x‚Äô). (12.2.2)
To illustrate this let‚Äôs plot a few functions and check which ones satisfy the requirement. Below we define a few functions, both convex and nonconvex. f = lambda x: 0.5 * x**2 # Convex g = lambda x: torch.cos(np.pi * x) # Nonconvex h = lambda x: torch.exp(0.5 * x) # Convex x, segment = torch.arange(-2, 2, 0.01), torch.tensor([-1.5, 1]) d2l.use_svg_display() _, axes = d2l.plt.subplots(1, 3, figsize=(9, 3)) for ax, func in zip(axes, [f, g, h]): d2l.plot([x, segment], [func(x), func(segment)], axes=ax)
Convexity
Optimization Algorithms
476


As expected, the cosine function is nonconvex, whereas the parabola and the exponential function are. Note that the requirement that X is a convex set is necessary for the condition to make sense. Otherwise the outcome of f (Ax+(1‚ÄîA)x‚Äô) might not be well defined. Jensen‚Äôs Inequality
Givenaconvexfunction ùëì, oneofthemostusefulmathematicaltoolsis Jensen‚Äôsinequality. It amounts to a generalization of the definition of convexity:
! ¬ª aj f(x) =f 2 QjX; and Ex[f(X)] = f (Ex[X]). (12.2.3) i i
where ùõºùëñ are nonnegative real numbers such that
other words, the expectation of a convex function is no less than the convex function of an expectation, where the latter is usually a simpler expression. To prove the first inequality we repeatedly apply the definition of convexity to one term in the sum at a time. One of the common applications of Jensen‚Äôs inequality is to bound a more complicated expression by a simpler one. For example, its application can be with regard to the log- likelihood of partially observed random variables. That is, we use
Ey~py)[‚Äîlog P(X | Y)] = ‚Äîlog P(X),
(12.2.4)
Ô¨Ç
since ùëÉ‚Äûùëå‚ÄùùëÉ‚Äûùëã j ùëå‚Äùùëëùëå = ùëÉ‚Äûùëã‚Äù. This can be used in variational methods. Here ùëå is typically the unobserved random variable, ùëÉ‚Äûùëå‚Äù is the best guess of how it might be distributed, and ùëÉ‚Äûùëã‚Äù is the distribution with ùëå integrated out. For instance, in clustering ùëå might be the cluster labels and ùëÉ‚Äûùëã j ùëå‚Äù is the generative model when applying cluster labels. 12.2.2 Properties
Convex functions have many useful properties. We describe a few commonly-used ones below. Àù
ùëñ ùõºùëñ = 1 and ùëã is a random variable. In
477

Local Minima Are Global Minima
First and foremost, the local minima of convex functions are also the global minima. We can prove it by contradiction as follows. Consider a convex function f defined on a convex set X. Suppose that x* ‚Ç¨ X is a local
Consider a convex function f defined on a convex set X. Suppose that x* ‚Ç¨ X is a local minimum: there exists a small positive value p so that for x ‚Ç¨ X that satisfies 0 < |x‚Äîx*| < p we have f(x*) < f(x). Assume that the local minimum x‚Äù is not the global minimum of f: there exists x‚Äô ¬¢ X
Assume that the local minimum x‚Äù is not the global minimum of f: there exists x‚Äô ¬¢ X for which f(x‚Äô) < f(x*). There also exists 2 ‚Ç¨ [0,1) such as A = 1 - al so that 0 < |ax* + (1-A)x‚Äô -x"| < p. However, according to the definition of convex functions, we have
f (Ax* + (1 = A)x‚Äô) < AF (x") + 1 - AD F(x‚Äô) <Af(x*) +(1- a) f(x") (12.2.5) =f"),
which contradicts with our statement that x* is a local minimum. Therefore, there does
which contradicts with our statement that x* is a local minimum. Therefore, there does not exist x‚Äô ‚Ç¨ X for which f(x‚Äô) < f(x*). The local minimum x‚Äù* is also the global minimum. For instance, the convex function f(x) = (x ‚Äî 1)? has a local minimum at x = 1, which is also the global minimum. f = lambda x: (x - 1) ** 2 d2l.set_figsize() d2l.plot([x, segment], [f(x), f(segment)], 'x', 'f(x)')

The fact that the local minima for convex functions are also the global minima is very convenient. It means that if we minimize functions we cannot ‚Äúget stuck‚Äù. Note, though, that this does not mean that there cannot be more than one global minimum or that there might even exist one. For instance, the function f(x) = max(|x|‚Äî 1,0) attains its minimum value over the interval [-1, 1]. Conversely, the function f(x) = exp(x) does not attain a minimum value on R: for x ‚Äî ‚Äîco it asymptotes to 0, but there is no x for which f(x) = 0. Convexity
Optimization Algorithms
478

Below Sets of Convex Functions Are Convex
We can conveniently define convex sets via below sets of convex functions. Concretely, given a convex function ùëì defined on a convex set X, any below set
def
Sp, El (alx ‚Ç¨ X and f(x) < b} (12.2.6)
is convex. Let‚Äôs prove this quickly. Recall that for any x, x‚Äô ‚Ç¨ Sp we need to show that Ax+(1‚ÄîA)x‚Äô ‚Ç¨
Let‚Äôs prove this quickly. Recall that for any x, x‚Äô ‚Ç¨ Sp we need to show that Ax+(1‚ÄîA)x‚Äô ‚Ç¨ Sp as long as A ‚Ç¨ [0, 1]. Since f(x) < b and f(x‚Äô) < b, by the definition of convexity we have
f(ax + (1=a)x‚Äô) < Af(x) + (1 - A) f(x‚Äô) < b. (12.2.7)
Convexity and Second Derivatives
Whenever the second derivative of a function ùëì : Rùëõ ! R exists it is very easy to check
Whenever the second derivative of a function f : R‚Äù ‚Äî R exists it is very easy to check whether f is convex. All we need to do is check whether the Hessian of f is positive semidefinite: V7 f > 0, i.e., denoting the Hessian matrix V?f by H, x"Hx > 0 for all x ‚Ç¨ R". For instance, the function f(x) = silx|? is convex since V7f = 1, i.e., its Hessian is an identity matrix. Formally, a twice-differentiable one-dimensional function ùëì : R ! R is convex if and only
Formally, a twice-differentiable one-dimensional function f : R ‚Äî R is convex if and only if its second derivative f‚Äù > 0. For any twice-differentiable multidimensional function f :R" SR, it is convex if and only if its Hessian V7 f > 0. First, we need to prove the one-dimensional case. To see that convexity of f implies f‚Äô‚Äù‚Äù > 0
we use the fact that
xXx-‚Ç¨E 1 1 x+e‚Ç¨ = = - = 12.2. faro+ssa-92F(5 ) = Foo. (12.2.8)
Since the second derivative is given by the limit over finite differences it follows that
im LEFF SOT OM 2f0) 2 Sf") = (12.2.9) ‚Ç¨
To see that f‚Äô‚Äù > 0 implies that f is convex we use the fact that f‚Äô‚Äù > 0 implies that f‚Äô
To see that f‚Äô‚Äù > 0 implies that f is convex we use the fact that f‚Äô‚Äù > 0 implies that f‚Äô is a monotonically nondecreasing function. Let a < x < b be three points in R, where = (1-A)a+Ab and A ‚Ç¨ (0,1). According to the mean value theorem, there exist a ‚Ç¨ [a,x] and B ‚Ç¨ [x, b] such that
fay ia) 1) f(a) = and f‚Äô(p) = LO= 10) F0) (12.2.10)
By monotonicity f‚Äô(8) = Po).t hence
b +27" F(a) > f(x). (12.2.11) b-a
Since x = (1 ‚Äî A)a + Ab, we have
Af(b) + (1-a) f(a) = f(A -A)a+ ab), (12.2.12)
x+e‚Ç¨
xXx-‚Ç¨E
LO=
b
479

thus proving convexity. Second, we need a lemma before proving the multidimensional case: ùëì : Rùëõ ! R is convex
if and only if for all x,y 2 Rùëõ
g(z) & f(zx+ (1 2)y) where z ‚Ç¨ [0, 1] (12.2.13)
is convex. Toprovethatconvexityof ùëì impliesthat ùëî isconvex, wecanshowthatforall ùëé, ùëè,ùúÜ 2 ¬ª0,1‚Ä¶
To prove that convexity of f implies that g is convex, we can show that for all a, b, A ‚Ç¨ [0, 1] (thus 0 < Ada+(1-A)b < 1)
g(Aa+ (1 -A)b) =f ((Aa+(1-A)b)x+ (1 -Aa- (1-A)b) y) =f (A(ax+ (1 -a)y) + (1 - A) (bx + (1 - b)y)) (12.2.14) <Af (ax+(1-a)y)+(1-A)f (bx + (1 - b)y) =Ag(a) + (1 -A)g(d). To prove the converse, we can show that for all ùúÜ 2 ¬ª0,1‚Ä¶
f(ax+ (1 - ayy) =g(A-1+(1-A)-0) <Ag(1) + (1 - 2)g(0) =Af(x) + (1 - a) f(y). (12.2.15)
Finally, using the lemma above and the result of the one-dimensional case, the multidimen- sional case can be proven as follows. A multidimensional function f : R‚Äù ‚Äî R is convex if and only if for all x,y ‚Ç¨ R" g(z) ef Sf (zx + (1 - z)y), where z ‚Ç¨ [0, 1], is convex. Ac- cording to the one-dimensional case, this holds if and only if g‚Äù = (x - y)"H(x-y) > 0 (H a V* f) for all x, y ‚Ç¨ R‚Äù, which is equivalent to H > 0 per the definition of positive semidefinite matrices. 12.2.3 Constraints
Oneofthenicepropertiesofconvexoptimizationisthatitallowsustohandleconstraintsef- ficiently. Thatis,itallowsustosolveconstrainedoptimizationproblemsoftheform:
ùëì ‚Äûx‚Äù
minimize f(x) x (12.2.16) subject to c;(x) < 0 for alli ‚Ç¨ {1,...,n},
where ùëì is the objective and the functions ùëêùëñ are constraint functions. To see what this does
where f is the objective and the functions c; are constraint functions. To see what this does consider the case where c1(x) = ||x||2 ‚Äî 1. In this case the parameters x are constrained to the unit ball. If a second constraint is c2(x) = v'x+ b, then this corresponds to all x lying on a half-space. Satisfying both constraints simultaneously amounts to selecting a slice of a ball. Convexity
Optimization Algorithms
480

In general, solving a constrained optimization problem is difficult. One way of addressing it stems from physics with a rather simple intuition.bubuImagine a ball inside a box. The ball will roll to the place that is lowest and the forces of gravity will be balanced out with the forces that the sides of the box can impose on the ball. In short, the gradient of the objective function (i.e., gravity) will be offset by the gradient of the constraint function (the ball need to remain inside the box by virtue of the walls ‚Äúpushing back‚Äù). Note that some constraints may not be active: the walls that are not touched by the ball will not be able to exert any force on the ball. Skipping over the derivation of the Lagrangian ùêø, the above reasoning can be expressed
via the following saddle point optimization problem:
h L(x, Q1,...,0n) = f(x) + ¬ª ajci(x) where a; > 0. (12.2.17) i=l
Here the variables ùõºùëñ (ùëñ = 1, .bubu. .,ùëõ) are the so-called Lagrange multipliers that ensure that
Here the variables a; (i = 1,...,) are the so-called Lagrange multipliers that ensure that constraints are properly enforced. They are chosen just large enough to ensure that c;(x) < 0 for all 7.bubuFor instance, for any x where c;(x) < 0 naturally, we'd end up picking a; = 0. Moreover, this is a saddle point optimization problem where one wants to maximize L with respect to all a; and simultaneously minimize it with respect to x. There is a rich body of literature explaining how to arrive at the function L(x, @1,...,@¬ª). For our purposes it is sufficient to know that the saddle point of L is where the original constrained optimization problem is solved optimally. One way of satisfying constrained optimization problems at least approximately is to adapt the Lagrangian L. Rather than satisfying c;(x) < 0 we simply add a;c;(x) to the objective function f(x). This ensures that the constraints will not be violated too badly.bubuIn fact, we have been using this trick all along. Consider weight decay in Section 3.7. In it we add 4\|wll? to the objective function to ensure that w does not grow too large. From the constrained optimization point of view we can see that this will ensure that ||w1|? ‚Äîr?bubu< 0 for some radius r. Adjusting the value of 2 allows us to vary the size of w. In general, adding penalties is a good way of ensuring approximate constraint satisfaction. In practice this turns out to be much more robust than exact satisfaction. Furthermore, for nonconvex problems many of the properties that make the exact approach so appealing in the convex case (e.g., optimality) no longer hold. An alternative strategy for satisfying constraints is projections. Again, we encountered them before, e.g., when dealing with gradient clipping in Section 9.5. There we ensured
Lagrangian
h
Penalties
Projections
481

that a gradient has length bounded by ùúÉ via
g<‚Äîg-min(1,6/|lgll). (12.2.18)
This turns out to be a projection of g onto the ball of radius ùúÉ. More generally, a projection
on a convex set X is defined as
Proj x(x) = argmin ||x - x‚Äô ||, (12.2.19) x‚ÄôeX
which is the closest point in X to x. tFig. 12.2.4 Convex Projections. The mathematical definition of projections may sound a bit abstract. Fig.bubu12.2.4 explains it somewhat more clearly. In it we have two convex sets, a circle and a diamond. Points inside both sets (yellow) remain unchanged during projections. Points outside both sets (black) are projected to the points inside the sets (red) that are closet to the original points (black). While for ‚Ñì2 balls this leaves the direction unchanged, this need not be the case in general, as can be seen in the case of the diamond. One of the uses for convex projections is to compute sparse weight vectors. In this case we project weight vectors onto an ‚Ñì1 ball, which is a generalized version of the diamond case in Fig. 12.2.4. 12.2.4 Summary
In the context of deep learning the main purpose of convex functions is to motivate opti- mization algorithms and help us understand them in detail. In the following we will see how gradient descent and stochastic gradient descent can be derived accordingly. e Intersections of convex sets are convex. Unions are not. The expectation of a convex function is no less than the convex function of an expectation
(Jensen‚Äôs inequality). A twice-differentiable function is convex if and only if its Hessian (a matrix of second
derivatives) is positive semidefinite. e Convex constraints can be added via the Lagrangian. In practice we may simply add
them with a penalty to the objective function. Projections map to points in the convex set closest to the original points. Convexity
Optimization Algorithms
482

12.2.5 Exercises
1. Assume that we want to verify convexity of a set by drawing all lines between points within the set and checking whether the lines are contained. 1. Prove that it is sufficient to check only the points on the boundary. 2. Prove that it is sufficient to check only the vertices of the set. 2. Denote by Bùëù¬ªùëü‚Ä¶ def
a {x|x ‚Ç¨ R@ and ||x||, < r} the ball of radius r using the p-norm. 2. Denote by 8,[r] a {x|x ‚Ç¨ R@ and ||x||, < r} the ball of radius r using the p-norm. Prove that 8B, [r] is convex for all p > 1. 3. Givenconvexfunctions ùëì andùëî,showthatmax‚Äû ùëì,ùëî‚Äù isconvex,too. Provethatmin‚Äû ùëì,ùëî‚Äù
is not convex. 4. Prove that the normalization of the softmax function is convex. More specifically prove Àù the convexity of ùëì ‚Äûùë•‚Äù = log ùëñ exp‚Äûùë•ùëñ‚Äù. 5. Prove that linear subspaces, i.e., X = fxjWx = bg, are convex sets. 6. Prove that in the case of linear subspaces with b = 0 the projection ProjX can be written as Mx for some matrix M. 7. Show that for twice-differentiable convex functions ùëì we can write ùëì ‚Äûùë• ‚Äö ùúñ‚Äù = ùëì ‚Äûùë•‚Äù ‚Äö
ùúñ ùëì 0‚Äûùë•‚Äù ‚Äö 1 ùúñ2 ùëì 00‚Äûùë• ‚Äö ùúâ‚Äù for some ùúâ 2 ¬ª0,ùúñ‚Ä¶. 2
8. Given a convex set X and two vectors x and y, prove that projections never increase
8. Given a convex set X and two vectors x and y, prove that projections never increase distances, i.e., ||x ‚Äî y|] = ||Projy (x) ‚Äî Proj (y)|I. 167

Discussions167.bubu12.3 Gradient Descent

In this section we are going to introduce the basic concepts underlying gradient descent. Although it is rarely used directly in deep learning, an understanding of gradient descent is key to understanding stochastic gradient descent algorithms. For instance, the optimization problem might diverge due to an overly large learning rate. This phenomenon can already be seen in gradient descent. Likewise, preconditioning is a common technique in gradient descent and carries over to more advanced algorithms. Let‚Äôs start with a simple special case. 12.3.1 One-Dimensional Gradient Descent
Gradient descent in one dimension is an excellent example to explain why the gradient descent algorithm may reduce the value of the objective function. Consider some con- tinuously differentiable real-valued function ùëì : R ! R. Using a Taylor expansion we
Gradient Descent
483

obtain
ùëì ‚Äûùë• ‚Äö ùúñ‚Äù = ùëì ‚Äûùë•‚Äù ‚Äö ùúñ ùëì 0‚Äûùë•‚Äù ‚Äö O‚Äûùúñ2‚Äù. (12.3.1)
That is, in first-order approximation ùëì ‚Äûùë• ‚Äö ùúñ‚Äù is given by the function value ùëì ‚Äûùë•‚Äù and the
That is, in first-order approximation f(x + ‚Ç¨) is given by the function value f(x) and the first derivative f‚Äô(x) at x. It is not unreasonable to assume that for small ‚Ç¨ moving in the direction of the negative gradient will decrease f. To keep things simple we pick a fixed step size 7 > 0 and choose ‚Ç¨ = ‚Äî7 f‚Äô(x). Plugging this into the Taylor expansion above we get
f(x=nf'(2)) =f) - nf(x) + OCP f7 (x). (12.3.2)
If the derivative ùëì 0‚Äûùë•‚Äù ‚â† 0 does not vanish we make progress since ùúÇ ùëì 02‚Äûùë•‚Äù > 0. Moreover,
we can always choose ùúÇ small enough for the higher-order terms to become irrelevant. Hence we arrive at
f(x = nf") & FQ). (12.3.3)
This means that, if we use
xox-nf'(x)
(12.3.4)
to iterate ùë•, the value of function ùëì ‚Äûùë•‚Äù might decline. Therefore, in gradient descent we first choose an initial value ùë• and a constant ùúÇ > 0 and then use them to continuously iterate ùë• until the stop condition is reached, for example, when the magnitude of the gradient j ùëì 0‚Äûùë•‚Äùj is small enough or the number of iterations has reached a certain value. For simplicity we choose the objective function ùëì ‚Äûùë•‚Äù = ùë•2 to illustrate how to implement gradient descent. Although we know that ùë• = 0 is the solution to minimize ùëì ‚Äûùë•‚Äù, we still use this simple function to observe how ùë• changes. %matplotlib inline import numpy as np import torch from d2l import torch as d2l
def f(x): # Objective function return x ** 2 def f_grad(x): # Gradient (derivative) of the objective function return 2 * x
Next, we use ùë• = 10 as the initial value and assume ùúÇ = 0.2. Using gradient descent to
iterate ùë• for 10 times we can see that, eventually, the value of ùë• approaches the optimal solution. def gd(eta, f_grad): x = 10.0 results = [x]
(continues on next page)
Optimization Algorithms
484

for i in range(10): x -= eta * f_grad(x) results.append(float(x)) print(f'epoch 10, x: {x:f}') return results results = gd(0.2, f_grad)
epoch 10, x: 0.060466
The progress of optimizing over ùë• can be plotted as follows. def show_trace(results, f): n = max(abs(min(results)), abs(max(results))) f_line = torch.arange(-n, n, 0.01) d2l.set_figsize() d2l.plot([f_line, results], [[f(x) for x in f_line], [ f(x) for x in results]], 'x', 'f(x)', fmts=['-', '-o']) show_trace(results, f)
100 80 60 f(x) 40 20 -10 5 i} 5 10
Learning Rate
The learning rate ùúÇ can be set by the algorithm designer. If we use a learning rate that is too
small, it will cause ùë• to update very slowly, requiring more iterations to get a better solu- tion.bubuTo show what happens in such a case, consider the progress in the same optimization problem for ùúÇ = 0.05. As we can see, even after 10 steps we are still very far from the optimal solution. show_trace(gd(0.05, f_grad), f)
epoch 10, x: 3.486784
Conversely, if we use an excessively high learning rate, jùúÇ ùëì 0‚Äûùë•‚Äùj might be too large for
the first-order Taylor expansion formula. That is, the term O‚ÄûùúÇ2 ùëì 02‚Äûùë•‚Äù‚Äù in (12.3.2) might
(continued from previous page)
Gradient Descent
485

100 80 60 f(x) 40 20 -10 5 0 5 10
become significant. In this case, we cannot guarantee that the iteration of ùë• will be able to
lower the value of ùëì ‚Äûùë•‚Äù. For example, when we set the learning rate to ùúÇ = 1.1, ùë• overshoots the optimal solution ùë• = 0 and gradually diverges. show_trace(gd(1.1, f_grad), f)
epoch 10, x: 61.917364
4000 3000 = 2000 1000 0 -50 -25 0 25 50 x
Local Minima
To illustrate what happens for nonconvex functions consider the case of f(x) = x - cos(cx)
for some constant ùëê. This function has infinitely many local minima. Depending on our choice of the learning rate and depending on how well conditioned the problem is, we may end up with one of many solutions. The example below illustrates how an (unrealistically) high learning rate will lead to a poor local minimum. c = torch.tensor(0.15 * np.pi) def f(x): # Objective function return x * torch.cos(c * x) def f_grad(x): # Gradient of the objective function return torch.cos(c * x) - c * x * torch.sin(c * x) show_trace(gd(2, f_grad), f)
Optimization Algorithms
486

epoch 10, x: -1.528166
F(x) ¬∞ -10 -5 0 5 10
12.3.2 Multivariate Gradient Descent
Now that we have a better intuition of the univariate case, let‚Äôs consider the situation where x = ¬ªùë•1,ùë•2, . .bubu.,ùë•ùëë‚Ä¶>. That is, the objective function ùëì : Rùëë ! R maps vectors into scalars. Correspondingly its gradient is multivariate, too. It is a vector consisting of ùëë partial derivatives:
rùëì ‚Äûx‚Äù = ùúï ùëì ‚Äûx‚Äù ùúïùë•1 , ùúï ùëì ‚Äûx‚Äù ùúïùë•2 , . . ., ùúï ùëì ‚Äûx‚Äù ùúïùë•ùëë . (12.3.5)
Each partial derivative element 6 f (x)/0x; in the gradient indicates the rate of change of
ùëì at x with respect to the input ùë•ùëñ. As before in the univariate case we can use the cor- responding Taylor approximation for multivariate functions to get some idea of what we should do. In particular, we have that
ùëì ‚Äûx ‚Äö ùùê‚Äù = ùëì ‚Äûx‚Äù ‚Äö ùùê>rùëì ‚Äûx‚Äù ‚Äö O‚Äûkùùêk2‚Äù. (12.3.6)
Inotherwords, uptosecond-ordertermsinùùê thedirectionofsteepestdescentisgivenbythe
In other words, up to second-order terms in ‚Ç¨ the direction of steepest descent is given by the negative gradient ‚ÄîV f(x). Choosing a suitable learning rate 7 > 0 yields the prototypical gradient descent algorithm:
x x-nVf(x). (12.3.7)
To see how the algorithm behaves in practice let‚Äôs construct an objective function ùëì ‚Äûx‚Äù =
To see how the algorithm behaves in practice let‚Äôs construct an objective function f(x) = xt + 2x3 with a two-dimensional vector x = [x1,x2]" as input and a scalar as output. The gradient is given by V f(x) = [2x1,4x2]'. We will observe the trajectory of x by gradient descent from the initial position [‚Äî5, ‚Äî2]. To begin with, we need two more helper functions. The first uses an update function and ap- plies it 20 times to the initial value. The second helper visualizes the trajectory of x. def train_2d(trainer, steps=20, f_grad=None): #@save """Optimize a 2D objective function with a customized trainer.""" # `s1` and `s2` are internal state variables that will be used in Momentum, ‚Ü©! adagrad, RMSProp
|"
(continues on next page)
Gradient Descent
487

x1, x2, s1, s2 = -5, -2, 0, 0 results = [(x1, x2)] for i in range(steps): if f_grad: x1, x2, s1, s2 = trainer(x1, x2, s1, s2, f_grad) else: x1, x2, s1, s2 = trainer(x1, x2, s1, s2) results.append((x1, x2)) print(f'epoch {i + 1}, x1: {float(x1):f}, x2: {float(x2):f}') return results
def show_trace_2d(f, results): #@save """Show the trace of 2D variables during optimization.""" d2l.set_figsize() d2l.plt.plot(*zip(*results), '-o', color='#ff7f0e') x1, x2 = torch.meshgrid(torch.arange(-5.5, 1.0, 0.1), torch.arange(-3.0, 1.0, 0.1), indexing='ij') d2l.plt.contour(x1, x2, f(x1, x2), colors='#1f77b4') d2l.plt.xlabel('x1') d2l.plt.ylabel('x2')
Next, we observe the trajectory of the optimization variable x for learning rate ùúÇ = 0.1. We can see that after 20 steps the value of x approaches its minimum at ¬ª0,0‚Ä¶. Progress is
fairly well-behaved albeit rather slow. def f_2d(x1, x2): # Objective function return x1 ** 2 + 2 * x2 ** 2 def f_2d_grad(x1, x2): # Gradient of the objective function return (2 * x1, 4 * x2) def gd_2d(x1, x2, s1, s2, f_grad): g1, g2 = f_grad(x1, x2) return (x1 - eta * g1, x2 - eta * g2, 0, 0) eta = 0.1 show_trace_2d(f_2d, train_2d(gd_2d, f_grad=f_2d_grad))
epoch 20, x1: -0.057646, x2: -0.000073

(continued from previous page)
Optimization Algorithms
488

12.3.3 Adaptive Methods
As we could see in Section 12.3.1, getting the learning rate ùúÇ ‚Äújust right‚Äù is tricky. If we
pick it too small, we make little progress.bubuIf we pick it too large, the solution oscillates and in the worst case it might even diverge. What if we could determine ùúÇ automatically or get rid of having to select a learning rate at all? Second-order methods that look not only at the value and gradient of the objective function but also at its curvature can help in this case. While these methods cannot be applied to deep learning directly due to the computational cost, they provide useful intuition into how to design advanced optimization algorithms that mimic many of the desirable properties of the algorithms outlined below. Newton‚Äôs Method
Reviewing the Taylor expansion of some function ùëì : Rùëë ! R there is no need to stop after
the first term. In fact, we can write it as
ùëì ‚Äûx ‚Äö ùùê‚Äù = ùëì ‚Äûx‚Äù ‚Äö ùùê>rùëì ‚Äûx‚Äù ‚Äö 1 2 ùùê>r2 ùëì ‚Äûx‚Äùùùê ‚Äö O‚Äûkùùêk3‚Äù. (12.3.8)
To avoid cumbersome notation we define H ‚Äú y? f(x) to be the Hessian of f, which is ad x d matrix. For small d and simple problems H is easy to compute. For deep neural networks, on the other hand, H may be prohibitively large, due to the cost of storing O(a‚Äù) entries. Furthermore it may be too expensive to compute via backpropagation. For now let‚Äôs ignore such considerations and look at what algorithm we would get. After all, the minimum of ùëì satisfies rùëì = 0. Following calculus rules in Section 2.4.3, by taking derivatives of (12.3.8) with regard to ùùê and ignoring higher-order terms we arrive at
V f (x) + He = 0 and hence ‚Ç¨ = -H7'V f(x). (12.3.9)
That is, we need to invert the Hessian H as part of the optimization problem. As a simple example, for f(x) = 3x? we have V f(x) = x and H = 1. Hence for any x we obtain ¬´ = ‚Äîx. In other words, a single step is sufficient to converge perfectly without the need for any adjustment! Alas, we got a bit lucky here: the Taylor expansion was exact since f(x +) = $x? + ext $e.bubu2
2
Let‚Äôs see what happens in other problems. Given a convex hyperbolic cosine function ùëì ‚Äûùë•‚Äù = cosh‚Äûùëêùë•‚Äù for some constant ùëê, we can see that the global minimum at ùë• = 0 is reached after a few iterations. c = torch.tensor(0.5) def f(x): # Objective function return torch.cosh(c * x) def f_grad(x): # Gradient of the objective function return c * torch.sinh(c * x)
(continues on next page)
Gradient Descent
489

def f_hess(x): # Hessian of the objective function return c**2 * torch.cosh(c * x) def newton(eta=1): x = 10.0 results = [x] for i in range(10): x -= eta * f_grad(x) / f_hess(x) results.append(float(x)) print('epoch 10, x:', x) return results show_trace(newton(), f)
epoch 10, x: tensor(0.)

Now let‚Äôs consider a nonconvex function, such as ùëì ‚Äûùë•‚Äù = ùë• cos‚Äûùëêùë•‚Äù for some constant ùëê. After all, note that in Newton‚Äôs method we end up dividing by the Hessian. This means that if the second derivative is negative we may walk into the direction of increasing the value of ùëì. That is a fatal flaw of the algorithm. Let‚Äôs see what happens in practice. c = torch.tensor(0.15 * np.pi) def f(x): # Objective function return x * torch.cos(c * x) def f_grad(x): # Gradient of the objective function return torch.cos(c * x) - c * x * torch.sin(c * x) def f_hess(x): # Hessian of the objective function return - 2 * c * torch.sin(c * x) - x * c**2 * torch.cos(c * x) show_trace(newton(), f)
epoch 10, x: tensor(26.8341)
This went spectacularly wrong. How can we fix it? One way would be to ‚Äúfix‚Äù the Hessian by taking its absolute value instead. Another strategy is to bring back the learning rate. (continued from previous page)
Optimization Algorithms
490

20 10 F(x) ¬∞ -10 -20
This seems to defeat the purpose, but not quite. Having second-order information allows us to be cautious whenever the curvature is large and to take longer steps whenever the objective function is flatter. Let‚Äôs see how this works with a slightly smaller learning rate, say ùúÇ = 0.5. As we can see, we have quite an efficient algorithm. show_trace(newton(0.5), f)
epoch 10, x: tensor(7.2699)

Convergence Analysis
We only analyze the convergence rate of Newton‚Äôs method for some convex and three times differentiable objective function ùëì, where the second derivative is nonzero, i.e., ùëì 00 > 0. The multivariate proof is a straightforward extension of the one-dimensional argument be- low and omitted since it does not help us much in terms of intuition. Denote by x(*) the value of x at the k"" iteration and let e*) = x") ‚Äîx* be the distance from optimality at the k" iteration. By Taylor expansion we have that the condition f‚Äô(x*) = 0 can be written as
O= FO ~ el) = fe) ‚Äî OM FO) + seey7yme, (12.3.10)
which holds for some √© ‚Ç¨ [x ‚Äî ex], Dividing the above expansion by f‚Äù‚Äô (x)
Gradient Descent
491

yields
1 (Ck) rr glk) oth) ‚Äî fa) =H(e Got (E‚Äù) (12.3.1) fF!) Lx (x) *
Recall that we have the update x4*)) = x ‚Äî f(x) / (x). Plugging in this update equation and taking the absolute value of both sides, we have
(elt fEIL L(g) 2 Fa)‚Äù lee] = 5 (12.3.12)
Consequently, whenever we are in a region of bounded have a quadratically decreasing error
jew < c(e)?2, (12.3.13)
As an aside, optimization researchers call this /inear convergence, whereas a condition such as Je] <a je| would be called a constant rate of convergence. Note that this analysis comes with a number of caveats. First, we do not really have much of a guarantee when we will reach the region of rapid convergence. Instead, we only know that once we reach it, convergence will be very quick. Second, this analysis requires that f is well-behaved up to higher-order derivatives. It comes down to ensuring that f does not have any ‚Äúsurprising‚Äù properties in terms of how it might change its values. Preconditioning
Quite unsurprisingly computing and storing the full Hessian is very expensive. It is thus desirable to find alternatives. One way to improve matters is preconditioning. It avoids computing the Hessian in its entirety but only computes the diagonal entries. This leads to update algorithms of the form
x ‚Äî x ‚Äî ndiag(H)~'V f(x). (12.3.14)
While this is not quite as good as the full Newton‚Äôs method, it is still much better than not using it. To see why this might be a good idea consider a situation where one variable denotes height in millimeters and the other one denotes height in kilometers. Assuming that for both the natural scale is in meters, we have a terrible mismatch in parametrizations. Fortunately, using preconditioning removes this. Effectively preconditioning with gradient descent amounts to selecting a different learning rate for each variable (coordinate of vector x). Aswewillseelater, preconditioningdrivessomeoftheinnovationinstochasticgradient descent optimization algorithms. Gradient Descent with Line Search
One of the key problems in gradient descent is that we might overshoot the goal or make insufficient progress. A simple fix for the problem is to use line search in conjunction with gradient descent. That is, we use the direction given by V f(x) and then perform binary search as to which learning rate 7 minimizes f(x ‚Äî 7V f(x)). [(2f'(x)) < c, we
Optimization Algorithms
492

This algorithm converges rapidly (for an analysis and proof see e.g., Boyd and Vanden- berghe (2004)). However, for the purpose of deep learning this is not quite so feasible, since each step of the line search would require us to evaluate the objective function on the entire dataset. This is way too costly to accomplish. 12.3.4 Summary
e Learning rates matter. Too large and we diverge, too small and we do not make progress. e Gradient descent can get stuck in local minima. e In high dimensions adjusting the learning rate is complicated. e Preconditioning can help with scale adjustment. e Newton‚Äôs method is a lot faster once it has started working properly in convex problems. e Beware of using Newton‚Äôs method without any adjustments for nonconvex problems. 12.3.5 Exercises
1. Experiment with different learning rates and objective functions for gradient descent. 2. Implement line search to minimize a convex function in the interval ¬ªùëé, ùëè‚Ä¶. 1. Do you need derivatives for binary search, i.e., to decide whether to pick ¬ªùëé, ‚Äûùëé ‚Äö
1. Do you need derivatives for binary search, i.e., to decide whether to pick [a, (a + b)/2] or [(a + b)/2, db). 2. How rapid is the rate of convergence for the algorithm? 3. Implement the algorithm and apply it to minimizing log(exp(x) + exp(‚Äî2x ‚Äî 3)). 3. Design an objective function defined on R2 where gradient descent is exceedingly slow. Hint: scale different coordinates differently. 4. Implement the lightweight version of Newton‚Äôs method using preconditioning:
1. Use diagonal Hessian as preconditioner. 2.bubuUse the absolute values of that rather than the actual (possibly signed) values. 168
3.bubuApply this to the problem above.bubu5. Apply the algorithm above to a number of objective functions (convex or not). What happens if you rotate coordinates by 45 degrees? Discussions168. Stochastic Gradient Descent
493

12.4 Stochastic Gradient Descent
ae
In earlier chapters we kept using stochastic gradient descent in our training procedure, how- ever, without explaining why it works. To shed some light on it, we just described the basic principles of gradient descent in Section 12.3. In this section, we go on to discuss stochastic gradient descent in greater detail. %matplotlib inline import math import torch from d2l import torch as d2l
12.4.1 Stochastic Gradient Updates
In deep learning, the objective function is usually the average of the loss functions for each example in the training dataset. Given a training dataset of ùëõ examples, we assume that ùëìùëñ‚Äûx‚Äù is the loss function with respect to the training example of index ùëñ, where x is the parameter vector. Then we arrive at the objective function
ùëì ‚Äûx‚Äù = 1 ùëõ ùëñ=1 ùëìùëñ‚Äûx‚Äù. (12.4.1)
The gradient of the objective function at x is computed as
rùëì ‚Äûx‚Äù = 1 ùëõ ùëñ=1 rùëìùëñ‚Äûx‚Äù. (12.4.2)
If gradient descent is used, the computational cost for each independent variable iteration is O‚Äûùëõ‚Äù, which grows linearly with ùëõ. Therefore, when the training dataset is larger, the cost of gradient descent for each iteration will be higher. Stochastic gradient descent (SGD) reduces computational cost at each iteration. At each iteration of stochastic gradient descent, we uniformly sample an index ùëñ 2 f1, . . .,ùëõg for data examples at random, and compute the gradient rùëìùëñ‚Äûx‚Äù to update x:
x x-7Vfi(x),
(12.4.3)
where ùúÇ is the learning rate. We can see that the computational cost for each iteration drops
from O‚Äûùëõ‚Äù of the gradient descent to the constant O‚Äû1‚Äù. Moreover, we want to empha- size that the stochastic gradient rùëìùëñ‚Äûx‚Äù is an unbiased estimate of the full gradient rùëì ‚Äûx‚Äù because
Eùëñrùëìùëñ‚Äûx‚Äù = 1 ùëõ ùëñ=1 rùëìùëñ‚Äûx‚Äù = rùëì ‚Äûx‚Äù. (12.4.4)
Thismeansthat,onaverage,thestochasticgradientisagoodestimateofthegradient. Now, we will compare it with gradient descent by adding random noise with a mean of 0 and a variance of 1 to the gradient to simulate a stochastic gradient descent. Optimization Algorithms
494

def f(x1, x2): # Objective function return x1 ** 2 + 2 * x2 ** 2 def f_grad(x1, x2): # Gradient of the objective function return 2 * x1, 4 * x2
def sgd(x1, x2, s1, s2, f_grad): g1, g2 = f_grad(x1, x2) # Simulate noisy gradient g1 += torch.normal(0.0, 1, (1,)).item() g2 += torch.normal(0.0, 1, (1,)).item() eta_t = eta * lr() return (x1 - eta_t * g1, x2 - eta_t * g2, 0, 0)
def constant_lr(): return 1 eta = 0.1 lr = constant_lr # Constant learning rate d2l.show_trace_2d(f, d2l.train_2d(sgd, steps=50, f_grad=f_grad))
epoch 50, x1: 0.225517, x2: -0.076646

As we can see, the trajectory of the variables in the stochastic gradient descent is much more noisy than the one we observed in gradient descent in Section 12.3. This is due to the stochastic nature of the gradient. That is, even when we arrive near the minimum, we are still subject to the uncertainty injected by the instantaneous gradient via ùúÇrùëìùëñ‚Äûx‚Äù. Even after 50 steps the quality is still not so good. Even worse, it will not improve after additional steps (we encourage you to experiment with a larger number of steps to confirm this). This leaves us with the only alternative: change the learning rate ùúÇ. However, if we pick this too small, we will not make any meaningful progress initially. On the other hand, if we pick it too large, we will not get a good solution, as seen above. The only way to resolve these conflicting goals is to reduce the learning rate dynamically as optimization progresses. This is also the reason for adding a learning rate function lr into the sgd step function. In
Stochastic Gradient Descent
495

the example above any functionality for learning rate scheduling lies dormant as we set the associated lr function to be constant. 12.4.2 Dynamic Learning Rate
Replacing ùúÇ with a time-dependent learning rate ùúÇ‚Äûùë°‚Äù adds to the complexity of controlling
convergence of an optimization algorithm. In particular, we need to figure out how rapidly ùúÇ should decay. If it is too quick, we will stop optimizing prematurely. If we decrease it too slowly, we waste too much time on optimization. The following are a few basic strategies that are used in adjusting ùúÇ over time (we will discuss more advanced strategies later):
n(t) =n if t; <t < tiz1 piecewise constant t n(t) =no-e-* exponential decay (12.4.5) n(t) =no-(Bt+1)~* polynomial decay
Inthefirstpiecewiseconstantscenariowedecreasethelearningrate,e.g.,wheneverprogress in optimization stalls. This is a common strategy for training deep networks. Alternatively we could decrease it much more aggressively by an exponential decay. Unfortunately this often leads to premature stopping before the algorithm has converged. A popular choice is polynomial decay with ùõº = 0.5. In the case of convex optimization there are a number of proofs that show that this rate is well behaved. Let‚Äôs see what the exponential decay looks like in practice. def exponential_lr(): # Global variable that is defined outside this function and updated inside global t t += 1 return math.exp(-0.1 * t) t = 1 lr = exponential_lr d2l.show_trace_2d(f, d2l.train_2d(sgd, steps=1000, f_grad=f_grad))
epoch 1000, x1: -0.758829, x2: -0.115584

As expected, the variance in the parameters is significantly reduced. However, this comes
Optimization Algorithms
496

at the expense of failing to converge to the optimal solution x = ‚Äû0,0‚Äù.bubuEven after 1000
iterationstepsarewearestillveryfarawayfromtheoptimalsolution. Indeed, thealgorithm fails to converge at all. On the other hand, if we use a polynomial decay where the learning rate decays with the inverse square root of the number of steps, convergence gets better after only 50 steps. def polynomial_lr(): # Global variable that is defined outside this function and updated inside global t t += 1 return (1 + 0.1 * t) ** (-0.5) t = 1 lr = polynomial_lr d2l.show_trace_2d(f, d2l.train_2d(sgd, steps=50, f_grad=f_grad))
epoch 50, x1: 0.144834, x2: 0.041688

There exist many more choices for how to set the learning rate. For instance, we could start with a small rate, then rapidly ramp up and then decrease it again, albeit more slowly.bubuWe could even alternate between smaller and larger learning rates. There exists a large variety of such schedules. For now let‚Äôs focus on learning rate schedules for which a comprehen- sive theoretical analysis is possible, i.e., on learning rates in a convex setting. For general nonconvex problems it is very difficult to obtain meaningful convergence guarantees, since in general minimizing nonlinear nonconvex problems is NP hard. For a survey see e.g., the excellent lecture notes169 of Tibshirani 2015. 169
12.4.3 Convergence Analysis for Convex Objectives
The following convergence analysis of stochastic gradient descent for convex objective functions is optional and primarily serves to convey more intuition about the problem. We limit ourselves to one of the simplest proofs (Nesterov and Vial, 2000). Significantly more advanced proof techniques exist, e.g., whenever the objective function is particularly well behaved. Suppose that the objective function ùëì ‚ÄûùùÉ,x‚Äù is convex in x for all ùùÉ. More concretely, we
Stochastic Gradient Descent
497

consider the stochastic gradient descent update:
Xr41 = Xr ‚Äî 10x f (E;,X),
(12.4.6)
where ùëì ‚ÄûùùÉùë°,x‚Äù is the objective function with respect to the training example ùùÉùë° drawn from
some distribution at step ùë° and x is the model parameter. Denote by
ùëÖ‚Äûx‚Äù = ùê∏ùùÉ¬ª ùëì ‚ÄûùùÉ,x‚Äù‚Ä¶
(12.4.7)
the expected risk and by R* its minimum with regard to x. Last let x* be the minimizer
the expected risk and by R* its minimum with regard to x. Last let x* be the minimizer (we assume that it exists within the domain where x is defined). In this case we can track the distance between the current parameter x; at time ¬¢ and the risk minimizer x* and see whether it improves over time:
IIXee1 ‚Äî "I? = [x1 ‚Äî mcf (E,.x) ‚Äî "I? (12.4.8) =l[xr ‚Äî x"? + 7 Oe f(E,. 011?bubu‚Äî 2m (Xr ‚Äî &" Oxf (Ep. %)) ¬´
We assume that the ‚Ñì2 norm of stochastic gradient ùúïx ùëì ‚ÄûùùÉùë°,x‚Äù is bounded by some constant
ùêø, hence we have that
mlOxf (Er, IP < nF L?. (12.4.9)
We are mostly interested in how the distance between x, and x* changes in expectation.bubuWe are mostly interested in how the distance between x, and x* changes in expectation. In fact, for any specific sequence of steps the distance might well increase, depending on whichever ‚Ç¨, we encounter. Hence we need to bound the dot product. Since for any convex function f it holds that f(y) > f(x) + (f‚Äô(x), y ‚Äî x) for all x and y, by convexity we have
FE x) = f(E.%1) + (x* - 1, Ox f (E;,X1)) . (12.4.10)
Plugging both inequalities (12.4.9) and (12.4.10) into (12.4.8) we obtain a bound on the distance between parameters at time ùë° ‚Äö 1 as follows:
Whxr ‚Äî <1? = xian ‚Äî IP 2m FE, 0) ‚Äî FE) ‚Äî mL‚Äô. (12.4.1)
This means that we make progress as long as the difference between current loss and the optimal loss outweighs 7; 7/2. Since this difference is bound to converge to zero it follows that the learning rate 7; also needs to vanish. Next we take expectations over (12.4.11). This yields
E [Ix ‚Äîx¬∞[P] ~ E [Iles ‚Äî x¬∞I?] = 2m EL RGe)] - R'] = PL?. (124.12)
The last step involves summing over the inequalities for ùë° 2 f1, . .bubu.,ùëág. Since the sum
telescopes and by dropping the lower term we obtain
! T IIx: ‚Äî x"|]? > ap) ‚Ñ¢ t=1 T [E[R(x)] = R*}- 1?) np. (12.4.13) t=
Optimization Algorithms
498

Note that we exploited that x1 is given and thus the expectation can be dropped. Last define
¬Øx def = ùúÇùë°xùë° ùë°=1 Àùùëá ùúÇùë° ùë°=1 . (12.4.14)
Since
Àùùëá
! Àùùëá
ùúÇùë°ùëÖ‚Äûxùë°‚Äù ùë°=1 Àùùëá ùúÇùë° ùë°=1 = ùë°=1 ùúÇùë°ùê∏¬ªùëÖ‚Äûxùë°‚Äù‚Ä¶ Àùùëá ùúÇùë° ùë°=1 = ùê∏¬ªùëÖ‚Äûxùë°‚Äù‚Ä¶, (12.4.15)
ùê∏
by Jensen‚Äôs inequality (setting i = t, aj = m/s mr in (12.2.3)) and convexity of R it follows that E[R(x,)] => E[R(xX)], thus
T
T T SD mE[ROG)] = > mE [RI - (12.4.16) t=1 tl
Plugging this into the inequality (12.4.13) yields the bound
P+ Dein [ELS Rs oT , (12.4.17)
where ùëü2 def
||x1 ‚Äî x*||? is a bound on the distance between the initial choice of parameters
where r2 ||x1 ‚Äî x*||? is a bound on the distance between the initial choice of parameters and the final outcome. In short, the speed of convergence depends on how the norm of stochastic gradient is bounded (L) and how far away from optimality the initial parameter value is (r). Note that the bound is in terms of X rather than x7. This is the case since X is a smoothed version of the optimization path. Whenever r, L, and T are known we can pick the learning rate 7 = r/(LVT). This yields as upper bound rL/VT. That is, we converge with rate O(1/-T) to the optimal solution. 12.4.4 Stochastic Gradients and Finite Samples
So far we have played a bit fast and loose when it comes to talking about stochastic gra- dient descent. We posited that we draw instances ùë•ùëñ, typically with labels ùë¶ùëñ from some distribution ùëù‚Äûùë•, ùë¶‚Äù and that we use this to update the model parameters in some man- ner. In particular, for a finite sample size we simply argued that the discrete distribution Àùùëõ ùëù‚Äûùë•, ùë¶‚Äù = 1 ùõøùë•ùëñ‚Äûùë•‚Äùùõøùë¶ùëñ‚Äûùë¶‚Äù for some functions ùõøùë•ùëñ and ùõøùë¶ùëñ allows us to perform stochas- ùëñ=1 ùëõ tic gradient descent over it. However, this is not really what we did. In the toy examples in the current section we simply added noise to an otherwise non-stochastic gradient, i.e., we pretended to have pairs (x;, yi). It turns out that this is justified here (see the exercises for a detailed discussion).bubuMore troubling is that in all previous discussions we clearly did not do this. Instead we iterated over all instances exactly once. To see why this is preferable consider the converse, namely that we are sampling n observations from the discrete distribution with replacement. The probability of choosing an element i at random is 1/n. Thus to choose it at least once is
P(choose i) = 1 ‚Äî P(omit ?) = 1‚Äî (1 - 1/n)" = 1-7! = 0.63. (12.4.18)
Àùùëá
Àùùëá
T
Àùùëá
Stochastic Gradient Descent
499

A similar reasoning shows that the probability of picking some sample (i.e., training exam- ple) exactly once is given by
("4 (1-4) = n (1-2) et soar (12.4.19) Ijn n n
Sampling with replacement leads to an increased variance and decreased data efficiency relative to sampling without replacement. Hence, in practice we perform the latter (and this is the default choice throughout this book). Last note that repeated passes through the training dataset traverse it in a different random order. 12.4.5 Summary
e For convex problems we can prove that for a wide choice of learning rates stochastic
gradient descent will converge to the optimal solution. e For deep learning this is generally not the case. However, the analysis of convex prob-
lems gives us useful insight into how to approach optimization, namely to reduce the learning rate progressively, albeit not too quickly. e Problems occur when the learning rate is too small or too large. In practice a suitable
learning rate is often found only after multiple experiments. e When there are more examples in the training dataset, it costs more to compute each
iteration for gradient descent, so stochastic gradient descent is preferred in these cases. e Optimality guarantees for stochastic gradient descent are in general not available in non-
convex cases since the number of local minima that require checking might well be exponential. 12.4.6 Exercises
1. Experiment with different learning rate schedules for stochastic gradient descent and with different numbers of iterations. In particular, plot the distance from the optimal solution ‚Äû0,0‚Äù as a function of the number of iterations. 2. Prove that for the function f(x1,x2) = xt + 2x5 adding normal noise to the gradient is equivalent to minimizing a loss function f(x, w) = (x1 ‚Äî w1)? + 2(x2 ‚Äî w2)?bubuwhere x is drawn from a normal distribution.bubu3. Compareconvergenceofstochasticgradientdescentwhenyousamplefrom f‚Äûùë•1, ùë¶1‚Äù, . . ., ‚Äûùë•ùëõ, ùë¶ùëõ‚Äùg
with replacement and when you sample without replacement.bubu4. How would you change the stochastic gradient descent solver if some gradient (or rather some coordinate associated with it) was consistently larger than all the other gradients? 5.bubuAssume that ùëì ‚Äûùë•‚Äù = ùë•2‚Äû1 ‚Äö sinùë•‚Äù. How many local minima does ùëì have? Can you change ùëì in such a way that to minimize it one needs to evaluate all the local minima?bubu170
Discussions170. Optimization Algorithms
500

12.5 Minibatch Stochastic Gradient Descent

So far we encountered two extremes in the approach to gradient-based learning: Section 12.3 uses the full dataset to compute gradients and to update parameters, one pass at a time. Conversely Section 12.4 processes one training example at a time to make progress. Either of them has its own drawbacks. Gradient descent is not particularly data eÔ¨Äicient whenever data is very similar. Stochastic gradient descent is not particularly computationally eÔ¨Äicient since CPUs and GPUs cannot exploit the full power of vectorization. This suggests that there might be something in between, and in fact, that is what we have been using so far in the examples we discussed. 12.5.1 Vectorization and Caches
At the heart of the decision to use minibatches is computational efficiency. This is most easily understood when considering parallelization to multiple GPUs and multiple servers. In this case we need to send at least one image to each GPU. With 8 GPUs per server and 16 servers we already arrive at a minibatch size no smaller than 128. Things are a bit more subtle when it comes to single GPUs or even CPUs. These devices have multiple types of memory, often multiple types of computational units and different bandwidth constraints between them. For instance, a CPU has a small number of registers and then the L1, L2, and in some cases even L3 cache (which is shared among different processor cores). These caches are of increasing size and latency (and at the same time they are of decreasing bandwidth). Suffice to say, the processor is capable of performing many more operations than what the main memory interface is able to provide. First, a 2GHz CPU with 16 cores and AVX-512 vectorization can process up to 2 - 10¬∞ - 16 - 32 = 10!? bytes per second. The capability of GPUs easily exceeds this number by a factor of 100. On the other hand, a midrange server processor might not have much more than 100 GB/s bandwidth, i.e., less than one tenth of what would be required to keep the processor fed. To make matters worse, not all memory access is created equal: memory interfaces are typically 64 bit wide or wider (e.g., on GPUs up to 384 bit), hence reading a single byte incurs the cost of a much wider access. Second, there is significant overhead for the first access whereas sequential access is rela- tively cheap (this is often called a burst read). There are many more things to keep in mind, such as caching when we have multiple sockets, chiplets, and other structures. See this Wikipedia article171 for a more in-depth discussion. 171
The way to alleviate these constraints is to use a hierarchy of CPU caches that are actu- ally fast enough to supply the processor with data. This is the driving force behind batch- ing in deep learning. To keep matters simple, consider matrix-matrix multiplication, say A = BC. We have a number of options for calculating A. For instance, we could try the following:
Minibatch Stochastic Gradient Descent
501

1. We could compute Aùëñùëó = Bùëñ,:C:, ùëó, i.e., we could compute it elementwise by means of dot products. 2. We could compute A:, ùëó = BC:, ùëó, i.e., we could compute it one column at a time. Likewise we could compute A one row Aùëñ,: at a time. 3. We could simply compute A = BC. 4. We could break B and C into smaller block matrices and compute A one block at a time. If we follow the first option, we will need to copy one row and one column vector into the CPU each time we want to compute an element Aùëñùëó. Even worse, due to the fact that matrix elements are aligned sequentially we are thus required to access many disjoint locations for one of the two vectors as we read them from memory. The second option is much more favorable. In it, we are able to keep the column vector C:, ùëó in the CPU cache while we keep on traversing through B. This halves the memory bandwidth requirement with correspondingly faster access. Of course, option 3 is most desirable. Unfortunately, most matrices might not entirely fit into cache (this is what we are discussing after all). However, option 4 offers a practically useful alternative: we can move blocks of the matrix into cache and multiply them locally. Optimized libraries take care of this for us.bubuLet‚Äôs have a look at how efficient these operations are in practice. Beyond computational efficiency, the overhead introduced by Python and by the deep learn- ing framework itself is considerable. Recall that each time we execute a command the Python interpreter sends a command to the MXNet engine which needs to insert it into the computational graph and deal with it during scheduling. Such overhead can be quite detrimental. In short, it is highly advisable to use vectorization (and matrices) whenever possible. %matplotlib inline import time import numpy as np import torch from torch import nn from d2l import torch as d2l A = torch.zeros(256, 256) B = torch.randn(256, 256) C = torch.randn(256, 256)
torch.zeros(256, 256) A
B = torch.randn(256, 256)
C = torch.randn(256, 256)
Since we will benchmark the running time frequently in the rest of the book, let‚Äôs define a timer. timer. class Timer: #@save """Record multiple running times.""" def __init__(self): self.times = [] self.start()
(continues on next page)
Optimization Algorithms
502

def start(self): """Start the timer.""" self.tik = time.time() def stop(self): """Stop the timer and record the time in a list.""" self.times.append(time.time() - self.tik) return self.times[-1] def avg(self): """Return the average time.""" return sum(self.times) / len(self.times) def sum(self): """Return the sum of time.""" return sum(self.times) def cumsum(self): """Return the accumulated time.""" return np.array(self.times).cumsum().tolist() timer = Timer()
Element-wiseassignmentsimplyiteratesoverallrowsandcolumnsofBandCrespectively to assign the value to A. to assign the value to A. # Compute A = BC one element at a time timer.start() for i in range(256): for j in range(256): A[i, j] = torch.dot(B[i, :], C[:, j]) timer.stop()
1.7845737934112549
A faster strategy is to perform column-wise assignment. # Compute A = BC one column at a time timer.start() for j in range(256): A[:, j] = torch.mv(B, C[:, j]) timer.stop()
0.06541275978088379
Last, the most effective manner is to perform the entire operation in one block. Note that multiplying any two matrices B ‚Ç¨ R‚Äù‚Äù*‚Äù and C ‚Ç¨ R"*? takes approximately 2mnp floating point operations, when scalar multiplication and addition are counted as separate operations
(continued from previous page)
Minibatch Stochastic Gradient Descent
503

(fused in practice). Thus, multiplying two 256 x 256 matrices takes 0.03 billion floating
point operations. Let‚Äôs see what the respective speed of the operations is. # Compute A = BC in one go timer.start() A = torch.mm(B, C) timer.stop() gigaflops = [0.03 / i for i in timer.times] print(f'performance in Gigaflops: element {gigaflops[0]:.3f}, ' f'column {gigaflops[1]:.3f}, full {gigaflops[2]:.3f}')
performance in Gigaflops: element 0.017, column 0.459, full 51.633
12.5.2 Minibatches
In the past we took it for granted that we would read minibatches of data rather than single observations to update parameters. We now give a brief justification for it. Processing sin- gle observations requires us to perform many single matrix-vector (or even vector-vector) multiplications, which is quite expensive and which incurs a significant overhead on behalf of the underlying deep learning framework. This applies both to evaluating a network when applied to data (often referred to as inference) and when computing gradients to update pa- rameters. That is, this applies whenever we perform w <‚Äî w ‚Äî 7;g; where
gùë° = ùúïw ùëì ‚Äûxùë°,w‚Äù
(12.5.1)
We can increase the computational efficiency of this operation by applying it to a minibatch of observations at a time. That is, we replace the gradient gùë° over a single observation by one over a small batch
gùë° = ùúïw 1 jBùë°j ùëñ2Bùë° ùëì ‚Äûxùëñ,w‚Äù (12.5.2)
Let‚Äôs see what this does to the statistical properties of g;: since both x; and also all elements of the minibatch 8; are drawn uniformly at random from the training set, the expectation of the gradient remains unchanged. The variance, on the other hand, is reduced significantly. Since the minibatch gradient is composed of b ef |B;| independent gradients which are being averaged, its standard deviation is reduced by a factor of b~ 2, This, by itself, is a good thing, since it means that the updates are more reliably aligned with the full gradient. Naively this would indicate that choosing a large minibatch Bùë° would be universally desir-
able. Alas, after some point, the additional reduction in standard deviation is minimal when compared to the linear increase in computational cost. In practice we pick a minibatch that is large enough to offer good computational efficiency while still fitting into the memory of a GPU. To illustrate the savings let‚Äôs have a look at some code. In it we perform the same matrix-matrix multiplication, but this time broken up into ‚Äúminibatches‚Äù of 64 columns at a time. Optimization Algorithms
504

timer.start() for j in range(0, 256, 64): A[:, j:j+64] = torch.mm(B, C[:, j:j+64]) timer.stop() print(f'performance in Gigaflops: block {0.03 / timer.times[3]:.3f}')
performance in Gigaflops: block 37.640
As we can see, the computation on the minibatch is essentially as efficient as on the full matrix. A word of caution is in order.bubuIn Section 8.5 we used a type of regularization that was heavily dependent on the amount of variance in a minibatch. As we increase the latter, the variance decreases and with it the benefit of the noise-injection due to batch normal- ization. See e.g., Ioffe (2017) for details on how to rescale and compute the appropriate terms. 12.5.3 Reading the Dataset
Let‚Äôs have a look at how minibatches are efficiently generated from data. In the following we use a dataset developed by NASA to test the wing noise from different aircraft 172 to compare these optimization algorithms. For convenience we only use the first 1,500 examples. The data is whitened for preprocessing, i.e., we remove the mean and rescale the variance to 1 per coordinate. 172

#@save d2l.DATA_HUB['airfoil'] = (d2l.DATA_URL + 'airfoil_self_noise.dat', '76e5be1548fd8222e5074cf0faae75edff8cf93f') #@save def get_data_ch11(batch_size=10, n=1500): data = np.genfromtxt(d2l.download('airfoil'), dtype=np.float32, delimiter='\t') data = torch.from_numpy((data - data.mean(axis=0)) / data.std(axis=0)) data_iter = d2l.load_array((data[:n, :-1], data[:n, -1]), batch_size, is_train=True) return data_iter, data.shape[1]-1
12.5.4 Implementation from Scratch
Recall the minibatch stochastic gradient descent implementation from Section 3.4. In the following we provide a slightly more general implementation.bubuFor convenience it has the same call signature as the other optimization algorithms introduced later in this chapter. Specifically, we add the status input states and place the hyperparameter in dictionary hyperparams. In addition, we will average the loss of each minibatch example in the train- ing function, so the gradient in the optimization algorithm does not need to be divided by the batch size. Minibatch Stochastic Gradient Descent
505

def sgd(params, states, hyperparams): for p in params: p.data.sub_(hyperparams['lr'] * p.grad) p.grad.data.zero_()
Next, weimplementagenerictrainingfunctiontofacilitatetheuseoftheotheroptimization algorithms introduced later in this chapter. It initializes a linear regression model and can be used to train the model with minibatch stochastic gradient descent and other algorithms introduced subsequently. #@save def train_ch11(trainer_fn, states, hyperparams, data_iter, feature_dim, num_epochs=2): # Initialization w = torch.normal(mean=0.0, std=0.01, size=(feature_dim, 1), requires_grad=True) b = torch.zeros((1), requires_grad=True) net, loss = lambda X: d2l.linreg(X, w, b), d2l.squared_loss # Train animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[0, num_epochs], ylim=[0.22, 0.35]) n, timer = 0, d2l.Timer() for _ in range(num_epochs): for X, y in data_iter: l = loss(net(X), y).mean() l.backward() trainer_fn([w, b], states, hyperparams) n += X.shape[0] if n % 200 == 0: timer.stop() animator.add(n/X.shape[0]/len(data_iter), (d2l.evaluate_loss(net, data_iter, loss),)) timer.start() print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/ ‚Ü©!epoch') return timer.cumsum(), animator.Y[0]
Let‚Äôs see how optimization proceeds for batch gradient descent. This can be achieved by setting the minibatch size to 1500 (i.e., to the total number of examples).bubuAs a result the model parameters are updated only once per epoch. There is little progress. In fact, after 6 steps progress stalls. def train_sgd(lr, batch_size, num_epochs=2): data_iter, feature_dim = get_data_ch11(batch_size) return train_ch11( sgd, None, {'lr': lr}, data_iter, feature_dim, num_epochs) gd_res = train_sgd(1, 1500, 10)
gd_res = train_sgd(1, 1500, 10)
loss: 0.247, 0.020 sec/epoch
Optimization Algorithms
506

0.350 0.325 0.300 loss 0.275 0.250 ‚Äî___ 0.225
When the batch size equals 1, we use stochastic gradient descent for optimization. For simplicity of implementation we picked a constant (albeit small) learning rate. In stochastic gradient descent, the model parameters are updated whenever an example is processed. In our case this amounts to 1500 updates per epoch. As we can see, the decline in the value of theobjectivefunctionslowsdownafteroneepoch. Althoughboththeproceduresprocessed 1500 examples within one epoch, stochastic gradient descent consumes more time than gradient descent in our experiment. This is because stochastic gradient descent updated the parameters more frequently and since it is less efficient to process single observations one at a time. sgd_res = train_sgd(0.005, 1)
loss: 0.245, 0.685 sec/epoch
0.350 0.325 0.300 loss 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
Finally, when the batch size equals 100, we use minibatch stochastic gradient descent for optimization. The time required per epoch is shorter than the time needed for stochastic gradient descent and the time for batch gradient descent. mini1_res = train_sgd(.4, 100)
loss: 0.246, 0.025 sec/epoch
Reducing the batch size to 10, the time for each epoch increases because the workload for each batch is less efficient to execute. Minibatch Stochastic Gradient Descent
507

0.350 0.325 0,300 loss 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
mini2_res = train_sgd(.05, 10)
loss: 0.246, 0.090 sec/epoch
0.350 0.325 0.300 loss 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
Now we can compare the time vs. loss for the previous four experiments. As can be seen, although stochastic gradient descent converges faster than GD in terms of number of ex- amples processed, it uses more time to reach the same loss than GD because computing the gradient example by example is not as efficient. Minibatch stochastic gradient descent is able to trade-off convergence speed and computation efficiency. A minibatch size of 10 is more efficient than stochastic gradient descent; a minibatch size of 100 even outperforms GD in terms of runtime. d2l.set_figsize([6, 3]) d2l.plot(*list(map(list, zip(gd_res, sgd_res, mini1_res, mini2_res))), 'time (sec)', 'loss', xlim=[1e-2, 10], legend=['gd', 'sgd', 'batch size=100', 'batch size=10']) d2l.plt.gca().set_xscale('log')
12.5.5 Concise Implementation
In Gluon, we can use the Trainer class to call optimization algorithms. This is used to im- plementa generic training function. Wewill use this throughout thecurrent chapter. Optimization Algorithms
508

0.32 4% ‚Äî ad - batch size=100 batch size=10 10-1 10¬∞ 101 time (sec)
#@save def train_concise_ch11(trainer_fn, hyperparams, data_iter, num_epochs=4): # Initialization net = nn.Sequential(nn.Linear(5, 1)) def init_weights(module): if type(module) == nn.Linear: torch.nn.init.normal_(module.weight, std=0.01) net.apply(init_weights) optimizer = trainer_fn(net.parameters(), **hyperparams) loss = nn.MSELoss(reduction='none') animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[0, num_epochs], ylim=[0.22, 0.35]) n, timer = 0, d2l.Timer() for _ in range(num_epochs): for X, y in data_iter: optimizer.zero_grad() out = net(X) y = y.reshape(out.shape) l = loss(out, y) l.mean().backward() optimizer.step() n += X.shape[0] if n % 200 == 0: timer.stop() # `MSELoss` computes squared error without the 1/2 factor animator.add(n/X.shape[0]/len(data_iter), (d2l.evaluate_loss(net, data_iter, loss) / 2,)) timer.start() print(f'loss: {animator.Y[0][-1]:.3f}, {timer.sum()/num_epochs:.3f} sec/
‚Ü©!epoch')
Using Gluon to repeat the last experiment shows identical behavior. data_iter, _ = get_data_ch11(10) trainer = torch.optim.SGD train_concise_ch11(trainer, {'lr': 0.01}, data_iter)
Minibatch Stochastic Gradient Descent
509

0.350 0.325 0,300 loss 0.275 0.250 0.225 epoch
loss: 0.243, 0.096 sec/epoch
12.5.6 Summary
e Vectorization makes code more efficient due to reduced overhead arising from the deep
learning framework and due to better memory locality and caching on CPUs and GPUs. e There is a trade-off between statistical efficiency arising from stochastic gradient descent
and computational efficiency arising from processing large batches of data at a time. e Minibatch stochastic gradient descent offers the best of both worlds: computational and
statistical efficiency. e Inminibatch stochastic gradient descent we process batches of data obtained by a random
permutation of the training data (i.e., each observation is processed only once per epoch, albeit in random order). e It is advisable to decay the learning rates during training. e In general, minibatch stochastic gradient descent is faster than stochastic gradient descent
and gradient descent for convergence to a smaller risk, when measured in terms of clock time. 12.5.7 Exercises
1.bubuModify the batch size and learning rate and observe the rate of decline for the value of the objective function and the time consumed in each epoch. 2. Read the MXNet documentation and use the Trainer class set_learning_rate func- tion to reduce the learning rate of the minibatch stochastic gradient descent to 1/10 of its previous value after each epoch. 3. Compare minibatch stochastic gradient descent with a variant that actually samples with replacement from the training set. What happens?bubu4. An evil genie replicates your dataset without telling you (i.e., each observation occurs twice and your dataset grows to twice its original size, but nobody told you). How does
Optimization Algorithms
510

the behavior of stochastic gradient descent, minibatch stochastic gradient descent and that of gradient descent change? Discussions173. 173
12.6 Momentum
eC
In Section 12.4 we reviewed what happens when performing stochastic gradient descent, i.e., when performing optimization where only a noisy variant of the gradient is available. In particular, we noticed that for noisy gradients we need to be extra cautious when it comes to choosing the learning rate in the face of noise. If we decrease it too rapidly, convergence stalls. If we are too lenient, we fail to converge to a good enough solution since noise keeps on driving us away from optimality. 12.6.1 Basics
In this section, we will explore more effective optimization algorithms, especially for cer- tain types of optimization problems that are common in practice. Leaky Averages
The previous section saw us discussing minibatch SGD as a means for accelerating com- putation. It also had the nice side-effect that averaging gradients reduced the amount of variance. The minibatch stochastic gradient descent can be calculated by:
1 1 S11-1 = Ow SD, f (Xi, Wr-1) = BW OD, Hhia-1- 12.6.1 1 p> '8,| py ( )
To keep the notation simple, here we used hj 7-1 = Owf (xi, Wr-1) as the stochastic gra- dient descent for sample i using the weights updated at time f ‚Äî 1. It would be nice if we could benefit from the effect of variance reduction even beyond averaging gradients on a minibatch. One option to accomplish this task is to replace the gradient computation by a ‚Äúleaky average‚Äù:
Vr = BVt-1 + Stt-1
Vr = BVt-1 + Stt-1 (12.6.2)
for some ùõΩ 2 ‚Äû0,1‚Äù. This effectively replaces the instantaneous gradient by one that is been
averaged over multiple past gradients. v is called velocity. It accumulates past gradients similar to how a heavy ball rolling down the objective function landscape integrates over past forces. To see what is happening in more detail let‚Äôs expand vùë° recursively into
t-1 Vr = Bvi-2 + BS1-1.1-2+ Srr-1 = ++ = SB Bt-rt-r-1- (12.6.3) =0
Large ùõΩ amounts to a long-range average, whereas small ùõΩ amounts to only a slight correc-
tion relative to a gradient method. The new gradient replacement no longer points into the
(12.6.2)
511

direction of steepest descent on a particular instance any longer but rather in the direction of a weighted average of past gradients. This allows us to realize most of the benefits of averaging over a batch without the cost of actually computing the gradients on it. We will revisit this averaging procedure in more detail later. The above reasoning formed the basis for what is now known as accelerated gradient meth- ods, such as gradients with momentum. They enjoy the additional benefit of being much more effective in cases where the optimization problem is ill-conditioned (i.e., where there are some directions where progress is much slower than in others, resembling a narrow canyon). Furthermore, they allow us to average over subsequent gradients to obtain more stable directions of descent. Indeed, the aspect of acceleration even for noise-free convex problems is one of the key reasons why momentum works and why it works so well. Asonewouldexpect, duetoitsefficacymomentumisawell-studiedsubjectinoptimization for deep learning and beyond. See e.g., the beautiful expository article174 by Goh (2017) for an in-depth analysis and interactive animation. It was proposed by Polyak (1964). Nes- terov (2018) has a detailed theoretical discussion in the context of convex optimization. Momentum in deep learning has been known to be beneficial for a long time. See e.g., the discussion by Sutskever et al. (2013) for details. 174
An Ill-conditioned Problem
To get a better understanding of the geometric properties of the momentum method we revisit gradient descent, albeit with a significantly less pleasant objective function. Recall thatin Section 12.3 weused ùëì ‚Äûx‚Äù = ùë•2 ‚Äö2ùë•2 2, i.e., a moderatelydistorted ellipsoid objective. 1 We distort this function further by stretching it out in the ùë•1 direction via
ùëì ‚Äûx‚Äù = 0.1ùë•2 1 ‚Äö 2ùë•2 2 . (12.6.4)
As before ùëì has its minimum at ‚Äû0,0‚Äù. This function is very flat in the direction of ùë•1. Let‚Äôs
see what happens when we perform gradient descent as before on this new function. We pick a learning rate of 0.4. %matplotlib inline import torch from d2l import torch as d2l eta = 0.4 def f_2d(x1, x2): return 0.1 * x1 ** 2 + 2 * x2 ** 2 def gd_2d(x1, x2, s1, s2): return (x1 - eta * 0.2 * x1, x2 - eta * 4 * x2, 0, 0) d2l.show_trace_2d(f_2d, d2l.train_2d(gd_2d))
epoch 20, x1: -0.943467, x2: -0.000073
By construction, the gradient in the ùë•2 direction is much higher and changes much more
Momentum
Optimization Algorithms
512


rapidly than in the horizontal ùë•1 direction. Thus we are stuck between two undesirable choices: if we pick a small learning rate we ensure that the solution does not diverge in the ùë•2 direction but we are saddled with slow convergence in the ùë•1 direction. Conversely, with a large learning rate we progress rapidly in the ùë•1 direction but diverge in ùë•2. The example below illustrates what happens even after a slight increase in learning rate from 0.4 to 0.6. Convergence in the ùë•1 direction improves but the overall solution quality is much worse. eta = 0.6 d2l.show_trace_2d(f_2d, d2l.train_2d(gd_2d))
epoch 20, x1: -0.387814, x2: -1673.365109
1000 i} y y ‚Äî1000 4 -2 0 x1
The Momentum Method
The momentum method allows us to solve the gradient descent problem described above. Looking at the optimization trace above we might intuit that averaging gradients over the past would work well. After all, in the ùë•1 direction this will aggregate well-aligned gradi- ents, thus increasing the distance we cover with every step. Conversely, in the ùë•2 direction where gradients oscillate, an aggregate gradient will reduce step size due to oscillations that cancel each other out. Using vùë° instead of the gradient gùë° yields the following update equations:
Vr ‚Äî BV1-1 + Srr-1,
Vr ‚Äî BV1-1 + Srr-1, Xp T Xp-1 ‚Äî Mr Ve- (12.6.5)
513

Note that for ùõΩ = 0 we recover regular gradient descent. Before delving deeper into the
mathematical properties let‚Äôs have a quick look at how the algorithm behaves in prac- tice. def momentum_2d(x1, x2, v1, v2): v1 = beta * v1 + 0.2 * x1 v2 = beta * v2 + 4 * x2 return x1 - eta * v1, x2 - eta * v2, v1, v2 eta, beta = 0.6, 0.5 d2l.show_trace_2d(f_2d, d2l.train_2d(momentum_2d))
epoch 20, x1: 0.007188, x2: 0.002553
x2 ¬∞ -2
As we can see, even with the same learning rate that we used before, momentum still con- verges well. Let‚Äôs see what happens when we decrease the momentum parameter. Halving it to ùõΩ = 0.25 leads to a trajectory that barely converges at all. Nonetheless, it is a lot better than without momentum (when the solution diverges). eta, beta = 0.6, 0.25 d2l.show_trace_2d(f_2d, d2l.train_2d(momentum_2d))
epoch 20, x1: -0.126340, x2: -0.186632
x2 ¬∞
Note that we can combine momentum with stochastic gradient descent and in particular, minibatch stochastic gradient descent. The only change is that in that case we replace the
Momentum
Optimization Algorithms
514

gradients g, ;-1 with g,. Last, for convenience we initialize vp = 0 at time t = 0. Let‚Äôs
look at what leaky averaging actually does to the updates. Effective Sample Weight
errr In the limit the terms add up to
Recall that v, = DNB errr In the limit the terms add up to Y}¬∞_) B* = a In other words, rather than taking a step of size 7 in gradient descent or stochastic gradient descent we take a step of size 13 while at the same time, dealing with a potentially much better behaved descent direction. These are two benefits in one.bubuTo illustrate how weighting behaves for different choices of 8 consider the diagram below. d2l.set_figsize() betas = [0.95, 0.9, 0.6, 0] for beta in betas: x = torch.arange(40).detach().numpy() d2l.plt.plot(x, beta ** x, label=f'beta = {beta:.2f}') d2l.plt.xlabel('time') d2l.plt.legend();
10 ‚Äî beta = 0.95 08 ‚Äî beta = 0.90 ‚Äî beta = 0.60 0.6 beta = 0.00 04 02 0.0 , - - : , 0 10 20 30 40 time
12.6.2 Practical Experiments
Let‚Äôs see how momentum works in practice, i.e., when used within the context of a proper optimizer. For this we need a somewhat more scalable implementation. Implementation from Scratch
Compared with (minibatch) stochastic gradient descent the momentum method needs to maintain a set of auxiliary variables, i.e., velocity. It has the same shape as the gradients (and variables of the optimization problem). In the implementation below we call these variables states. def init_momentum_states(feature_dim): v_w = torch.zeros((feature_dim, 1)) v_b = torch.zeros(1) return (v_w, v_b)
Àù1
ùõΩùúè = 1
515

def sgd_momentum(params, states, hyperparams): for p, v in zip(params, states): with torch.no_grad(): v[:] = hyperparams['momentum'] * v + p.grad p[:] -= hyperparams['lr'] * v p.grad.data.zero_()
Let‚Äôs see how this works in practice. def train_momentum(lr, momentum, num_epochs=2):
d2l.train_ch11(sgd_momentum, init_momentum_states(feature_dim),
{'lr': lr, 'momentum': momentum}, data_iter,
feature_dim, num_epochs)
data_iter, feature_dim = d2l.get_data_ch11(batch_size=10) train_momentum(0.02, 0.5)
loss: 0.245, 0.153 sec/epoch
0.350 0.325 0,300 loss 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
When we increase the momentum hyperparameter momentum to 0.9, it amounts to a signif- icantly larger effective sample size of a = 10. We reduce the learning rate slightly to 0.01 to keep matters under control. train_momentum(0.01, 0.9)
loss: 0.248, 0.109 sec/epoch
Reducing the learning rate further addresses any issue of non-smooth optimization prob- lems. Setting it to 0.005 yields good convergence properties. train_momentum(0.005, 0.9)
loss: 0.243, 0.107 sec/epoch
Momentum
Optimization Algorithms
516

0.350 0.325 0,300 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
B g
~
0.350
0.325 0.300 a g i} 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
~
Concise Implementation
There is very little to do in Gluon since the standard sgd solver already had momentum built in. Setting matching parameters yields a very similar trajectory. trainer = torch.optim.SGD d2l.train_concise_ch11(trainer, {'lr': 0.005, 'momentum': 0.9}, data_iter)
loss: 0.250, 0.108 sec/epoch
0.350 0.325 0,300 loss 0.275 0.250 0.225 epoch
12.6.3 Theoretical Analysis
So far the 2D example of ùëì ‚Äûùë•‚Äù = 0.1ùë•2 1 ‚Äö2ùë•2 2 seemed rather contrived. We will now see that this is actually quite representative of the types of problem one might encounter, at least in the case of minimizing convex quadratic objective functions. 517

Quadratic Convex Functions
Consider the function
‚Ñé‚Äûx‚Äù = 1 2 x>Qx ‚Äö x>c ‚Äö ùëè. (12.6.6)
This is a general quadratic function. For positive definite matrices Q > 0, i.e., for matrices
This is a general quadratic function. For positive definite matrices Q > 0, i.e., for matrices with positive eigenvalues this has a minimizer at x* = ‚ÄîQ‚Ñ¢'c with minimum value b ‚Äî ze7Q'le. Hence we can rewrite h as
h(x) = 5x ‚ÄîQ7!e)TQ(x- Q¬∞!ce) +b- seTQr le. (12.6.7)
The gradient is given by 0,.4(x) = Q(x ‚Äî Q-!c). That is, it is given by the distance between x and the minimizer, multiplied by Q. Consequently also the velocity is a linear combination of terms Q(x, ‚Äî Q-!c). Since Q is positive definite it can be decomposed into its eigensystem via Q = O>ùö≤O for
Since Q is positive definite it can be decomposed into its eigensystem via Q = O' AO for an orthogonal (rotation) matrix O and a diagonal matrix A of positive eigenvalues. This : def .bubuallows us to perform a change of variables from x to z = O(x‚Äî Q‚Ñ¢!c) to obtain a much simplified expression:
‚Ñé‚Äûz‚Äù = 1 2 z>ùö≤z ‚Äö ùëè0. (12.6.8)
Here b‚Äô = b -
se7Qrle. Since O is only an orthogonal matrix this does not perturb the
gradients in a meaningful way. Expressed in terms of z gradient descent becomes
Zp = Zy-1 ‚Äî Az,-) = (I- A)zy-1. (12.6.9)
The important fact in this expression is that gradient descent does not mix between different eigenspaces. That is, when expressed in terms of the eigensystem of Q the optimization problem proceeds in a coordinate-wise manner. This also holds for
Vy = BV;-1 + AZ,-|
Vy = BV;-1 + AZ,-| Zr = Zr-1 ‚Äî N (Bvr-1 + AZr-1) (12.6.10) = (I= A)z,-1 - nBvr-1. In doing this we just proved the following theorem: gradient descent with and without momentum for a convex quadratic function decomposes into coordinate-wise optimization in the direction of the eigenvectors of the quadratic matrix. Scalar Functions
Given the above result let‚Äôs see what happens when we minimize the function ùëì ‚Äûùë•‚Äù = ùúÜ
2 For gradient descent we have
X41 =X, ‚Äî MAX, = (1 - nA)x;. (12.6.11)
Whenever |1 ‚Äî7A| < 1 this optimization converges at an exponential rate since after t steps
Whenever |1 ‚Äî7A| < 1 this optimization converges at an exponential rate since after t steps we have x; = (1 - 7A)'xo. This shows how the rate of convergence improves initially as
Momentum
ùë•2. Optimization Algorithms
518

we increase the learning rate ùúÇ until ùúÇùúÜ = 1. Beyond that things diverge and for ùúÇùúÜ > 2 the
optimization problem diverges. lambdas = [0.1, 1, 10, 19] eta = 0.1 d2l.set_figsize((6, 4)) for lam in lambdas: t = torch.arange(20).detach().numpy() d2l.plt.plot(t, (1 - eta * lam) ** t, label=f'lambda = {lam:.2f}') d2l.plt.xlabel('time') d2l.plt.legend();
1.00 0.75 0.50 0.25 0.00 -0.25 -0.50 ‚Äî lambda = 0.10 ‚Äî‚Äî lambda = 1.00 -0.75 ‚Äî‚Äî lambda = 10.00 ‚Äî lambda = 19.00 0.0 2.5 5.0 75 10.0 12.5 15.0 17.5 time
To analyze convergence in the case of momentum we begin by rewriting the update equa- tions in terms of two scalars: one for ùë• and one for velocity ùë£. This yields:
"| _ B a xi} [-nB (i -na) Vr} Vr .bubuI = R(f,7, A) I . (12.6.12)
We used R to denote the 2 x 2 governing convergence behavior. After ft steps the initial
choice ¬ªùë£0,ùë•0‚Ä¶ becomes R‚ÄûùõΩ,ùúÇ,ùúÜ‚Äùùë°¬ªùë£0,ùë•0‚Ä¶. Hence, it is up to the eigenvalues of R to determine the speed of convergence. See the Distill post 175 of Goh (2017) for a great animation and Flammarion and Bach (2015) for a detailed analysis. One can show that 0 < ùúÇùúÜ < 2 ‚Äö 2ùõΩ velocity converges. This is a larger range of feasible parameters when compared to 0 < ùúÇùúÜ < 2 for gradient descent. It also suggests that in general large values of ùõΩ are desirable. Further details require a fair amount of technical detail and we suggest that the interested reader consult the original publications. 175

12.6.4 Summary
e Momentum replaces gradients with a leaky average over past gradients. This accelerates
convergence significantly. e Itis desirable for both noise-free gradient descent and (noisy) stochastic gradient descent. e Momentum prevents stalling of the optimization process that is much more likely to
occur for stochastic gradient descent. 519

The effective number of gradients is given by
The effective number of gradients is given by TG due to exponentiated downweighting of past data. In the case of convex quadratic problems this can be analyzed explicitly in detail. Implementation is quite straightforward but it requires us to store an additional state
vector (velocity v). 12.6.5 Exercises
1. Use other combinations of momentum hyperparameters and learning rates and observe and analyze the different experimental results. 2. Try out gradient descent and momentum for a quadratic problem where you have multi- ple eigenvalues, i.e., f(x) = 3 xi Aix?, e.g., A; = 27. Plot how the values of x decrease for the initialization x; = 1. 3. Derive minimum value and minimizer for ‚Ñé‚Äûx‚Äù = 1
3. Derive minimum value and minimizer for h(x) = 3x" Qx+xTc+b. 4. What changes when we perform stochastic gradient descent with momentum? What happens when we use minibatch stochastic gradient descent with momentum? Experi- ment with the parameters?bubu176 
Discussions176. 12.7 Adagrad
a
Let‚Äôs begin by considering learning problems with features that occur infrequently. 12.7.1 Sparse Features and Learning Rates
Imagine that we are training a language model. To get good accuracy we typically want to decrease the learning rate as we keep on training, usually at a rate of O(t-?) or slower. Now consider a model training on sparse features, i.e., features that occur only infrequently. This is common for natural language, e.g., it is a lot less likely that we will see the word preconditioning than learning. However, it is also common in other areas such as computa- tional advertising and personalized collaborative filtering. After all, there are many things that are of interest only for a small number of people. Parameters associated with infrequent features only receive meaningful updates whenever these features occur. Given a decreasing learning rate we might end up in a situation where the parameters for common features converge rather quickly to their optimal values, whereas for infrequent features we are still short of observing them sufficiently frequently before their optimal values can be determined. In other words, the learning rate either decreases too slowly for frequent features or too quickly for infrequent ones. Adagrad
2x>Qx ‚Äö x>c ‚Äö ùëè. Optimization Algorithms
520

A possible hack to redress this issue would be to count the number of times we see a par- ticular feature and to use this as a clock for adjusting learning rates. That is, rather than ùúÇ0p ùúÇ0p choosing a learning rate of the form ùúÇ = ùë°‚Äöùëê we could use ùúÇùëñ = . Here ùë†‚Äûùëñ,ùë°‚Äù ùë†‚Äûùëñ,ùë°‚Äù‚Äöùëê counts the number of nonzeros for feature ùëñ that we have observed up to time ùë°. This is ac- tually quite easy to implement at no meaningful overhead. However, it fails whenever we do not quite have sparsity but rather just data where the gradients are often very small and only rarely large. After all, it is unclear where one would draw the line between something that qualifies as an observed feature or not. Adagrad by Duchi et al. (2011) addresses this by replacing the rather crude counter ùë†‚Äûùëñ,ùë°‚Äù
by an aggregate of the squares of previously observed gradients. In particular, it uses ùë†‚Äûùëñ,ùë° ‚Äö1‚Äù = ùë†‚Äûùëñ,ùë°‚Äù‚Äö‚Äûùúïùëñ ùëì ‚Äûx‚Äù‚Äù2 as a means to adjust the learning rate. This has two benefits: first, we no longer need to decide just when a gradient is large enough. Second, it scales automatically with the magnitude of the gradients. Coordinates that routinely correspond to large gradients are scaled down significantly, whereas others with small gradients re- ceive a much more gentle treatment. In practice this leads to a very effective optimization procedure for computational advertising and related problems. But this hides some of the additional benefits inherent in Adagrad that are best understood in the context of precondi- tioning. 12.7.2 Preconditioning
Convex optimization problems are good for analyzing the characteristics of algorithms. After all, for most nonconvex problems it is difficult to derive meaningful theoretical guar- antees, but intuition and insight often carry over. Let‚Äôs look at the problem of minimizing 2x>Qx ‚Äö c>x ‚Äö ùëè. ùëì ‚Äûx‚Äù = 1
As we saw in Section 12.6, it is possible to rewrite this problem in terms of its eigendecom- position Q = U>ùö≤U to arrive at a much simplified problem where each coordinate can be solved individually:
ùëì ‚Äûx‚Äù = ¬Øùëì ‚Äû¬Øx‚Äù = 1 2 ¬Øx>ùö≤¬Øx ‚Äö ¬Øc> ¬Øx ‚Äö ùëè. (12.7.1)
Here we used X = Ux and consequently ‚Ç¨ = Uc. The modified problem has as its min- imizer X = ‚ÄîA~'√© and minimum value -4eTA le +b. This is much easier to compute since A is a diagonal matrix containing the eigenvalues of Q. If we perturb c slightly we would hope to find only slight changes in the minimizer of ùëì. Unfortunately this is not the case. While slight changes in c lead to equally slight changes in ¬Øc, this is not the case for the minimizer of ùëì (and of ¬Øùëì respectively). Whenever the eigenvalues ùö≤ùëñ are large we will see only small changes in ¬Øùë•ùëñ and in the minimum of ¬Øùëì. Conversely, for small ùö≤ùëñ changes in ¬Øùë•ùëñ can be dramatic. The ratio between the largest and the smallest eigenvalue is called the condition number of an optimization problem. Iftheconditionnumber ùúÖ islarge, it isdifficult tosolvetheoptimizationproblemaccurately. We need to ensure that we are careful in getting a large dynamic range of values right. Our
ùö≤1
ùúÖ = ùö≤ùëë . (12.7.2)
521

analysis leads to an obvious, albeit somewhat naive question: couldn‚Äôt we simply ‚Äúfix‚Äù the problem by distorting the space such that all eigenvalues are 1. In theory this is quite easy: we only need the eigenvalues and eigenvectors of Q to rescale the problem from x to one in z def = ùö≤ 1 2Ux. In the new coordinate system x>Qx could be simplified to kzk2. Alas, this is a rather impractical suggestion. Computing eigenvalues and eigenvectors is in general much more expensive than solving the actual problem. While computing eigenvalues exactly might be expensive, guessing them and computing them even somewhat approximately may already be a lot better than not doing anything at all. In particular, we could use the diagonal entries of Q and rescale it accordingly. This is much cheaper than computing eigenvalues. Q = diag? (Q)Qdiag~2(Q). (12.7.3)
p
In this case we have Qi; = Qi;/¬•QiiQ;; and specifically Qi; = 1 for all 7. In most cases this simplifies the condition number considerably.bubuFor instance, the cases we discussed previously, this would entirely eliminate the problem at hand since the problem is axis aligned. Unfortunately we face yet another problem: in deep learning we typically do not even have access to the second derivative of the objective function: for x 2 Rùëë the second derivative even on a minibatch may require O‚Äûùëë2‚Äù space and work to compute, thus making it practi- cally infeasible. The ingenious idea of Adagrad is to use a proxy for that elusive diagonal of the Hessian that is both relatively cheap to compute and effective‚Äîthe magnitude of the gradient itself. In order to see why this works, let‚Äôs look at ¬Øùëì ‚Äû¬Øx‚Äù. We have that
Oxf (%) = AX +E = A(X - Xo),
(12.7.4)
where Xo is the minimizer of f. Hence the magnitude of the gradient depends both on A and the distance from optimality. If x ‚Äî Xp did not change, this would be all that is needed. After all, in this case the magnitude of the gradient dz f() suffices. Since AdaGrad is a stochastic gradient descent algorithm, we will see gradients with nonzero variance even at optimality. As a result we can safely use the variance of the gradients as a cheap proxy for the scale of the Hessian. A thorough analysis is beyond the scope of this section (it would be several pages). We refer the reader to (Duchi et al., 2011) for details. 12.7.3 The Algorithm
Let‚Äôs formalize the discussion from above. We use the variable sùë° to accumulate past gra- dient variance as follows. Sr = Owl(y1, f(x, w)), 8 =S8)-1+ 8 (12.7.5) ‚ÄúSr. Wr = Wr-1 ‚Äî i] Vs: + ‚Ç¨
Adagrad
Optimization Algorithms
522

Here the operation are applied coordinate wise. That is, v2 has entries ùë£2
Here the operation are applied coordinate wise. That is, v? has entries ve. Likewise ¬• has 1 and u- v has entries u;v;. As before 77 is the learning rate and ‚Ç¨ is an additive constant that ensures that we do not divide by 0. Last, we initialize so = 0. entries
Just like in the case of momentum we need to keep track of an auxiliary variable, in this case to allow for an individual learning rate per coordinate. This does not increase the cost of Adagrad significantly relative to SGD, simply since the main cost is typically to compute ùëô‚Äûùë¶ùë°, ùëì ‚Äûxùë°,w‚Äù‚Äù and its derivative. Note that accumulating squared gradients in s; means that s; grows essentially at linear rate (somewhat slower than linearly in practice, since the gradients initially diminish). This leads to an O(t-?) learning rate, albeit adjusted on a per coordinate basis. For convex problems this is perfectly adequate. In deep learning, though, we might want to decrease the learning rate rather more slowly. This led to a number of Adagrad variants that we will discuss in the subsequent chapters. For now let‚Äôs see how it behaves in a quadratic convex problem. We use the same problem as before:
ùëì ‚Äûx‚Äù = 0.1ùë•2 ‚Äö 2ùë•2 . (12.7.6)
We are going to implement Adagrad using the same learning rate previously, i.e., ùúÇ = 0.4. As we can see, the iterative trajectory of the independent variable is smoother. However, due to the cumulative effect of ùíîùë°, the learning rate continuously decays, so the independent variable does not move as much during later stages of iteration. %matplotlib inline import math import torch from d2l import torch as d2l
def adagrad_2d(x1, x2, s1, s2): eps = 1e-6 g1, g2 = 0.2 * x1, 4 * x2 s1 += g1 ** 2 s2 += g2 ** 2 x1 -= eta / math.sqrt(s1 + eps) * g1 x2 -= eta / math.sqrt(s2 + eps) * g2 return x1, x2, s1, s2 def f_2d(x1, x2): return 0.1 * x1 ** 2 + 2 * x2 ** 2 eta = 0.4 d2l.show_trace_2d(f_2d, d2l.train_2d(adagrad_2d))
epoch 20, x1: -2.382563, x2: -0.158591
As we increase the learning rate to 2 we see much better behavior. This already indicates that the decrease in learning rate might be rather aggressive, even in the noise-free case and we need to ensure that parameters converge appropriately. 2
1
523


eta = 2 d2l.show_trace_2d(f_2d, d2l.train_2d(adagrad_2d))
epoch 20, x1: -0.002295, x2: -0.000000

12.7.4 Implementation from Scratch
Just like the momentum method, Adagrad needs to maintain a state variable of the same shape as the parameters. def init_adagrad_states(feature_dim): s_w = torch.zeros((feature_dim, 1)) s_b = torch.zeros(1) return (s_w, s_b) def adagrad(params, states, hyperparams): eps = 1e-6 for p, s in zip(params, states): with torch.no_grad(): s[:] += torch.square(p.grad) p[:] -= hyperparams['lr'] * p.grad / torch.sqrt(s + eps) p.grad.data.zero_()
Compared to the experiment in Section 12.5 we use a larger learning rate to train the model. Adagrad
Optimization Algorithms
524

data_iter, feature_dim = d2l.get_data_ch11(batch_size=10) d2l.train_ch11(adagrad, init_adagrad_states(feature_dim), {'lr': 0.1}, data_iter, feature_dim);
loss: 0.243, 0.162 sec/epoch
0.350 0.325 0.300 wa a ie] ~ 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
12.7.5 Concise Implementation
Using the Trainer instance of the algorithm adagrad, we can invoke the Adagrad algo- rithm in Gluon. trainer = torch.optim.Adagrad d2l.train_concise_ch11(trainer, {'lr': 0.1}, data_iter)
loss: 0.242, 0.129 sec/epoch
0.350 0.325 0.300 loss 0.275 0.250 \ 0.225
12.7.6 Summary
e Adagrad decreases the learning rate dynamically on a per-coordinate basis. e It uses the magnitude of the gradient as a means of adjusting how quickly progress is
achieved - coordinates with large gradients are compensated with a smaller learning rate. 525

e Computing the exact second derivative is typically infeasible in deep learning problems
due to memory and computational constraints. The gradient can be a useful proxy. e If the optimization problem has a rather uneven structure Adagrad can help mitigate the
distortion. e Adagrad is particularly effective for sparse features where the learning rate needs to de-
crease more slowly for infrequently occurring terms. e On deep learning problems Adagrad can sometimes be too aggressive in reducing learn-
ing rates. We will discuss strategies for mitigating this in the context of Section 12.10.bubu12.7.7 Exercises
1. Prove that for an orthogonal matrix U and a vector c the following holds: ||c ‚Äî ffill2 =
1. Prove that for an orthogonal matrix U and a vector c the following holds: ||c ‚Äî ffill2 = ||Uc‚Äî Uffill2. Why does this mean that the magnitude of perturbations does not change after an orthogonal change of variables? 2. Try out Adagrad for f(x) = 0. Ix? + 2x5 and also for the objective function was rotated by 45 degrees, i.e., f(x) = 0.1(x1 +.x2)? + 2(x1 ‚Äî x2)?. Does it behave differently?bubu3. Prove Gerschgorin‚Äôs circle theorem!‚Äù‚Äù which states that eigenvalues 2; of a matrix M satisfy |; - Mjj| < Dee; [Mjx| for at least one choice of j. 177
4. What does Gerschgorin‚Äôs theorem tell us about the eigenvalues of the diagonally pre- conditioned matrix diag~ ? (M1) Mdiag‚Ñ¢ ?bubu(M)?bubu5. TryoutAdagradforaproperdeepnetwork, suchasSection7.6whenappliedtoFashion- MNIST. 6. How would you need to modify Adagrad to achieve a less aggressive decay in learning rate? Discussions178. 178
12.8 RMSProp
a
One of the key issues in Section 12.7 is that the learning rate decreases at a predefined schedule of effectively O(t-?). While this is generally appropriate for convex problems, it might not be ideal for nonconvex ones, such as those encountered in deep learning. Yet, the coordinate-wise adaptivity of Adagrad is highly desirable as a preconditioner. Tieleman and Hinton (2012) proposed the RMSProp algorithm as a simple fix to decouple rate scheduling from coordinate-adaptive learning rates. The issue is that Adagrad accu- mulates the squares of the gradient g, into a state vector s; = s;-| + g?. As a result s; keeps on growing without bound due to the lack of normalization, essentially linearly as the algorithm converges. RMSProp
Optimization Algorithms
526

One way of fixing this problem would be to use s,/t. For reasonable distributions of g;
One way of fixing this problem would be to use s,/t. For reasonable distributions of g; this will converge. Unfortunately it might take a very long time until the limit behavior starts to matter since the procedure remembers the full trajectory of values. An alternative is to use a leaky average in the same way we used in the momentum method, i.e., s, <‚Äî ys:-1 + (1 ‚Äî y)g? for some parameter y > 0. Keeping all other parts unchanged yields RMSProp. 12.8.1 The Algorithm
Let‚Äôs write out the equations in detail. Ss) ‚Äî ys;-1+ (1-y)g;, n (12.8.1) X, ‚Äî X-1 ‚Äî ~‚Äî‚Äî O8;- S; +e
The constant ‚Ç¨ > 0 is typically set to 10~¬∞ to ensure that we do not suffer from division by zero or overly large step sizes. Given this expansion we are now free to control the learning rate 7 independently of the scaling that is applied on a per-coordinate basis. In terms of leaky averages we can apply the same reasoning as previously applied in the case of the momentum method. Expanding the definition of s; yields
s,
=(1-y)g7 +811 (12.8.2) =(1-y) (s? + y87_, +P gi2t....). As before in Section 12.6 we use l+y+y?+...,= ry Hence the sum of weights is normalized to 1 with a half-life time of an observation of y~!. Let‚Äôs visualize the weights for the past 40 time steps for various choices of y. import math import torch from d2l import torch as d2l
d2l.set_figsize() gammas = [0.95, 0.9, 0.8, 0.7] for gamma in gammas: x = torch.arange(40).detach().numpy() d2l.plt.plot(x, (1-gamma) * gamma ** x, label=f'gamma = {gamma:.2f}') d2l.plt.xlabel('time');
12.8.2 Implementation from Scratch
As before we use the quadratic function ùëì ‚Äûx‚Äù = 0.1ùë•2 1 ‚Äö 2ùë•2 2 to observe the trajectory of RMSProp. Recall that in Section 12.7, when we used Adagrad with a learning rate of 0.4, the variables moved only very slowly in the later stages of the algorithm since the learning rate decreased too quickly. Since ùúÇ is controlled separately this does not happen with RMSProp. 527

0.3 0.2 o1 0.0 i) 10 20 30 40 time
def rmsprop_2d(x1, x2, s1, s2): g1, g2, eps = 0.2 * x1, 4 * x2, 1e-6 s1 = gamma * s1 + (1 - gamma) * g1 ** 2 s2 = gamma * s2 + (1 - gamma) * g2 ** 2 x1 -= eta / math.sqrt(s1 + eps) * g1 x2 -= eta / math.sqrt(s2 + eps) * g2 return x1, x2, s1, s2 def f_2d(x1, x2): return 0.1 * x1 ** 2 + 2 * x2 ** 2 eta, gamma = 0.4, 0.9 d2l.show_trace_2d(f_2d, d2l.train_2d(rmsprop_2d))
epoch 20, x1: -0.010599, x2: 0.000000
x2 I a
Next, we implement RMSProp to be used in a deep network. This is equally straightfor- ward. def init_rmsprop_states(feature_dim): s_w = torch.zeros((feature_dim, 1)) s_b = torch.zeros(1) return (s_w, s_b)
def rmsprop(params, states, hyperparams): gamma, eps = hyperparams['gamma'], 1e-6
RMSProp
(continues on next page)
Optimization Algorithms
528

for p, s in zip(params, states): with torch.no_grad(): s[:] = gamma * s + (1 - gamma) * torch.square(p.grad) p[:] -= hyperparams['lr'] * p.grad / torch.sqrt(s + eps) p.grad.data.zero_()
We set the initial learning rate to 0.01 and the weighting term ùõæ to 0.9. That is, s aggregates
We set the initial learning rate to 0.01 and the weighting term y to 0.9. That is, s aggregates on average over the past 1/(1 ‚Äî y) = 10 observations of the square gradient. data_iter, feature_dim = d2l.get_data_ch11(batch_size=10) d2l.train_ch11(rmsprop, init_rmsprop_states(feature_dim), {'lr': 0.01, 'gamma': 0.9}, data_iter, feature_dim);
loss: 0.245, 0.245 sec/epoch
0.350 0.325 0.300 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
loss
12.8.3 Concise Implementation
Since RMSProp is a rather popular algorithm it is also available in the Trainer instance. All we need to do is instantiate it using an algorithm named rmsprop, assigning ùõæ to the parameter gamma1. parameter gammal. trainer = torch.optim.RMSprop d2l.train_concise_ch11(trainer, {'lr': 0.01, 'alpha': 0.9}, data_iter)
loss: 0.246, 0.129 sec/epoch
12.8.4 Summary
e RMSProp is very similar to Adagrad insofar as both use the square of the gradient to
scale coefficients. e RMSProp shares with momentum the leaky averaging. However, RMSProp uses the
technique to adjust the coefficient-wise preconditioner. (continued from previous page)
529

0.350 0.325 0,300 loss 0.275 0.250 0.225
e The learning rate needs to be scheduled by the experimenter in practice. e The coefficient y determines how long the history is when adjusting the per-coordinate
scale. 12.8.5 Exercises
1. What happens experimentally if we set ùõæ = 1? Why?bubu2. Rotate the optimization problem to minimize f(x) = 0.1 (x1 +.x2)? +2(x1 ‚Äîx2)*. What
happens to the convergence?bubu3. Try out what happens to RMSProp on a real machine learning problem, such as training on Fashion-MNIST. Experiment with different choices for adjusting the learning rate. 4. Would you want to adjust ùõæ as optimization progresses? How sensitive is RMSProp to
this? Discussions179. 179
mae
12.9 Adadelta

Adadelta is yet another variant of AdaGrad (Section 12.7). The main difference lies in the fact that it decreases the amount by which the learning rate is adaptive to coordinates. Moreover, traditionally it referred to as not having a learning rate since it uses the amount of change itself as calibration for future change. The algorithm was proposed in Zeiler (2012).bubuIt is fairly straightforward, given the discussion of previous algorithms so far. 12.9.1 The Algorithm
In a nutshell, Adadelta uses two state variables, sùë° to store a leaky average of the second momentofthegradientandŒîxùë° tostorealeakyaverageofthesecondmomentofthechange of parameters in the model itself. Note that we use the original notation and naming of the authors for compatibility with other publications and implementations (there is no other
Adadelta
Optimization Algorithms
530

real reason why one should use different Greek variables to indicate a parameter serving the same purpose in momentum, Adagrad, RMSProp, and Adadelta). Here are the technical details of Adadelta. Given the parameter du jour is ùúå, we obtain the
following leaky updates similarly to Section 12.8:
St = p81 + (1 ‚Äî p)g?. (12.9.1)
The difference to Section 12.8 is that we perform updates with the rescaled gradient g0
ùë°, i.e.,
X, = X-1 ‚Äî By. ùë°. (12.9.2)
So what is the rescaled gradient g0
ùë°? We can calculate it as follows:
VAX;-1 + g, = og, (12.9.3) Vs; +‚Ç¨
where Ax;,_ is the leaky average of the squared rescaled gradients g;. ùë°. We initialize Œîx0 to be 0 and update it at each step with g0 ùë°, i.e.,
Ax, = pAx;-1 + (1 - p)g‚Äù‚Äù, (12.9.4)
and ‚Ç¨ (a small value such as 10~>) is added to maintain numerical stability. 12.9.2 Implementation
Adadelta needs to maintain two state variables for each variable, sùë° and Œîxùë°. This yields the following implementation. %matplotlib inline import torch from d2l import torch as d2l def init_adadelta_states(feature_dim): s_w, s_b = torch.zeros((feature_dim, 1)), torch.zeros(1) delta_w, delta_b = torch.zeros((feature_dim, 1)), torch.zeros(1) return ((s_w, delta_w), (s_b, delta_b)) def adadelta(params, states, hyperparams): rho, eps = hyperparams['rho'], 1e-5 for p, (s, delta) in zip(params, states): with torch.no_grad(): # In-place updates via [:] s[:] = rho * s + (1 - rho) * torch.square(p.grad) g = (torch.sqrt(delta + eps) / torch.sqrt(s + eps)) * p.grad p[:] -= g delta[:] = rho * delta + (1 - rho) * g * g p.grad.data.zero_()
Choosing ùúå = 0.9 amounts to a half-life time of 10 for each parameter update. This tends
to work quite well. We get the following behavior. p
531

data_iter, feature_dim = d2l.get_data_ch11(batch_size=10) d2l.train_ch11(adadelta, init_adadelta_states(feature_dim), {'rho': 0.9}, data_iter, feature_dim);
loss: 0.245, 0.160 sec/epoch
0.350 0.325 0,300 loss 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
For a concise implementation we simply use the Adadelta algorithm from high-level APIs. This yields the following one-liner for a much more compact invocation. trainer = torch.optim.Adadelta d2l.train_concise_ch11(trainer, {'rho': 0.9}, data_iter)
loss: 0.243, 0.119 sec/epoch
0.350 0.325 0.300 loss 0.275 0.250 0.225 epoch
12.9.3 Summary
e Adadelta has no learning rate parameter. Instead, it uses the rate of change in the param-
eters itself to adapt the learning rate. e Adadelta requires two state variables to store the second moments of gradient and the
change in parameters. e Adadelta uses leaky averages to keep a running estimate of the appropriate statistics. Adadelta
Optimization Algorithms
532

12.9.4 Exercises
1. Adjust the value of ùúå. What happens?bubu2. Show how to implement the algorithm without the use of g0
ùë°. Why might this be a good idea?bubu3. Is Adadelta really learning rate free? Could you find optimization problems that break Adadelta? 4. Compare Adadelta to Adagrad and RMS prop to discuss their convergence behavior. Discussions180. 180
Discussions !8¬∞,
12.10 Adam

In the discussions leading up to this section we encountered a number of techniques for efficient optimization. Let‚Äôs recap them in detail here:
e We saw that Section 12.4 is more effective than Gradient Descent when solving opti-
mization problems, e.g., due to its inherent resilience to redundant data. We saw that Section 12.5 affords significant additional efficiency arising from vector-
ization, using larger sets of observations in one minibatch. This is the key to efficient multi-machine, multi-GPU and overall parallel processing. Section 12.6 added a mechanism for aggregating a history of past gradients to accelerate
convergence. Section 12.7 used per-coordinate scaling to allow for a computationally efficient precon-
ditioner. Section 12.8 decoupled per-coordinate scaling from a learning rate adjustment. Adam (Kingma and Ba, 2014) combines all these techniques into one efficient learning algorithm. As expected, this is an algorithm that has become rather popular as one of the more robust and effective optimization algorithms to use in deep learning. It is not without issues, though. In particular, (Reddi et al., 2019) show that there are situations where Adam can diverge due to poor variance control. In a follow-up work Zaheer et al. (2018) proposed a hotfix to Adam, called Yogi which addresses these issues. More on this later.bubuFor now let‚Äôs review the Adam algorithm. 12.10.1 The Algorithm
One of the key components of Adam is that it uses exponential weighted moving averages (also known as leaky averaging) to obtain an estimate of both the momentum and also the
533

second moment of the gradient. That is, it uses the state variables
vi ‚Äî Bivi-1+ (1 - Bigs,
vi ‚Äî Bivi-1+ (1 - Bigs, 8, ‚Äî Pos;-1+ (1 - Bo) 8.bubu(12.10.1)
Here ¬£; and ¬£2 are nonnegative weighting parameters. Common choices for them are Bh = 0.9 and B2 = 0.999. That is, the variance estimate moves much more slowly than the momentum term. Note that if we initialize vo = so = 0 we have a significant amount of bias initially towards smaller values. This can be addressed by using the fact that Da p= ce to re-normalize terms. Correspondingly the normalized state variables are given by
vùë°
nN d Sr vi = and 5; 12.10.2 '=TL Bi ¬´= TL B ( )
Armed with the proper estimates we can now write out the update equations. First, we rescale the gradient in a manner very much akin to that of RMSProp to obtain
g0 ùë° = ùúÇÀÜvùë°p ÀÜsùë° ‚Äö ùúñ . (12.10.3)
Unlike RMSProp our update uses the momentum 7, rather than the gradient itself. More- over, there is a slight cosmetic difference as the rescaling happens using Je EE The former works arguably slightly better in practice, hence the deviation from RM- SProp. Typically we pick ‚Ç¨ = 10~¬∞ for a good trade-off between numerical stability and fidelity. instead of
Now we have all the pieces in place to compute updates. This is slightly anticlimactic and we have a simple update of the form
X ‚Äî Xy-1 - &-
ùë°. (12.10.4)
Reviewing the design of Adam its inspiration is clear. Momentum and scale are clearly visible in the state variables. Their rather peculiar definition forces us to debias terms (this could be fixed by a slightly different initialization and update condition). Second, the combination of both terms is pretty straightforward, given RMSProp. Last, the explicit learning rate ùúÇ allows us to control the step length to address issues of convergence. 12.10.2 Implementation
Implementing Adam from scratch is not very daunting. For convenience we store the time step counter ùë° in the hyperparams dictionary. Beyond that all is straightforward. %matplotlib inline import torch from d2l import torch as d2l
def init_adam_states(feature_dim): v_w, v_b = torch.zeros((feature_dim, 1)), torch.zeros(1) s_w, s_b = torch.zeros((feature_dim, 1)), torch.zeros(1) return ((v_w, s_w), (v_b, s_b))
Adam
sùë°
(continues on next page)
Optimization Algorithms
534

def adam(params, states, hyperparams): beta1, beta2, eps = 0.9, 0.999, 1e-6 for p, (v, s) in zip(params, states): with torch.no_grad(): v[:] = beta1 * v + (1 - beta1) * p.grad s[:] = beta2 * s + (1 - beta2) * torch.square(p.grad) v_bias_corr = v / (1 - beta1 ** hyperparams['t']) s_bias_corr = s / (1 - beta2 ** hyperparams['t']) p[:] -= hyperparams['lr'] * v_bias_corr / (torch.sqrt(s_bias_corr) + eps) p.grad.data.zero_() hyperparams['t'] += 1
We are ready to use Adam to train the model. We use a learning rate of ùúÇ = 0.01. data_iter, feature_dim = d2l.get_data_ch11(batch_size=10) d2l.train_ch11(adam, init_adam_states(feature_dim), {'lr': 0.01, 't': 1}, data_iter, feature_dim);
loss: 0.243, 0.193 sec/epoch
0.350 0.325 0.300 loss 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
A more concise implementation is straightforward since adam is one of the algorithms pro- vided as part of the Gluon trainer optimization library. Hence we only need to pass configuration parameters for an implementation in Gluon. trainer = torch.optim.Adam
d2l.train_concise_ch11(trainer, {'lr': 0.01}, data_iter)
loss: 0.243, 0.152 sec/epoch
12.10.3 Yogi
One of the problems of Adam is that it can fail to converge even in convex settings when the second moment estimate in sùë° blows up. As a fix Zaheer et al. (2018) proposed a refined
(continued from previous page)
535

0.350 0.325 0,300 loss 0.275 0.250 0.225 epoch
update (and initialization) for sùë°. To understand what‚Äôs going on, let‚Äôs rewrite the Adam update as follows:
S; ‚Äî S;-1 + (1 - f2) (gs? -s:-1).bubu(12.10.5)
Whenever g? has high variance or updates are sparse, s, might forget past values too quickly. A possible fix for this is to replace g>‚Äîs,_, by g?Osgn(g?‚Äîs,_1). Now the magnitude of the update no longer depends on the amount of deviation. This yields the Yogi updates
Ss ¬© s;-1 + (1‚Äî Bo)g? ¬© sgn(g?bubu‚Äî s;-1). (12.10.6)
The authors furthermore advise to initialize the momentum on a larger initial batch rather than just initial pointwise estimate. We omit the details since they are not material to the discussion and since even without this convergence remains pretty good. def yogi(params, states, hyperparams): beta1, beta2, eps = 0.9, 0.999, 1e-3 for p, (v, s) in zip(params, states): with torch.no_grad(): v[:] = beta1 * v + (1 - beta1) * p.grad s[:] = s + (1 - beta2) * torch.sign( torch.square(p.grad) - s) * torch.square(p.grad) v_bias_corr = v / (1 - beta1 ** hyperparams['t']) s_bias_corr = s / (1 - beta2 ** hyperparams['t']) p[:] -= hyperparams['lr'] * v_bias_corr / (torch.sqrt(s_bias_corr) + eps) p.grad.data.zero_() hyperparams['t'] += 1 data_iter, feature_dim = d2l.get_data_ch11(batch_size=10) d2l.train_ch11(yogi, init_adam_states(feature_dim), {'lr': 0.01, 't': 1}, data_iter, feature_dim);
loss: 0.243, 0.165 sec/epoch
12.10.4 Summary
e Adam combines features of many optimization algorithms into a fairly robust update
rule. Adam
Optimization Algorithms
536

0.350 0.325 0,300 loss 0.275 0.250 0.225 0.0 0.5 1.0 15 2.0 epoch
e Created on the basis of RMSProp, Adam also uses EWMA on the minibatch stochastic
gradient.bubue Adam uses bias correction to adjust for a slow startup when estimating momentum and
a second moment. e For gradients with significant variance we may encounter issues with convergence. They
can be amended by using larger minibatches or by switching to an improved estimate for sùë°. Yogi offers such an alternative. 12.10.5 Exercises
1. Adjust the learning rate and observe and analyze the experimental results. 2. Can you rewrite momentum and second moment updates such that it does not require bias correction? 3. Why do you need to reduce the learning rate ùúÇ as we converge? 4. Try to construct a case for which Adam diverges and Yogi converges? Discussions181. 181
Discussions !*?,
12.11 Learning Rate Scheduling
a
Sofarweprimarilyfocusedonoptimizationalgorithmsforhowtoupdatetheweightvectors rather than on the rate at which they are being updated. Nonetheless, adjusting the learning rate is often just as important as the actual algorithm. There are a number of aspects to consider:
e Most obviously the magnitude of the learning rate matters. If it is too large, optimization diverges, if it is too small, it takes too long to train or we end up with a suboptimal result. We saw previously that the condition number of the problem matters (see e.g., Section 12.6 for details). Intuitively it is the ratio of the amount of change in the least sensitive direction vs. the most sensitive one. Learning Rate Scheduling
537

e Secondly, the rate of decay is just as important. If the learning rate remains large we may
e Secondly, the rate of decay is just as important. If the learning rate remains large we may simply end up bouncing around the minimum and thus not reach optimality. Section 12.5 discussed this in some detail and we analyzed performance guarantees in Section 12.4. In short, we want the rate to decay, but probably more slowly than O(t~ 2) which would be a good choice for convex problems. e Another aspect that is equally important is initialization. This pertains both to how the
parameters are set initially (review Section 5.4 for details) and also how they evolve initially. This goes under the moniker of warmup, i.e., how rapidly we start moving towards the solution initially. Large steps in the beginning might not be beneficial, in particular since the initial set of parameters is random. The initial update directions might be quite meaningless, too. e Lastly, there are a number of optimization variants that perform cyclical learning rate
adjustment. This is beyond the scope of the current chapter. We recommend the reader to review details in Izmailov et al. (2018), e.g., how to obtain better solutions by averaging over an entire path of parameters. Given the fact that there is a lot of detail needed to manage learning rates, most deep learn- ing frameworks have tools to deal with this automatically. In the current chapter we will review the effects that different schedules have on accuracy and also show how this can be managed efficiently via a learning rate scheduler. 12.11.1 Toy Problem
We begin with a toy problem that is cheap enough to compute easily, yet sufficiently non- trivial to illustrate some of the key aspects. For that we pick a slightly modernized version of LeNet (relu instead of sigmoid activation, MaxPooling rather than AveragePooling), as applied to Fashion-MNIST. Moreover, we hybridize the network for performance. Since most of the code is standardwejustintroduce thebasics without furtherdetaileddiscussion.bubuSee Chapter 7 for a refresher as needed. %matplotlib inline import math import torch from torch import nn from torch.optim import lr_scheduler from d2l import torch as d2l def net_fn(): model = nn.Sequential( nn.Conv2d(1, 6, kernel_size=5, padding=2), nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2), nn.Conv2d(6, 16, kernel_size=5), nn.ReLU(), nn.MaxPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.Linear(16 * 5 * 5, 120), nn.ReLU(), nn.Linear(120, 84), nn.ReLU(), nn.Linear(84, 10))
(continues on next page)
Optimization Algorithms
538

return model loss = nn.CrossEntropyLoss() device = d2l.try_gpu() batch_size = 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size) # The code is almost identical to `d2l.train_ch6` defined in the # lenet section of chapter convolutional neural networks def train(net, train_iter, test_iter, num_epochs, loss, trainer, device, scheduler=None): net.to(device) animator = d2l.Animator(xlabel='epoch', xlim=[0, num_epochs], legend=['train loss', 'train acc', 'test acc']) for epoch in range(num_epochs): metric = d2l.Accumulator(3) # train_loss, train_acc, num_examples for i, (X, y) in enumerate(train_iter): net.train() trainer.zero_grad() X, y = X.to(device), y.to(device) y_hat = net(X) l = loss(y_hat, y) l.backward() trainer.step() with torch.no_grad(): metric.add(l * X.shape[0], d2l.accuracy(y_hat, y), X.shape[0]) train_loss = metric[0] / metric[2] train_acc = metric[1] / metric[2] if (i + 1) % 50 == 0: animator.add(epoch + i / len(train_iter), (train_loss, train_acc, None)) test_acc = d2l.evaluate_accuracy_gpu(net, test_iter) animator.add(epoch+1, (None, None, test_acc)) if scheduler: if scheduler.__module__ == lr_scheduler.__name__: # Using PyTorch In-Built scheduler scheduler.step() else: # Using custom defined scheduler for param_group in trainer.param_groups: param_group['lr'] = scheduler(epoch) print(f'train loss {train_loss:.3f}, train acc {train_acc:.3f}, ' f'test acc {test_acc:.3f}')
Let‚Äôs have a look at what happens if we invoke this algorithm with default settings, such as a learning rate of 0.3 and train for 30 iterations. Note how the training accuracy keeps on increasing while progress in terms of test accuracy stalls beyond a point. The gap between both curves indicates overfitting. (continued from previous page)
Learning Rate Scheduling
539

lr, num_epochs = 0.3, 30 net = net_fn() trainer = torch.optim.SGD(net.parameters(), lr=lr) train(net, train_iter, test_iter, num_epochs, loss, trainer, device)
train loss 0.145, train acc 0.944, test acc 0.877
‚Äî train loss --- train acc ‚Äî-- test acc 2.0 0 5 10 15 20 25 30 epoch
12.11.2 Schedulers
One way of adjusting the learning rate is to set it explicitly at each step. This is conve- niently achieved by the set_learning_rate method. We could adjust it downward after every epoch (or even after every minibatch), e.g., in a dynamic manner in response to how optimization is progressing. lr = 0.1 trainer.param_groups[0]["lr"] = lr print(f'learning rate is now {trainer.param_groups[0]["lr"]:.2f}')
Ir = 0.1
learning rate is now 0.10
More generally we want to define a scheduler. When invoked with the number of updates it returns the appropriate value of the learning rate. Let‚Äôs define a simple one that sets the learning rate to 7 = (t+ N72. class SquareRootScheduler: def __init__(self, lr=0.1): self.lr = lr def __call__(self, num_update): return self.lr * pow(num_update + 1.0, -0.5)
Let‚Äôs plot its behavior over a range of values. scheduler = SquareRootScheduler(lr=0.1) d2l.plot(torch.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
Optimization Algorithms
540

0.10 0.08 0.04 0.02
Now let‚Äôs see how this plays out for training on Fashion-MNIST. We simply provide the scheduler as an additional argument to the training algorithm. net = net_fn() trainer = torch.optim.SGD(net.parameters(), lr) train(net, train_iter, test_iter, num_epochs, loss, trainer, device, scheduler)
train loss 0.273, train acc 0.900, test acc 0.886
2.0 ‚Äî train loss === train acc ‚Äî-- test acc 15 ¬∞ u 10 15 20 25 30 epoch
This worked quite a bit better than previously. Two things stand out: the curve was rather more smooth than previously. Secondly, there was less overfitting. Unfortunately it is not a well-resolved question as to why certain strategies lead to less overfitting in theory. There is some argument that a smaller stepsize will lead to parameters that are closer to zero and thussimpler. However, thisdoesnotexplainthephenomenonentirelysincewedonotreally stop early but simply reduce the learning rate gently. 12.11.3 Policies
While we cannot possibly cover the entire variety of learning rate schedulers, we attempt to give a brief overview of popular policies below. Common choices are polynomial decay and piecewise constant schedules. Beyond that, cosine learning rate schedules have been found to work well empirically on some problems. Lastly, on some problems it is beneficial to warm up the optimizer prior to using large learning rates. Learning Rate Scheduling
541

Factor Scheduler
One alternative to a polynomial decay would be a multiplicative one, that is 7441 < mr -@
One alternative to a polynomial decay would be a multiplicative one, that is 7441 < mr -@ for a ‚Ç¨ (0, 1). To prevent the learning rate from decaying beyond a reasonable lower bound the update equation is often modified to 77,41 ‚Äî max(7min, Mr * @)-
class FactorScheduler: def __init__(self, factor=1, stop_factor_lr=1e-7, base_lr=0.1): self.factor = factor self.stop_factor_lr = stop_factor_lr self.base_lr = base_lr def __call__(self, num_update): self.base_lr = max(self.stop_factor_lr, self.base_lr * self.factor) return self.base_lr
scheduler = FactorScheduler(factor=0.9, stop_factor_lr=1e-2, base_lr=2.0) d2l.plot(torch.arange(50), [scheduler(t) for t in range(50)])
1.545 1.04 0.54 0.04
This can also be accomplished by a built-in scheduler in MXNet via the lr_scheduler. FactorScheduler object. It takes a few more parameters, such as warmup period, warmup mode (linear or constant), the maximum number of desired updates, etc.; Going forward we will use the built-in schedulers as appropriate and only explain their functionality here. As illustrated, it is fairly straightforward to build your own scheduler if needed. Multi Factor Scheduler
A common strategy for training deep networks is to keep the learning rate piecewise con- stant and to decrease it by a given amount every so often. That is, given a set of times when to decrease the rate, such as s = {5, 10,20} decrease 77,41 <‚Äî 7; -@ whenever t ‚Ç¨ s. Assuming that the values are halved at each step we can implement this as follows. net = net_fn() trainer = torch.optim.SGD(net.parameters(), lr=0.5) scheduler = lr_scheduler.MultiStepLR(trainer, milestones=[15, 30], gamma=0.5) def get_lr(trainer, scheduler): lr = scheduler.get_last_lr()[0] trainer.step()
(continues on next page)
Optimization Algorithms
542

scheduler.step() return lr
d2l.plot(torch.arange(num_epochs), [get_lr(trainer, scheduler) for t in range(num_epochs)])
0.50 0.45 0.40 0.35 0.30 0.25
The intuition behind this piecewise constant learning rate schedule is that one lets opti- mization proceed until a stationary point has been reached in terms of the distribution of weight vectors. Then (and only then) do we decrease the rate such as to obtain a higher quality proxy to a good local minimum. The example below shows how this can produce ever slightly better solutions. train(net, train_iter, test_iter, num_epochs, loss, trainer, device, scheduler)
train loss 0.194, train acc 0.927, test acc 0.869
‚Äî train loss --- train acc ‚Äî-- test acc 2.0 epoch
Cosine Scheduler
A rather perplexing heuristic was proposed by Loshchilov and Hutter (2016). It relies on the observation that we might not want to decrease the learning rate too drastically in the beginning and moreover, that we might want to ‚Äúrefine‚Äù the solution in the end using a very small learning rate. This results in a cosine-like schedule with the following functional
(continued from previous page)
Learning Rate Scheduling
543

form for learning rates in the range ùë° 2 ¬ª0,ùëá‚Ä¶. mt = mr + Po (1 +c0s(at/T)) (12.11.1)
Here ùúÇ0 is the initial learning rate, ùúÇùëá is the target rate at time ùëá. Furthermore, for ùë° > ùëá
we simply pin the value to ùúÇùëá without increasing it again. In the following example, we set the max update step ùëá = 20. class CosineScheduler: def __init__(self, max_update, base_lr=0.01, final_lr=0, warmup_steps=0, warmup_begin_lr=0): self.base_lr_orig = base_lr self.max_update = max_update self.final_lr = final_lr self.warmup_steps = warmup_steps self.warmup_begin_lr = warmup_begin_lr self.max_steps = self.max_update - self.warmup_steps def get_warmup_lr(self, epoch): increase = (self.base_lr_orig - self.warmup_begin_lr) \ * float(epoch) / float(self.warmup_steps) return self.warmup_begin_lr + increase def __call__(self, epoch): if epoch < self.warmup_steps: return self.get_warmup_lr(epoch) if epoch <= self.max_update: self.base_lr = self.final_lr + ( self.base_lr_orig - self.final_lr) * (1 + math.cos( math.pi * (epoch - self.warmup_steps) / self.max_steps)) / 2 return self.base_lr
scheduler = CosineScheduler(max_update=20, base_lr=0.3, final_lr=0.01) d2l.plot(torch.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
0.3 0.2 0.1 0.0 0 10 20 30
In the context of computer vision this schedule can lead to improved results. Note, though, that such improvements are not guaranteed (as can be seen below). net = net_fn() trainer = torch.optim.SGD(net.parameters(), lr=0.3) train(net, train_iter, test_iter, num_epochs, loss, trainer, device, scheduler)
Optimization Algorithms
544

train loss 0.159, train acc 0.942, test acc 0.904
‚Äî train loss --- train acc ‚Äî-- test acc 2.0 te) 5 10 15 20 25 30 epoch
In some cases initializing the parameters is not sufficient to guarantee a good solution. This is particularly a problem for some advanced network designs that may lead to unstable optimization problems. We could address this by choosing a sufficiently small learning rate to prevent divergence in the beginning. Unfortunately this means that progress is slow. Conversely, a large learning rate initially leads to divergence. Arathersimplefixforthisdilemmaistouseawarmupperiodduringwhichthelearningrate increases to its initial maximum and to cool down the rate until the end of the optimization process. For simplicity one typically uses a linear increase for this purpose. This leads to a schedule of the form indicated below. scheduler = CosineScheduler(20, warmup_steps=5, base_lr=0.3, final_lr=0.01) d2l.plot(torch.arange(num_epochs), [scheduler(t) for t in range(num_epochs)])
0.3 0.2 O.1 0.0
Note that the network converges better initially (in particular observe the performance dur- ing the first 5 epochs). net = net_fn() trainer = torch.optim.SGD(net.parameters(), lr=0.3) train(net, train_iter, test_iter, num_epochs, loss, trainer, device, scheduler)
Warmup
Learning Rate Scheduling
545

train loss 0.181, train acc 0.934, test acc 0.901
2.0 ‚Äî train loss --- train acc ‚Äî-- test acc epoch
Warmup can be applied to any scheduler (not just cosine). For a more detailed discussion of learning rate schedules and many more experiments see also (Gotmare et al., 2018). In particular they find that a warmup phase limits the amount of divergence of parameters in very deep networks. This makes intuitively sense since we would expect significant divergence due to random initialization in those parts of the network that take the most time to make progress in the beginning. 12.11.4 Summary
e Decreasing the learning rate during training can lead to improved accuracy and (most
perplexingly) reduced overfitting of the model. e A piecewise decrease of the learning rate whenever progress has plateaued is effective
in practice. Essentially this ensures that we converge efficiently to a suitable solution and only then reduce the inherent variance of the parameters by reducing the learning rate. e Cosine schedulers are popular for some computer vision problems. See e.g., GluonCV
182 for details of such a scheduler. 182
e A warmup period before optimization can prevent divergence. e Optimization serves multiple purposes in deep learning. Besides minimizing the training
objective, different choices of optimization algorithms and learning rate scheduling can lead to rather different amounts of generalization and overfitting on the test set (for the same amount of training error). 12.11.5 Exercises
1. Experiment with the optimization behavior for a given fixed learning rate. What is the best model you can obtain this way? 2. How does convergence change if you change the exponent of the decrease in the learning rate? Use PolyScheduler for your convenience in the experiments.bubuOptimization Algorithms
546

3. Apply the cosine scheduler to large computer vision problems, e.g., training ImageNet. How does it affect performance relative to other schedulers?bubu4. How long should warmup last? 5.bubuCan you connect optimization and sampling? Start by using results from Welling and Teh (2011) on Stochastic Gradient Langevin Dynamics. Discussions183. 183
13
Computational Performance
In deep learning, datasets and models are usually large, which involves heavy computa- tion. Therefore, computational performance matters a lot. This chapter will focus on the major factors that affect computational performance: imperative programming, symbolic programming, asynchronous computing, automatic parallelism, and multi-GPU computa- tion. By studying this chapter, you may further improve computational performance of those models implemented in the previous chapters, for example, by reducing training time without affecting accuracy. 13.1 Compilers and Interpreters
De
So far, this book has focused on imperative programming, which makes use of statements such as print, +, and if to change a program‚Äôs state. Consider the following example of a simple imperative program. def add(a, b): return a + b def fancy_func(a, b, c, d): e = add(a, b) f = add(c, d) g = add(e, f) return g
print(fancy_func(1, 2, 3, 4))
10
Python is an interpreted language. When evaluating the above fancy_func function it performs the operations making up the function‚Äôs body in sequence. That is, it will evaluate e = add(a, b) and store the results as variable e, thereby changing the program‚Äôs state. The next two statements f = add(c, d) and g = add(e, f) will be executed similarly, performing additions and storing the results as variables. Fig.bubu13.1.1 illustrates the flow of data. 547
Computational Performance
548

add(e, f)
tFig. 13.1.1 Data Ô¨Çow in an imperative program. Although imperative programming is convenient, it may be inefficient. On the one hand, even if the add function is repeatedly called throughout fancy_func, Python will execute the three function calls individually. If these are executed, say, on a GPU (or even on mul- tiple GPUs), the overhead arising from the Python interpreter can become overwhelming. Moreover, it will need to save the variable values of e and f until all the statements in fancy_func have been executed. This is because we do not know whether the variables e and f will be used by other parts of the program after the statements e = add(a, b) and f = add(c, d) are executed. 13.1.1 Symbolic Programming
Consider the alternative, symbolic programming, where computation is usually performed onlyoncetheprocesshasbeenfullydefined. Thisstrategyisusedbymultipledeeplearning frameworks, including Theano and TensorFlow (the latter has acquired imperative exten- sions). It usually involves the following steps:
1.bubuDefine the operations to be executed. 2. Compile the operations into an executable program. 3. Provide the required inputs and call the compiled program for execution. This allows for a significant amount of optimization. First, we can skip the Python inter- preter in many cases, thus removing a performance bottleneck that can become significant on multiple fast GPUs paired with a single Python thread on a CPU. Second, a compiler might optimize and rewrite the above code into print((1 + 2) + (3 + 4)) or even print(10). This is possible since a compiler gets to see the full code before turning it into machine instructions. For instance, it can release memory (or never allocate it) whenever a variable is no longer needed. Or it can transform the code entirely into an equivalent piece. To get a better idea, consider the following simulation of imperative programming (it is Python after all) below. def add_(): return ''' def add(a, b): return a + b ''' def fancy_func_(): return '''
(continues on next page)
Compilers and Interpreters
549

def fancy_func(a, b, c, d): e = add(a, b) f = add(c, d) g = add(e, f) return g ''' def evoke_(): return add_() + fancy_func_() + 'print(fancy_func(1, 2, 3, 4))' prog = evoke_() print(prog) y = compile(prog, '', 'exec') exec(y)
def add(a, b): return a + b def fancy_func(a, b, c, d): e = add(a, b) f = add(c, d) g = add(e, f) return g print(fancy_func(1, 2, 3, 4)) 10
Thedifferencesbetweenimperative(interpreted)programmingandsymbolicprogramming are as follows:
e Imperative programming is easier. When imperative programming is used in Python,
the majority of the code is straightforward and easy to write. It is also easier to de- bug imperative programming code. This is because it is easier to obtain and print all relevant intermediate variable values, or use Python‚Äôs built-in debugging tools. e Symbolic programming is more efficient and easier to port. Symbolic programming
makes it easier to optimize the code during compilation, while also having the ability to port the program into a format independent of Python. This allows the program to be run in a non-Python environment, thus avoiding any potential performance issues related to the Python interpreter. 13.1.2 Hybrid Programming
Historically most deep learning frameworks choose between an imperative or a symbolic approach. For example, Theano, TensorFlow (inspired by the former), Keras, and CNTK formulate models symbolically. Conversely, Chainer and PyTorch take an imperative ap- proach. AnimperativemodewasaddedtoTensorFlow2.0andKerasinlaterrevisions. As mentioned above, PyTorch is based on imperative programming and uses dynamic com- putation graphs. In an effort to leverage the portability and efficiency of symbolic program- ming, developers considered whether it would be possible to combine the benefits of both
(continued from previous page)
Computational Performance
550

programming paradigms. This led to a torchscript that lets users develop and debug us- ing pure imperative programming, while having the ability to convert most programs into symbolic programs to be run when product-level computing performance and deployment are required. 13.1.3 Hybridizing the Sequential Class
The easiest way to get a feel for how hybridization works is to consider deep networks with multiple layers. Conventionally the Python interpreter will need to execute the code for all layers to generate an instruction that can then be forwarded to a CPU or a GPU. For a single (fast) computing device this does not cause any major issues. On the other hand, if we use an advanced 8-GPU server such as an AWS P3dn.24xlarge instance Python will struggle to keep all GPUs busy. The single-threaded Python interpreter becomes the bottleneck here. Let‚Äôs see how we can address this for significant parts of the code by replacing Sequential with HybridSequential. We begin by defining a simple MLP. import torch from torch import nn from d2l import torch as d2l # Factory for networks def get_net(): net = nn.Sequential(nn.Linear(512, 256), nn.ReLU(), nn.Linear(256, 128), nn.ReLU(), nn.Linear(128, 2)) return net x = torch.randn(size=(1, 512)) net = get_net() net(x)
tensor([[-0.1602, 0.0003]], grad_fn=<AddmmBackward0>)
Byconvertingthemodelusingtorch.jit.scriptfunction,weareabletocompileandop- timizethecomputationintheMLP.Themodel‚Äôscomputationresultremainsunchanged. net = torch.jit.script(net) net(x)
tensor([[-0.1602, 0.0003]], grad_fn=<AddmmBackward0>)
This seems almost too good to be true: write the same code as before and simply convert the model using torch.jit.script. Once this happens the network is optimized (we will benchmark the performance below). Compilers and Interpreters
551

Acceleration by Hybridization
To demonstrate the performance improvement gained by compilation we compare the time needed to evaluate net(x) before and after hybridization. Let‚Äôs define a class to measure this time first.bubuIt will come handy throughout the chapter as we set out to measure (and improve) performance. #@save class Benchmark: """For measuring running time.""" def __init__(self, description='Done'): self.description = description def __enter__(self): self.timer = d2l.Timer() return self def __exit__(self, *args): print(f'{self.description}: {self.timer.stop():.4f} sec')
Now we can invoke the network twice, once with and once without torchscript. net = get_net() with Benchmark('Without torchscript'): for i in range(1000): net(x) net = torch.jit.script(net) with Benchmark('With torchscript'): for i in range(1000): net(x)
Without torchscript: 2.1447 sec With torchscript: 4.0545 sec
As is observed in the above results, after an nn.Sequential instance is scripted using the torch.jit.script function, computing performance is improved through the use of symbolic programming. Serialization
One of the benefits of compiling the models is that we can serialize (save) the model and its parameters to disk.bubuThis allows us to store a model in a manner that is independent of the front-end language of choice. This allows us to deploy trained models to other devices and easily use other front-end programming languages. At the same time the code is often faster than what can be achieved in imperative programming. Let‚Äôs see the save function in action. net.save('my_mlp') !ls -lh my_mlp*
Computational Performance
552

-rw-r--r-- 1 ci ci 651K Aug 18 19:32 my_mlp
13.1.4 Summary
e Imperative programming makes it easy to design new models since it is possible to write
code with control flow and the ability to use a large amount of the Python software ecosystem. e Symbolic programming requires that we specify the program and compile it before exe-
cuting it. The benefit is improved performance.bubu13.1.5 Exercises
1. Review the models that interest you in the previous chapters. Can you improve their computational performance by reimplementing them?bubuDiscussions184. 184
Bi: iE]
13.2 Asynchronous Computation
|
Today‚Äôs computers are highly parallel systems, consisting of multiple CPU cores (often multiplethreadspercore), multipleprocessingelementsperGPU,andoftenmultipleGPUs per device. In short, we can process many different things at the same time, often on differ- ent devices. Unfortunately Python is not a great way of writing parallel and asynchronous code, at least not without some extra help. After all, Python is single-threaded and this is unlikely to change in the future. Deep learning frameworks such as MXNet and Tensor- Flow adopt an asynchronous programming model to improve performance, while PyTorch uses Python‚Äôs own scheduler leading to a different performance trade-off. For PyTorch, by default, GPU operations are asynchronous. When you call a function that uses the GPU, the operations are enqueued to the particular device, but not necessarily executed until later. This allows us to execute more computations in parallel, including operations on the CPU or other GPUs. Hence, understanding how asynchronous programming works helps us to develop more efficient programs, by proactively reducing computational requirements and mutual de- pendencies. This allows us to reduce memory overhead and increase processor utiliza- tion. import os import subprocess import numpy import torch from torch import nn from d2l import torch as d2l
Asynchronous Computation
553

13.2.1 Asynchrony via Backend
For a warmup consider the following toy problem: we want to generate a random matrix and multiply it. Let‚Äôs do that both in NumPy and in PyTorch tensor to see the difference. Note that PyTorch tensor is defined on a GPU. # Warmup for GPU computation device = d2l.try_gpu() a = torch.randn(size=(1000, 1000), device=device) b = torch.mm(a, a) with d2l.Benchmark('numpy'): for _ in range(10): a = numpy.random.normal(size=(1000, 1000)) b = numpy.dot(a, a) with d2l.Benchmark('torch'): for _ in range(10): a = torch.randn(size=(1000, 1000), device=device) b = torch.mm(a, a)
numpy: 1.4693 sec torch: 0.0022 sec
The benchmark output via PyTorch is orders of magnitude faster. NumPy dot product is ex- ecuted on the CPU processor while PyTorch matrix multiplication is executed on GPU and hence the latter is expected to be much faster. But the huge time difference suggests some- thing else must be going on. By default, GPU operations are asynchronous in PyTorch. Forcing PyTorch to finish all computation prior to returning shows what happened previ- ously: computation is being executed by the backend while the frontend returns control to Python. with d2l.Benchmark(): for _ in range(10): a = torch.randn(size=(1000, 1000), device=device) b = torch.mm(a, a) torch.cuda.synchronize(device)
Done: 0.0058 sec
Broadly speaking, PyTorch has a frontend for direct interaction with the users, e.g., via Python, as well as a backend used by the system to perform the computation. As shown in Fig. 13.2.1, users can write PyTorch programs in various frontend languages, such as Python and C++. Regardless of the frontend programming language used, the execution of PyTorch programs occurs primarily in the backend of C++ implementations. Operations issued by the frontend language are passed on to the backend for execution. The backend manages its own threads that continuously collect and execute queued tasks. Note that for this to work the backend must be able to keep track of the dependencies between various
Computational Performance
554

steps in the computational graph. Hence, it is not possible to parallelize operations that depend on each other. Language Computing frontend device Zscala thon @ PY ‚Äî> @xnet =‚Äî R Framework backend (scheduler, kernel, etc.)
tFig. 13.2.1
Programming language frontends and deep learning framework backends. Let‚Äôs look at another toy example to understand the dependency graph a bit better. x = torch.ones((1, 2), device=device) y = torch.ones((1, 2), device=device) z = x * y + 2 z
tensor([[3., 3.]], device='cuda:0')
ones(1,2) ‚Äîones(1, 2)
+2
tFig. 13.2.2
The backend tracks dependencies between various steps in the computational graph.bubuThe code snippet above is also illustrated in Fig.bubu13.2.2. Whenever the Python frontend thread executes one of the first three statements, it simply returns the task to the backend queue. When the last statement‚Äôs results need to be printed, the Python frontend thread will wait for the C++ backend thread to finish computing the result of the variable z. One benefit of this design is that the Python frontend thread does not need to perform actual computations. Thus, there is little impact on the program‚Äôs overall performance, regardless of Python‚Äôs performance. Fig. 13.2.3 illustrates how frontend and backend interact. 13.2.2 Barriers and Blockers
13.2.3 Improving Computation
Automatic Parallelism
555

¬© eaial] o [eat] ¬© 5] ¬© | ¬© [a] Frontend |@|@/O!]@|@¬Æ print(z) wat Backend
tFig. 13.2.3
Interactions of the frontend and backend. 13.2.4 Summary
e Deep learning frameworks may decouple the Python frontend from an execution back-
end. This allows for fast asynchronous insertion of commands into the backend and associated parallelism. e Asynchrony leads to a rather responsive frontend. However, use caution not to overfill
thetaskqueuesinceitmayleadtoexcessivememoryconsumption. Itisrecommended to synchronize for each minibatch to keep frontend and backend approximately syn- chronized. e Chip vendors offer sophisticated performance analysis tools to obtain a much more fine-
grained insight into the efficiency of deep learning. 13.2.5 Exercises
1. On the CPU, benchmark the same matrix multiplication operations in this section. Can you still observe asynchrony via the backend? Discussions185.bubuDiscussions !6¬∞. 185

13.3 Automatic Parallelism
ae
Deep learning frameworks (e.g., MXNet and PyTorch) automatically construct computa- tional graphs at the backend. Using a computational graph, the system is aware of all the dependencies, and can selectively execute multiple non-interdependent tasks in parallel to improve speed. For instance, Fig. 13.2.2 in Section 13.2 initializes two variables indepen- dently. Consequently the system can choose to execute them in parallel. Typically, a single operator will use all the computational resources on all CPUs or on a sin- gle GPU. For example, the dot operator will use all cores (and threads) on all CPUs, even if there are multiple CPU processors on a single machine. The same applies to a single GPU. Hence parallelization is not quite so useful for single-device computers. With multiple de- vices things matter more. While parallelization is typically most relevant between multiple GPUs, adding the local CPU will increase performance slightly. For example, see Hadjis et
Computational Performance
556

al. (2016) that focuses on training computer vision models combining a GPU and a CPU. With the convenience of an automatically parallelizing framework we can accomplish the same goal in a few lines of Python code. More broadly, our discussion of automatic parallel computation focuses on parallel computation using both CPUs and GPUs, as well as the parallelization of computation and communication. Note that we need at least two GPUs to run the experiments in this section. import torch from d2l import torch as d2l
13.3.1 Parallel Computation on GPUs
Let‚Äôs start by defining a reference workload to test: the run function below performs 10 matrix-matrix multiplications on the device of our choice using data allocated into two variables: x_gpu1 and x_gpu2. devices = d2l.try_all_gpus() def run(x): return [x.mm(x) for _ in range(50)] x_gpu1 = torch.rand(size=(4000, 4000), device=devices[0]) x_gpu2 = torch.rand(size=(4000, 4000), device=devices[1])
Now we apply the function to the data. To ensure that caching does not play a role in the results we warm up the devices by performing a single pass on either of them prior to mea- suring. torch.cuda.synchronize() waits for all kernels in all streams on a CUDA device to complete. It takes in a device argument, the device for which we need to synchronize. It uses the current device, given by current_device(), if the device argument is None (default). run(x_gpu1) run(x_gpu2) # Warm-up all devices torch.cuda.synchronize(devices[0]) torch.cuda.synchronize(devices[1]) with d2l.Benchmark('GPU1 time'): run(x_gpu1) torch.cuda.synchronize(devices[0]) with d2l.Benchmark('GPU2 time'): run(x_gpu2) torch.cuda.synchronize(devices[1])
GPU1 time: 0.4660 sec GPU2 time: 0.4510 sec
Ifweremovethesynchronizestatementbetweenbothtasksthesystemisfreetoparallelize computation on both devices automatically. Automatic Parallelism
557

with d2l.Benchmark('GPU1 & GPU2'): run(x_gpu1) run(x_gpu2) torch.cuda.synchronize()
GPU1 & GPU2: 0.4659 sec
In the above case the total execution time is less than the sum of its parts, since the deep learning framework automatically schedules computation on both GPU devices without the need for sophisticated code on behalf of the user. 13.3.2 Parallel Computation and Communication
In many cases we need to move data between different devices, say between the CPU and GPU, or between different GPUs. For instance, this occurs when we want to perform dis- tributed optimization where we need to aggregate the gradients over multiple accelerator cards. Let‚Äôs simulate this by computing on the GPU and then copying the results back to the CPU. def copy_to_cpu(x, non_blocking=False): return [y.to('cpu', non_blocking=non_blocking) for y in x] with d2l.Benchmark('Run on GPU1'): y = run(x_gpu1) torch.cuda.synchronize() with d2l.Benchmark('Copy to CPU'): y_cpu = copy_to_cpu(y) torch.cuda.synchronize()
Run on GPU1: 0.4656 sec Copy to CPU: 2.3125 sec
This is somewhat inefficient. Note that we could already start copying parts of y to the CPU while the remainder of the list is still being computed. This situation occurs, e.g., when we compute the (backprop) gradient on a minibatch. The gradients of some of the parameters will be available earlier than that of others. Hence it works to our advantage to start using PCI-Express bus bandwidth while the GPU is still running. In PyTorch, several functions such as to() and copy_() admit an explicit non_blocking argument, which lets the caller bypass synchronization when it is unnecessary. Setting non_blocking=True allows us to simulate this scenario. with d2l.Benchmark('Run on GPU1 and copy to CPU'): y = run(x_gpu1) y_cpu = copy_to_cpu(y, True) torch.cuda.synchronize()
Computational Performance
558

Run on GPU1 and copy to CPU: 1.6907 sec
The total time required for both operations is (as expected) less than the sum of their parts. Note that this task is different from parallel computation as it uses a different resource: the bus between the CPU and GPUs. In fact, we could compute on both devices and communi- cate, all at the same time. As noted above, there is a dependency between computation and communication: y[i] must be computed before it can be copied to the CPU. Fortunately, the system can copy y[i-1] while computing y[i] to reduce the total running time. We conclude with an illustration of the computational graph and its dependencies for a simple two-layer MLP when training on a CPU and two GPUs, as depicted in Fig. 13.3.1. It wouldbequitepainfultoscheduletheparallelprogramresultingfromthismanually. Thisis whereitisadvantageoustohaveagraph-basedcomputingbackendforoptimization. data[gpu0].copyfrom(data[0:50})_ }¬´‚Äî]
feT[gpu0] = FullcForward(datafgpu0], fe1_weight[gpu0})
fc2[gpud] = FulleForward(fc1 [gpu0], fc2_weight[gpu0})
fc2_ograd[gpu0] = LossGrad(fc2{gpu0], label[0:50])
fe1_ograd[gpu0], fc2_wgrad[gpu0] fet_wgrad{epu] = = FulleBackward(fc2_ograd[gpu0}] , fe1_wgrad[gpu0] + fc2_weight[gpu0]) fet_wgrad{gput]
_¬ª f1_wgrad[gpu0] = fe1_weight[epu] -= Ir* FulleBackward(fe1_ograd[gpud] , fetliwaradigplo] fe1_weight[gpu0]) = i fe1_weight{cpu].copyto( fc1_weight[gpu0] , fe_weight{gput])
tFig. 13.3.1
The computational graph and its dependencies of a two-layer MLP on a CPU and two GPUs.bubu13.3.3 Summary
e Modern systems have a variety of devices, such as multiple GPUs and CPUs. They can
be used in parallel, asynchronously. e Modern systems also have a variety of resources for communication, such as PCI Ex-
press, storage (typically solid-state drives or via networks), and network bandwidth. They can be used in parallel for peak efficiency.bubue The backend can improve performance through automatic parallel computation and com-
munication. data = next_batch() +) data[gpu0}.copyfrom(data[51:100})
fe2_wgrad{epu] = fc2_wgrad[gpu0] + fc2_wgrad{gpu‚Äò]
fel[gput] = FulleForward(data[gput}, fe1_weight[gput]})
fe2[gput] = FulleForward(fe1 [gput], fc2_weight[gpu1])
fo2_weight[cpu] -= Ir'fc12_wgrad[gpu0)
fc2_weight{cpu].copyto( fc2_weight[gpu0] , fc2_weight[gput])
fc2_ograd[gpu1] = LossGrad(fc2[gpu1], label[51:100})
fe1_ograd{gpu], fc2_wgrad[gput] = FulleBackward(fc2_ograd[gput] , fc2_weight[gput])
‚Äî: fc1_wgrad[gput] = FulleBackward(fe1_ogradigput] , fe1_weight[gpu1})
559

13.3.4 Exercises
1. Eight operations were performed in the run function defined in this section.bubuThere are no dependencies between them. Design an experiment to see if the deep learning framework will automatically execute them in parallel. 2. When the workload of an individual operator is sufficiently small, parallelization can help even on a single CPU or GPU. Design an experiment to verify this. 3. Design an experiment that uses parallel computation on CPUs, GPUs, and communica- tion between both devices. 4. Use a debugger such as NVIDIA‚Äôs Nsight186 to verify that your code is efficient. 186
5. Designing computation tasks that include more complex data dependencies, and run experiments to see if you can obtain the correct results while improving performance. Discussions187. 187
13.4 Hardware

Building systems with great performance requires a good understanding of the algorithms and models to capture the statistical aspects of the problem. At the same time it is also indispensable to have at least a modicum of knowledge of the underlying hardware. The current section is no substitute for a proper course on hardware and system design. Instead, it might serve as a starting point for understanding why some algorithms are more efficient than others and how to achieve good throughput. A good design can easily make a differ- ence of an order of magnitude and, in turn, this can make the difference between being able to train a network (e.g., in a week) and not at all (in 3 months, thus missing the deadline). We will start by looking at computers.bubuThen we will zoom in to look more carefully at CPUs and GPUs. Lastly we zoom out to review how multiple computers are connected in a server center or in the cloud. : = ; Pepe tibia commeolty netweor sequentially from $50 ans 49,000ns = 49us, . Li cache reference: ins ‚Äî_ w= 1,000ns = 1ps ‚Äù SSD random read: = Disk seek: 2,000,000ns = 16,000ns = 16us 2ms a ranch mispredict: 3ns √©s eM tere ‚Äòompress 1KB wth Zippy: ,000ns = 2us ' Read 1,000,000 bytes . Read 1,000,000 bytes L2 cache reference: ans sequentially from sequentially from disk: 0,000ns = 10s = = memory: 3,000ns * 3p 825,000ns = 825us IMME Nutex lock/unlock: 17ns Sein ore stacenter: 500,000ns ~ Packet roundtrip CA to Netherlands: 150,000,000ns ~ 150ms 100ns = = (000,000ns = ims = =
tFig. 13.4.1
Latency Numbers that every programmer should know. Hardware
Computational Performance
560

Impatient readers may be able to get by with Fig. 13.4.1. It is taken from Colin Scott‚Äôs inter- active post188 that gives a good overview of the progress over the past decade. The original numbers are due to Jeff Dean‚Äôs Stanford talk from 2010189. The discussion below explains some of the rationale for these numbers and how they can guide us in designing algorithms. The discussion below is very high level and cursory. It is clearly no substitute for a proper course but rather just meant to provide enough information for a statistical modeler to make suitable design decisions. For an in-depth overview of computer architecture we refer the reader to (Hennessy and Patterson, 2011) or a recent course on the subject, such as the one by Arste Asanovic190. 188
189
190
13.4.1 Computers
Most deep learning researchers and practitioners have access to a computer with a fair amount of memory, computation, some form of an accelerator such as a GPU, or multiples thereof. A computer consists of the following key components:
e A processor (also referred to as a CPU) that is able to execute the programs we give it (in
addition to running an operating system and many other things), typically consisting of 8 or more cores. Memory (RAM) to store and retrieve the results from computation, such as weight vec-
tors and activations, and training data. An Ethernet network connection (sometimes multiple) with speeds ranging from 1 GB/s
to 100 GB/s. On high end servers more advanced interconnects can be found. A high speed expansion bus (PCle) to connect the system to one or more GPUs. Servers
have up to 8 accelerators, often connected in an advanced topology, while desktop systems have 1 or 2, depending on the budget of the user and the size of the power supply. Durable storage, such as a magnetic hard disk drive, a solid state drive, in many cases connected using the PCle bus. It provides efficient transfer of training data to the system and storage of intermediate checkpoints as needed. Chipset | cPU PCle bus
tFig. 13.4.2 Connectivity of components of a computer. As Fig. 13.4.2 indicates, most components (network, GPU, and storage) are connected to the CPU across the PCIe bus. It consists of multiple lanes that are directly attached to the CPU. For instance AMD‚Äôs Threadripper 3 has 64 PCIe 4.0 lanes, each of which is capable 16 Gbit/s data transfer in both directions. The memory is directly attached to the CPU with a total bandwidth of up to 100 GB/s. Whenweruncodeonacomputerweneedtoshuffledatatotheprocessors(CPUsorGPUs),
561

perform computation, and then move the results off the processor back to RAM and durable storage. Hence, in order to get good performance we need to make sure that this works seamlessly without any one of the systems becoming a major bottleneck. For instance, if wecannotloadimagesquicklyenoughtheprocessorwillnothaveanyworktodo. Likewise, if we cannot move matrices quickly enough to the CPU (or GPU), its processing elements will starve. Finally, if we want to synchronize multiple computers across the network, the latter should not slow down computation. One option is to interleave communication and computation. Let‚Äôs have a look at the various components in more detail. 13.4.2 Memory
At its most basic memory is used to store data that needs to be readily accessible. At present CPU RAM is typically of the DDR4 191 variety, offering 20‚Äì25 GB/s bandwidth per module. Each module has a 64-bit-wide bus. Typically pairs of memory modules are used to allow for multiple channels. CPUs have between 2 and 4 memory channels, i.e., they have between 4 0GB/s and 100 GB/s peak memory bandwidth. Often there are two banks per channel. For instance AMD‚Äôs Zen 3 Threadripper has 8 slots. 191 
While these numbers are impressive, indeed, they only tell part of the story. When we want to read a portion from memory we first need to tell the memory module where the information can be found. That is, we first need to send the address to RAM. Once this is accomplished we can choose to read just a single 64 bit record or a long sequence of records. The latter is called burst read. In a nutshell, sending an address to memory and setting up the transfer takes approximately 100 ns (details depend on the specific timing coefficients of the memory chips used), every subsequent transfer takes only 0.2 ns. In short, the first read is 500 times as expensive as subsequent ones! Note that we could perform up to 10,000,000 random reads per second. This suggests that we avoid random memory access as far as possible and use burst reads (and writes) instead. Matters are a bit more complex when we take into account that we have multiple banks. Each bank can read memory largely independently. This means two things. On the one hand, the effective number of random reads is up to 4 times higher, provided that they are spread evenly across memory. It also means that it is still a bad idea to perform random reads since burst reads are 4 times faster, too. On the other hand, due to memory alignment to 64 bit boundaries it is a good idea to align any data structures with the same boundaries. Compilers do this pretty much automatically192 when the appropriate flags are set. Curious readers are encouraged to review a lecture on DRAMs such as the one by Zeshan Chishti 193. 192
GPU memory is subject to even higher bandwidth requirements since they have many more processing elements than CPUs. By and large there are two options to address them. The first is to make the memory bus significantly wider. For instance, NVIDIA‚Äôs RTX 2080 Ti has a 352-bit-wide bus. This allows for much more information to be transferred at the same time. Second, GPUs use specific high-performance memory. Consumer-grade devices, such as NVIDIA‚Äôs RTX and Titan series typically use GDDR6194 chips with over 500 GB/s aggregate bandwidth. An alternative is to use HBM (high bandwidth memory) modules. They use a very different interface and connect directly with GPUs on a dedicated
193
194
Hardware
Computational Performance
562

silicon wafer. This makes them very expensive and their use is typically limited to high-end server chips, such as the NVIDIA Volta V100 series of accelerators. Quite unsurprisingly, GPU memory is generally much smaller than CPU memory due to the higher cost of the former. For our purposes, by and large their performance characteristics are similar, just a lot faster. We can safely ignore the details for the purpose of this book. They only matter when tuning GPU kernels for high throughput. 13.4.3 Storage
We saw that some of the key characteristics of RAM are bandwidth and latency. The same is true for storage devices, just that the differences can be even more extreme. Hard Disk Drives
Hard disk drives (HDDs) have been in use for over half a century. In a nutshell they contain a number of spinning platters with heads that can be positioned to read or write at any given track. High-end disks hold up to 16 TB on 9 platters. One of the key benefits of HDDs is that they are relatively inexpensive. One of their many downsides are their typically catastrophic failure modes and their relatively high read latency. Tounderstandthelatter, considerthefactthatHDDsspinataround7,200RPM(revolutions per minute). If they were much faster they would shatter due to the centrifugal force exerted on the platters. This has a major downside when it comes to accessing a specific sector on the disk: we need to wait until the platter has rotated in position (we can move the heads but not accelerate the actual disks). Hence it can take over 8 ms until the requested data is available. A common way this is expressed is to say that HDDs can operate at approximately 100 IOPs (input/output operations per second). This number has essentially remained unchanged for the past two decades. Worse still, it is equally difficult to increase bandwidth (it is in the order of 100‚Äì200 MB/s). After all, each head reads a track of bits, hence the bit rate only scales with the square root of the information density. As a result, HDDs are quickly becoming relegated to archival storage and low-grade storage for very large datasets. Solid State Drives
Solid state drives (SSDs) use flash memory to store information persistently. This allows for much faster access to stored records. Modern SSDs can operate at 100,000 to 500,000 IOPs, i.e., up to 3 orders of magnitude faster than HDDs. Furthermore, their bandwidth can reach 1‚Äì3GB/s, i.e., one order of magnitude faster than HDDs. These improvements sound almost too good to be true. Indeed, they come with the following caveats, due to the way SSDs are designed. e SSDs store information in blocks (256 KB or larger). They can only be written as a whole,
which takes significant time. Consequently bit-wise random writes on SSD have very poor performance. Likewise, writing data in general takes significant time since the block has to be read, erased and then rewritten with new information. By now SSD
563

controllers and firmware have developed algorithms to mitigate this. Nonetheless, writes can be much slower, in particular for QLC (quad level cell) SSDs. The key for improved performance is to maintain a queue of operations, to prefer reads and to write in large blocks if possible. e The memory cells in SSDs wear out relatively quickly (often already after a few thousand
writes). Wear-levelprotectionalgorithmsareabletospreadthedegradationovermany cells. That said, it is not recommended to use SSDs for swapping files or for large aggregations of log-files. e Lastly, the massive increase in bandwidth has forced computer designers to attach SSDs
directly to the PCIe bus. The drives capable of handling this, referred to as NVMe (Non Volatile Memory enhanced), can use up to 4 PCIe lanes. This amounts to up to 8GB/s on PCIe 4.0. Cloud Storage
Cloud storage provides a configurable range of performance. That is, the assignment of storage to virtual machines is dynamic, both in terms of quantity and in terms of speed, as chosen by users. We recommend that users increase the provisioned number of IOPs whenever latency is too high, e.g., during training with many small records. 13.4.4 CPUs
Central processing units (CPUs) are the centerpiece of any computer. They consist of a number of key components: processor cores that are able to execute machine code, a bus connectingthem (thespecific topologydiffers significantlybetweenprocessormodels, gen- erations, andvendors), and cachestoallowforhigherbandwidth and lowerlatencymemory access than what is possible by reads from main memory. Lastly, almost all modern CPUs contain vector processing units to aid with high performance linear algebra and convolu- tions, as they are common in media processing and machine learning. Upto4k Display Intel 100 Series 2 channel DDR3/DDR4 WiFi+ Bluetooth >| Ethernet ++ Thunderbolt 64MB or 128MB L wicig
tFig. 13.4.3
Intel Skylake consumer quad-core CPU. Fig. 13.4.3 depicts an Intel Skylake consumer-grade quad-core CPU. It has an integrated
Hardware
Computational Performance
564

GPU, caches, and a ringbus connecting the four cores. Peripherals, such as Ethernet, WiFi, Bluetooth, SSD controller, and USB, are either part of the chipset or directly attached (PCIe) to the CPU. Microarchitecture
Each of the processor cores consists of a rather sophisticated set of components. While details differ between generations and vendors, the basic functionality is pretty much stan- dard. The front-end loads instructions and tries to predict which path will be taken (e.g., for control flow). Instructions are then decoded from assembly code to microinstructions. Assembly code is often not the lowest level code that a processor executes. Instead, com- plex instructions may be decoded into a set of more lower level operations. These are then processed by the actual execution core. Often the latter is capable of performing many op- erations simultaneously. For instance, the ARM Cortex A77 core of Fig. 13.4.4 is able to perform up to 8 operations simultaneously. Branch 1 Branch 0 Integer integer Single Cycle 1 Single Cycle 0 Integer Single / Decode Multi Cycle 1 Dispatch my FP/ASIMD 1 FP/ASIMD 0 Load / Store 1 Load / Store 0 Store Data 1 Store Data 0
tFig. 13.4.4 ARM Cortex A77 Microarchitecture. This means that efficient programs might be able to perform more than one instruction per clock cycle, provided that they can be carried out independently. Not all units are created equal. Some specialize in integer instructions whereas others are optimized for floating point performance. To increase throughput, the processor might also follow multiple code paths simultaneously in a branching instruction and then discard the results of the branches not taken. This is why branch prediction units matter (on the front-end) such that only the most promising paths are pursued. Vectorization
Deep learning is extremely compute-hungry. Hence, to make CPUs suitable for machine learning, one needs to perform many operations in one clock cycle. This is achieved via vector units. They have different names: on ARM they are called NEON, on x86 they (a recent generation) are referred to as AVX2195 units. A common aspect is that they are able to perform SIMD (single instruction multiple data) operations. Fig. 13.4.5 shows how 8 short integers can be added in one clock cycle on ARM. 195
565

128.0 -112,~‚Äî~‚ÄîO9G BB 0 Q2 vector [ alee O9OO9G9 OF OA HOA Qo
tFig. 13.4.5
128 bit NEON vectorization. Depending on architecture choices, such registers are up to 512 bits long, allowing for the combination of up to 64 pairs of numbers. For instance, we might be multiplying two numbers and adding them to a third, which is also known as a fused multiply-add. Intel‚Äôs OpenVino 196 uses these to achieve respectable throughput for deep learning on server- grade CPUs. Note, though, that this number is entirely dwarfed by what GPUs are capable of achieving. For instance, NVIDIA‚Äôs RTX 2080 Ti has 4,352 CUDA cores, each of which is capable of processing such an operation at any time. 196
Consider the following situation: we have a modest CPU core with 4 cores as depicted in Fig. 13.4.3 above, running at 2 GHz frequency. Moreover, let‚Äôs assume that we have an IPC (instructions per clock) count of | and that the units have AVX2 with 256-bit width enabled. Let‚Äôs furthermore assume that at least one of the registers used for AVX2 operations needs to be retrieved from memory. This means that the CPU consumes 4 x 256 bit = 128 bytes of data per clock cycle. Unless we are able to transfer 2 x 10? x 128 = 256 x 10¬∞ bytes to the processor per second the processing elements are going to starve. Unfortunately the memory interface of such a chip only supports 20-40 GB/s data transfer, i.e., one order of magnitude less. The fix is to avoid loading new data from memory as far as possible and rather to cache it locally on the CPU. This is where caches come in handy. Commonly the following names or concepts are used:
e Registers are strictly speaking not part of the cache. They help stage instructions. That said, CPU registers are memory locations that a CPU can access at clock speed with- out any delay penalty. CPUs have tens of registers. It is up to the compiler (or pro- grammer) to use registers efficiently. For instance the C programming language has a register keyword. e L1 caches are the first line of defense against high memory bandwidth requirements. L1 caches are tiny (typical sizes might be 32‚Äì64 KB) and often split into data and instructions caches. When data is found in the L1 cache, access is very fast. If they cannot be found there, the search progresses down the cache hierarchy. e L2 caches are the next stop. Depending on architecture design and processor size they
might be exclusive. They might be accessible only by a given core or shared among multiple cores. L2 caches are larger (typically 256‚Äì512 KB per core) and slower than
Hardware
Cache
Computational Performance
566

L1. Furthermore, to access something in L2 we first need to check to realize that the data is not in L1, which adds a small amount of extra latency. e L3 caches are shared among multiple cores and can be quite large. AMD‚Äôs Epyc 3 server
CPUshaveawhopping256MBofcachespreadacrossmultiplechiplets. Moretypical numbers are in the 4‚Äì8 MB range. Predicting which memory elements will be needed next is one of the key optimization pa- rameters in chip design. For instance, it is advisable to traverse memory in a forward direc- tion since most caching algorithms will try to read ahead rather than backwards. Likewise, keeping memory access patterns local is a good way of improving performance. Adding caches is a double-edge sword. On the one hand they ensure that the processor cores do not starve of data. At the same time they increase chip size, using up area that otherwise could have been spent on increasing processing power. Moreover, cache misses canbeexpensive. Considertheworstcasescenario, falsesharing, asdepictedinFig.13.4.6. A memory location is cached on processor 0 when a thread on processor 1 requests the data. To obtain it, processor 0 needs to stop what it is doing, write the information back to main memory and then let processor 1 read it from memory. During this operation both processors wait. Quite potentially such code runs more slowly on multiple processors when compared with an efficient single-processor implementation. This is one more reason for why there is a practical limit to cache sizes (besides their physical size). Socket 0 Socket 1 Thread 0 Thread 1 Cache Cache Cache Line Shared Cache Line Ty | cache tine Memory
tFig. 13.4.6
False sharing (image courtesy of Intel). 13.4.5 GPUs and other Accelerators
It is not an exaggeration to claim that deep learning would not have been successful without GPUs. By the same token, it is quite reasonable to argue that GPU manufacturers‚Äô fortunes have increased significantly due to deep learning. This co-evolution of hardware and al- gorithms has led to a situation where for better or worse deep learning is the preferable statistical modeling paradigm. Hence it pays to understand the specific benefits that GPUs and related accelerators such as the TPU (Jouppi et al., 2017). Of note is a distinction that is often made in practice: accelerators are optimized either for training or inference. For the latter we only need to compute the forward propagation in a network. No storage of intermediate data is needed for backpropagation. Moreover, we maynotneedveryprecisecomputation(FP16orINT8typicallysuffice). Ontheotherhand,
567

during training all intermediate results need storage to compute gradients. Moreover, ac- cumulating gradients requires higher precision to avoid numerical underflow (or overflow). This means that FP16 (or mixed precision with FP32) is the minimum requirement. All of this necessitates faster and larger memory (HBM2 vs. GDDR6) and more processing power. For instance, NVIDIA‚Äôs Turing197 T4 GPUs are optimized for inference whereas the V100 GPUs are preferable for training. 197
Recall vectorization as illustrated in Fig. 13.4.5. Adding vector units to a processor core allowed us to increase throughput significantly. For example, in the example in Fig. 13.4.5 we were able to perform 16 operations simultaneously. First, what if we added operations that optimized not just operations between vectors but also between matrices? This strategy led to tensor cores (to be covered shortly). Second, what if we added many more cores? In a nutshell, these two strategies summarize the design decisions in GPUs. Fig.bubu13.4.7 gives an overview of a basic processing block. It contains 16 integer and 16 floating point units. In addition to that, two tensor cores accelerate a narrow subset of additional op- erations relevant for deep learning. Each streaming multiprocessor consists of four such blocks. ‚ÄòWarp Scheduler + Dispatch (32 thread/cik) Register File (16,384 x 32-bit) TENSOR CORES INT32 FP32 Lost LOST LOST Lost SFU
tFig. 13.4.7 NVIDIA Turing processing block (image courtesy of NVIDIA). Next, 12 streaming multiprocessors are grouped into graphics processing clusters which make up the high-end TU102 processors. Ample memory channels and an L2 cache com- plement the setup.bubuFig.bubu13.4.8 has the relevant details. One of the reasons for designing such a device is that individual blocks can be added or removed as needed to allow for more compact chips and to deal with yield issues (faulty modules might not be activated). Fortu- nately programming such devices is well hidden from the casual deep learning researcher beneath layers of CUDA and framework code. In particular, more than one of the programs might well be executed simultaneously on the GPU, provided that there are available re- sources. Nonetheless it pays to be aware of the limitations of the devices to avoid picking models that do not fit into device memory. A last aspect that is worth mentioning in more detail are tensor cores. They are an example of a recent trend of adding more optimized circuits that are specifically effective for deep learning. Forinstance, theTPUaddedasystolicarray(Kung, 1988)forfastmatrixmultipli-
Hardware
Computational Performance
568


tFig. 13.4.8 NVIDIA Turing architecture (image courtesy of NVIDIA)
cation. There the design was to support a very small number (one for the first generation of TPUs) of large operations. Tensor cores are at the other end. They are optimized for small operations involving between 4 x 4 and 16 x 16 matrices, depending on their numerical precision. Fig.bubu13.4.9 gives an overview of the optimizations. PASCAL TURING TENSOR CORE TURING TENSOR CORE TURING TENSOR CORE FP16 INT 8 INT 4 8X THROUGHPUT: 16K: STHROUGHEDTE LL 32KSS STHROUGHEDT
tFig. 13.4.9 NVIDIA tensor cores in Turing (image courtesy of NVIDIA). Obviously when optimizing for computation we end up making certain compromises. One of them is that GPUs are not very good at handling interrupts and sparse data. While there are notable exceptions, such as Gunrock198 (Wang et al., 2016), the access pattern of sparse matrices and vectors do not go well with the high bandwidth burst read operations where
198
569

GPUs excel. Matching both goals is an area of active research.bubuSee e.g., DGL199, a library
tuned for deep learning on graphs. 199
13.4.6 Networks and Buses
Whenever a single device is insufficient for optimization we need to transfer data to and from it to synchronize processing. This is where networks and buses come in handy. We have a number of design parameters: bandwidth, cost, distance, and flexibility. On one end we have WiFi that has a pretty good range, is very easy to use (no wires, after all), cheap but it offers comparatively mediocre bandwidth and latency. No machine learning researcher within their right mind would use it to build a cluster of servers. In what follows we focus on interconnects that are suitable for deep learning. e PCle is a dedicated bus for very high bandwidth point-to-point connections (up to 32 GB/s on PCle 4.0 in a 16-lane slot) per lane. Latency is in the order of single-digit microseconds (5 js).bubuPCle links are precious. Processors only have a limited number of them: AMD‚Äôs EPYC 3 has 128 lanes, Intel‚Äôs Xeon has up to 48 lanes per chip; on desktop-grade CPUs the numbers are 20 (Ryzen 9) and 16 (Core i9) respectively. Since GPUs have typically 16 lanes, this limits the number of GPUs that can connect to the CPU at full bandwidth. After all, they need to share the links with other high bandwidth peripherals such as storage and Ethernet. Just like with RAM access, large bulk transfers are preferable due to reduced packet overhead. e Ethernet is the most commonly used way of connecting computers. While it is signifi- cantly slower than PCle, it is very cheap and resilient to install and covers much longer distances. Typical bandwidth for low-grade servers is 1 GBit/s. Higher-end devices (e.g., C5 instances?¬∞ in the cloud) offer between 10 and 100 GBit/s bandwidth. As in all previous cases data transmission has significant overheads. Note that we al- most never use raw Ethernet directly but rather a protocol that is executed on top of the physical interconnect (such as UDP or TCP/IP). This adds further overhead. Like PCle, Ethernet is designed to connect two devices, e.g., a computer and a switch. 200
201
e Switches allow us to connect multiple devices in a manner where any pair of them can carry out a (typically full bandwidth) point-to-point connection simultaneously. For instance, Ethernet switches might connect 40 servers at high cross-sectional band- width. Note that switches are not unique to traditional computer networks. Even PCle lanes can be switched?¬∞!. This occurs, e.g., to connect a large number of GPUs to a host processor, as is the case for the P2 instances?¬∞?. 202
e NVLink is an alternative to PCle when it comes to very high bandwidth interconnects. It offers up to 300 Gbit/s data transfer rate per link. Server GPUs (Volta V100) have six links whereas consumer-grade GPUs (RTX 2080 Ti) have only one link, operating at a reduced 100 Gbit/s rate. We recommend to use NCCL?¬∞? to achieve high data transfer between GPUs. 203
204
13.4.7 More Latency Numbers
Hardware
Computational Performance
570

The summary in Table 13.4.1 and Table 13.4.2 are from Eliot Eshelman204 who maintains
an updated version of the numbers as a GitHub gist205. 205

Table 13.4.1: Common Latency Numbers. Action Time Notes L1 cache reference/hit 1.5 ns 4 cycles Floating-point add/mult/FMA 1.5 ns 4 cycles L2 cache reference/hit 5 ns 12 ~ 17 cycles Branch mispredict 6 ns 15 ~ 20 cycles L3 cache hit (unshared cache) 16 ns 42 cycles L3 cache hit (shared in another core) 25 ns 65 cycles Mutex lock/unlock 25 ns L3 cache hit (modified in another core) 29 ns 75 cycles L3 cache hit (on a remote CPU socket) 40 ns 100 ~ 300 cycles (40 ~ 116 ns) QPI hop to a another CPU (per hop) 40 ns 64MB memory ref. (local CPU) 46 ns TinyMemBench on Broadwell E5-2690v4 64MB memory ref.bubu(remote CPU) 70 ns TinyMemBench on Broadwell E5-2690v4 256MB memory ref. (local CPU) 75 ns TinyMemBench on Broadwell E5-2690v4 Intel Optane random write 94 ns UCSD Non-Volatile Systems Lab 256MB memory ref. (remote CPU) 120 ns TinyMemBench on Broadwell E5-2690v4 Intel Optane random read 305 ns UCSD Non-Volatile Systems Lab Send 4KB over 100 Gbps HPC fabric 1 Œºs MVAPICH2 over Intel Omni-Path Compress 1KB with Google Snappy 3 Œºs Send 4KB over 10 Gbps ethernet 10 Œºs Write 4KB randomly to NVMe SSD 30 Œºs DC P3608 NVMe SSD (QOS 99% is 500Œºs) Transfer 1MB to/from NVLink GPU 30 Œºs ~33GB/s on NVIDIA 40GB NVLink Transfer 1MB to/from PCI-E GPU 80 Œºs ~12GB/s on PCIe 3.0 x16 link Read 4KB randomly from NVMe SSD 120 Œºs DC P3608 NVMe SSD (QOS 99%) Read 1MB sequentially from NVMe SSD 208 Œºs ~4.8GB/s DC P3608 NVMe SSD Write 4KB randomly to SATA SSD 500 Œºs DC S3510 SATA SSD (QOS 99.9%) Read 4KB randomly from SATA SSD 500 Œºs DC S3510 SATA SSD (QOS 99.9%) Round trip within same data center 500 Œºs One-way ping is ~250Œºs Read 1MB sequentially from SATA SSD 2 ms ~550MB/s DC S3510 SATA SSD Read 1MB sequentially from disk 5 ms ~200MB/s server HDD Random Disk Access (seek+rotation) 10 ms Send packet CA->Netherlands->CA 150 ms
Table 13.4.2: Latency Numbers for NVIDIA Tesla GPUs. 571

Action Time Notes GPU Shared Memory access 30 ns 30~90 cycles (bank conflicts add la- tency) GPU Global Memory access 200 200~800 cycles ns Launch CUDA kernel on GPU 10 Œºs Host CPU instructs GPU to start kernel Transfer 1MB to/from NVLink 30 Œºs ~33GB/s on NVIDIA 40GB NVLink GPU Transfer 1MB to/from PCI-E GPU 80 Œºs ~12GB/s on PCI-Express x16 link
13.4.8 Summary
Devices have overheads for operations. Hence it is important to aim for a small number
of large transfers rather than many small ones. This applies to RAM, SSDs, networks and GPUs. Vectorization is key for performance. Make sure you are aware of the specific abilities
of your accelerator. E.g., some Intel Xeon CPUs are particularly good for INT8 op- erations, NVIDIA Volta GPUs excel at FP16 matrix-matrix operations and NVIDIA Turing shines at FP16, INT8, and INT4 operations. Numerical overflow due to small data types can be a problem during training (and to a
lesser extent during inference). Aliasing can significantly degrade performance. For instance, memory alignment on 64
bit CPUs should be done with respect to 64 bit boundaries. On GPUs it is a good idea to keep convolution sizes aligned, e.g., to tensor cores. Match your algorithms to the hardware (e.g., memory footprint, and bandwidth). Great
speedup(ordersofmagnitude)canbeachievedwhenfittingtheparametersintocaches. We recommend that you sketch out the performance of a novel algorithm on paper before
verifying the experimental results. Discrepancies of an order-of-magnitude or more are reasons for concern. Use profilers to debug performance bottlenecks. Training and inference hardware have different sweet spots in terms of price and perfor-
mance. 13.4.9 Exercises
1. Write C code to test whether there is any difference in speed between accessing memory aligned or misaligned relative to the external memory interface. Hint: be careful of caching effects. 2. Test the difference in speed between accessing memory in sequence or with a given stride. Hardware
Computational Performance
572

3. How could you measure the cache sizes on a CPU? 4. Howwouldyoulayoutdataacrossmultiplememorychannelsformaximumbandwidth? How would you lay it out if you had many small threads?bubu5. An enterprise-class HDD is spinning at 10,000 rpm. What is the absolutely minimum time an HDD needs to spend worst case before it can read data (you can assume that heads move almost instantaneously)? Why are 2.5‚Äù HDDs becoming popular for com- mercial servers (relative to 3.5‚Äù and 5.25‚Äù drives)? 6. Assume that an HDD manufacturer increases the storage density from 1 Tbit per square inch to 5 Tbit per square inch. How much information can you store on a ring on a 2.5‚Äù HDD? Is there a difference between the inner and outer tracks?bubu7. Going from 8 bit to 16 bit data types increases the amount of silicon approximately by four times. Why? Why might NVIDIA have added INT4 operations to their Turing GPUs? 8. How much faster is it to read forward through memory vs. reading backwards? Does this number differ between different computers and CPU vendors? Why? Write C code and experiment with it. 9. Can you measure the cache size of your disk? What is it for a typical HDD? Do SSDs need a cache? 10. Measure the packet overhead when sending messages across the Ethernet. Look up the difference between UDP and TCP/IP connections.bubu11. Direct memory access allows devices other than the CPU to write (and read) directly to (from) memory. Why is this a good idea?bubu12. Look at the performance numbers for the Turing T4 GPU. Why does the performance ‚Äúonly‚Äù double as you go from FP16 to INT8 and INT4? 13. What is the shortest time it should take for a packet on a round trip between San Fran- cisco and Amsterdam? Hint: you can assume that the distance is 10,000 km.bubuDiscussions206. 206
13.5 Training on Multiple GPUs

So far we discussed how to train models efficiently on CPUs and GPUs. We even showed how deep learning frameworks allow one to parallelize computation and communication automatically between them in Section 13.3. We also showed in Section 6.7 how to list all the available GPUs on a computer using the nvidia-smi command. What we did not discuss is how to actually parallelize deep learning training. Instead, we implied in pass- ing that one would somehow split the data across multiple devices and make it work. The
Training on Multiple GPUs
573

present section fills in the details and shows how to train a network in parallel when starting from scratch. Details on how to take advantage of functionality in high-level APIs is rele- gated to Section 13.6. We assume that you are familiar with minibatch stochastic gradient descent algorithms such as the ones described in Section 12.5. 13.5.1 Splitting the Problem
Let‚Äôs start with a simple computer vision problem and a slightly archaic network, e.g., with multiple layers of convolutions, pooling, and possibly a few fully connected layers in the end. That is, let‚Äôs start with a network that looks quite similar to LeNet (LeCun et al., 1998) or AlexNet (Krizhevsky et al., 2012). Given multiple GPUs (2 if it is a desktop server, 4 on an AWS g4dn.12xlarge instance, 8 on a p3.16xlarge, or 16 on a p2.16xlarge), we want to partition training in a manner as to achieve good speedup while simultaneously benefitting from simple and reproducible design choices. Multiple GPUs, after all, increase both memory and computation ability. In a nutshell, we have the following choices, given a minibatch of training data that we want to classify. First, we could partition the network across multiple GPUs. That is, each GPU takes as input the data flowing into a particular layer, processes data across a number of subsequent layers and then sends the data to the next GPU. This allows us to process data with larger networkswhencomparedwithwhatasingleGPUcouldhandle. Besides, memoryfootprint per GPU can be well controlled (it is a fraction of the total network footprint). However, the interface between layers (and thus GPUs) requires tight synchronization. This can be tricky, in particular if the computational workloads are not properly matched be- tween layers. The problem is exacerbated for large numbers of GPUs. The interface be- tween layers also requires large amounts of data transfer, such as activations and gradients. This may overwhelm the bandwidth of the GPU buses. Moreover, compute-intensive, yet sequential operations are nontrivial to partition. See e.g., Mirhoseini et al.bubu(2017) for a best effort in this regard. It remains a difficult problem and it is unclear whether it is possible to achieve good (linear) scaling on nontrivial problems. We do not recommend it unless there is excellent framework or operating system support for chaining together multiple GPUs. Second, we could split the work layerwise. For instance, rather than computing 64 channels on a single GPU we could split up the problem across 4 GPUs, each of which generates data for 16 channels. Likewise, for a fully connected layer we could split the number of output units. Fig.bubu13.5.1 (taken from Krizhevsky et al. (2012)) illustrates this design, where this strategy was used to deal with GPUs that had a very small memory footprint (2 GB at the time). This allows for good scaling in terms of computation, provided that the number of channels (or units) is not too small. Besides, multiple GPUs can process increasingly larger networks since the available memory scales linearly. However, we need a very large number of synchronization or barrier operations since each layer depends on the results from all the other layers. Moreover, the amount of data that needs to be transferred is potentially even larger than when distributing layers across GPUs. Thus, wedonotrecommendthisapproachduetoitsbandwidthcostandcomplexity. Computational Performance
574

>| >| 3 ~ \ 192 128 20% \/ Zoa8 \dense oy ie 13 3 zi 3h > >| >) 7 = a3 dense} |densel 1500 1 128 Max 228 Max 728 Max pooling 7048 ‚Äî 2048 pooling pooling 3 48
tFig. 13.5.1 Model parallelism in the original AlexNet design due to limited GPU memory. Last, we could partition data across multiple GPUs. This way all GPUs perform the same type of work, albeit on different observations. Gradients are aggregated across GPUs after each minibatch of training data. This is the simplest approach and it can be applied in any situation. Weonlyneedtosynchronizeaftereachminibatch. Thatsaid, itishighlydesirable to start exchanging gradients parameters already while others are still being computed. Moreover, larger numbers of GPUs lead to larger minibatch sizes, thus increasing training efficiency. However, adding more GPUs does not allow us to train larger models. ¬∞o GPUO GPU 1 GPUO GPU 1 2 Fc FC oO FC FC FC FC t = t _ <i | FC 5 FC FC FC FC FC 2 t t t 5 x 5 Conv (256) ¬∞ 5 x 5 Conv (256) 5X 5 Conv (128) ||] 5 x 5 Conv (128) 5X5 Conv 5X5 Conv ¬∞ 2 11 x 11 Conv (96) ¬∞ 11 x 11 Conv (96) 1x‚Äù arn esi ie i t i i Image (3 x 224 x 224) Image (3 x 224 x 224) Image (3 x 224 x 224) Image Image Original problem Network partitioning Layer-wise partitioning Data parallelism
tFig. 13.5.2
Parallelization on multiple GPUs. From left to right: original problem, network partitioning, layerwise partitioning, data parallelism. A comparison of different ways of parallelization on multiple GPUs is depicted in Fig. 13.5.2. By and large, data parallelism is the most convenient way to proceed, provided that we have access to GPUs with sufficiently large memory. See also (Li et al., 2014) for a detailed description of partitioning for distributed training. GPU memory used to be a problem in the early days of deep learning. By now this issue has been resolved for all but the most unusual cases. We focus on data parallelism in what follows. 13.5.2 Data Parallelism
Assume that there are ùëò GPUs on a machine. Given the model to be trained, each GPU will
maintainacompletesetofmodelparametersindependentlythoughparametervaluesacross
Training on Multiple GPUs
575

the GPUs are identical and synchronized. As an example, Fig. 13.5.3 illustrates training with data parallelism when ùëò = 2. GPUO Local -¬ª|_ gradient Model Mini-batch subset Local gradient : Ea Stochastic mini-batch Mini-batch |‚Äù! subset
tFig. 13.5.3 Calculation of minibatch stochastic gradient descent using data parallelism on two GPUs. In general, the training proceeds as follows:
e In any iteration of training, given a random minibatch, we split the examples in the batch
into ùëò portions and distribute them evenly across the GPUs. Each GPU calculates loss and gradient of the model parameters based on the minibatch
subset it was assigned. The local gradients of each of the k GPUs are aggregated to obtain the current minibatch
stochastic gradient. The aggregate gradient is re-distributed to each GPU. Each GPU uses this minibatch stochastic gradient to update the complete set of model
parameters that it maintains. Note that in practice we increase the minibatch size ùëò-fold when training on ùëò GPUs such
that each GPU has the same amount of work to do as if we were training on a single GPU only. On a 16-GPU server this can increase the minibatch size considerably and we may havetoincreasethelearningrateaccordingly. AlsonotethatbatchnormalizationinSection 8.5 needs to be adjusted, e.g., by keeping a separate batch normalization coefficient per GPU. In what follows we will use a toy network to illustrate multi-GPU training. %matplotlib inline import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l
13.5.3 A Toy Network
We use LeNet as introduced in Section 7.6 (with slight modifications). We define it from scratch to illustrate parameter exchange and synchronization in detail. Computational Performance
576

# Initialize model parameters
scale = 0.01 W1 = torch.randn(size=(20, 1, 3, 3)) * scale b1 = torch.zeros(20) W2 = torch.randn(size=(50, 20, 5, 5)) * scale b2 = torch.zeros(50) W3 = torch.randn(size=(800, 128)) * scale b3 = torch.zeros(128) W4 = torch.randn(size=(128, 10)) * scale b4 = torch.zeros(10) params = [W1, b1, W2, b2, W3, b3, W4, b4] # Define the model def lenet(X, params): h1_conv = F.conv2d(input=X, weight=params[0], bias=params[1]) h1_activation = F.relu(h1_conv) h1 = F.avg_pool2d(input=h1_activation, kernel_size=(2, 2), stride=(2, 2)) h2_conv = F.conv2d(input=h1, weight=params[2], bias=params[3]) h2_activation = F.relu(h2_conv) h2 = F.avg_pool2d(input=h2_activation, kernel_size=(2, 2), stride=(2, 2)) h2 = h2.reshape(h2.shape[0], -1) h3_linear = torch.mm(h2, params[4]) + params[5] h3 = F.relu(h3_linear) y_hat = torch.mm(h3, params[6]) + params[7] return y_hat # Cross-entropy loss function
loss = nn.CrossEntropyLoss(reduction='none')
13.5.4 Data Synchronization
For efficient multi-GPU training we need two basic operations. First we need to have the ability to distribute a list of parameters to multiple devices and to attach gradients (get_params). Without parameters it is impossible to evaluate the network on a GPU. Second, we need the ability to sum parameters across multiple devices, i.e., we need an allreduce function. def get_params(params, device): new_params = [p.to(device) for p in params] for p in new_params: p.requires_grad_() return new_params
Let‚Äôs try it out by copying the model parameters to one GPU. new_params = get_params(params, d2l.try_gpu(0)) print('b1 weight:', new_params[1]) print('b1 grad:', new_params[1].grad)
b1 weight: tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,‚ê£ (continues on next page)
Training on Multiple GPUs
577

‚Ü©!0., 0., 0., 0., 0.], device='cuda:0', requires_grad=True) b1 grad: None
Since we did not perform any computation yet, the gradient with regard to the bias param- eter is still zero. Now let‚Äôs assume that we have a vector distributed across multiple GPUs. The following allreduce function adds up all vectors and broadcasts the result back to all GPUs. Note that for this to work we need to copy the data to the device accumulating the results. def allreduce(data): for i in range(1, len(data)): data[0][:] += data[i].to(data[0].device) for i in range(1, len(data)): data[i][:] = data[0].to(data[i].device)
Let‚Äôs test this by creating vectors with different values on different devices and aggregate them. data = [torch.ones((1, 2), device=d2l.try_gpu(i)) * (i + 1) for i in range(2)] print('before allreduce:\n', data[0], '\n', data[1]) allreduce(data) print('after allreduce:\n', data[0], '\n', data[1])
before allreduce: tensor([[1., 1.]], device='cuda:0') tensor([[2., 2.]], device='cuda:1') after allreduce: tensor([[3., 3.]], device='cuda:0') tensor([[3., 3.]], device='cuda:1')
13.5.5 Distributing Data
We need a simple utility function to distribute a minibatch evenly across multiple GPUs. For instance, on two GPUs we would like to have half of the data to be copied to either of the GPUs. Since it is more convenient and more concise, we use the built-in function from the deep learning framework to try it out on a 4 x 5 matrix. data = torch.arange(20).reshape(4, 5) devices = [torch.device('cuda:0'), torch.device('cuda:1')] split = nn.parallel.scatter(data, devices) print('input :', data) print('load into', devices) print('output:', split)
(continued from previous page)
Computational Performance
578

input : tensor([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]) load into [device(type='cuda', index=0), device(type='cuda', index=1)] output: (tensor([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]], device='cuda:0'), tensor([[10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], device='cuda:1'))
For later reuse we define a split_batch function that splits both data and labels. #@save def split_batch(X, y, devices): """Split `X` and `y` into multiple devices.""" assert X.shape[0] == y.shape[0] return (nn.parallel.scatter(X, devices), nn.parallel.scatter(y, devices))
13.5.6 Training
Now we can implement multi-GPU training on a single minibatch. Its implementation is primarily based on the data parallelism approach described in this section. We will use the auxiliary functions we just discussed, allreduce and split_and_load, to synchronize the data among multiple GPUs. Note that we do not need to write any specific code to achieve parallelism. Since the computational graph does not have any dependencies across devices within a minibatch, it is executed in parallel automatically. def train_batch(X, y, device_params, devices, lr): X_shards, y_shards = split_batch(X, y, devices) # Loss is calculated separately on each GPU ls = [loss(lenet(X_shard, device_W), y_shard).sum() for X_shard, y_shard, device_W in zip( X_shards, y_shards, device_params)] for l in ls: # Backpropagation is performed separately on each GPU l.backward() # Sum all gradients from each GPU and broadcast them to all GPUs with torch.no_grad(): for i in range(len(device_params[0])): allreduce([device_params[c][i].grad for c in range(len(devices))]) # The model parameters are updated separately on each GPU for param in device_params: d2l.sgd(param, lr, X.shape[0]) # Here, we use a full-size batch
Now, we can define the training function. It is slightly different from the ones used in the previous chapters: we need to allocate the GPUs and copy all the model parameters to all the devices. Obviously each batch is processed using the train_batch function to deal with multiple GPUs. For convenience (and conciseness of code) we compute the accuracy on a single GPU, though this is ineÔ¨Äicient since the other GPUs are idle. Training on Multiple GPUs
579

def train(num_gpus, batch_size, lr): train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) devices = [d2l.try_gpu(i) for i in range(num_gpus)] # Copy model parameters to `num_gpus` GPUs device_params = [get_params(params, d) for d in devices] num_epochs = 10 animator = d2l.Animator('epoch', 'test acc', xlim=[1, num_epochs]) timer = d2l.Timer() for epoch in range(num_epochs): timer.start() for X, y in train_iter: # Perform multi-GPU training for a single minibatch train_batch(X, y, device_params, devices, lr) torch.cuda.synchronize() timer.stop() # Evaluate the model on GPU 0 animator.add(epoch + 1, (d2l.evaluate_accuracy_gpu( lambda x: lenet(x, device_params[0]), test_iter, devices[0]),)) print(f'test acc: {animator.Y[0][-1]:.2f}, {timer.avg():.1f} sec/epoch ' f'on {str(devices)}')
Let‚Äôs see how well this works on a single GPU. We first use a batch size of 256 and a learning rate of 0.2. train(num_gpus=1, batch_size=256, lr=0.2)
test acc: 0.83, 3.0 sec/epoch on [device(type='cuda', index=0)]
0.8 0.6 ¬• 8 ¬Æ g 04 0.2 2 4 6 8 10 epoch
By keeping the batch size and learning rate unchanged and increasing the number of GPUs to 2, we can see that the test accuracy roughly stays the same compared with the previous experiment. Intermsoftheoptimizationalgorithms, theyareidentical. Unfortunatelythere is no meaningful speedup to be gained here: the model is simply too small; moreover we only have a small dataset, where our slightly unsophisticated approach to implementing multi-GPU training suffered from significant Python overhead. We will encounter more complex models and more sophisticated ways of parallelization going forward. Let‚Äôs see what happens nonetheless for Fashion-MNIST. Computational Performance
580

train(num_gpus=2, batch_size=256, lr=0.2)
test acc: 0.84, 2.8 sec/epoch on [device(type='cuda', index=0), device(type= ‚Ü©!'cuda', index=1)]
0.8 vu 0.6 8 8 a 204 0.2 2 4 6 8 10 epoch
13.5.7 Summary
There are multiple ways to split deep network training over multiple GPUs. We could
split them between layers, across layers, or across data.bubuThe former two require tightly choreographed data transfers. Data parallelism is the simplest strategy. Data parallel training is straightforward. However, it increases the effective minibatch
size to be efficient. In data parallelism, data is split across multiple GPUs, where each GPU executes its
own forward and backward operation and subsequently gradients are aggregated and results are broadcast back to the GPUs. e We may use slightly increased learning rates for larger minibatches.bubu13.5.8 Exercises
1. When training on k GPUs, change the minibatch size from b to k - b, i.e., scale it up by
the number of GPUs. 2. Compare accuracy for different learning rates. How does it scale with the number of GPUs? 3. Implement a more efficient allreduce function that aggregates different parameters on different GPUs? Why is it more efficient? 207
4. Implement multi-GPU test accuracy computation. Discussions207. Concise Implementation for Multiple GPUs
581

13.6 Concise Implementation for Multiple GPUs

Implementing parallelism from scratch for every new model is no fun. Moreover, there is significant benefit in optimizing synchronization tools for high performance. In the follow- ing we will show how to do this using high-level APIs of deep learning frameworks. The mathematics and the algorithms are the same as in Section 13.5. Quite unsurprisingly you will need at least two GPUs to run code of this section. import torch from torch import nn from d2l import torch as d2l
13.6.1 A Toy Network
Let‚Äôs use a slightly more meaningful network than LeNet from Section 13.5 that is still sufficiently easy and quick to train. We pick a ResNet-18 variant (He et al., 2016).bubuSince the input images are tiny we modify it slightly. In particular, the difference from Section 8.6 is that we use a smaller convolution kernel, stride, and padding at the beginning. Moreover, we remove the max-pooling layer. #@save
def resnet18(num_classes, in_channels=1): """A slightly modified ResNet-18 model.""" def resnet_block(in_channels, out_channels, num_residuals, first_block=False): blk = [] for i in range(num_residuals): if i == 0 and not first_block: blk.append(d2l.Residual(out_channels, use_1x1conv=True, strides=2)) else: blk.append(d2l.Residual(out_channels)) return nn.Sequential(*blk) # This model uses a smaller convolution kernel, stride, and padding and # removes the max-pooling layer net = nn.Sequential( nn.Conv2d(in_channels, 64, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(64), nn.ReLU()) net.add_module("resnet_block1", resnet_block(64, 64, 2, first_block=True)) net.add_module("resnet_block2", resnet_block(64, 128, 2)) net.add_module("resnet_block3", resnet_block(128, 256, 2)) net.add_module("resnet_block4", resnet_block(256, 512, 2)) net.add_module("global_avg_pool", nn.AdaptiveAvgPool2d((1,1))) net.add_module("fc", nn.Sequential(nn.Flatten(), nn.Linear(512, num_classes)))
return net
Computational Performance
582

13.6.2 Network Initialization
We will initialize the network inside the training loop. For a refresher on initialization methods see Section 5.4. net = resnet18(10) # Get a list of GPUs devices = d2l.try_all_gpus() # We will initialize the network inside the training loop
13.6.3 Training
As before, the training code needs to perform several basic functions for efficient paral- lelism:
e Network parameters need to be initialized across all devices. e While iterating over the dataset minibatches are to be divided across all devices. e We compute the loss and its gradient in parallel across devices. e Gradients are aggregated and parameters are updated accordingly. In the end we compute the accuracy (again in parallel) to report the final performance of
the network. The training routine is quite similar to implementations in previous chapters, except that we need to split and aggregate data. def train(net, num_gpus, batch_size, lr): train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) devices = [d2l.try_gpu(i) for i in range(num_gpus)] def init_weights(module): if type(module) in [nn.Linear, nn.Conv2d]: nn.init.normal_(module.weight, std=0.01) net.apply(init_weights) # Set the model on multiple GPUs net = nn.DataParallel(net, device_ids=devices) trainer = torch.optim.SGD(net.parameters(), lr) loss = nn.CrossEntropyLoss() timer, num_epochs = d2l.Timer(), 10 animator = d2l.Animator('epoch', 'test acc', xlim=[1, num_epochs]) for epoch in range(num_epochs): net.train() timer.start() for X, y in train_iter: trainer.zero_grad() X, y = X.to(devices[0]), y.to(devices[0]) l = loss(net(X), y) l.backward() trainer.step() timer.stop() animator.add(epoch + 1, (d2l.evaluate_accuracy_gpu(net, test_iter),)) print(f'test acc: {animator.Y[0][-1]:.2f}, {timer.avg():.1f} sec/epoch ' f'on {str(devices)}')
Concise Implementation for Multiple GPUs
583

Let‚Äôs see how this works in practice. As a warm-up we train the network on a single GPU. train(net, num_gpus=1, batch_size=256, lr=0.1)
test acc: 0.91, 12.2 sec/epoch on [device(type='cuda', index=0)]
0.92 0.90 gv 8 ¬© 0.88 rd <j 0.86 0.84 2 4 6 8 10 epoch
Next we use 2 GPUs for training. Compared with LeNet evaluated in Section 13.5, the model for ResNet-18 is considerably more complex. This is where parallelization shows its advantage. The time for computation is meaningfully larger than the time for synchro- nizing parameters. This improves scalability since the overhead for parallelization is less relevant. train(net, num_gpus=2, batch_size=512, lr=0.2)
test acc: 0.73, 7.5 sec/epoch on [device(type='cuda', index=0), device(type= ‚Ü©!'cuda', index=1)]
0.84 v 07 8 ¬Æ % i] 0.64 0.54 2 4 6 8 10 epoch
13.6.4 Summary
e Data is automatically evaluated on the devices where the data can be found. e Take care to initialize the networks on each device before trying to access the parameters
on that device. Otherwise you will encounter an error. e The optimization algorithms automatically aggregate over multiple GPUs. Computational Performance
584

13.6.5 Exercises
1.bubuThis section uses ResNet-18. Try different epochs, batch sizes, and learning rates. Use more GPUs for computation. What happens if you try this with 16 GPUs (e.g., on an AWS p2.16xlarge instance)? 2. Sometimes, different devices provide different computing power. We could use the GPUs and the CPU at the same time. How should we divide the work? Is it worth the effort? Why?bubuWhy not?bubuDiscussions208. 208

13.7 Parameter Servers
ae
As we move from a single GPU to multiple GPUs and then to multiple servers containing multiple GPUs, possibly all spread out across multiple racks and network switches, our algorithms for distributed and parallel training need to become much more sophisticated. Details matter since different interconnects have very different bandwidth (e.g., NVLink can offer up to 100 GB/s across 6 links in an appropriate setting, PCIe 4.0 (16-lane) offers 32 GB/s, while even high speed 100GbE Ethernet only amounts to 10 GB/s). At the same time it is unreasonable to expect that a statistical modeler be an expert in networking and systems. The core idea of the parameter server was introduced in Smola and Narayanamurthy (2010) in the context of distributed latent variable models. A description of the push and pull semantics then followed in Ahmed et al. (2012) and a description of the system and an open source library followed in Li et al. (2014).bubuIn the following we will motivate the components needed for efficiency. 13.7.1 Data-Parallel Training
Let‚Äôs review the data parallel training approach to distributed training. We will use this to the exclusion of all others in this section since it is significantly simpler to implement in practice. There are virtually no use cases (besides deep learning on graphs) where any other strategy for parallelism is preferred since GPUs have plenty of memory nowadays. Fig. 13.7.1 describes the variant of data parallelism that we implemented in Section 13.5. The key aspect in it is that the aggregation of gradients occurs on one single GPU (GPU 0) before the updated parameters are rebroadcast to all GPUs. In retrospect, the decision to aggregate on GPU 0 seems rather ad-hoc. After all, we might just as well aggregate on the CPU. In fact, we could even decide to aggregate some of the parameters on one GPU and some others on another. Provided that the optimization algorithm supports this, there is no real reason for why we could not. For instance, if we have four parameter vectors with associated gradients g1, . . .,g4 we could aggregate the gradients on one GPU for each gùëñ (ùëñ = 1, . .bubu.,4). Parameter Servers
585

storage data CPU minibatch GPU network & Gp r parameters ‚Äî i t gradient ¬© ¬©- He as single GPU multiple GPUs
tFig. 13.7.1
Left: single GPU training. Right: a variant of multi-GPU training: (1) we compute loss and gradient, (2) all gradients are aggregated on one GPU, (3) parameter update happens and the parameters are re-distributed to all GPUs. Thisreasoningseemsarbitraryandfrivolous.bubuAfterall,themathematicsisthesamethrough- out. However, we are dealing with real physical hardware where different buses have differ- ent bandwidth as discussed in Section 13.4. Consider a real 4-way GPU server as described in Fig. 13.7.2. If it is particularly well connected, it might have a 100 GbE network card. More typical numbers are in the 1‚Äì10 GbE range with an effective bandwidth of 100 MB/s to 1 GB/s. Since the CPUs have too few PCIe lanes to connect to all GPUs directly (e.g., consumer-grade Intel CPUs have 24 lanes) we need a multiplexer209. The bandwidth from the CPU on a 16x Gen3 link is 16 GB/s. This is also the speed at which each of the GPUs is connected to the switch. This means that it is more effective to communicate between the devices. 209
network co ‚Äòswitch 2283) 10-100 cde (1-10 GB/s) cpu PCle 3.0 16x (16 GBis) PCle itch seu 4x PCle 3.0 16x (64 GBis)
tFig. 13.7.2 A 4-way GPU server. Computational Performance
586

For the sake of the argument let‚Äôs assume that the gradients are of 160 MB. In this case it takes 30 ms to send the gradients from all 3 remaining GPUs to the fourth one (each transfer takes 10 ms = 160 MB / 16 GB/s). Adding another 30 ms to transmit the weight vectors back we arrive at a total of 60 ms. If we send all data to the CPU we incur a penalty of 40 ms since each of the four GPUs needs to send the data to the CPU, yielding a total of 80 ms. Lastly assume that we are able to split the gradients into 4 parts of 40 MB each. Now we can aggregate each of the parts on a different GPU simultaneously since the PCIe switch offers a full-bandwidth operation between all links. Instead of 30 ms this takes 7.5 ms, yielding a total of 15 ms for a synchronization operation. In short, depending on how we synchronize parameters the same operation can take anywhere from 15 ms to 80 ms. Fig.bubu13.7.3 depicts the different strategies for exchanging parameters. cPU network & parameters gradient Parameter server in CPU Parameter server in GPU 0 Parameter server distributed over all GPUs
tFig. 13.7.3
Parameter synchronization strategies. Note that we have yet another tool at our disposal when it comes to improving performance: in a deep network it takes some time to compute all gradients from the top to the bottom. We can begin synchronizing gradients for some parameter groups even while we are still busy computing them for others. See e.g., Sergeev and Del Balso (2018) for details on how to do this in Horovod210. 210
13.7.2 Ring Synchronization
When it comes to synchronization on modern deep learning hardware we often encounter significantlybespokenetworkconnectivity. Forinstance,theAWSp3.16xlargeandNVIDIA DGX-2 instances share the connectivity structure of Fig. 13.7.4. Each GPU connects to a host CPU via a PCIe link which operates at best at 16 GB/s. Additionally each GPU also has 6 NVLink connections, each of which is capable of transferring 300 Gbit/s bidirec- tionally. This amounts to around 18 GB/s per link per direction. In short, the aggregate NVLink bandwidth is significantly higher than the PCIe bandwidth. The question is how to use it most efficiently. It turns out that the optimal synchronization strategy is to decompose the network into two ringsandtousethemtosynchronizedatadirectly(Wangetal., 2018). Fig.13.7.5illustrates that the network can be decomposed into one ring (1-2-3-4-5-6-7-8-1) with double NVLink bandwidth and into one (1-4-6-3-5-8-2-7-1) with regular bandwidth. Designing an efficient synchronization protocol in this case is nontrivial. Consider the following thought experiment: given a ring of ùëõ computing nodes (or GPUs)
Parameter Servers
587


tFig. 13.7.4 NVLink connectivity on 8 V100 GPU servers (image courtesy of NVIDIA). MH iH if VY
tFig. 13.7.5 Decomposition of the NVLink network into two rings. we can send gradients from the first to the second node. There it is added to the local gradient and sent on to the third node, and so on. After n ‚Äî 1 steps the aggregate gradient can be found in the last-visited node. That is, the time to aggregate gradients grows linearly with the number of nodes. But if we do this the algorithm is quite inefficient. After all, at any time there is only one of the nodes communicating. What if we broke the gradients into n chunks and started synchronizing chunk i starting at node i? Since each chunk is of size 1/n the total time is now (n ‚Äî 1)/n ~ 1. In other words, the time spent to aggregate
Computational Performance
588

gradients does not grow as we increase the size of the ring. This is quite an astonishing result.bubuFig. 13.7.6 illustrates the sequence of steps on ùëõ = 4 nodes. f F A F | | | A GPU GPU {cru} GPU GPU GPU x x} | Pet x} | |x x] | xbox x} | |x x] | x| x x}x x| xb} xdx} |x x| x x} x| x| x x|x}x x x x} x x|x}x x GPU GPU [eru| GPU GPU GPU [ru | GPU GPU
tFig. 13.7.6 Ring synchronization across 4 nodes. Each node starts transmitting parts of gradients to
its left neighbor until the assembled gradient can be found in its right neighbor. If we use the same example of synchronizing 160 MB across 8 V100 GPUs we arrive at approximately 2 - 160MB/(3 - 18GB/s) ~ 6ms. This is better than using the PCle bus, even though we are now using 8 GPUs. Note that in practice these numbers are a bit worse, since deep learning frameworks often fail to assemble communication into large burst transfers. Note that there is a common misconception that ring synchronization is fundamentally different from other synchronization algorithms. The only difference is that the synchro- nization path is somewhat more elaborate when compared with a simple tree. 13.7.3 Multi-Machine Training
Distributed training on multiple machines adds a further challenge: we need to communi- catewithserversthatareonlyconnectedacrossacomparativelylowerbandwidthfabricthat can be over an order of magnitude slower in some cases. Synchronization across devices is tricky. After all, different machines running training code will have subtly different speed. Hence we need to synchronize themif wewantto use synchronous distributed optimization. Fig. 13.7.7 illustrates how distributed parallel training occurs. 1. A (different) batch of data is read on each machine, split across multiple GPUs and transferred to GPU memory. There predictions and gradients are computed on each GPU batch separately. 2. The gradients from all local GPUs are aggregated on one GPU (or parts of it are aggre- gated over different GPUs). Parameter Servers
589

3. The gradients are sent to the CPUs. 4. The CPUs send the gradients to a central parameter server which aggregates all the gradients. 5. The aggregate gradients are then used to update the parameters and the updated param- eters are broadcast back to the individual CPUs. 6. The information is sent to one (or multiple) GPUs. 7. The updated parameters are spread across all GPUs. parameter storage data minibatch GPU network & parameters gradient
tFig. 13.7.7 Multi-machine multi-GPU distributed parallel training. Each of these operations seems rather straightforward.bubuAnd, indeed, they can be carrie out efficiently within a single machine. Once we look at multiple machines, though, we can see that the central parameter server becomes the bottleneck. After all, the bandwidth per server is limited, hence for m workers the time it takes to send all gradients to the server is O(m). We can break through this barrier by increasing the number of servers to n. At this point each server only needs to store O(1/n) of the parameters, hence the total time for updates and optimization becomes O(m/n). Matching both numbers yields constant scaling regardless of how many workers we are dealing with. In practice we use the same machines both as workers and as servers. Fig. 13.7.8 illustrates the design (see also (Li et al., 2014) for details). In particular, ensuring that multiple machines work without unreasonable delays is nontrivial. 13.7.4 Key‚ÄìValue Stores
Implementingthestepsrequiredfordistributed multi-GPUtraininginpracticeisnontrivial. This is why it pays to use a common abstraction, namely that of a key‚Äìvalue store with redefined update semantics. Computational Performance
590

cpu | | GPu | | GPU | | GPU | | GPU | | GPU | | GPU | | GPU | | GPU | | GPU single parameter server GPU GPU GPU GPU GPU GPU GPU GPU GPU GPU
tFig. 13.7.8
Top: a single parameter server is a bottleneck since its bandwidth is Ô¨Ånite. Bottom: multiple parameter servers store parts of the parameters with aggregate bandwidth. AcrossmanyworkersandmanyGPUsthecomputationforgradientùëñ canbedefinedas
gùëñ = gùëñùëóùëò, ùëò2workers ùëó2GPUs (13.7.1)
where gùëñùëóùëò is part of gradientùëñ split on GPU ùëó of worker ùëò. The key aspect in this operation is that it is a commutative reduction, that is, it turns many vectors into one and the order in which the operation is applied does not matter. This is great for our purposes since we do not (need to) have fine grained control over when which gradient is received. Besides, note that this operation is independent among different ùëñ. This allows us to define the following two operations: push, which accumulates gradients, and pull, which retrieves aggregate gradients. Since we have many different sets of gra- dients (after all, we have many layers), we need to index the gradients with a key ùëñ. This similarity to key‚Äìvalue stores, such as the one introduced in Dynamo (DeCandia et al., 2007) is not by coincidence. They, too, satisfy many similar characteristics, in particular when it comes to distributing the parameters across multiple servers. The push and pull operations for key-value stores are described as follows:
e push(key, value) sends a particular gradient (the value) from a worker to a common
storage. There the value is aggregated, e.g., by summing it up. e pull(key, value) retrieves an aggregate value from common storage, e.g., after combining
the gradients from all workers. Byhidingallthecomplexityaboutsynchronizationbehindasimplepushandpulloperation
multiple servers
Parameter Servers
591

we can decouple the concerns of statistical modelers who want to be able to express opti- mization in simple terms and the system engineers who need to deal with the complexity inherent in distributed synchronization. 13.7.5 Summary
Synchronization needs to be highly adaptive to specific network infrastructure and con-
nectivity within a server. This can make a significant difference to the time it takes to synchronize. Ring-synchronization can be optimal for p3 and DGX-2 servers. For others possibly not
so much. A hierarchical synchronization strategy works well when adding multiple parameter
servers for increased bandwidth. 13.7.6 Exercises
1. Can you increase the ring synchronization even further? Hint: you can send messages in both directions. 2. Is it possible to allow asynchronous communication (while computation is still ongo- ing)? How does it affect performance?bubu3. What if we lost a server during a long-running computation? How can we design a fault tolerance mechanism to avoid restarting the computation fully? Discussions211. 211
14
Computer Vision
Whether it is medical diagnosis, self-driving vehicles, camera monitoring, or smart filters, many applications in the field of computer vision are closely related to our current and fu- ture lives. In recent years, deep learning has been the transformative power for advancing the performance of computer vision systems. It can be said that the most advanced com- puter vision applications are almost inseparable from deep learning. In view of this, this chapter will focus on the field of computer vision, and investigate methods and applications that have recently been influential in academia and industry. In Chapter 7 and Chapter 8, we studied various convolutional neural networks that are commonly used in computer vision, and applied them to simple image classification tasks. At the beginning of this chapter, we will describe two methods that may improve model generalization, namely image augmentation and fine-tuning, and apply them to image clas- sification. Since deep neural networks can effectively represent images in multiple lev- els, such layerwise representations have been successfully used in various computer vision tasks such as object detection, semantic segmentation, and style transfer. Following the key idea of leveraging layerwise representations in computer vision, we will begin with major components and techniques for object detection. Next, we will show how to use fully con- volutional networks for semantic segmentation of images. Then we will explain how to use style transfer techniques to generate images like the cover of this book. In the end, we con- clude this chapter by applying the materials of this chapter and several previous chapters on two popular computer vision benchmark datasets. 14.1 Image Augmentation
ee
In Section 8.1, we mentioned that large datasets are a prerequisite for the success of deep neural networks in various applications. Image augmentation generates similar but distinct training examples after a series of random changes to the training images, thereby expand- ing the size of the training set. Alternatively, image augmentation can be motivated by the fact that random tweaks of training examples allow models to rely less on certain attributes, thereby improving their generalization ability. For example, we can crop an image in dif- ferent ways to make the object of interest appear in different positions, thereby reducing the dependence of a model on the position of the object. We can also adjust factors such as brightness and color to reduce a model‚Äôs sensitivity to color. It is probably true that image
592
Image Augmentation
593

augmentation was indispensable for the success of AlexNet at that time. In this section we
will discuss this widely used technique in computer vision. %matplotlib inline import torch import torchvision from torch import nn from d2l import torch as d2l
14.1.1 Common Image Augmentation Methods
In our investigation of common image augmentation methods, we will use the following
400 x 500 image an example. d2l.set_figsize() img = d2l.Image.open('../img/cat1.jpg') d2l.plt.imshow(img);

Most image augmentation methods have a certain degree of randomness. To make it easier for us to observe the effect of image augmentation, next we define an auxiliary function apply. This function runs the image augmentation method aug multiple times on the input image img and shows all the results. def apply(img, aug, num_rows=2, num_cols=4, scale=1.5): Y = [aug(img) for _ in range(num_rows * num_cols)] d2l.show_images(Y, num_rows, num_cols, scale=scale)
Flipping and Cropping
Flipping the image left and right usually does not change the category of the object. This is one of the earliest and most widely used methods of image augmentation. Next, we use the transforms module to create the RandomHorizontalFlip instance, which flips an image left and right with a 50% chance. apply(img, torchvision.transforms.RandomHorizontalFlip())
Flipping up and down is not as common as flipping left and right. But at least for this
Computer Vision
594





example image, flipping up and down does not hinder recognition. Next, we create a Ran- domVerticalFlip instance to flip an image up and down with a 50% chance. apply(img, torchvision.transforms.RandomVerticalFlip())




In the example image we used, the cat is in the middle of the image, but this may not be the caseingeneral. InSection7.5, weexplainedthatthepoolinglayercanreducethesensitivity of a convolutional layer to the target position. In addition, we can also randomly crop the image to make objects appear in different positions in the image at different scales, which can also reduce the sensitivity of a model to the target position. In the code below, we randomly crop an area with an area of 10% ~ 100% of the original
In the code below, we randomly crop an area with an area of 10% ~ 100% of the original area each time, and the ratio of width to height of this area is randomly selected from 0.5 ~ 2. Then, the width and height of the region are both scaled to 200 pixels. Unless otherwise specified, the random number between a and b in this section refers to a continuous value obtained by random and uniform sampling from the interval [a, b]. shape_aug = torchvision.transforms.RandomResizedCrop( (200, 200), scale=(0.1, 1), ratio=(0.5, 2)) apply(img, shape_aug)
Changing Colors
Another augmentation method is changing colors. We can change four aspects of the image color: brightness, contrast, saturation, and hue. In the example below, we randomly change the brightness of the image to a value between 50% (1 ‚Äî 0.5) and 150% (1 + 0.5) of the original image. Image Augmentation
595





apply(img, torchvision.transforms.ColorJitter( brightness=0.5, contrast=0, saturation=0, hue=0))




Similarly, we can randomly change the hue of the image. apply(img, torchvision.transforms.ColorJitter( brightness=0, contrast=0, saturation=0, hue=0.5))




We can also create a RandomColorJitter instance and set how to randomly change the brightness, contrast, saturation, and hue of the image at the same time. color_aug = torchvision.transforms.ColorJitter(
brightness=0.5, contrast=0.5, saturation=0.5, hue=0.5) apply(img, color_aug)












Computer Vision
596





Combining Multiple Image Augmentation Methods
In practice, we will combine multiple image augmentation methods. For example, we can combine the different image augmentation methods defined above and apply them to each image via a Compose instance. augs = torchvision.transforms.Compose([ torchvision.transforms.RandomHorizontalFlip(), color_aug, shape_aug]) apply(img, augs)




14.1.2 Training with Image Augmentation
Let‚Äôs train a model with image augmentation. Here we use the CIFAR-10 dataset instead of the Fashion-MNIST dataset that we used before. This is because the position and size of the objects in the Fashion-MNIST dataset have been normalized, while the color and size of the objects in the CIFAR-10 dataset have more significant differences. The first 32 training images in the CIFAR-10 dataset are shown below. all_images = torchvision.datasets.CIFAR10(train=True, root="../data", download=True) d2l.show_images([all_images[i][0] for i in range(32)], 4, 8, scale=0.8);
Downloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ../data/
‚Ü©!cifar-10-python.tar.gz 100%|| 170498071/170498071 [00:04<00:00, 37716809.52it/s] Extracting ../data/cifar-10-python.tar.gz to ../data
In order to obtain definitive results during prediction, we usually only apply image aug-








Image Augmentation
597

ia ES Bs PPA =n asASlb ehao Res ak



CG
les

mentation to training examples, and do not use image augmentation with random opera- tions during prediction. Here we only use the simplest random left-right flipping method. In addition, we use a ToTensor instance to convert a minibatch of images into the format required by the deep learning framework, i.e., 32-bit floating point numbers between 0 and 1 with the shape of (batch size, number of channels, height, width). train_augs = torchvision.transforms.Compose([ torchvision.transforms.RandomHorizontalFlip(), torchvision.transforms.ToTensor()]) test_augs = torchvision.transforms.Compose([ torchvision.transforms.ToTensor()])
Next, we define an auxiliary function to facilitate reading the image and applying image augmentation. The transform argument provided by PyTorch‚Äôs dataset applies augmen- tation to transform the images. For a detailed introduction to DataLoader, please refer to Section 4.2. def load_cifar10(is_train, augs, batch_size): dataset = torchvision.datasets.CIFAR10(root="../data", train=is_train, transform=augs, download=True) dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size, shuffle=is_train, num_workers=d2l.get_dataloader_workers()) return dataloader
Multi-GPU Training
We train the ResNet-18 model from Section 8.6 on the CIFAR-10 dataset. Recall the in- troduction to multi-GPU training in Section 13.6. In the following, we define a function to train and evaluate the model using multiple GPUs. #@save def train_batch_ch13(net, X, y, loss, trainer, devices): """Train for a minibatch with multiple GPUs (defined in Chapter 13).""" if isinstance(X, list): # Required for BERT fine-tuning (to be covered later) X = [x.to(devices[0]) for x in X]



OB
in



(continues on next page)
Computer Vision
598

else: X = X.to(devices[0]) y = y.to(devices[0]) net.train() trainer.zero_grad() pred = net(X) l = loss(pred, y) l.sum().backward() trainer.step() train_loss_sum = l.sum() train_acc_sum = d2l.accuracy(pred, y) return train_loss_sum, train_acc_sum
#@save def train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices=d2l.try_all_gpus()): """Train a model with multiple GPUs (defined in Chapter 13).""" timer, num_batches = d2l.Timer(), len(train_iter) animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], ylim=[0, 1], legend=['train loss', 'train acc', 'test acc']) net = nn.DataParallel(net, device_ids=devices).to(devices[0]) for epoch in range(num_epochs): # Sum of training loss, sum of training accuracy, no. of examples, # no. of predictions metric = d2l.Accumulator(4) for i, (features, labels) in enumerate(train_iter): timer.start() l, acc = train_batch_ch13( net, features, labels, loss, trainer, devices) metric.add(l, acc, labels.shape[0], labels.numel()) timer.stop() if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (metric[0] / metric[2], metric[1] / metric[3], None)) test_acc = d2l.evaluate_accuracy_gpu(net, test_iter) animator.add(epoch + 1, (None, None, test_acc)) print(f'loss {metric[0] / metric[2]:.3f}, train acc ' f'{metric[1] / metric[3]:.3f}, test acc {test_acc:.3f}') print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec on ' f'{str(devices)}')
Now we can define the train_with_data_aug function to train the model with image augmentation. This function gets all available GPUs, uses Adam as the optimization algo- rithm, applies image augmentation to the training dataset, and finally calls the train_ch13 function just defined to train and evaluate the model. batch_size, devices, net = 256, d2l.try_all_gpus(), d2l.resnet18(10, 3) net.apply(d2l.init_cnn)
def train_with_data_aug(train_augs, test_augs, net, lr=0.001): train_iter = load_cifar10(True, train_augs, batch_size)
(continued from previous page)
(continues on next page)
Image Augmentation
599

test_iter = load_cifar10(False, test_augs, batch_size) loss = nn.CrossEntropyLoss(reduction="none") trainer = torch.optim.Adam(net.parameters(), lr=lr) net(next(iter(train_iter))[0]) train_ch13(net, train_iter, test_iter, loss, trainer, 10, devices)
Let‚Äôs train the model using image augmentation based on random left-right flipping. train_with_data_aug(train_augs, test_augs, net)
loss 0.215, train acc 0.925, test acc 0.810 4728.8 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
1.0 0.8 0.6 Jone 0.4 ‚Äî train loss 0.24 --- train acc ‚Äî'- test acc 0.0 T T T T 2 4 6 8 10 epoch
14.1.3 Summary
Image augmentation generates random images based on existing training data to improve
the generalization ability of models. In order to obtain definitive results during prediction, we usually only apply image aug-
mentation to training examples, and do not use image augmentation with random op- erations during prediction. Deep learning frameworks provide many different image augmentation methods, which
can be applied simultaneously. 14.1.4 Exercises
1. Trainthemodelwithoutusingimageaugmentation: train_with_data_aug(test_augs, test_augs). Compare training and testing accuracy when using and not using image augmentation. Can this comparative experiment support the argument that image aug- mentation can mitigate overfitting? Why? 2. CombinemultipledifferentimageaugmentationmethodsinmodeltrainingontheCIFAR- 10 dataset. Does it improve test accuracy? (continued from previous page)
Computer Vision
600

3. Refer to the online documentation of the deep learning framework. What other image augmentation methods does it also provide? Discussions212. 212
fof
el
14.2 Fine-Tuning
|
In earlier chapters, we discussed how to train models on the Fashion-MNIST training dataset with only 60000 images. We also described ImageNet, the most widely used large- scale image dataset in academia, which has more than 10 million images and 1000 objects. However, the size of the dataset that we usually encounter is between those of the two datasets. Suppose that we want to recognize different types of chairs from images, and then recom- mend purchase links to users. One possible method is to first identify 100 common chairs, take 1000 images of different angles for each chair, and then train a classification model on the collected image dataset. Although this chair dataset may be larger than the Fashion- MNIST dataset, the number of examples is still less than one-tenth of that in ImageNet. This may lead to overfitting of complicated models that are suitable for ImageNet on this chair dataset. Besides, due to the limited amount of training examples, the accuracy of the trained model may not meet practical requirements. In order to address the above problems, an obvious solution is to collect more data. How- ever, collecting and labeling data can take a lot of time and money. For example, in order to collect the ImageNet dataset, researchers have spent millions of dollars from research funding. Although the current data collection cost has been significantly reduced, this cost still cannot be ignored. Another solution is to apply transfer learning to transfer the knowledge learned from the source dataset to the target dataset. For example, although most of the images in the Ima- geNet dataset have nothing to do with chairs, the model trained on this dataset may extract more general image features, which can help identify edges, textures, shapes, and object composition. These similar features may also be effective for recognizing chairs. 14.2.1 Steps
In this section, we will introduce a common technique in transfer learning: fine-tuning. As shown in Fig. 14.2.1, fine-tuning consists of the following four steps:
1. Pretrain a neural network model, i.e., the source model, on a source dataset (e.g., the ImageNet dataset). 2. Create a new neural network model, i.e., the target model. This copies all model de- signs and their parameters on the source model except the output layer. We assume that these model parameters contain the knowledge learned from the source dataset and this
601

knowledge will also be applicable to the target dataset. We also assume that the output layer of the source model is closely related to the labels of the source dataset; thus it is not used in the target model. 3. Add an output layer to the target model, whose number of outputs is the number of categories in the target dataset. Then randomly initialize the model parameters of this layer. 4. Train the target model on the target dataset, such as a chair dataset. The output layer will be trained from scratch, while the parameters of all the other layers are fine-tuned based on the parameters of the source model. Source Target model model Random Train from LayerL-1 fe-+--SOPY.... >| LayerL-1 T T we ee SOPY . we Fine-tune Layer 1 Layer 1 Source dataset Target dataset
Pretrain
tFig. 14.2.1
Fine tuning. When target datasets are much smaller than source datasets, fine-tuning helps to improve models‚Äô generalization ability. 14.2.2 Hot Dog Recognition
Let‚Äôs demonstrate fine-tuning via a concrete case: hot dog recognition. We will fine-tune
a ResNet model on a small dataset, which was pretrained on the ImageNet dataset. This small dataset consists of thousands of images with and without hot dogs. We will use the fine-tuned model to recognize hot dogs from images. %matplotlib inline import os import torch import torchvision from torch import nn from d2l import torch as d2l
Reading the Dataset
The hot dog dataset we use was taken from online images. This dataset consists of 1400 positive-class images containing hot dogs, and as many negative-class images containing other foods. 1000 images of both classes are used for training and the rest are for test- ing. Fine-Tuning
Computer Vision
602

Afterunzippingthedownloadeddataset, weobtaintwofoldershotdog/trainandhotdog/ test. Both folders have hotdog and not-hotdog subfolders, either of which contains images of the corresponding class. #@save d2l.DATA_HUB['hotdog'] = (d2l.DATA_URL + 'hotdog.zip', 'fba480ffa8aa7e0febbb511d181409f899b9baa5')
data_dir = d2l.download_extract('hotdog')
Downloading ../data/hotdog.zip from http://d2l-data.s3-accelerate.amazonaws. ‚Ü©!com/hotdog.zip... We create two instances to read all the image files in the training and testing datasets, re- spectively. train_imgs = torchvision.datasets.ImageFolder(os.path.join(data_dir, 'train')) test_imgs = torchvision.datasets.ImageFolder(os.path.join(data_dir, 'test'))
The first 8 positive examples and the last 8 negative images are shown below. As you can see, the images vary in size and aspect ratio. hotdogs = [train_imgs[i][0] for i in range(8)] not_hotdogs = [train_imgs[-i - 1][0] for i in range(8)] d2l.show_images(hotdogs + not_hotdogs, 2, 8, scale=1.4);

During training, we first crop a random area of random size and random aspect ratio from the image, and then scale this area to a 224x224 input image. During testing, we scale both the height and width of an image to 256 pixels, and then crop a central 224 x 224 area as input. In addition, for the three RGB (red, green, and blue) color channels we standardize their values channel by channel. Concretely, the mean value of a channel is subtracted from each value of that channel and then the result is divided by the standard deviation of that channel. # Specify the means and standard deviations of the three RGB channels to # standardize each channel
normalize = torchvision.transforms.Normalize(
(continues on next page)
603

[0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
train_augs = torchvision.transforms.Compose([ torchvision.transforms.RandomResizedCrop(224), torchvision.transforms.RandomHorizontalFlip(), torchvision.transforms.ToTensor(), normalize])
test_augs = torchvision.transforms.Compose([ torchvision.transforms.Resize([256, 256]), torchvision.transforms.CenterCrop(224), torchvision.transforms.ToTensor(), normalize])
Defining and Initializing the Model
We use ResNet-18, which was pretrained on the ImageNet dataset, as the source model. Here, we specify pretrained=True to automatically download the pretrained model pa- rameters. If this model is used for the first time, Internet connection is required for down- load. pretrained_net = torchvision.models.resnet18(pretrained=True)
The pretrained source model instance contains a number of feature layers and an output layer fc. The main purpose of this division is to facilitate the fine-tuning of model param- eters of all layers but the output layer. The member variable fc of source model is given below. pretrained_net.fc
Linear(in_features=512, out_features=1000, bias=True)
As a fully connected layer, it transforms ResNet‚Äôs final global average pooling outputs into 1000 class outputs of the ImageNet dataset. We then construct a new neural network as the target model. It is defined in the same way as the pretrained source model except that its number of outputs in the final layer is set to the number of classes in the target dataset (rather than 1000). In the code below, the model parameters before the output layer of the target model in- stance finetune_net are initialized to model parameters of the corresponding layers from the source model. Since these model parameters were obtained via pretraining on Ima- geNet, they are effective. Therefore, we can only use a small learning rate to fine-tune such pretrained parameters. In contrast, model parameters in the output layer are randomly ini- tialized and generally require a larger learning rate to be learned from scratch. Letting the base learning rate be ùúÇ, a learning rate of 10ùúÇ will be used to iterate the model parameters in the output layer. Fine-Tuning
(continued from previous page)
Computer Vision
604

finetune_net = torchvision.models.resnet18(pretrained=True) finetune_net.fc = nn.Linear(finetune_net.fc.in_features, 2) nn.init.xavier_uniform_(finetune_net.fc.weight);
Fine-Tuning the Model
First, we define a training function train_fine_tuning that uses fine-tuning so it can be called multiple times. # If `param_group=True`, the model parameters in the output layer will be
# updated using a learning rate ten times greater def train_fine_tuning(net, learning_rate, batch_size=128, num_epochs=5, param_group=True): train_iter = torch.utils.data.DataLoader(torchvision.datasets.ImageFolder( os.path.join(data_dir, 'train'), transform=train_augs), batch_size=batch_size, shuffle=True) test_iter = torch.utils.data.DataLoader(torchvision.datasets.ImageFolder( os.path.join(data_dir, 'test'), transform=test_augs), batch_size=batch_size) devices = d2l.try_all_gpus() loss = nn.CrossEntropyLoss(reduction="none") if param_group: params_1x = [param for name, param in net.named_parameters() if name not in ["fc.weight", "fc.bias"]] trainer = torch.optim.SGD([{'params': params_1x}, {'params': net.fc.parameters(), 'lr': learning_rate * 10}], lr=learning_rate, weight_decay=0.001) else: trainer = torch.optim.SGD(net.parameters(), lr=learning_rate, weight_decay=0.001) d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
We set the base learning rate to a small value in order to fine-tune the model parameters obtained via pretraining. Based on the previous settings, we will train the output layer parameters of the target model from scratch using a learning rate ten times greater. train_fine_tuning(finetune_net, 5e-5)
loss 0.242, train acc 0.909, test acc 0.940 1062.4 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
For comparison, we define an identical model, but initialize all of its model parameters to random values. Since the entire model needs to be trained from scratch, we can use a larger learning rate. 605

1.0 ve eee] wet 08 06 ‚Äî train loss - train acc 04 ‚Äî-- test ace 0.2 0.0 1 2 3 4 5
scratch_net = torchvision.models.resnet18() scratch_net.fc = nn.Linear(scratch_net.fc.in_features, 2) train_fine_tuning(scratch_net, 5e-4, param_group=False)
loss 0.352, train acc 0.846, test acc 0.850 1525.4 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
‚Äî train loss 0.24 --- train acc ‚Äî-- test acc 0.0 1 2 3 4 5 epoch
As we can see, the fine-tuned model tends to perform better for the same epoch because its initial parameter values are more effective. 14.2.3 Summary
e Transfer learning transfers knowledge learned from the source dataset to the target dataset. Fine-tuning is a common technique for transfer learning. e The target model copies all model designs with their parameters from the source model
except the output layer, and fine-tunes these parameters based on the target dataset. In contrast, the output layer of the target model needs to be trained from scratch. e Generally, fine-tuning parameters uses a smaller learning rate, while training the output
layer from scratch can use a larger learning rate. 14.2.4 Exercises
Fine-Tuning
Computer Vision
606

1. Keep increasing the learning rate of finetune_net. How does the accuracy of the model change? 2. Further adjust hyperparameters of finetune_net and scratch_net in the comparative experiment. Do they still differ in accuracy? 3. Settheparametersbeforetheoutputlayerof finetune_nettothoseofthesourcemodel and do not update them during training. How does the accuracy of the model change? You can use the following code. for param in finetune_net.parameters(): param.requires_grad = False
4. In fact, there is a ‚Äúhotdog‚Äù class in the ImageNet dataset. Its corresponding weight parameter in the output layer can be obtained via the following code. How can we leverage this weight parameter? weight = pretrained_net.fc.weight hotdog_w = torch.split(weight.data, 1, dim=0)[934] hotdog_w.shape
torch.Size([1, 512])
213
Discussions213. 14.3 Object Detection and Bounding Boxes
es
In earlier sections (e.g., Section 8.1‚ÄìSection 8.4), we introduced various models for image classification. In image classification tasks, we assume that there is only one major object in the image and we only focus on how to recognize its category. However, there are often multiple objects in the image of interest. We not only want to know their categories, but also their specific positions in the image. In computer vision, we refer to such tasks as object detection (or object recognition). Object detection has been widely applied in many fields. For example, self-driving needs to plantravelingroutesbydetectingthepositionsofvehicles, pedestrians, roads, andobstacles in the captured video images. Besides, robots may use this technique to detect and localize objects of interest throughout its navigation of an environment. Moreover, security systems may need to detect abnormal objects, such as intruders or bombs. In the next few sections, we will introduce several deep learning methods for object detec- tion. We will begin with an introduction to positions (or locations) of objects. Object Detection and Bounding Boxes
607

%matplotlib inline import torch from d2l import torch as d2l
We will load the sample image to be used in this section. We can see that there is a dog on the left side of the image and a cat on the right. They are the two major objects in this image. d2l.set_figsize() img = d2l.plt.imread('../img/catdog.jpg') d2l.plt.imshow(img);

100
200
300
400
500
0
200
14.3.1 Bounding Boxes
In object detection, we usually use a bounding box to describe the spatial location of an object. The bounding box is rectangular, which is determined by the ùë• and ùë¶ coordinates of the upper-left corner of the rectangle and the such coordinates of the lower-right corner. Another commonly used bounding box representation is the ‚Äûùë•, ùë¶‚Äù-axis coordinates of the bounding box center, and the width and height of the box. Herewedefinefunctionstoconvertbetweenthesetworepresentations: box_corner_to_center converts from the two-corner representation to the center-width-height presentation, and box_center_to_cornerviceversa. Theinputargumentboxesshouldbeatwo-dimensional tensor of shape (ùëõ, 4), where ùëõ is the number of bounding boxes. #@save def box_corner_to_center(boxes): """Convert from (upper-left, lower-right) to (center, width, height).""" x1, y1, x2, y2 = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3] cx = (x1 + x2) / 2 cy = (y1 + y2) / 2 w = x2 - x1 h = y2 - y1 boxes = torch.stack((cx, cy, w, h), axis=-1) return boxes #@save def box_center_to_corner(boxes):
400
600
(continues on next page)
Computer Vision
608

"""Convert from (center, width, height) to (upper-left, lower-right).""" cx, cy, w, h = boxes[:, 0], boxes[:, 1], boxes[:, 2], boxes[:, 3] x1 = cx - 0.5 * w y1 = cy - 0.5 * h x2 = cx + 0.5 * w y2 = cy + 0.5 * h boxes = torch.stack((x1, y1, x2, y2), axis=-1) return boxes
We will define the bounding boxes of the dog and the cat in the image based on the co- ordinate information. The origin of the coordinates in the image is the upper-left corner of the image, and to the right and down are the positive directions of the ùë• and ùë¶ axes, respectively. # Here `bbox` is the abbreviation for bounding box dog_bbox, cat_bbox = [60.0, 45.0, 378.0, 516.0], [400.0, 112.0, 655.0, 493.0]
We can verify the correctness of the two bounding box conversion functions by converting twice. boxes = torch.tensor((dog_bbox, cat_bbox)) box_center_to_corner(box_corner_to_center(boxes)) == boxes
tensor([[True, True, True, True], [True, True, True, True]])
Let‚Äôs draw the bounding boxes in the image to check if they are accurate. Before drawing, we will define a helper function bbox_to_rect. It represents the bounding box in the bounding box format of the matplotlib package. #@save def bbox_to_rect(bbox, color): """Convert bounding box to matplotlib format.""" # Convert the bounding box (upper-left x, upper-left y, lower-right x, # lower-right y) format to the matplotlib format: ((upper-left x, # upper-left y), width, height) return d2l.plt.Rectangle( xy=(bbox[0], bbox[1]), width=bbox[2]-bbox[0], height=bbox[3]-bbox[1], fill=False, edgecolor=color, linewidth=2)
After adding the bounding boxes on the image, we can see that the main outline of the two objects are basically inside the two boxes. fig = d2l.plt.imshow(img)
fig.axes.add_patch(bbox_to_rect(dog_bbox, 'blue'))
fig.axes.add_patch(bbox_to_rect(cat_bbox, 'red'));
(continued from previous page)
Anchor Boxes
609


14.3.2 Summary
e Object detection not only recognizes all the objects of interest in the image, but also their
positions. The position is generally represented by a rectangular bounding box. e We can convert between two commonly used bounding box representations. 14.3.3 Exercises
1. Find another image and try to label a bounding box that contains the object. Compare labeling bounding boxes and categories: which usually takes longer? 2. Whyistheinnermostdimensionoftheinputargumentboxesof box_corner_to_center and box_center_to_corner always 4?bubu214 
Discussions214. 14.4 Anchor Boxes

Object detection algorithms usually sample a large number of regions in the input image, determine whether these regions contain objects of interest, and adjust the boundaries of the regions so as to predict the ground-truth bounding boxes of the objects more accurately. Different models may adopt different region sampling schemes. Here we introduce one of such methods: it generates multiple bounding boxes with varying scales and aspect ratios centered on each pixel. These bounding boxes are called anchor boxes. We will design an object detection model based on anchor boxes in Section 14.7. First, let‚Äôs modify the printing accuracy just for more concise outputs. %matplotlib inline import torch from d2l import torch as d2l
torch.set_printoptions(2) # Simplify printing accuracy
Computer Vision
610

14.4.1 Generating Multiple Anchor Boxes
Suppose that the input image has a height of ‚Ñé and width of ùë§. We generate anchor boxes
Suppose that the input image has a height of h and width of w. We generate anchor boxes with different shapes centered on each pixel of the image. Let the scale be s ‚Ç¨ (0, 1] and the aspect ratio (ratio of width to height) is r > 0. Then the width and height of the anchor box are ws-yr and hs/+r, respectively. Note that when the center position is given, an anchor box with known width and height is determined. Togeneratemultipleanchorboxeswithdifferentshapes, let‚Äôssetaseriesofscales ùë†1, . . ., ùë†ùëõ and a series of aspect ratios ùëü1, . . .,ùëüùëö. When using all the combinations of these scales and aspect ratios with each pixel as the center, the input image will have a total of ùë§‚Ñéùëõùëö anchor boxes. Although these anchor boxes may cover all the ground-truth bounding boxes, the computational complexity is easily too high. In practice, we can only consider those combinations containing ùë†1 or ùëü1:
‚Äûùë†1,ùëü1‚Äù, ‚Äûùë†1,ùëü2‚Äù, .bubu. ., ‚Äûùë†1,ùëüùëö‚Äù, ‚Äûùë†2,ùëü1‚Äù, ‚Äûùë†3,ùëü1‚Äù, . .bubu., ‚Äûùë†ùëõ,ùëü1‚Äù. (14.4.1)
That is to say, the number of anchor boxes centered on the same pixel is n+ m ‚Äî 1. For the
That is to say, the number of anchor boxes centered on the same pixel is n+ m ‚Äî 1. For the entire input image, we will generate a total of wh(n + m ‚Äî 1) anchor boxes. The above method of generating anchor boxes is implemented in the following multi- box_prior function. We specify the input image, a list of scales, and a list of aspect ratios, then this function will return all the anchor boxes. #@save
def multibox_prior(data, sizes, ratios): """Generate anchor boxes with different shapes centered on each pixel.""" in_height, in_width = data.shape[-2:] device, num_sizes, num_ratios = data.device, len(sizes), len(ratios) boxes_per_pixel = (num_sizes + num_ratios - 1) size_tensor = torch.tensor(sizes, device=device) ratio_tensor = torch.tensor(ratios, device=device) # Offsets are required to move the anchor to the center of a pixel. Since # a pixel has height=1 and width=1, we choose to offset our centers by 0.5 offset_h, offset_w = 0.5, 0.5 steps_h = 1.0 / in_height # Scaled steps in y axis steps_w = 1.0 / in_width # Scaled steps in x axis # Generate all center points for the anchor boxes center_h = (torch.arange(in_height, device=device) + offset_h) * steps_h center_w = (torch.arange(in_width, device=device) + offset_w) * steps_w shift_y, shift_x = torch.meshgrid(center_h, center_w, indexing='ij') shift_y, shift_x = shift_y.reshape(-1), shift_x.reshape(-1) # Generate `boxes_per_pixel` number of heights and widths that are later # used to create anchor box corner coordinates (xmin, xmax, ymin, ymax) w = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]), sizes[0] * torch.sqrt(ratio_tensor[1:])))\ * in_height / in_width # Handle rectangular inputs h = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]), sizes[0] / torch.sqrt(ratio_tensor[1:]))) # Divide by 2 to get half height and half width
anchor_manipulations = torch.stack((-w, -h, w, h)).T.repeat(
(continues on next page)
Anchor Boxes
611

# Each center point will have `boxes_per_pixel` number of anchor boxes, so # generate a grid of all anchor box centers with `boxes_per_pixel` repeats out_grid = torch.stack([shift_x, shift_y, shift_x, shift_y], dim=1).repeat_interleave(boxes_per_pixel, dim=0) output = out_grid + anchor_manipulations return output.unsqueeze(0)
We can see that the shape of the returned anchor box variable Y is (batch size, number of anchor boxes, 4). img = d2l.plt.imread('../img/catdog.jpg') h, w = img.shape[:2] print(h, w) X = torch.rand(size=(1, 3, h, w)) # Construct input data Y = multibox_prior(X, sizes=[0.75, 0.5, 0.25], ratios=[1, 2, 0.5]) Y.shape
561 728
torch.Size([1, 2042040, 4])
After changing the shape of the anchor box variable Y to (image height, image width, num- ber of anchor boxes centered on the same pixel, 4), we can obtain all the anchor boxes centered on a specified pixel position. In the following, we access the first anchor box cen- tered on (250, 250). It has four elements: the ‚Äûùë•, ùë¶‚Äù-axis coordinates at the upper-left corner and the ‚Äûùë•, ùë¶‚Äù-axis coordinates at the lower-right corner of the anchor box. The coordinate values of both axes are divided by the width and height of the image, respectively. boxes = Y.reshape(h, w, 5, 4) boxes[250, 250, 0, :]
tensor([0.06, 0.07, 0.63, 0.82])
In order to show all the anchor boxes centered on one pixel in the image, we define the following show_bboxes function to draw multiple bounding boxes on the image. #@save def show_bboxes(axes, bboxes, labels=None, colors=None): """Show bounding boxes.""" def make_list(obj, default_values=None): if obj is None: obj = default_values
(continued from previous page)
in_height * in_width, 1) / 2
(continues on next page)
Computer Vision
612

elif not isinstance(obj, (list, tuple)): obj = [obj] return obj labels = make_list(labels) colors = make_list(colors, ['b', 'g', 'r', 'm', 'c']) for i, bbox in enumerate(bboxes): color = colors[i % len(colors)] rect = d2l.bbox_to_rect(bbox.detach().numpy(), color) axes.add_patch(rect) if labels and len(labels) > i: text_color = 'k' if color == 'w' else 'w' axes.text(rect.xy[0], rect.xy[1], labels[i], va='center', ha='center', fontsize=9, color=text_color, bbox=dict(facecolor=color, lw=0))
As we just saw, the coordinate values of the ùë• and ùë¶ axes in the variable boxes have been
divided by the width and height of the image, respectively. When drawing anchor boxes, we need to restore their original coordinate values; thus, we define variable bbox_scale below. Now, we can draw all the anchor boxes centered on (250, 250) in the image. As you can see, the blue anchor box with a scale of 0.75 and an aspect ratio of 1 well surrounds the dog in the image. d2l.set_figsize() bbox_scale = torch.tensor((w, h, w, h)) fig = d2l.plt.imshow(img) show_bboxes(fig.axes, boxes[250, 250, :, :] * bbox_scale, ['s=0.75, r=1', 's=0.5, r=1', 's=0.25, r=1', 's=0.75, r=2', 's=0.75, r=0.5'])

14.4.2 Intersection over Union (IoU)
We just mentioned that an anchor box ‚Äúwell‚Äù surrounds the dog in the image. If the ground- truth bounding box of the object is known, how can ‚Äúwell‚Äù here be quantified? Intuitively, we can measure the similarity between the anchor box and the ground-truth bounding box. We know that the Jaccard index can measure the similarity between two sets. Given sets A and B, their Jaccard index is the size of their intersection divided by the size of their
(continued from previous page)
Anchor Boxes
613

union:
ùêΩ‚ÄûA, B‚Äù = jA [ Bj . (14.4.2)
In fact, we can consider the pixel area of any bounding box as a set of pixels. In this way, we can measure the similarity of the two bounding boxes by the Jaccard index of their pixel sets. For two bounding boxes, we usually refer their Jaccard index as intersection over union (IoU), which is the ratio of their intersection area to their union area, as shown in Fig. 14.4.1. The range of an IoU is between 0 and 1: 0 means that two bounding boxes do not overlap at all, while 1 indicates that the two bounding boxes are equal. loU = ‚Äî‚Äî‚Äî_
tFig. 14.4.1
IoU is the ratio of the intersection area to the union area of two bounding boxes. For the remainder of this section, we will use IoU to measure the similarity between anchor boxes and ground-truth bounding boxes, and between different anchor boxes. Given two lists of anchor or bounding boxes, the following box_iou computes their pairwise IoU across these two lists. #@save def box_iou(boxes1, boxes2): """Compute pairwise IoU across two lists of anchor or bounding boxes.""" box_area = lambda boxes: ((boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])) # Shape of `boxes1`, `boxes2`, `areas1`, `areas2`: (no. of boxes1, 4), # (no.bubuof boxes2, 4), (no. of boxes1,), (no. of boxes2,) areas1 = box_area(boxes1) areas2 = box_area(boxes2) # Shape of `inter_upperlefts`, `inter_lowerrights`, `inters`: (no. of # boxes1, no. of boxes2, 2) inter_upperlefts = torch.max(boxes1[:, None, :2], boxes2[:, :2]) inter_lowerrights = torch.min(boxes1[:, None, 2:], boxes2[:, 2:]) inters = (inter_lowerrights - inter_upperlefts).clamp(min=0) # Shape of `inter_areas` and `union_areas`: (no. of boxes1, no. of boxes2) inter_areas = inters[:, :, 0] * inters[:, :, 1] union_areas = areas1[:, None] + areas2 - inter_areas return inter_areas / union_areas
14.4.3 Labeling Anchor Boxes in Training Data
In a training dataset, we consider each anchor box as a training example. In order to train an object detection model, we need class and offset labels for each anchor box, where the former is the class of the object relevant to the anchor box and the latter is the offset of the ground-truth bounding box relative to the anchor box. During the prediction, for each im- age we generate multiple anchor boxes, predict classes and offsets for all the anchor boxes,
jA \ Bj
Computer Vision
614

adjust their positions according to the predicted offsets to obtain the predicted bounding boxes, and finally only output those predicted bounding boxes that satisfy certain crite- ria. As we know, an object detection training set comes with labels for locations of ground-truth bounding boxes and classes of their surrounded objects. To label any generated anchor box, we refer to the labeled location and class of its assigned ground-truth bounding box that is closest to the anchor box. In the following, we describe an algorithm for assigning closest ground-truth bounding boxes to anchor boxes. Assigning Ground-Truth Bounding Boxes to Anchor Boxes
Given an image, suppose that the anchor boxes are ùê¥1, ùê¥2, . . ., ùê¥ùëõùëé and the ground-truth
Given an image, suppose that the anchor boxes are Aj, A2,...,An, and the ground-truth bounding boxes are B), B2,...,Bn,, where ng > np. Let‚Äôs define a matrix X ‚Ç¨ R"*", whose element x;; in the i‚Äù row and je column is the IoU of the anchor box A; and the ground-truth bounding box B;. The algorithm consists of the following steps:
1. Find the largest element in matrix X and denote its row and column indices as ùëñ1 and
ùëó1, respectively. Then the ground-truth bounding box ùêµùëó1 is assigned to the anchor box ùê¥ùëñ1. This is quite intuitive because ùê¥ùëñ1 and ùêµùëó1 are the closest among all the pairs of anchor boxes and ground-truth bounding boxes. After the first assignment, discard all the elements in the ùëñ1 th row and the ùëó1 th column in matrix X. 2. Find the largest of the remaining elements in matrix X and denote its row and column indices as ùëñ2 and ùëó2, respectively. We assign ground-truth bounding box ùêµùëó2 to anchor box ùê¥ùëñ2 and discard all the elements in the ùëñ2 th row and the ùëó2 th column in matrix X. 3. At this point, elements in two rows and two columns in matrix X have been discarded. We proceed until all elements in ùëõùëè columns in matrix X are discarded. At this time, we have assigned a ground-truth bounding box to each of ùëõùëè anchor boxes. 4. Only traverse through the remaining ng ‚Äî np anchor boxes. For example, given any
anchor box ùê¥ùëñ, find the ground-truth bounding box ùêµùëó with the largest IoU with ùê¥ùëñ throughout the ùëñth row of matrix X, and assign ùêµùëó to ùê¥ùëñ only if this IoU is greater than a predefined threshold. Let‚Äôsillustratetheabovealgorithmusingaconcreteexample. AsshowninFig.14.4.2(left), assuming that the maximum value in matrix X is ùë•23, we assign the ground-truth bounding box ùêµ3 to the anchor box ùê¥2. Then, we discard all the elements in row 2 and column 3 of the matrix, find the largest ùë•71 in the remaining elements (shaded area), and assign the ground- truth bounding box ùêµ1 to the anchor box ùê¥7. Next, as shown in Fig. 14.4.2 (middle), discard all the elements in row 7 and column 1 of the matrix, find the largest ùë•54 in the remaining elements (shaded area), and assign the ground-truth bounding box ùêµ4 to the anchor box ùê¥5. Finally, as shown in Fig. 14.4.2 (right), discard all the elements in row 5 and column 4 of the matrix, find the largest ùë•92 in the remaining elements (shaded area), and assign the ground-truth bounding box ùêµ2 to the anchor box ùê¥9. After that, we only need to traverse through the remaining anchor boxes ùê¥1, ùê¥3, ùê¥4, ùê¥6, ùê¥8 and determine whether to assign them ground-truth bounding boxes according to the threshold. 615

1 2 3 4 1 2 3 4 1 2 3 4 1 2 %, yy Xy 3 Anchor 4 box indices 5 ey oy 6 7 [on a a 8 9 Xp
tFig. 14.4.2 Assigning ground-truth bounding boxes to anchor boxes. Thisalgorithmisimplementedinthefollowingassign_anchor_to_bboxfunction. #@save
def assign_anchor_to_bbox(ground_truth, anchors, device, iou_threshold=0.5): """Assign closest ground-truth bounding boxes to anchor boxes.""" num_anchors, num_gt_boxes = anchors.shape[0], ground_truth.shape[0] # Element x_ij in the i-th row and j-th column is the IoU of the anchor # box i and the ground-truth bounding box j jaccard = box_iou(anchors, ground_truth) # Initialize the tensor to hold the assigned ground-truth bounding box for # each anchor anchors_bbox_map = torch.full((num_anchors,), -1, dtype=torch.long, device=device) # Assign ground-truth bounding boxes according to the threshold max_ious, indices = torch.max(jaccard, dim=1) anc_i = torch.nonzero(max_ious >= iou_threshold).reshape(-1) box_j = indices[max_ious >= iou_threshold] anchors_bbox_map[anc_i] = box_j col_discard = torch.full((num_anchors,), -1) row_discard = torch.full((num_gt_boxes,), -1) for _ in range(num_gt_boxes): max_idx = torch.argmax(jaccard) # Find the largest IoU box_idx = (max_idx % num_gt_boxes).long() anc_idx = (max_idx / num_gt_boxes).long() anchors_bbox_map[anc_idx] = box_idx jaccard[:, box_idx] = col_discard jaccard[anc_idx, :] = row_discard return anchors_bbox_map
Labeling Classes and Offsets
Now we can label the class and offset for each anchor box. Suppose that an anchor box ùê¥ is assigned a ground-truth bounding box ùêµ. On the one hand, the class of the anchor box ùê¥ will be labeled as that of ùêµ. On the other hand, the offset of the anchor box ùê¥ will be labeled according to the relative position between the central coordinates of ùêµ and ùê¥ together with the relative size between these two boxes. Given varying positions and sizes
Anchor Boxes
Ground-truth bounding box indices
Computer Vision
616

of different boxes in the dataset, we can apply transformations to those relative positions and sizes that may lead to more uniformly distributed offsets that are easier to fit. Here we describe a common transformation. Given the central coordinates of ùê¥ and ùêµ as ‚Äûùë•ùëé, ùë¶ùëé‚Äù and ‚Äûùë•ùëè, ùë¶ùëè‚Äù, their widths as ùë§ùëé and ùë§ùëè, and their heights as ‚Ñéùëé and ‚Ñéùëè, respectively. We may label the offset of ùê¥ as
Xb-Xa
Yb-Ya
Xb-Xa Yb-Ya Wp hp ‚Äî Mx ‚Äî Hy log 2 - Mw log 72 - un Wa , fa ; Wa , fa , (14.4.3) Ox Cy Ow Ch
where default values of the constants are ùúáùë• = ùúáùë¶ = ùúáùë§ = ùúá‚Ñé = 0, ùúéùë• = ùúéùë¶ = 0.1,
and ùúéùë§ = ùúé‚Ñé = 0.2. This transformation is implemented below in the offset_boxes function. #@save def offset_boxes(anchors, assigned_bb, eps=1e-6): """Transform for anchor box offsets.""" c_anc = d2l.box_corner_to_center(anchors) c_assigned_bb = d2l.box_corner_to_center(assigned_bb) offset_xy = 10 * (c_assigned_bb[:, :2] - c_anc[:, :2]) / c_anc[:, 2:] offset_wh = 5 * torch.log(eps + c_assigned_bb[:, 2:] / c_anc[:, 2:]) offset = torch.cat([offset_xy, offset_wh], axis=1) return offset
If an anchor box is not assigned a ground-truth bounding box, we just label the class of the anchor box as ‚Äúbackground‚Äù. Anchor boxes whose classes are background are often referred to as negative anchor boxes, and the rest are called positive anchor boxes. We implement the following multibox_target function to label classes and offsets for anchor boxes (the anchors argument) using ground-truth bounding boxes (the labels argument). This function sets the background class to zero and increments the integer index of a new class by one. #@save
def multibox_target(anchors, labels): """Label anchor boxes using ground-truth bounding boxes.""" batch_size, anchors = labels.shape[0], anchors.squeeze(0) batch_offset, batch_mask, batch_class_labels = [], [], [] device, num_anchors = anchors.device, anchors.shape[0] for i in range(batch_size): label = labels[i, :, :] anchors_bbox_map = assign_anchor_to_bbox( label[:, 1:], anchors, device) bbox_mask = ((anchors_bbox_map >= 0).float().unsqueeze(-1)).repeat( 1, 4) # Initialize class labels and assigned bounding box coordinates with # zeros class_labels = torch.zeros(num_anchors, dtype=torch.long, device=device) assigned_bb = torch.zeros((num_anchors, 4), dtype=torch.float32, device=device) # Label classes of anchor boxes using their assigned ground-truth # bounding boxes. If an anchor box is not assigned any, we label its
! ùë§ùëè
‚Ñéùëè
(continues on next page)
Anchor Boxes
617

# class as background (the value remains zero) indices_true = torch.nonzero(anchors_bbox_map >= 0) bb_idx = anchors_bbox_map[indices_true] class_labels[indices_true] = label[bb_idx, 0].long() + 1 assigned_bb[indices_true] = label[bb_idx, 1:] # Offset transformation offset = offset_boxes(anchors, assigned_bb) * bbox_mask batch_offset.append(offset.reshape(-1)) batch_mask.append(bbox_mask.reshape(-1)) batch_class_labels.append(class_labels) bbox_offset = torch.stack(batch_offset) bbox_mask = torch.stack(batch_mask) class_labels = torch.stack(batch_class_labels) return (bbox_offset, bbox_mask, class_labels)
An Example
Let‚Äôs illustrate anchor box labeling via a concrete example. We define ground-truth bound- ing boxes for the dog and cat in the loaded image, where the first element is the class (0 for dog and 1 for cat) and the remaining four elements are the ‚Äûùë•, ùë¶‚Äù-axis coordinates at the upper-left corner and the lower-right corner (range is between 0 and 1). We also con- struct five anchor boxes to be labeled using the coordinates of the upper-left corner and the lower-right corner: ùê¥0, . . ., ùê¥4 (the index starts from 0). Then we plot these ground-truth bounding boxes and anchor boxes in the image. ground_truth = torch.tensor([[0, 0.1, 0.08, 0.52, 0.92], [1, 0.55, 0.2, 0.9, 0.88]]) anchors = torch.tensor([[0, 0.1, 0.2, 0.3], [0.15, 0.2, 0.4, 0.4], [0.63, 0.05, 0.88, 0.98], [0.66, 0.45, 0.8, 0.8], [0.57, 0.3, 0.92, 0.9]])
fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, ground_truth[:, 1:] * bbox_scale, ['dog', 'cat'], 'k') show_bboxes(fig.axes, anchors * bbox_scale, ['0', '1', '2', '3', '4']);

Using the multibox_target function defined above, we can label classes and offsets of these anchor boxes based on the ground-truth bounding boxes for the dog and cat. In this example, indices of the background, dog, and cat classes are 0, 1, and 2, respectively. (continued from previous page)
Computer Vision
618

Below we add an dimension for examples of anchor boxes and ground-truth bounding boxes. labels = multibox_target(anchors.unsqueeze(dim=0), ground_truth.unsqueeze(dim=0))
There are three items in the returned result, all of which are in the tensor format. The third item contains the labeled classes of the input anchor boxes. Let‚Äôs analyze the returned class labels below based on anchor box and ground-truth bound- ing box positions in the image. First, among all the pairs of anchor boxes and ground-truth bounding boxes, the IoU of the anchor box ùê¥4 and the ground-truth bounding box of the cat is the largest. Thus, the class of ùê¥4 is labeled as the cat. Taking out pairs containing ùê¥4 or the ground-truth bounding box of the cat, among the rest the pair of the anchor box ùê¥1 and the ground-truth bounding box of the dog has the largest IoU. So the class of ùê¥1 is labeled as the dog. Next, we need to traverse through the remaining three unlabeled anchor boxes: ùê¥0, ùê¥2, and ùê¥3. For ùê¥0, the class of the ground-truth bounding box with the largest IoU is the dog, but the IoU is below the predefined threshold (0.5), so the class is labeled as background; for ùê¥2, the class of the ground-truth bounding box with the largest IoU is the cat and the IoU exceeds the threshold, so the class is labeled as the cat; for ùê¥3, the class of the ground-truth bounding box with the largest IoU is the cat, but the value is below the threshold, so the class is labeled as background. labels[2]
tensor([[0, 1, 2, 0, 2]])
The second returned item is a mask variable of the shape (batch size, four times the number of anchor boxes). Every four elements in the mask variable correspond to the four offset values of each anchor box. Since we do not care about background detection, offsets of this negative class should not affect the objective function. Through elementwise multiplica- tions, zeros in the mask variable will filter out negative class offsets before calculating the objective function. labels[1]
tensor([[0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 0., 0., 0., 0., 1., 1. ‚Ü©!, 1., 1.]])
The first returned item contains the four offset values labeled for each anchor box. Note that the offsets of negative-class anchor boxes are labeled as zeros. labels[0]
Anchor Boxes
619

tensor([[-0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, 1.40e+00, 1.00e+01, 2.59e+00, 7.18e+00, -1.20e+00, 2.69e-01, 1.68e+00, -1.57e+00, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -5.71e-01, -1.00e+00, 4.17e-06, 6.26e-01]])
14.4.4 Predicting Bounding Boxes with Non-Maximum Suppression
During prediction, we generate multiple anchor boxes for the image and predict classes and offsets for each of them. A predicted bounding box is thus obtained according to an anchor box with its predicted offset. Below we implement the offset_inverse function that takes in anchors and offset predictions as inputs and applies inverse offset transformations to return the predicted bounding box coordinates. #@save
def offset_inverse(anchors, offset_preds): """Predict bounding boxes based on anchor boxes with predicted offsets.""" anc = d2l.box_corner_to_center(anchors) pred_bbox_xy = (offset_preds[:, :2] * anc[:, 2:] / 10) + anc[:, :2] pred_bbox_wh = torch.exp(offset_preds[:, 2:] / 5) * anc[:, 2:] pred_bbox = torch.cat((pred_bbox_xy, pred_bbox_wh), axis=1) predicted_bbox = d2l.box_center_to_corner(pred_bbox) return predicted_bbox
def offset_inverse(anchors, offset_preds):
Whentherearemanyanchorboxes,manysimilar(withsignificantoverlap)predictedbound- ing boxes can be potentially output for surrounding the same object. To simplify the output, we can merge similar predicted bounding boxes that belong to the same object by using non-maximum suppression (NMS). Here is how non-maximum suppression works. For a predicted bounding box ùêµ, the object
detectionmodel calculates the predicted likelihood foreachclass. Denoting by ùëù thelargest predicted likelihood, the class corresponding to this probability is the predicted class for ùêµ. Specifically, we refer to ùëù as the confidence (score) of the predicted bounding box ùêµ. On the same image, all the predicted non-background bounding boxes are sorted by confidence in descending order to generate a list ùêø. Then we manipulate the sorted list ùêø in the following steps:
1. Select the predicted bounding box ùêµ1 with the highest confidence from ùêø as a basis and
remove all non-basis predicted bounding boxes whose IoU with ùêµ1 exceeds a predefined threshold ùúñ from ùêø. At this point, ùêø keeps the predicted bounding box with the highest confidence but drops others that are too similar to it. In a nutshell, those with non- maximum confidence scores are suppressed. 2. Select the predicted bounding box ùêµ2 with the second highest confidence from ùêø as
another basis and remove all non-basis predicted bounding boxes whose IoU with ùêµ2 exceeds ùúñ from ùêø. 3. Repeat the above process until all the predicted bounding boxes in ùêø have been used as
Computer Vision
620

a basis. At this time, the IoU of any pair of predicted bounding boxes in ùêø is below the
threshold ùúñ; thus, no pair is too similar with each other. 4.bubuOutput all the predicted bounding boxes in the list ùêø. The following nms function sorts confidence scores in descending order and returns their indices. #@save def nms(boxes, scores, iou_threshold): """Sort confidence scores of predicted bounding boxes.""" B = torch.argsort(scores, dim=-1, descending=True) keep = [] # Indices of predicted bounding boxes that will be kept while B.numel() > 0: i = B[0] keep.append(i) if B.numel() == 1: break iou = box_iou(boxes[i, :].reshape(-1, 4), boxes[B[1:], :].reshape(-1, 4)).reshape(-1) inds = torch.nonzero(iou <= iou_threshold).reshape(-1) B = B[inds + 1] return torch.tensor(keep, device=boxes.device)
We define the following multibox_detection to apply non-maximum suppression to pre- dicting bounding boxes. Do not worry if you find the implementation a bit complicated: we will show how it works with a concrete example right after the implementation. #@save
def multibox_detection(cls_probs, offset_preds, anchors, nms_threshold=0.5, pos_threshold=0.009999999): """Predict bounding boxes using non-maximum suppression.""" device, batch_size = cls_probs.device, cls_probs.shape[0] anchors = anchors.squeeze(0) num_classes, num_anchors = cls_probs.shape[1], cls_probs.shape[2] out = [] for i in range(batch_size): cls_prob, offset_pred = cls_probs[i], offset_preds[i].reshape(-1, 4) conf, class_id = torch.max(cls_prob[1:], 0) predicted_bb = offset_inverse(anchors, offset_pred) keep = nms(predicted_bb, conf, nms_threshold) # Find all non-`keep` indices and set the class to background all_idx = torch.arange(num_anchors, dtype=torch.long, device=device) combined = torch.cat((keep, all_idx)) uniques, counts = combined.unique(return_counts=True) non_keep = uniques[counts == 1] all_id_sorted = torch.cat((keep, non_keep)) class_id[non_keep] = -1 class_id = class_id[all_id_sorted] conf, predicted_bb = conf[all_id_sorted], predicted_bb[all_id_sorted] # Here `pos_threshold` is a threshold for positive (non-background) # predictions below_min_idx = (conf < pos_threshold) class_id[below_min_idx] = -1 conf[below_min_idx] = 1 - conf[below_min_idx]
(continues on next page)
621

pred_info = torch.cat((class_id.unsqueeze(1), conf.unsqueeze(1), predicted_bb), dim=1) out.append(pred_info) return torch.stack(out)
Now let‚Äôs apply the above implementations to a concrete example with four anchor boxes. For simplicity, we assume that the predicted offsets are all zeros. This means that the predicted bounding boxes are anchor boxes. For each class among the background, dog, and cat, we also define its predicted likelihood. anchors = torch.tensor([[0.1, 0.08, 0.52, 0.92], [0.08, 0.2, 0.56, 0.95], [0.15, 0.3, 0.62, 0.91], [0.55, 0.2, 0.9, 0.88]]) offset_preds = torch.tensor([0] * anchors.numel()) cls_probs = torch.tensor([[0] * 4, # Predicted background likelihood [0.9, 0.8, 0.7, 0.1], # Predicted dog likelihood [0.1, 0.2, 0.3, 0.9]]) # Predicted cat likelihood
We can plot these predicted bounding boxes with their confidence on the image. fig = d2l.plt.imshow(img) show_bboxes(fig.axes, anchors * bbox_scale, ['dog=0.9', 'dog=0.8', 'dog=0.7', 'cat=0.9'])

Now we can invoke the multibox_detection function to perform non-maximum suppres- sion, where the threshold is set to 0.5. Note that we add a dimension for examples in the tensor input. We can see that the shape of the returned result is (batch size, number of anchor boxes, 6). The six elements in the innermost dimension gives the output information for the same predicted bounding box. The first element is the predicted class index, which starts from 0 (0 is dog and 1 is cat). The value -1 indicates background or removal in non-maximum suppression. The second element is the confidence of the predicted bounding box. The remaining four elements are the ‚Äûùë•, ùë¶‚Äù-axis coordinates of the upper-left corner and the lower-right corner of the predicted bounding box, respectively (range is between 0 and 1). Anchor Boxes
(continued from previous page)
Computer Vision
622

output = multibox_detection(cls_probs.unsqueeze(dim=0), offset_preds.unsqueeze(dim=0), anchors.unsqueeze(dim=0), nms_threshold=0.5) output tensor([[[ 0.00, 0.90, 0.10, 0.08, 0.52, 0.92], [ 1.00, 0.90, 0.55, 0.20, 0.90, 0.88], [-1.00, 0.80, 0.08, 0.20, 0.56, 0.95], [-1.00, 0.70, 0.15, 0.30, 0.62, 0.91]]])
Afterremovingthosepredictedboundingboxesofclass-1, wecanoutputthefinalpredicted bounding box kept by non-maximum suppression. fig = d2l.plt.imshow(img) for i in output[0].detach().numpy(): if i[0] == -1: continue label = ('dog=', 'cat=')[int(i[0])] + str(i[1]) show_bboxes(fig.axes, [torch.tensor(i[2:]) * bbox_scale], label)

In practice, we can remove predicted bounding boxes with lower confidence even before performing non-maximum suppression, thereby reducing computation in this algorithm. We may also post-process the output of non-maximum suppression, for example, by only keeping results with higher confidence in the final output. 14.4.5 Summary
e We generate anchor boxes with different shapes centered on each pixel of the image. Intersection over union (IoU), also known as Jaccard index, measures the similarity of
two bounding boxes. It is the ratio of their intersection area to their union area.bubuIn a training set, we need two types of labels for each anchor box. One is the class of
the object relevant to the anchor box and the other is the offset of the ground-truth bounding box relative to the anchor box. During prediction, we can use non-maximum suppression (NMS) to remove similar pre-
dicted bounding boxes, thereby simplifying the output. 200
400
600
Multiscale Object Detection
623

14.4.6 Exercises
1. Change values of sizes and ratios in the multibox_prior function. What are the changes to the generated anchor boxes?bubu2. Construct and visualize two bounding boxes with an IoU of 0.5. How do they overlap with each other?bubu3. Modify the variable anchors in Section 14.4.3 and Section 14.4.4. How do the results change?bubu4. Non-maximum suppression is a greedy algorithm that suppresses predicted bounding boxes by removing them. Is it possible that some of these removed ones are actually useful? How can this algorithm be modified to suppress softly? You may refer to Soft- NMS (Bodla et al., 2017). 5. Rather than being hand-crafted, can non-maximum suppression be learned? Discussions215. 215 
14.5 Multiscale Object Detection
es
In Section 14.4, we generated multiple anchor boxes centered on each pixel of an input image. Essentially these anchor boxes represent samples of different regions of the image. However, we may end up with too many anchor boxes to compute if they are generated for every pixel. Think of a 561 x 728 input image. If five anchor boxes with varying shapes are generated for each pixel as their center, over two million anchor boxes (561 x 728 x 5) need to be labeled and predicted on the image. 14.5.1 Multiscale Anchor Boxes
You may realize that it is not difficult to reduce anchor boxes on an image. For instance, we can just uniformly sample a small portion of pixels from the input image to generate anchor boxes centered on them. In addition, at different scales we can generate different numbers of anchor boxes of different sizes. Intuitively, smaller objects are more likely to appear on an image than larger ones. As an example, 1 x 1, 1 x 2, and 2 x 2 objects can appear on a 2x2 image in 4, 2, and 1 possible ways, respectively. Therefore, when using smaller anchor boxes to detect smaller objects, we can sample more regions, while for larger objects we can sample fewer regions. To demonstrate how to generate anchor boxes at multiple scales, let‚Äôs read an image. Its height and width are 561 and 728 pixels, respectively. %matplotlib inline import torch
(continues on next page)
Computer Vision
624

from d2l import torch as d2l img = d2l.plt.imread('../img/catdog.jpg') h, w = img.shape[:2] h, w
(561, 728)
Recall that in Section 7.2 we call a two-dimensional array output of a convolutional layer a feature map. By defining the feature map shape, we can determine centers of uniformly sampled anchor boxes on any image. The display_anchors function is defined below. We generate anchor boxes (anchors) on the feature map (fmap) with each unit (pixel) as the anchor box center. Since the ‚Äûùë•, ùë¶‚Äù- axis coordinate values in the anchor boxes (anchors) have been divided by the width and height of the feature map (fmap), these values are between 0 and 1, which indicate the relative positions of anchor boxes in the feature map. Since centers of the anchor boxes (anchors) are spread over all units on the feature map (fmap), these centers must be uniformly distributed on any input image in terms of their relative spatial positions. More concretely, given the width and height of the feature map fmap_w and fmap_h, respectively, the following function will uniformly sample pixels in fmap_h rows and fmap_w columns on any input image. Centered on these uniformly sam- pled pixels, anchor boxes of scale s (assuming the length of the list s is 1) and different aspect ratios (ratios) will be generated. def display_anchors(fmap_w, fmap_h, s): d2l.set_figsize() # Values on the first two dimensions do not affect the output fmap = torch.zeros((1, 10, fmap_h, fmap_w)) anchors = d2l.multibox_prior(fmap, sizes=s, ratios=[1, 2, 0.5]) bbox_scale = torch.tensor((w, h, w, h)) d2l.show_bboxes(d2l.plt.imshow(img).axes, anchors[0] * bbox_scale)
First, let‚Äôs consider detection of small objects. In order to make it easier to distinguish when displayed, the anchor boxes with different centers here do not overlap: the anchor box scale is set to 0.15 and the height and width of the feature map are set to 4. We can see that the centers of the anchor boxes in 4 rows and 4 columns on the image are uniformly distributed. display_anchors(fmap_w=4, fmap_h=4, s=[0.15])
We move on to reduce the height and width of the feature map by half and use larger anchor boxes to detect larger objects. When the scale is set to 0.4, some anchor boxes will overlap with each other. (continued from previous page)
Multiscale Object Detection
625


display_anchors(fmap_w=2, fmap_h=2, s=[0.4])

100
200
300
400
500
Finally, we further reduce the height and width of the feature map by half and increase the anchor box scale to 0.8. Now the center of the anchor box is the center of the image. display_anchors(fmap_w=1, fmap_h=1, s=[0.8])

100
200
300
400
500
0
14.5.2 Multiscale Detection
Since we have generated multiscale anchor boxes, we will use them to detect objects of various sizes at different scales. In the following we introduce a CNN-based multiscale object detection method that we will implement in Section 14.7. At some scale, say that we have c feature maps of shape x w. Using the method in Section
14.5.1, we generate ‚Ñéùë§ sets of anchor boxes, where each set has ùëé anchor boxes with the same center. For example, at the first scale in the experiments in Section 14.5.1, given ten
200
400
600
Computer Vision
626

(number of channels) 4 x 4 feature maps, we generated 16 sets of anchor boxes, where each
set contains 3 anchor boxes with the same center. Next, each anchor box is labeled with the class and offset based on ground-truth bounding boxes. At the current scale, the object detection model needs to predict the classes and offsets of ‚Ñéùë§ sets of anchor boxes on the input image, where different sets have different centers. Assume that the ùëê feature maps here are the intermediate outputs obtained by the CNN for-
ward propagation based on the input image. Since there are ‚Ñéùë§ different spatial positions on each feature map, the same spatial position can be thought of as having ùëê units. Ac- cording to the definition of receptive field in Section 7.2, these ùëê units at the same spatial position of the feature maps have the same receptive field on the input image: they repre- sent the input image information in the same receptive field. Therefore, we can transform the ùëê units of the feature maps at the same spatial position into the classes and offsets of the ùëé anchor boxes generated using this spatial position. In essence, we use the information of the input image in a certain receptive field to predict the classes and offsets of the anchor boxes that are close to that receptive field on the input image. When the feature maps at different layers have varying-size receptive fields on the input image, they can be used to detect objects of different sizes. For example, we can design a neural network where units of feature maps that are closer to the output layer have wider receptive fields, so they can detect larger objects from the input image. In a nutshell, we can leverage layerwise representations of images at multiple levels by deep neural networks for multiscale object detection. We will show how this works through a concrete example in Section 14.7. 14.5.3 Summary
e At multiple scales, we can generate anchor boxes with different sizes to detect objects
with different sizes. e By defining the shape of feature maps, we can determine centers of uniformly sampled
anchor boxes on any image. e We use the information of the input image in a certain receptive field to predict the classes
and offsets of the anchor boxes that are close to that receptive field on the input image. e Through deep learning, we can leverage its layerwise representations of images at mul-
tiple levels for multiscale object detection. 14.5.4 Exercises
1. According to our discussions in Section 8.1, deep neural networks learn hierarchical features with increasing levels of abstraction for images. In multiscale object detection, do feature maps at different scales correspond to different levels of abstraction? Why or why not?bubu2. At the first scale (fmap_w=4, fmap_h=4) in the experiments in Section 14.5.1, generate uniformly distributed anchor boxes that may overlap. The Object Detection Dataset
627

3. Given a feature map variable with shape 1 x c x h x w, where c, h, and w are the
number of channels, height, and width of the feature maps, respectively. How can you transform this variable into the classes and offsets of anchor boxes? What is the shape of the output?bubuDiscussions216. 216
14.6 The Object Detection Dataset
a
There is no small dataset such as MNIST and Fashion-MNIST in the field of object detec- tion. In order to quickly demonstrate object detection models, we collected and labeled a small dataset. First, we took photos of free bananas from our office and generated 1000 banana images with different rotations and sizes. Then we placed each banana image at a random position on some background image. In the end, we labeled bounding boxes for those bananas on the images. 14.6.1 Downloading the Dataset
The banana detection dataset with all the image and csv label files can be downloaded directly from the Internet. %matplotlib inline import os import pandas as pd import torch import torchvision from d2l import torch as d2l
#@save d2l.DATA_HUB['banana-detection'] = ( d2l.DATA_URL + 'banana-detection.zip', '5de26c8fce5ccdea9f91267273464dc968d20d72')
14.6.2 Reading the Dataset
We are going to read the banana detection dataset in the read_data_bananas function below. The dataset includes a csv file for object class labels and ground-truth bounding box coordinates at the upper-left and lower-right corners. #@save def read_data_bananas(is_train=True): """Read the banana detection dataset images and labels.""" data_dir = d2l.download_extract('banana-detection') csv_fname = os.path.join(data_dir, 'bananas_train' if is_train
(continues on next page)
Computer Vision
628

else 'bananas_val', 'label.csv') csv_data = pd.read_csv(csv_fname) csv_data = csv_data.set_index('img_name') images, targets = [], [] for img_name, target in csv_data.iterrows(): images.append(torchvision.io.read_image( os.path.join(data_dir, 'bananas_train' if is_train else 'bananas_val', 'images', f'{img_name}'))) # Here `target` contains (class, upper-left x, upper-left y, # lower-right x, lower-right y), where all the images have the same # banana class (index 0) targets.append(list(target)) return images, torch.tensor(targets).unsqueeze(1) / 256
By using the read_data_bananas function to read images and labels, the following Ba- nanasDataset class will allow us to create a customized Dataset instance for loading the banana detection dataset. #@save class BananasDataset(torch.utils.data.Dataset): """A customized dataset to load the banana detection dataset.""" def __init__(self, is_train): self.features, self.labels = read_data_bananas(is_train) print('read ' + str(len(self.features)) + (f' training examples' if is_train else f' validation examples')) def __getitem__(self, idx): return (self.features[idx].float(), self.labels[idx]) def __len__(self): return len(self.features)
Finally, we define the load_data_bananas function to return two data iterator instances for both the training and test sets. For the test dataset, there is no need to read it in random order. #@save def load_data_bananas(batch_size): """Load the banana detection dataset.""" train_iter = torch.utils.data.DataLoader(BananasDataset(is_train=True), batch_size, shuffle=True) val_iter = torch.utils.data.DataLoader(BananasDataset(is_train=False), batch_size) return train_iter, val_iter
#@save
Let‚Äôs read a minibatch and print the shapes of both images and labels in this minibatch. The shape of the image minibatch, (batch size, number of channels, height, width), looks familiar: it is the same as in our earlier image classification tasks. The shape of the label minibatch is (batch size, ùëö, 5), where ùëö is the largest possible number of bounding boxes that any image has in the dataset. (continued from previous page)
The Object Detection Dataset
629

Although computation in minibatches is more efficient, it requires that all the image exam- ples contain the same number of bounding boxes to form a minibatch via concatenation. In general, images may have a varying number of bounding boxes; thus, images with fewer than ùëö bounding boxes will be padded with illegal bounding boxes until ùëö is reached. Then the label of each bounding box is represented by an array of length 5. The first element in the array is the class of the object in the bounding box, where -1 indicates an illegal bound- ing box for padding. The remaining four elements of the array are the (ùë•, ùë¶)-coordinate values of the upper-left corner and the lower-right corner of the bounding box (the range is between 0 and 1). For the banana dataset, since there is only one bounding box on each image, we have ùëö = 1. batch_size, edge_size = 32, 256 train_iter, _ = load_data_bananas(batch_size) batch = next(iter(train_iter)) batch[0].shape, batch[1].shape
Downloading ../data/banana-detection.zip from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/banana-detection.zip... read 1000 training examples read 100 validation examples
(torch.Size([32, 3, 256, 256]), torch.Size([32, 1, 5]))
14.6.3 Demonstration
Let‚Äôs demonstrate ten images with their labeled ground-truth bounding boxes. We can see that the rotations, sizes, and positions of bananas vary across all these images. Of course, this is just a simple artificial dataset. In practice, real-world datasets are usually much more complicated. imgs = (batch[0][:10].permute(0, 2, 3, 1)) / 255 axes = d2l.show_images(imgs, 2, 5, scale=2) for ax, label in zip(axes, batch[1][:10]): d2l.show_bboxes(ax, [label[0][1:5] * edge_size], colors=['w'])
14.6.4 Summary
e The banana detection dataset we collected can be used to demonstrate object detection
models. e The data loading for object detection is similar to that for image classification. However,
inobjectdetectionthelabelsalsocontaininformationofground-truthboundingboxes, which is missing in image classification. 14.6.5 Exercises
Computer Vision
630


1. Demonstrate other images with ground-truth bounding boxes in the banana detection dataset. How do they differ with respect to bounding boxes and objects? 2. Say that we want to apply data augmentation, such as random cropping, to object detec- tion. How can it be different from that in image classification? Hint: what if a cropped image only contains a small portion of an object? Discussions217. 217
Bye iat
14.7 Single Shot Multibox Detection
|
In Section 14.3‚ÄìSection 14.6, we introduced bounding boxes, anchor boxes, multiscale object detection, and the dataset for object detection. Now we are ready to use such back- ground knowledge to design an object detection model: single shot multibox detection (SSD) (Liu et al., 2016). This model is simple, fast, and widely used. Although this is just one of vast amounts of object detection models, some of the design principles and implementation details in this section are also applicable to other models. 14.7.1 Model
Fig. 14.7.1 provides an overview of the design of single-shot multibox detection. This model mainly consists of a base network followed by several multiscale feature map blocks. The base network is for extracting features from the input image, so it can use a deep CNN. For example, the original single-shot multibox detection paper adopts a VGG network trun- catedbeforetheclassificationlayer(Liuetal.,2016),whileResNethasalsobeencommonly used. Through our design we can make the base network output larger feature maps so as to generate more anchor boxes for detecting smaller objects. Subsequently, each multiscale feature map block reduces (e.g., by half) the height and width of the feature maps from the previous block, and enables each unit of the feature maps to increase its receptive field on the input image. Single Shot Multibox Detection
631

Recallthedesignofmultiscaleobjectdetectionthroughlayerwiserepresentationsofimages by deep neural networks in Section 14.5. Since multiscale feature maps closer to the top of Fig. 14.7.1 are smaller but have larger receptive fields, they are suitable for detecting fewer but larger objects. In a nutshell, via its base network and several multiscale feature map blocks, single-shot multibox detection generates a varying number of anchor boxes with different sizes, and detects varying-size objects by predicting classes and offsets of these anchor boxes (thus the bounding boxes); thus, this is a multiscale object detection model. Class prediction [+ [Anchor |, Bounding box }<‚Äî‚Äî|_box prediction
Class prediction + [Anchor |, Bounding box }¬¢‚Äî‚Äî|_box prediction
tFig. 14.7.1 As a multiscale object detection model, single-shot multibox detection mainly consists of
a base network followed by several multiscale feature map blocks. In the following, we will describe the implementation details of different blocks in Fig.bubu14.7.1. To begin with, we discuss how to implement the class and bounding box predic- tion. Class Prediction Layer
Let the number of object classes be ùëû. Then anchor boxes have ùëû‚Äö1 classes, where class 0 is
background. At some scale, suppose that the height and width of feature maps are ‚Ñé and ùë§, respectively. When ùëé anchor boxes are generated with each spatial position of these feature maps as their center, a total of ‚Ñéùë§ùëé anchor boxes need to be classified. This often makes classification with fully connected layers infeasible due to likely heavy parametrization costs. Recall how we used channels of convolutional layers to predict classes in Section 8.3. Single-shot multibox detection uses the same technique to reduce model complex- ity. Specifically, the class prediction layer uses a convolutional layer without altering width or height of feature maps. In this way, there can be a one-to-one correspondence between outputs and inputs at the same spatial dimensions (width and height) of feature maps. More concretely, channels of the output feature maps at any spatial position (ùë•, ùë¶) represent class predictions for all the anchor boxes centered on (ùë•, ùë¶) of the input feature maps. To produce validpredictions, theremustbe ùëé‚Äûùëû‚Äö1‚Äù outputchannels, whereforthesamespatialposition
Class ‚ÄòAnchor |‚Äî>} _ prediction box _|-~s! Bounding box prediction
t
ue
Computer Vision
632

the output channel with index i(q+1)+, represents the prediction of the class j (0 < j < q)
the output channel with index i(q+1)+, represents the prediction of the class j (0 < j < q) for the anchor box i (0 < i < a). Belowwedefinesuchaclasspredictionlayer,specifyingùëé andùëû viaargumentsnum_anchors
Below we define such a class prediction layer, specifying a and g via arguments num_anchors and num_classes, respectively. This layer uses a 3 x 3 convolutional layer with a padding of 1. The width and height of the input and output of this convolutional layer remain un- changed. %matplotlib inline import torch import torchvision from torch import nn from torch.nn import functional as F from d2l import torch as d2l def cls_predictor(num_inputs, num_anchors, num_classes): return nn.Conv2d(num_inputs, num_anchors * (num_classes + 1), kernel_size=3, padding=1)
Bounding Box Prediction Layer
The design of the bounding box prediction layer is similar to that of the class prediction layer. The only difference lies in the number of outputs for each anchor box: here we need to predict four offsets rather than ùëû ‚Äö 1 classes. def bbox_predictor(num_inputs, num_anchors): return nn.Conv2d(num_inputs, num_anchors * 4, kernel_size=3, padding=1)
Concatenating Predictions for Multiple Scales
As we mentioned, single-shot multibox detection uses multiscale feature maps to generate anchor boxes and predict their classes and offsets. At different scales, the shapes of feature mapsorthenumbersofanchorboxescenteredonthesameunitmayvary. Therefore, shapes of the prediction outputs at different scales may vary. In the following example, we construct feature maps at two different scales, Y1 and Y2, for the same minibatch, where the height and width of Y2 are half of those of Y1. Let‚Äôs take class prediction as an example. Suppose that 5 and 3 anchor boxes are generated for every unit in Y1 and Y2, respectively. Suppose further that the number of object classes is 10. For feature maps Y1 and Y2 the numbers of channels in the class prediction outputs are 5 x (10+ 1) = 55 and 3 x (10+ 1) = 33, respectively, where either output shape is (batch size, number of channels, height, width). def forward(x, block): return block(x)
(continues on next page)
Single Shot Multibox Detection
633

Y1 = forward(torch.zeros((2, 8, 20, 20)), cls_predictor(8, 5, 10)) Y2 = forward(torch.zeros((2, 16, 10, 10)), cls_predictor(16, 3, 10)) Y1.shape, Y2.shape
(torch.Size([2, 55, 20, 20]), torch.Size([2, 33, 10, 10]))
As we can see, except for the batch size dimension, the other three dimensions all have different sizes. To concatenate these two prediction outputs for more efficient computation, we will transform these tensors into a more consistent format. Note that the channel dimension holds the predictions for anchor boxes with the same center. We first move this dimension to the innermost. Since the batch size remains the same for different scales, we can transform the prediction output into a two-dimensional tensor with shape (batch size, height x width x number of channels). Then we can concatenate such outputs at different scales along dimension 1. def flatten_pred(pred):
return torch.flatten(pred.permute(0, 2, 3, 1), start_dim=1)
def concat_preds(preds):
return torch.cat([flatten_pred(p) for p in preds], dim=1)
In this way, even though Y1 and Y2 have different sizes in channels, heights, and widths, we can still concatenate these two prediction outputs at two different scales for the same minibatch. concat_preds([Y1, Y2]).shape
torch.Size([2, 25300])
Downsampling Block
In order to detect objects at multiple scales, we define the following downsampling block down_sample_b1k that halves the height and width of input feature maps. In fact, this block applies the design of VGG blocks in Section 8.2.1. More concretely, each downsampling block consists of two 3 x 3 convolutional layers with padding of 1 followed by a 2 x 2 max- pooling layer with stride of 2. As we know, 3 x 3 convolutional layers with padding of 1 do not change the shape of feature maps. However, the subsequent 2 x 2 max-pooling reduces the height and width of input feature maps by half. For both input and output feature maps of this downsampling block, because 1 x 2 + (3 ‚Äî 1) + (3 - 1) = 6, each unit in the output has a 6 x 6 receptive field on the input. Therefore, the downsampling block enlarges the receptive field of each unit in its output feature maps. (continued from previous page)
Computer Vision
634

def down_sample_blk(in_channels, out_channels): blk = [] for _ in range(2): blk.append(nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)) blk.append(nn.BatchNorm2d(out_channels)) blk.append(nn.ReLU()) in_channels = out_channels blk.append(nn.MaxPool2d(2)) return nn.Sequential(*blk)
Inthefollowingexample, ourconstructeddownsamplingblockchangesthenumberofinput channels and halves the height and width of the input feature maps. forward(torch.zeros((2, 3, 20, 20)), down_sample_blk(3, 10)).shape
torch.Size([2, 10, 10, 10])
Base Network Block
The base network block is used to extract features from input images. For simplicity, we construct a small base network consisting of three downsampling blocks that double the number of channels at each block. Given a 256 x 256 input image, this base network block outputs 32 x 32 feature maps (256/2? = 32). def base_net(): blk = [] num_filters = [3, 16, 32, 64] for i in range(len(num_filters) - 1): blk.append(down_sample_blk(num_filters[i], num_filters[i+1])) return nn.Sequential(*blk) forward(torch.zeros((2, 3, 256, 256)), base_net()).shape
torch.Size([2, 64, 32, 32])
The Complete Model
The complete single shot multibox detection model consists of five blocks. The feature maps produced by each block are used for both (i) generating anchor boxes and (ii) predict- ing classes and offsets of these anchor boxes. Among these five blocks, the first one is the base network block, the second to the fourth are downsampling blocks, and the last block uses global max-pooling to reduce both the height and width to 1. Technically, the second to the fifth blocks are all those multiscale feature map blocks in Fig. 14.7.1. Single Shot Multibox Detection
635

def get_blk(i): if i == 0: blk = base_net() elif i == 1: blk = down_sample_blk(64, 128) elif i == 4: blk = nn.AdaptiveMaxPool2d((1,1)) else: blk = down_sample_blk(128, 128) return blk
Now we define the forward propagation for each block. Different from in image classifica- tion tasks, outputs here include (i) CNN feature maps Y, (ii) anchor boxes generated using Y at the current scale, and (iii) classes and offsets predicted (based on Y) for these anchor boxes. def blk_forward(X, blk, size, ratio, cls_predictor, bbox_predictor): Y = blk(X) anchors = d2l.multibox_prior(Y, sizes=size, ratios=ratio) cls_preds = cls_predictor(Y) bbox_preds = bbox_predictor(Y) return (Y, anchors, cls_preds, bbox_preds)
Recall that in Fig. 14.7.1 a multiscale feature map block that is closer to the top is for detecting larger objects; thus, it needs to generate larger anchor boxes. In the above forward propagation, at each multiscale feature map block we pass in a list of two scale values via the sizes argument of the invoked multibox_prior function (described in Section 14.4). In the following, the interval between 0.2 and 1.05 is split evenly into five sections to determine the smaller scale values at the five blocks: 0.2, 0.37, 0.54, 0.71, and 0.88. Then their larger scale values are given by V0.2 x 0.37 = 0.272, V0.37 x 0.54 = 0.447, and so on. sizes = [[0.2, 0.272], [0.37, 0.447], [0.54, 0.619], [0.71, 0.79], [0.88, 0.961]] ratios = [[1, 2, 0.5]] * 5 num_anchors = len(sizes[0]) + len(ratios[0]) - 1
Now we can define the complete model TinySSD as follows. class TinySSD(nn.Module): def __init__(self, num_classes, **kwargs): super(TinySSD, self).__init__(**kwargs) self.num_classes = num_classes idx_to_in_channels = [64, 128, 128, 128, 128] for i in range(5): # Equivalent to the assignment statement `self.blk_i = get_blk(i)` setattr(self, f'blk_{i}', get_blk(i)) setattr(self, f'cls_{i}', cls_predictor(idx_to_in_channels[i], num_anchors, num_classes)) setattr(self, f'bbox_{i}', bbox_predictor(idx_to_in_channels[i], num_anchors))
(continues on next page)
Computer Vision
636

def forward(self, X): anchors, cls_preds, bbox_preds = [None] * 5, [None] * 5, [None] * 5 for i in range(5): # Here `getattr(self, 'blk_%d' % i)` accesses `self.blk_i` X, anchors[i], cls_preds[i], bbox_preds[i] = blk_forward( X, getattr(self, f'blk_{i}'), sizes[i], ratios[i], getattr(self, f'cls_{i}'), getattr(self, f'bbox_{i}')) anchors = torch.cat(anchors, dim=1) cls_preds = concat_preds(cls_preds) cls_preds = cls_preds.reshape( cls_preds.shape[0], -1, self.num_classes + 1) bbox_preds = concat_preds(bbox_preds) return anchors, cls_preds, bbox_preds
We create a model instance and use it to perform forward propagation on a minibatch of 256 x 256 images X. As shown earlier in this section, the first block outputs 32 x 32 feature maps.bubuRecall that the
As shown earlier in this section, the first block outputs 32 x 32 feature maps. Recall that the second to fourth downsampling blocks halve the height and width and the fifth block uses global pooling. Since 4 anchor boxes are generated for each unit along spatial dimensions of feature maps, at all the five scales a total of (32? + 167 + 8? + 47 + 1) x 4 = 5444 anchor boxes are generated for each image. net = TinySSD(num_classes=1) X = torch.zeros((32, 3, 256, 256)) anchors, cls_preds, bbox_preds = net(X) print('output anchors:', anchors.shape) print('output class preds:', cls_preds.shape) print('output bbox preds:', bbox_preds.shape)
output anchors: torch.Size([1, 5444, 4]) output class preds: torch.Size([32, 5444, 2]) output bbox preds: torch.Size([32, 21776])
14.7.2 Training
Now we will explain how to train the single shot multibox detection model for object de- tection. Reading the Dataset and Initializing the Model
To begin with, let‚Äôs read the banana detection dataset described in Section 14.6. batch_size = 32 train_iter, _ = d2l.load_data_bananas(batch_size)
(continued from previous page)
Single Shot Multibox Detection
637

read 1000 training examples read 100 validation examples
There is only one class in the banana detection dataset. After defining the model, we need to initialize its parameters and define the optimization algorithm. device, net = d2l.try_gpu(), TinySSD(num_classes=1) trainer = torch.optim.SGD(net.parameters(), lr=0.2, weight_decay=5e-4)
Defining Loss and Evaluation Functions
Object detection has two types of losses. The first loss concerns classes of anchor boxes: its computation can simply reuse the cross-entropy loss function that we used for image classification. Thesecondlossconcernsoffsetsofpositive(non-background)anchorboxes: this is a regression problem. For this regression problem, however, here we do not use the squared loss described in Section 3.1.3. Instead, we use the ‚Ñì1 norm loss, the absolute value of the difference between the prediction and the ground-truth. The mask variable bbox_masks filters out negative anchor boxes and illegal (padded) anchor boxes in the loss calculation. In the end, we sum up the anchor box class loss and the anchor box offset loss to obtain the loss function for the model. cls_loss = nn.CrossEntropyLoss(reduction='none') bbox_loss = nn.L1Loss(reduction='none')
def calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks): batch_size, num_classes = cls_preds.shape[0], cls_preds.shape[2] cls = cls_loss(cls_preds.reshape(-1, num_classes), cls_labels.reshape(-1)).reshape(batch_size, -1).mean(dim=1) bbox = bbox_loss(bbox_preds * bbox_masks, bbox_labels * bbox_masks).mean(dim=1) return cls + bbox
We can use accuracy to evaluate the classification results. Due to the used ‚Ñì1 norm loss
for the offsets, we use the mean absolute error to evaluate the predicted bounding boxes. These prediction results are obtained from the generated anchor boxes and the predicted offsets for them. def cls_eval(cls_preds, cls_labels): # Because the class prediction results are on the final dimension, # `argmax` needs to specify this dimension return float((cls_preds.argmax(dim=-1).type( cls_labels.dtype) == cls_labels).sum()) def bbox_eval(bbox_preds, bbox_labels, bbox_masks): return float((torch.abs((bbox_labels - bbox_preds) * bbox_masks)).sum())
Computer Vision
638

Training the Model
When training the model, we need to generate multiscale anchor boxes (anchors) and pre- dict their classes (cls_preds) and offsets (bbox_preds) in the forward propagation. Then we label the classes (cls_labels) and offsets (bbox_labels) of such generated anchor boxes based on the label information Y. Finally, we calculate the loss function using the predicted and labeled values of the classes and offsets. For concise implementations, eval- uation of the test dataset is omitted here. num_epochs, timer = 20, d2l.Timer() animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], legend=['class error', 'bbox mae']) net = net.to(device) for epoch in range(num_epochs): # Sum of training accuracy, no. of examples in sum of training accuracy, # Sum of absolute error, no. of examples in sum of absolute error metric = d2l.Accumulator(4) net.train() for features, target in train_iter: timer.start() trainer.zero_grad() X, Y = features.to(device), target.to(device) # Generate multiscale anchor boxes and predict their classes and # offsets anchors, cls_preds, bbox_preds = net(X) # Label the classes and offsets of these anchor boxes bbox_labels, bbox_masks, cls_labels = d2l.multibox_target(anchors, Y) # Calculate the loss function using the predicted and labeled values # of the classes and offsets l = calc_loss(cls_preds, cls_labels, bbox_preds, bbox_labels, bbox_masks) l.mean().backward() trainer.step() metric.add(cls_eval(cls_preds, cls_labels), cls_labels.numel(), bbox_eval(bbox_preds, bbox_labels, bbox_masks), bbox_labels.numel()) cls_err, bbox_mae = 1 - metric[0] / metric[1], metric[2] / metric[3] animator.add(epoch + 1, (cls_err, bbox_mae)) print(f'class err {cls_err:.2e}, bbox mae {bbox_mae:.2e}') print(f'{len(train_iter.dataset) / timer.stop():.1f} examples/sec on ' f'{str(device)}')
class err 3.27e-03, bbox mae 3.08e-03 4279.7 examples/sec on cuda:0
14.7.3 Prediction
During prediction, the goal is to detect all the objects of interest on the image. Below we read and resize a test image, converting it to a four-dimensional tensor that is required by convolutional layers. Single Shot Multibox Detection
639

0.020 ‚Äî class error =-- bbox mae 0.015 0.010 0.005 epoch
X = torchvision.io.read_image('../img/banana.jpg').unsqueeze(0).float() img = X.squeeze(0).permute(1, 2, 0).long()
Usingthemultibox_detectionfunctionbelow,thepredictedboundingboxesareobtained from the anchor boxes and their predicted offsets. Then non-maximum suppression is used to remove similar predicted bounding boxes. def predict(X): net.eval() anchors, cls_preds, bbox_preds = net(X.to(device)) cls_probs = F.softmax(cls_preds, dim=2).permute(0, 2, 1) output = d2l.multibox_detection(cls_probs, bbox_preds, anchors) idx = [i for i, row in enumerate(output[0]) if row[0] != -1] return output[0, idx] output = predict(X)
Finally, we display all the predicted bounding boxes with confidence 0.9 or above as out- put. put. def display(img, output, threshold): d2l.set_figsize((5, 5)) fig = d2l.plt.imshow(img) for row in output: score = float(row[1]) if score < threshold: continue h, w = img.shape[:2] bbox = [row[2:6] * torch.tensor((w, h, w, h), device=row.device)] d2l.show_bboxes(fig.axes, bbox, '%.2f' % score, 'w') display(img, output.cpu(), threshold=0.9)
14.7.4 Summary
e Single shot multibox detection is a multiscale object detection model. Via its base net-
work and several multiscale feature map blocks, single-shot multibox detection gen- erates a varying number of anchor boxes with different sizes, and detects varying-size
640
Computer Vision
640


objects by predicting classes and offsets of these anchor boxes (thus the bounding boxes). e When training the single-shot multibox detection model, the loss function is calculated
based on the predicted and labeled values of the anchor box classes and offsets. 14.7.5 Exercises
1. Can you improve the single-shot multibox detection by improving the loss function? For example, replace ‚Ñì1 norm loss with smooth ‚Ñì1 norm loss for the predicted offsets. This loss function uses a square function around zero for smoothness, which is controlled by the hyperparameter ùúé:
(
2 : 2 f= (eo /2, if |x| < 1/o (4.7.1) |x| -0.5/07, otherwise
When ùúé is very large, this loss is similar to the ‚Ñì1 norm loss. When its value is smaller, the
loss function is smoother. def smooth_l1(data, scalar): out = [] for i in data: if abs(i) < 1 / (scalar ** 2): out.append(((scalar * i) ** 2) / 2) else: out.append(abs(i) - 0.5 / (scalar ** 2)) return torch.tensor(out) sigmas = [10, 1, 0.5] lines = ['-', '--', '-.'] x = torch.arange(-2, 2, 0.1) d2l.set_figsize()
(continues on next page)
Single Shot Multibox Detection
641

for l, s in zip(lines, sigmas): y = smooth_l1(x, scalar=s) d2l.plt.plot(x, y, l, label='sigma=%.1f' % s) d2l.plt.legend();
2.0 ‚Äî sigma=10.0 === sigma=1.0 ‚Äî-- sigma=0.5 1.57. 1.0 0.5 0.0
Besides, in the experiment we used cross-entropy loss for class prediction: denoting by ùëù ùëó
Besides, in the experiment we used cross-entropy loss for class prediction: denoting by p; the predicted probability for the ground-truth class j, the cross-entropy loss is ‚Äî log p;. We can also use the focal loss (Lin et al., 2017): given hyperparameters y > 0 and a > 0, this loss is defined as:
‚Äîa(1 ‚Äî pj)‚Äù log p;. (14.7.2)
As we can see, increasing ùõæ can effectively reduce the relative loss for well-classified ex-
amples (e.g., ùëù ùëó > 0.5) so the training can focus more on those difficult examples that are misclassified. def focal_loss(gamma, x): return -(1 - x) ** gamma * torch.log(x) x = torch.arange(0.01, 1, 0.01) for l, gamma in zip(lines, [0, 1, 5]): y = d2l.plt.plot(x, focal_loss(gamma, x), l, label='gamma=%.1f' % gamma) d2l.plt.legend();
‚Äî _ gamma=0.0 ==* gamma=1.0 ‚Äî-- gamma=5.0
2. Due to space limitations, we have omitted some implementation details of the single shot multibox detection model in this section.bubuCan you further improve the model in the following aspects:
(continued from previous page)
Computer Vision
642

1. When an object is much smaller compared with the image, the model could resize the input image bigger. 2. There are typically a vast number of negative anchor boxes. To make the class dis- tribution more balanced, we could downsample negative anchor boxes. 3. In the loss function, assign different weight hyperparameters to the class loss and the offset loss. 4. Use other methods to evaluate the object detection model, such as those in the single shot multibox detection paper (Liu et al., 2016). Discussions218. Discussions?!8,
218

14.8 Region-based CNNs (R-CNNs)
a
Besides single shot multibox detection described in Section 14.7, region-based CNNs or regions with CNN features (R-CNNs) are also among many pioneering approaches of ap- plying deep learning to object detection (Girshick et al., 2014). In this section, we will introduce the R-CNN and its series of improvements: the fast R-CNN (Girshick, 2015), the faster R-CNN (Ren et al., 2015), and the mask R-CNN (He et al., 2017). Due to limited space, we will only focus on the design of these models. 14.8.1 R-CNNs
The R-CNN first extracts many (e.g., 2000) region proposals from the input image (e.g., an- chor boxes can also be considered as region proposals), labeling their classes and bounding boxes (e.g., offsets). (Girshick et al., 2014)
Then a CNN is used to perform forward propagation on each region proposal to extract its features. Next, features of each region proposal are used for predicting the class and bounding box of this region proposal. Selective search Class prediction Class prediction Bounding box prediction
tFig. 14.8.1
The R-CNN model.bubuFig. 14.8.1 shows the R-CNNmodel. More concretely, the R-CNN consists of the following four steps:
Region-based CNNs (R-CNNs)
643

1. Perform selective search to extract multiple high-quality region proposals on the input image (Uijlings et al., 2013). These proposed regions are usually selected at multiple scales with different shapes and sizes. Each region proposal will be labeled with a class and a ground-truth bounding box. 2. Choose a pretrained CNN and truncate it before the output layer. Resize each region proposal to the input size required by the network, and output the extracted features for the region proposal through forward propagation. 3.bubuTake the extracted features and labeled class of each region proposal as an example. Train multiple support vector machines to classify objects, where each support vector machine individually determines whether the example contains a specific class. 4. Take the extracted features and labeled bounding box of each region proposal as an example. Train a linear regression model to predict the ground-truth bounding box. Although the R-CNN model uses pretrained CNNs to effectively extract image features, it is slow. Imagine that we select thousands of region proposals from a single input image: this requires thousands of CNN forward propagations to perform object detection. This massive computing load makes it infeasible to widely use R-CNNs in real-world applica- tions. 14.8.2 Fast R-CNN
The main performance bottleneck of an R-CNN lies in the independent CNN forward prop- agation for each region proposal, without sharing computation. Since these regions usually have overlaps, independent feature extractions lead to much repeated computation. One of the major improvements of the fast R-CNN from the R-CNN is that the CNN forward propagation is only performed on the entire image (Girshick, 2015). Class prediction
t Rol pooling
ue
tFig. 14.8.2
The fast R-CNN model. Fig. 14.8.2 describes the fast R-CNN model. Its major computations are as follows:
1. Compared with the R-CNN, in the fast R-CNN the input of the CNN for feature extrac- tion is the entire image, rather than individual region proposals. Moreover, this CNN is trainable. Given an input image, let the shape of the CNN output be 1 x c x Ay X w1. Bounding box prediction
Selective search
Computer Vision
644

2. Suppose that selective search generates n region proposals. These region proposals (of different shapes) mark regions of interest (of different shapes) on the CNN output. Then these regions of interest further extract features of the same shape (say height hz and width w2 are specified) in order to be easily concatenated. To achieve this, the fast R- CNN introduces the region of interest (Rol) pooling layer: the CNN output and region proposals are input into this layer, outputting concatenated features of shape n xc x h2 x w? that are further extracted for all the region proposals. 3. Using a fully connected layer, transform the concatenated features into an output of shape n x d, where d depends on the model design. 4. Predict the class and bounding box for each of the ùëõ region proposals. More concretely,
4. Predict the class and bounding box for each of the n region proposals. More concretely, in class and bounding box prediction, transform the fully connected layer output into an output of shape n x q (q is the number of classes) and an output of shape n x 4, respectively. The class prediction uses softmax regression. TheregionofinterestpoolinglayerproposedinthefastR-CNNisdifferentfromthepooling layer introduced in Section 7.5. In the pooling layer, we indirectly control the output shape by specifying sizes of the pooling window, padding, and stride. In contrast, we can directly specify the output shape in the region of interest pooling layer. For example, let‚Äôs specify the output height and width for each region as ‚Ñé2 and ùë§2, re-
For example, let‚Äôs specify the output height and width for each region as hz and wo, re- spectively. For any region of interest window of shape h x w, this window is divided into a hz X w2 grid of subwindows, where the shape of each subwindow is approximately (h/hz) X (w/wz2). In practice, the height and width of any subwindow shall be rounded up, and the largest element shall be used as output of the subwindow. Therefore, the region of interest pooling layer can extract features of the same shape even when regions of interest have different shapes. As an illustrative example, in Fig. 14.8.3, the upper-left 3 x 3 region of interest is selected
As an illustrative example, in Fig. 14.8.3, the upper-left 3 x 3 region of interest is selected on a4x 4 input. For this region of interest, we use a 2 x 2 region of interest pooling layer to obtain a 2 x 2 output. Note that each of the four divided subwindows contains elements 0, 1, 4, and 5 (5 is the maximum); 2 and 6 (6 is the maximum); 8 and 9 (9 is the maximum); and 10. 2x2Rol [¬¢ Pooling lel
A 2 x 2 region of interest pooling layer. Below we demonstrate the computation of the region of interest pooling layer. Suppose that the height and width of the CNN-extracted features X are both 4, and there is only a single channel. import torch import torchvision
(continues on next page)
Region-based CNNs (R-CNNs)
645

X = torch.arange(16.).reshape(1, 1, 4, 4) X
tensor([[[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]]])
Let‚Äôs further suppose that the height and width of the input image are both 40 pixels and that selective search generates two region proposals on this image. Each region proposal is expressed as five elements: its object class followed by the ‚Äûùë•, ùë¶‚Äù-coordinates of its upper- left and lower-right corners. rois = torch.Tensor([[0, 0, 0, 20, 20], [0, 0, 10, 30, 30]])
Because the height and width of X are 1/10 of the height and width of the input image,
Because the height and width of X are 1/10 of the height and width of the input image, the coordinates of the two region proposals are multiplied by 0.1 according to the specified spatial_scale argument. Then the two regions of interest are marked on X as X[:, :, @:3, @:3]andX[:, :, 1:4, 0:4], respectively. Finally in the 2 x 2 region of interest pooling, each region of interest is divided into a grid of sub-windows to further extract features of the same shape 2 x 2. torchvision.ops.roi_pool(X, rois, output_size=(2, 2), spatial_scale=0.1)
tensor([[[[ 5., 6.], [ 9., 10.]]], [[[ 9., 11.], [13., 15.]]]])
14.8.3 Faster R-CNN
To be more accurate in object detection, the fast R-CNN model usually has to generate a lot of region proposals in selective search. To reduce region proposals without loss of accuracy, the faster R-CNN proposes to replace selective search with a region proposal network (Ren et al., 2015). Fig. 14.8.4 shows the faster R-CNN model. Compared with the fast R-CNN, the faster R- CNN only changes the region proposal method from selective search to a region proposal network. The rest of the model remain unchanged. The region proposal network works in the following steps:
1. Use a 3 x 3 convolutional layer with padding of | to transform the CNN output to a
(continued from previous page)
Computer Vision
646

Class prediction
Bounding box prediction
( TT \ 1 Binary class ' ' prediction H i Bounding box mH NMS &‚Äî} mean 1
i Rol pooling
'
t
‚Äò
2 A
tFig. 14.8.4
The faster R-CNN model. new output with ùëê channels. In this way, each unit along the spatial dimensions of the
CNN-extracted feature maps gets a new feature vector of length ùëê. 2. Centered on each pixel of the feature maps, generate multiple anchor boxes of different scales and aspect ratios and label them. 3. Using the length-ùëê feature vector at the center of each anchor box, predict the binary
class (background or objects) and bounding box for this anchor box. 4. Consider those predicted bounding boxes whose predicted classes are objects. Remove overlappedresultsusingnon-maximumsuppression. Theremainingpredictedbounding boxesforobjectsaretheregionproposalsrequiredbytheregionofinterestpoolinglayer. It is worth noting that, as part of the faster R-CNN model, the region proposal network is jointly trained with the rest of the model. In other words, the objective function of the faster R-CNN includes not only the class and bounding box prediction in object detection, butalsothebinaryclassandboundingboxpredictionofanchorboxesintheregionproposal network. As a result of the end-to-end training, the region proposal network learns how to generate high-quality region proposals, so as to stay accurate in object detection with a reduced number of region proposals that are learned from data. 14.8.4 Mask R-CNN
In the training dataset, if pixel-level positions of object are also labeled on images, the mask R-CNN can effectively leverage such detailed labels to further improve the accuracy of object detection (He et al., 2017). As shown in Fig. 14.8.5, the mask R-CNN is modified based on the faster R-CNN. Specif- ically, the mask R-CNN replaces the region of interest pooling layer with the region of interest (RoI) alignment layer. This region of interest alignment layer uses bilinear inter- polation to preserve the spatial information on the feature maps, which is more suitable for pixel-level prediction. The output of this layer contains feature maps of the same shape for all the regions of interest. They are used to predict not only the class and bounding box for each region of interest, but also the pixel-level position of the object through an addi- tional fully convolutional network. More details on using a fully convolutional network to
}<‚Äî Anchor box
,
Region proposal network
Region-based CNNs (R-CNNs)
647

Class prediction
Rol align
i
Ls
tFig. 14.8.5
The mask R-CNN model. predict pixel-level semantics of an image will be provided in subsequent sections of this chapter. 14.8.5 Summary
e The R-CNN extracts many region proposals from the input image, uses a CNN to perform
forward propagation on each region proposal to extract its features, then uses these features to predict the class and bounding box of this region proposal. e One of the major improvements of the fast R-CNN from the R-CNN is that the CNN for-
ward propagation is only performed on the entire image. It also introduces the region of interest pooling layer, so that features of the same shape can be further extracted for regions of interest that have different shapes. e The faster R-CNN replaces the selective search used in the fast R-CNN with a jointly
trained region proposal network, so that the former can stay accurate in object detec- tion with a reduced number of region proposals. e Based on the faster R-CNN, the mask R-CNN additionally introduces a fully convolu-
tional network, so as to leverage pixel-level labels to further improve the accuracy of object detection. 14.8.6 Exercises
1. Can we frame object detection as a single regression problem, such as predicting bound- ing boxes and class probabilities? You may refer to the design of the YOLO model (Redmon et al., 2016). 2. Compare single shot multibox detection with the methods introduced in this section. What are their major differences?bubuYou may refer to Figure 2 of Zhao et al. (2019).bubu219
Py ee
Discussions219. Bounding box prediction
Mask prediction
Region proposal network
Computer Vision
648

14.9 Semantic Segmentation and the Dataset
|
When discussing object detection tasks in Section 14.3‚ÄìSection 14.8, rectangular bound- ing boxes are used to label and predict objects in images. This section will discuss the problem of semantic segmentation, which focuses on how to divide an image into regions belonging to different semantic classes. Different from object detection, semantic seg- mentation recognizes and understands what are in images in pixel level: its labeling and prediction of semantic regions are in pixel level. Fig. 14.9.1 shows the labels of the dog, cat, and background of the image in semantic segmentation. Compared with in object de- tection, the pixel-level borders labeled in semantic segmentation are obviously more fine- grained. tFig. 14.9.1
Labels of the dog, cat, and background of the image in semantic segmentation. 14.9.1 Image Segmentation and Instance Segmentation
There are also two important tasks in the field of computer vision that are similar to seman- tic segmentation, namely image segmentation and instance segmentation. We will briefly distinguish them from semantic segmentation as follows. e Image segmentation divides an image into several constituent regions. The methods for
this type of problem usually make use of the correlation between pixels in the image. It does not need label information about image pixels during training, and it cannot guarantee that the segmented regions will have the semantics that we hope to obtain during prediction. Taking the image in Fig. 14.9.1 as input, image segmentation may divide the dog into two regions: one covers the mouth and eyes which are mainly black, and the other covers the rest of the body which is mainly yellow. e Instance segmentation is also called simultaneous detection and segmentation. It studies how to recognize the pixel-level regions of each object instance in an image. Differ- ent from semantic segmentation, instance segmentation needs to distinguish not only semantics, but also different object instances. For example, if there are two dogs in the image, instance segmentation needs to distinguish which of the two dogs a pixel belongs to. 220
14.9.2 The Pascal VOC2012 Semantic Segmentation Dataset
On of the most important semantic segmentation dataset is Pascal VOC2012 220 . In the
Background
Cat
Semantic Segmentation and the Dataset
649

following, we will take a look at this dataset. %matplotlib inline import os import torch import torchvision from d2l import torch as d2l
The tar file of the dataset is about 2 GB, so it may take a while to download the file. The extracted dataset is located at ../data/VOCdevkit/VOC2012. #@save d2l.DATA_HUB['voc2012'] = (d2l.DATA_URL + 'VOCtrainval_11-May-2012.tar', '4e443f8a2eca6b1dac8a6c57641b67dd40621a49') voc_dir = d2l.download_extract('voc2012', 'VOCdevkit/VOC2012')
Downloading ../data/VOCtrainval_11-May-2012.tar from http://d2l-data.s3- ‚Ü©!accelerate.amazonaws.com/VOCtrainval_11-May-2012.tar... After entering the path ../data/VOCdevkit/VOC2012, we can see the different compo- nents of the dataset. The ImageSets/Segmentation path contains text files that specify training and test samples, while the JPEGImages and SegmentationClass paths store the input image and label for each example, respectively. The label here is also in the im- age format, with the same size as its labeled input image. Besides, pixels with the same color in any label image belong to the same semantic class. The following defines the read_voc_images function to read all the input images and labels into the memory. #@save def read_voc_images(voc_dir, is_train=True): """Read all VOC feature and label images.""" txt_fname = os.path.join(voc_dir, 'ImageSets', 'Segmentation', 'train.txt' if is_train else 'val.txt') mode = torchvision.io.image.ImageReadMode.RGB with open(txt_fname, 'r') as f: images = f.read().split() features, labels = [], [] for i, fname in enumerate(images): features.append(torchvision.io.read_image(os.path.join( voc_dir, 'JPEGImages', f'{fname}.jpg'))) labels.append(torchvision.io.read_image(os.path.join( voc_dir, 'SegmentationClass' ,f'{fname}.png'), mode)) return features, labels train_features, train_labels = read_voc_images(voc_dir, True)
Wedrawthefirstfiveinputimagesandtheirlabels. Inthelabelimages, whiteandblackrep- resent borders and background, respectively, while the other colors correspond to different classes. Computer Vision
650

n=5
imgs = train_features[:n] + train_labels[:n] imgs = [img.permute(1,2,0) for img in imgs] d21.show_images(imgs, 2, n);

Next,weenumeratetheRGBcolorvaluesandclassnamesforallthelabelsinthisdataset. #@save VOC_COLORMAP = [[0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0], [0, 0, 128], [128, 0, 128], [0, 128, 128], [128, 128, 128], [64, 0, 0], [192, 0, 0], [64, 128, 0], [192, 128, 0], [64, 0, 128], [192, 0, 128], [64, 128, 128], [192, 128, 128], [0, 64, 0], [128, 64, 0], [0, 192, 0], [128, 192, 0], [0, 64, 128]] #@save VOC_CLASSES = ['background', 'aeroplane', 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningtable', 'dog', 'horse', 'motorbike', 'person', 'potted plant', 'sheep', 'sofa', 'train', 'tv/monitor']
With the two constants defined above, we can conveniently find the class index for each pixel in a label. We define the voc_colormap2label function to build the mapping from the above RGB color values to class indices, and the voc_label_indices function to map any RGB values to their class indices in this Pascal VOC2012 dataset. #@save def voc_colormap2label(): """Build the mapping from RGB to class indices for VOC labels.""" colormap2label = torch.zeros(256 ** 3, dtype=torch.long) for i, colormap in enumerate(VOC_COLORMAP): colormap2label[ (colormap[0] * 256 + colormap[1]) * 256 + colormap[2]] = i return colormap2label #@save def voc_label_indices(colormap, colormap2label): """Map any RGB values in VOC labels to their class indices.""" colormap = colormap.permute(1, 2, 0).numpy().astype('int32')
(continues on next page)
Semantic Segmentation and the Dataset
651

idx = ((colormap[:, :, 0] * 256 + colormap[:, :, 1]) * 256 + colormap[:, :, 2]) return colormap2label[idx]
For example, in the first example image, the class index for the front part of the airplane is 1, while the background index is 0. y = voc_label_indices(train_labels[0], voc_colormap2label()) y[105:115, 130:140], VOC_CLASSES[1]
(tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1]]), 'aeroplane')
Data Preprocessing
In previous experiments such as in Section 8.1‚ÄìSection 8.4, images are rescaled to fit the model‚Äôsrequiredinputshape. However, insemanticsegmentation, doingsorequiresrescal- ing the predicted pixel classes back to the original shape of the input image. Such rescaling may be inaccurate, especially for segmented regions with different classes. To avoid this issue, we crop the image to a fixed shape instead of rescaling. Specifically, using random cropping from image augmentation, we crop the same area of the input image and the la- bel. #@save def voc_rand_crop(feature, label, height, width): """Randomly crop both feature and label images.""" rect = torchvision.transforms.RandomCrop.get_params( feature, (height, width)) feature = torchvision.transforms.functional.crop(feature, *rect) label = torchvision.transforms.functional.crop(label, *rect) return feature, label
#@save
imgs = [] for _ in range(n): imgs += voc_rand_crop(train_features[0], train_labels[0], 200, 300) imgs = [img.permute(1, 2, 0) for img in imgs] d2l.show_images(imgs[::2] + imgs[1::2], 2, n);
(continued from previous page)
Computer Vision
652


Custom Semantic Segmentation Dataset Class
We define a custom semantic segmentation dataset class VOCSegDataset by inheriting the Dataset class provided by high-level APIs. By implementing the __getitem__ function, we can arbitrarily access the input image indexed as idx in the dataset and the class index of each pixel in this image. Since some images in the dataset have a smaller size than the output size of random cropping, these examples are filtered out by a custom filter function. In addition, we also define the normalize_image function to standardize the values of the three RGB channels of input images. #@save class VOCSegDataset(torch.utils.data.Dataset): """A customized dataset to load the VOC dataset.""" def __init__(self, is_train, crop_size, voc_dir): self.transform = torchvision.transforms.Normalize( mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]) self.crop_size = crop_size features, labels = read_voc_images(voc_dir, is_train=is_train) self.features = [self.normalize_image(feature) for feature in self.filter(features)] self.labels = self.filter(labels) self.colormap2label = voc_colormap2label() print('read ' + str(len(self.features)) + ' examples') def normalize_image(self, img): return self.transform(img.float() / 255) def filter(self, imgs): return [img for img in imgs if ( img.shape[1] >= self.crop_size[0] and img.shape[2] >= self.crop_size[1])] def __getitem__(self, idx): feature, label = voc_rand_crop(self.features[idx], self.labels[idx], *self.crop_size) return (feature, voc_label_indices(label, self.colormap2label)) def __len__(self): return len(self.features)
Semantic Segmentation and the Dataset
653

Reading the Dataset
We use the custom VOCSegDataset class to create instances of the training set and test set, respectively. Suppose that we specify that the output shape of randomly cropped images is 320 x 480. Below we can view the number of examples that are retained in the training set and test set. crop_size = (320, 480) voc_train = VOCSegDataset(True, crop_size, voc_dir) voc_test = VOCSegDataset(False, crop_size, voc_dir)
read 1114 examples
read 1078 examples
Setting the batch size to 64, we define the data iterator for the training set. Let‚Äôs print the shape of the first minibatch. Different from in image classification or object detection, labels here are three-dimensional tensors. labels here are three-dimensional tensors. batch_size = 64 train_iter = torch.utils.data.DataLoader(voc_train, batch_size, shuffle=True, drop_last=True, num_workers=d2l.get_dataloader_workers()) for X, Y in train_iter: print(X.shape) print(Y.shape) break
torch.Size([64, 3, 320, 480]) torch.Size([64, 320, 480])
Putting It All Together
Finally, we define the following load_data_voc function to download and read the Pascal VOC2012 semantic segmentation dataset. It returns data iterators for both the training and test datasets. #@save def load_data_voc(batch_size, crop_size): """Load the VOC semantic segmentation dataset.""" voc_dir = d2l.download_extract('voc2012', os.path.join( 'VOCdevkit', 'VOC2012')) num_workers = d2l.get_dataloader_workers() train_iter = torch.utils.data.DataLoader( VOCSegDataset(True, crop_size, voc_dir), batch_size, shuffle=True, drop_last=True, num_workers=num_workers) test_iter = torch.utils.data.DataLoader( VOCSegDataset(False, crop_size, voc_dir), batch_size, drop_last=True, num_workers=num_workers) return train_iter, test_iter
Computer Vision
654

14.9.3 Summary
e Semantic segmentation recognizes and understands what are in an image in pixel level
by dividing the image into regions belonging to different semantic classes. e One of the most important semantic segmentation dataset is Pascal VOC2012. e In semantic segmentation, since the input image and label correspond one-to-one on the
pixel, the input image is randomly cropped to a fixed shape rather than rescaled. 14.9.4 Exercises
1. How can semantic segmentation be applied in autonomous vehicles and medical image diagnostics? Can you think of other applications?bubu2. Recall the descriptions of data augmentation in Section 14.1. Which of the image aug- mentation methods used in image classification would be infeasible to be applied in semantic segmentation? 221 Discussions221. 14.10 Transposed Convolution
es
The CNN layers we have seen so far, such as convolutional layers (Section 7.2) and pool- ing layers (Section 7.5), typically reduce (downsample) the spatial dimensions (height and width) of the input, or keep them unchanged. In semantic segmentation that classifies at pixel-level, it will be convenient if the spatial dimensions of the input and output are the same. For example, the channel dimension at one output pixel can hold the classification results for the input pixel at the same spatial position. To achieve this, especially after the spatial dimensions are reduced by CNN layers, we can use another type of CNN layers that can increase (upsample) the spatial dimensions of intermediate feature maps. In this section, we will introduce transposed convolution, which is also called fractionally-strided convolution (Dumoulin and Visin, 2016), for reversing downsampling operations by the convolution. import torch from torch import nn from d2l import torch as d2l
14.10.1 Basic Operation
Ignoring channels for now, let‚Äôs begin with the basic transposed convolution operation with stride of 1 and no padding. Suppose that we are given a nj X ny input tensor and a ky, X ky kernel. Sliding the kernel window with stride of 1 for n,, times in each row and ny times
Transposed Convolution
655

in each column yields a total of ùëõ‚Ñéùëõùë§ intermediate results. Each intermediate result is
in each column yields a total of npn, intermediate results. Each intermediate result is a (npn + kn ‚Äî 1) X (ny + ky ‚Äî 1) tensor that are initialized as zeros. To compute each intermediate tensor, each element in the input tensor is multiplied by the kernel so that the resulting k;, x k,, tensor replaces a portion in each intermediate tensor. Note that the position of the replaced portion in each intermediate tensor corresponds to the position of the element in the input tensor used for the computation. In the end, all the intermediate results are summed over to produce the output. As an example, Fig. 14.10.1 illustrates how transposed convolution with a 2 x 2 kernel is
As an example, Fig. 14.10.1 illustrates how transposed convolution with a 2 x 2 kernel is computed for a 2 x 2 input tensor. Input Kernel O11} | transposed | | 9 | 1 2/13 Conv 2)3 Output o;}o0 o;1 oyo;}4 =|0/0 + 2/3)+]0]2 + O;3}=/0]4)6 4/6 6/9 4112) 9
4/6 6/9 4112) 9 Transposed convolution with a 2 x 2 kernel. The shaded portions are a portion of an
intermediate tensor as well as the input and kernel tensor elements used for the computation. We can implement this basic transposed convolution operation trans_conv for a input matrix X and a kernel matrix K. def trans_conv(X, K): h, w = K.shape Y = torch.zeros((X.shape[0] + h - 1, X.shape[1] + w - 1)) for i in range(X.shape[0]): for j in range(X.shape[1]): Y[i: i + h, j: j + w] += X[i, j] * K return Y
In contrast to the regular convolution (in Section 7.2) that reduces input elements via the kernel, the transposed convolution broadcasts input elements via the kernel, thereby pro- ducing an output that is larger than the input. We can construct the input tensor X and the kernel tensor K from Fig. 14.10.1 to validate the output of the above implementation of the basic two-dimensional transposed convolution operation. X = torch.tensor([[0.0, 1.0], [2.0, 3.0]]) K = torch.tensor([[0.0, 1.0], [2.0, 3.0]]) trans_conv(X, K)
tensor([[ 0., 0., 1.], [ 0., 4., 6.], [ 4., 12., 9.]])
Computer Vision
656

Alternatively, when the input X and kernel K are both four-dimensional tensors, we can use high-level APIs to obtain the same results. X, K = X.reshape(1, 1, 2, 2), K.reshape(1, 1, 2, 2) tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, bias=False) tconv.weight.data = K tconv(X)
tensor([[[[ 0.,
0., 1.], [ 0., 4., 6.], [ 4., 12., 9.]]]], grad_fn=<ConvolutionBackward0>)
14.10.2 Padding, Strides, and Multiple Channels
Different from in the regular convolution where padding is applied to input, it is applied to output in the transposed convolution. For example, when specifying the padding number on either side of the height and width as 1, the first and last rows and columns will be removed from the transposed convolution output. tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, padding=1, bias=False) tconv.weight.data = K tconv(X)
tensor([[[[4.]]]], grad_fn=<ConvolutionBackward0>)
In the transposed convolution, strides are specified for intermediate results (thus output), not for input. Using the same input and kernel tensors from Fig. 14.10.1, changing the stride from 1 to 2 increases both the height and weight of intermediate tensors, hence the output tensor in Fig. 14.10.2. The following code snippet can validate the transposed convolution output for stride of 2 in Fig. 14.10.2. tconv = nn.ConvTranspose2d(1, 1, kernel_size=2, stride=2, bias=False) tconv.weight.data = K tconv(X)
tensor([[[[0., 0., 0., 1.], [0., 0., 2., 3.], [0., 2., 0., 3.], [4., 6., 6., 9.]]]], grad_fn=<ConvolutionBackward0>)
For multiple input and output channels, the transposed convolution works in the same way as the regular convolution. Suppose that the input has c; channels, and that the transposed convolution assigns a k;, x ky, kernel tensor to each input channel. When multiple output channels are specified, we will have a c; X kp X ky kernel for each output channel. Transposed Convolution
657

Input Kernel 0] 1] [transposed] [0] 4 Conv 2/3 (stride 2) 2|3 o|o of1 o|o 2/3 = + + + o}2 o|3 4|6 6|9 Output alololo @[rniolo 1 3 3 9 elo|nfo
9 Transposed convolution with a 2 x 2 kernel with stride of 2. The shaded portions are a
portion of an intermediate tensor as well as the input and kernel tensor elements used for the computation. As in all, if we feed X into a convolutional layer ùëì to output Y = ùëì ‚ÄûX‚Äù and create a trans-
posed convolutional layer ùëî with the same hyperparameters as ùëì except for the number of output channels being the number of channels in X, then ùëî‚Äûùëå‚Äù will have the same shape as X. This can be illustrated in the following example. X = torch.rand(size=(1, 10, 16, 16)) conv = nn.Conv2d(10, 20, kernel_size=5, padding=2, stride=3) tconv = nn.ConvTranspose2d(20, 10, kernel_size=5, padding=2, stride=3) tconv(conv(X)).shape == X.shape
True
14.10.3 Connection to Matrix Transposition
The transposed convolution is named after the matrix transposition. To explain, let‚Äôs first see how to implement convolutions using matrix multiplications. In the example below, we define a 3 x 3 input X and a 2 x 2 convolution kernel K, and then use the corr2d function to compute the convolution output Y. X = torch.arange(9.0).reshape(3, 3) K = torch.tensor([[1.0, 2.0], [3.0, 4.0]]) Y = d2l.corr2d(X, K) Y
tensor([[27., 37.], [57., 67.]])
Next, we rewrite the convolution kernel K as a sparse weight matrix W containing a lot of
Computer Vision
658

zeros. The shape of the weight matrix is (4, 9), where the non-zero elements come from the convolution kernel K. def kernel2matrix(K): k, W = torch.zeros(5), torch.zeros((4, 9)) k[:2], k[3:5] = K[0, :], K[1, :] W[0, :5], W[1, 1:6], W[2, 3:8], W[3, 4:] = k, k, k, k return W W = kernel2matrix(K) W
tensor([[1., 2., 0., 3., 4., 0., 0., 0., 0.], [0., 1., 2., 0., 3., 4., 0., 0., 0.], [0., 0., 0., 1., 2., 0., 3., 4., 0.], [0., 0., 0., 0., 1., 2., 0., 3., 4.]])
Concatenate the input X row by row to get a vector of length 9. Then the matrix multiplica- tion of W and the vectorized X gives a vector of length 4. After reshaping it, we can obtain the same result Y from the original convolution operation above: we just implemented con- volutions using matrix multiplications. Y == torch.matmul(W, X.reshape(-1)).reshape(2, 2)
tensor([[True, True], [True, True]])
Likewise, we can implement transposed convolutions using matrix multiplications. In the following example, we take the 2 x 2 output Y from the above regular convolution as input to the transposed convolution. To implement this operation by multiplying matrices, we only need to transpose the weight matrix W with the new shape (9, 4). Z = trans_conv(Y, K) Z == torch.matmul(W.T, Y.reshape(-1)).reshape(3, 3)
tensor([[True, True, True], [True, True, True], [True, True, True]])
Consider implementing the convolution by multiplying matrices. Given an input vector x and a weight matrix W, the forward propagation function of the convolution can be implemented by multiplying its input with the weight matrix and outputting a vector y = Wx. Since backpropagation follows the chain rule and rxy = W>, the backpropagation functionoftheconvolutioncanbeimplementedbymultiplyingitsinputwiththetransposed weight matrix W>. Therefore, the transposed convolutional layer can just exchange the forward propagation function and the backpropagation function of the convolutional layer:
Fully Convolutional Networks
659

itsforwardpropagationandbackpropagationfunctionsmultiplytheirinputvectorwithW>
and W, respectively. 14.10.4 Summary
In contrast to the regular convolution that reduces input elements via the kernel, the
transposed convolution broadcasts input elements via the kernel, thereby producing an output that is larger than the input. If we feed X into a convolutional layer f to output Y = f(X) and create a transposed
convolutional layer ùëî with the same hyperparameters as ùëì except for the number of outputchannelsbeingthenumberofchannelsinX, then ùëî‚Äûùëå‚Äù willhavethesameshape as X. We can implement convolutions using matrix multiplications. The transposed convolu-
tional layer can just exchange the forward propagation function and the backpropaga- tion function of the convolutional layer. 14.10.5 Exercises
1. In Section 14.10.3, the convolution input X and the transposed convolution output Z have the same shape. Do they have the same value?bubuWhy?bubu2. Is it efficient to use matrix multiplications to implement convolutions? Why?bubu222 Discussions222. 14.11 Fully Convolutional Networks
|
As discussed in Section 14.9, semantic segmentation classifies images in pixel level. A fully convolutional network (FCN) uses a convolutional neural network to transform image pixels to pixel classes (Long et al., 2015). Unlike the CNNs that we encountered earlier for image classification or object detection, a fully convolutional network transforms the height and width of intermediate feature maps back to those of the input image: this is achieved by the transposed convolutional layer introduced in Section 14.10. As a result, the classification output and the input image have a one-to-one correspondence in pixel level: the channel dimension at any output pixel holds the classification results for the input pixel at the same spatial position. %matplotlib inline import torch import torchvision from torch import nn from torch.nn import functional as F from d2l import torch as d2l
Computer Vision
660

14.11.1 The Model
Here we describe the basic design of the fully convolutional network model. As shown in Fig. 14.11.1, this model first uses a CNN to extract image features, then transforms the number of channels into the number of classes via a 1 x 1 convolutional layer, and finally transforms the height and width of the feature maps to those of the input image via the transposed convolution introduced in Section 14.10. As a result, the model output has the same height and width as the input image, where the output channel contains the predicted classes for the input pixel at the same spatial position. tFig. 14.11.1 Fully convolutional network. Below, we use a ResNet-18 model pretrained on the ImageNet dataset to extract image features and denote the model instance as pretrained_net. The last few layers of this model include a global average pooling layer and a fully connected layer: they are not needed in the fully convolutional network. pretrained_net = torchvision.models.resnet18(pretrained=True) list(pretrained_net.children())[-3:]
Downloading: "https://download.pytorch.org/models/resnet18-f37072fd.pth" to / ‚Ü©!home/ci/.cache/torch/hub/checkpoints/resnet18-f37072fd.pth 100%|| 44.7M/44.7M [00:00<00:00, 56.3MB/s]
[Sequential( (0): BasicBlock( (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1,‚ê£ ‚Ü©!1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_ ‚Ü©!running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1,‚ê£ ‚Ü©!1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_
Background
Cat
F
Transposed conv F 1x1 Conv F
CNN
F
(continues on next page)
Fully Convolutional Networks
661

‚Ü©!running_stats=True) (downsample): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_ ‚Ü©!running_stats=True) ) ) (1): BasicBlock( (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1,‚ê£ ‚Ü©!1), bias=False) (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_ ‚Ü©!running_stats=True) (relu): ReLU(inplace=True) (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1,‚ê£ ‚Ü©!1), bias=False) (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_ ‚Ü©!running_stats=True) ) ), AdaptiveAvgPool2d(output_size=(1, 1)), Linear(in_features=512, out_features=1000, bias=True)]
Next, we create the fully convolutional network instance net. It copies all the pretrained layers in the ResNet-18 except for the final global average pooling layer and the fully con- nected layer that are closest to the output. nected layer that are closest to the output. net = nn.Sequential(*list(pretrained_net.children())[:-2])
Given an input with height and width of 320 and 480 respectively, the forward propagation of net reduces the input height and width to 1/32 of the original, namely 10 and 15. X = torch.rand(size=(1, 3, 320, 480)) net(X).shape
torch.Size([1, 512, 10, 15])
Next, we use a | X 1 convolutional layer to transform the number of output channels into
Next, we use a | X 1 convolutional layer to transform the number of output channels into the number of classes (21) of the Pascal VOC2012 dataset. Finally, we need to increase the height and width of the feature maps by 32 times to change them back to the height and width of the input image. Recall how to calculate the output shape of a convolutional layer in Section 7.3. Since (320-64+ 16x 2+32)/32 = 10 and (480-644 16x 2+32)/32 = 15, we construct a transposed convolutional layer with stride of 32, setting the height and width of the kernel to 64, the padding to 16. In general, we can see that for stride s, padding s/2 (assuming s/2 is an integer), and the height and width of the kernel 2s, the transposed convolution will increase the height and width of the input by s times. (continued from previous page)
Computer Vision
662

num_classes = 21 net.add_module('final_conv', nn.Conv2d(512, num_classes, kernel_size=1)) net.add_module('transpose_conv', nn.ConvTranspose2d(num_classes, num_classes, kernel_size=64, padding=16, stride=32))
14.11.2 Initializing Transposed Convolutional Layers
We already know that transposed convolutional layers can increase the height and width of feature maps. In image processing, we may need to scale up an image, i.e., upsampling. Bilinear interpolation is one of the commonly used upsampling techniques. It is also often used for initializing transposed convolutional layers. To explain bilinear interpolation, say that given an input image we want to calculate each pixel of the upsampled output image. In order to calculate the pixel of the output image at coordinate ‚Äûùë•, ùë¶‚Äù, first map ‚Äûùë•, ùë¶‚Äù to coordinate ‚Äûùë•0, ùë¶0‚Äù on the input image, for example, according to the ratio of the input size to the output size. Note that the mapped ùë•0 and ùë¶0 are real numbers. Then, find the four pixels closest to coordinate ‚Äûùë•0, ùë¶0‚Äù on the input image. Finally, the pixel of the output image at coordinate ‚Äûùë•, ùë¶‚Äù is calculated based on these four closest pixels on the input image and their relative distance from ‚Äûùë•0, ùë¶0‚Äù. Upsampling of bilinear interpolation can be implemented by the transposed convolutional layer with the kernel constructed by the following bilinear_kernel function. Due to space limitations, we only provide the implementation of the bilinear_kernel function below without discussions on its algorithm design. def bilinear_kernel(in_channels, out_channels, kernel_size): factor = (kernel_size + 1) // 2 if kernel_size % 2 == 1: center = factor - 1 else: center = factor - 0.5 og = (torch.arange(kernel_size).reshape(-1, 1), torch.arange(kernel_size).reshape(1, -1)) filt = (1 - torch.abs(og[0] - center) / factor) * \ (1 - torch.abs(og[1] - center) / factor) weight = torch.zeros((in_channels, out_channels, kernel_size, kernel_size)) weight[range(in_channels), range(out_channels), :, :] = filt return weight
Let‚Äôs experiment with upsampling of bilinear interpolation that is implemented by a trans- posed convolutional layer. We construct a transposed convolutional layer that doubles the height and weight, and initialize its kernel with the bilinear_kernel function. conv_trans = nn.ConvTranspose2d(3, 3, kernel_size=4, padding=1, stride=2, bias=False)
conv_trans.weight.data.copy_(bilinear_kernel(3, 3, 4));
Fully Convolutional Networks
663

Read the image X and assign the upsampling output to Y. In order to print the image, we need to adjust the position of the channel dimension. img = torchvision.transforms.ToTensor()(d2l.Image.open('../img/catdog.jpg')) X = img.unsqueeze(0) Y = conv_trans(X) out_img = Y[0].permute(1, 2, 0).detach()
As we can see, the transposed convolutional layer increases both the height and width of the image by a factor of two. Except for the different scales in coordinates, the image scaled up by bilinear interpolation and the original image printed in Section 14.3 look the same. d2l.set_figsize() print('input image shape:', img.permute(1, 2, 0).shape) d2l.plt.imshow(img.permute(1, 2, 0)); print('output image shape:', out_img.shape) d2l.plt.imshow(out_img);
input image shape: torch.Size([561, 728, 3]) output image shape: torch.Size([1122, 1456, 3])

200
400
600
800
1000
ie)
In a fully convolutional network, we initialize the transposed convolutional layer with up- sampling of bilinear interpolation. For the 1 x 1 convolutional layer, we use Xavier initial- ization. W = bilinear_kernel(num_classes, num_classes, 64) net.transpose_conv.weight.data.copy_(W);
14.11.3 Reading the Dataset
We read the semantic segmentation dataset as introduced in Section 14.9. The output image shape of random cropping is specified as 320 x 480: both the height and width are divisible by 32. batch_size, crop_size = 32, (320, 480) train_iter, test_iter = d2l.load_data_voc(batch_size, crop_size)
500
1000
Computer Vision
664

read 1114 examples read 1078 examples
14.11.4 Training
Now we can train our constructed fully convolutional network. The loss function and ac- curacy calculation here are not essentially different from those in image classification of earlier chapters. Because we use the output channel of the transposed convolutional layer to predict the class for each pixel, the channel dimension is specified in the loss calculation. In addition, the accuracy is calculated based on correctness of the predicted class for all the pixels. def loss(inputs, targets):
return F.cross_entropy(inputs, targets, reduction='none').mean(1).mean(1)
num_epochs, lr, wd, devices = 5, 0.001, 1e-3, d2l.try_all_gpus() trainer = torch.optim.SGD(net.parameters(), lr=lr, weight_decay=wd) d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
loss 0.449, train acc 0.861, test acc 0.852
226.7 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
‚Äî train loss 0.24 --- train acc ‚Äî-= test acc 0.0 + T T T 1 2 3 4 5 epoch
14.11.5 Prediction
When predicting, we need to standardize the input image in each channel and transform the image into the four-dimensional input format required by the CNN. def predict(img): X = test_iter.dataset.normalize_image(img).unsqueeze(0) pred = net(X.to(devices[0])).argmax(dim=1) return pred.reshape(pred.shape[1], pred.shape[2])
To visualize the predicted class of each pixel, we map the predicted class back to its label color in the dataset. Fully Convolutional Networks
665

def label2image(pred): colormap = torch.tensor(d2l.VOC_COLORMAP, device=devices[0]) X = pred.long() return colormap[X, :]
Images in the test dataset vary in size and shape. Since the model uses a transposed con- volutional layer with stride of 32, when the height or width of an input image is indivisible by 32, the output height or width of the transposed convolutional layer will deviate from the shape of the input image. In order to address this issue, we can crop multiple rectangu- lar areas with height and width that are integer multiples of 32 in the image, and perform forward propagation on the pixels in these areas separately. Note that the union of these rectangular areas needs to completely cover the input image. When a pixel is covered by multiple rectangular areas, the average of the transposed convolution outputs in separate areas for this same pixel can be input to the softmax operation to predict the class. For simplicity, we only read a few larger test images, and crop a 320480 area for prediction
startingfromtheupper-leftcornerofanimage. Forthesetestimages, weprinttheircropped areas, prediction results, and ground-truth row by row. voc_dir = d2l.download_extract('voc2012', 'VOCdevkit/VOC2012') test_images, test_labels = d2l.read_voc_images(voc_dir, False) n, imgs = 4, [] for i in range(n): crop_rect = (0, 0, 320, 480) X = torchvision.transforms.functional.crop(test_images[i], *crop_rect) pred = label2image(predict(X)) imgs += [X.permute(1,2,0), pred.cpu(), torchvision.transforms.functional.crop( test_labels[i], *crop_rect).permute(1,2,0)] d2l.show_images(imgs[::3] + imgs[1::3] + imgs[2::3], 3, n, scale=2);












Computer Vision
666

14.11.6 Summary
e The fully convolutional network first uses a CNN to extract image features, then trans-
e The fully convolutional network first uses a CNN to extract image features, then trans- forms the number of channels into the number of classes via a 1 xX 1 convolutional layer, and finally transforms the height and width of the feature maps to those of the input image via the transposed convolution. e In a fully convolutional network, we can use upsampling of bilinear interpolation to
initialize the transposed convolutional layer.bubu14.11.7 Exercises
1. If we use Xavier initialization for the transposed convolutional layer in the experiment, how does the result change? 2.bubuCan you further improve the accuracy of the model by tuning the hyperparameters? 3. Predict the classes of all pixels in test images. 4. The original fully convolutional network paper also uses outputs of some intermediate CNN layers (Long et al., 2015). Try to implement this idea.bubuDiscussions223. 223
14.12 Neural Style Transfer
a
If you are a photography enthusiast, you may be familiar with the filter. It can change the color style of photos so that landscape photos become sharper or portrait photos have whitened skins. However, one filter usually only changes one aspect of the photo. To apply an ideal style to a photo, you probably need to try many different filter combinations. This process is as complex as tuning the hyperparameters of a model. In this section, we will leverage layerwise representations of a CNN to automatically apply the style of one image to another image, i.e., style transfer (Gatys et al., 2016). This task needs two input images: one is the content image and the other is the style image. We will use neural networks to modify the content image to make it close to the style image in style. For example, the content image in Fig. 14.12.1 is a landscape photo taken by us in Mount Rainier National Park in the suburbs of Seattle, while the style image is an oil painting with the theme of autumn oak trees. In the output synthesized image, the oil brush strokes of the style image are applied, leading to more vivid colors, while preserving the main shape of the objects in the content image.bubu14.12.1 Method
Fig. 14.12.2 illustrates the CNN-based style transfer method with a simplified example. First, we initialize the synthesized image, for example, into the content image. This syn-
Neural Style Transfer
667

Content image


Style image

tFig. 14.12.1 Given content and style images, style transfer outputs a synthesized image. thesizedimageistheonlyvariablethatneedstobeupdatedduringthestyletransferprocess, i.e., the model parameters to be updated during training. Then we choose a pretrained CNN to extract image features and freeze its model parameters during training. This deep CNN uses multiple layers to extract hierarchical features for images. We can choose the output of some of these layers as content features or style features. Take Fig. 14.12.2 as an exam- ple. The pretrained neural network here has 3 convolutional layers, where the second layer outputs the content features, and the first and third layers output the style features. Conv +1 Content loss } Conv L-Oxs| Conv + +1 H Style loss Conv EO -4 +1 \
Conv 7
Conv 7

Content image
Synthesized image
tFig. 14.12.2 CNN-based style transfer process. Solid lines show the direction of forward propagation
and dotted lines show backward propagation. Next, we calculate the loss function of style transfer through forward propagation (direc- tion of solid arrows), and update the model parameters (the synthesized image for output) through backpropagation (direction of dashed arrows). The loss function commonly used in style transfer consists of three parts: (i) content loss makes the synthesized image and the content image close in content features; (ii) style loss makes the synthesized image and style image close in style features; and (iii) total variation loss helps to reduce the noise in the synthesized image. Finally, when the model training is over, we output the model parameters of the style transfer to generate the final synthesized image. In the following, we will explain the technical details of style transfer via a concrete exper- iment. Synthesized image
Style loss
7
Conv
+
Conv
7
Conv
7


Style image
Computer Vision
668

14.12.2 Reading the Content and Style Images
First, we read the content and style images. From their printed coordinate axes, we can tell that these images have different sizes. %matplotlib inline import torch import torchvision from torch import nn from d2l import torch as d2l
d2l.set_figsize() content_img = d2l.Image.open('../img/rainier.jpg') d2l.plt.imshow(content_img);

500
style_img = d2l.Image.open('../img/autumn-oak.jpg') d2l.plt.imshow(style_img);

14.12.3 Preprocessing and Postprocessing
Below, we define two functions for preprocessing and postprocessing images. The pre- process function standardizes each of the three RGB channels of the input image and transforms the results into the CNN input format. The postprocess function restores the pixel values in the output image to their original values before standardization. Since the image printing function requires that each pixel has a floating point value from 0 to 1, we replace any value smaller than 0 or greater than 1 with 0 or 1, respectively. 1000
1500
2000
1500
Neural Style Transfer
669

rgb_mean = torch.tensor([0.485, 0.456, 0.406]) rgb_std = torch.tensor([0.229, 0.224, 0.225]) def preprocess(img, image_shape): transforms = torchvision.transforms.Compose([ torchvision.transforms.Resize(image_shape), torchvision.transforms.ToTensor(), torchvision.transforms.Normalize(mean=rgb_mean, std=rgb_std)]) return transforms(img).unsqueeze(0) def postprocess(img): img = img[0].to(rgb_std.device) img = torch.clamp(img.permute(1, 2, 0) * rgb_std + rgb_mean, 0, 1) return torchvision.transforms.ToPILImage()(img.permute(2, 0, 1))
14.12.4 Extracting Features
We use the VGG-19 model pretrained on the ImageNet dataset to extract image features (Gatys et al., 2016). pretrained_net = torchvision.models.vgg19(pretrained=True)
Downloading: "https://download.pytorch.org/models/vgg19-dcbb9e9d.pth" to /home/ ‚Ü©!ci/.cache/torch/hub/checkpoints/vgg19-dcbb9e9d.pth 100%|| 548M/548M [00:02<00:00, 213MB/s]
In order to extract the content features and style features of the image, we can select the output of certain layers in the VGG network. Generally speaking, the closer to the input layer, the easier to extract details of the image, and vice versa, the easier to extract the global information of the image. In order to avoid excessively retaining the details of the content image in the synthesized image, we choose a VGG layer that is closer to the output as the content layer to output the content features of the image. We also select the output of different VGG layers for extracting local and global style features. These layers are also called style layers. As mentioned in Section 8.2, the VGG network uses 5 convolutional blocks. Intheexperiment, wechoosethelastconvolutionallayerofthefourthconvolutional block as the content layer, and the first convolutional layer of each convolutional block as the style layer. The indices of these layers can be obtained by printing the pretrained_net instance. style_layers, content_layers = [0, 5, 10, 19, 28], [25]
When extracting features using VGG layers, we only need to use all those from the input layer to the content layer or style layer that is closest to the output layer. Let‚Äôs construct a new network instance net, which only retains all the VGG layers to be used for feature extraction. Computer Vision
670

net = nn.Sequential(*[pretrained_net.features[i] for i in range(max(content_layers + style_layers) + 1)])
Given the input X, if we simply invoke the forward propagation net(X), we can only get the output of the last layer. Since we also need the outputs of intermediate layers, we need to perform layer-by-layer computation and keep the content and style layer outputs. def extract_features(X, content_layers, style_layers): contents = [] styles = [] for i in range(len(net)): X = net[i](X) if i in style_layers: styles.append(X) if i in content_layers: contents.append(X) return contents, styles
Two functions are defined below: the get_contents function extracts content features from the content image, and the get_styles function extracts style features from the style image. Since there is no need to update the model parameters of the pretrained VGG during training, we can extract the content and the style features even before the training starts. Since the synthesized image is a set of model parameters to be updated for style transfer, we can only extract the content and style features of the synthesized image by calling the extract_features function during training. def get_contents(image_shape, device): content_X = preprocess(content_img, image_shape).to(device) contents_Y, _ = extract_features(content_X, content_layers, style_layers) return content_X, contents_Y def get_styles(image_shape, device): style_X = preprocess(style_img, image_shape).to(device) _, styles_Y = extract_features(style_X, content_layers, style_layers) return style_X, styles_Y
14.12.5 Defining the Loss Function
Now we will describe the loss function for style transfer. The loss function consists of the content loss, style loss, and total variation loss. Content Loss
Similar to the loss function in linear regression, the content loss measures the difference in content features between the synthesized image and the content image via the squared loss function. The two inputs of the squared loss function are both outputs of the content layer computed by the extract_features function. Neural Style Transfer
671

def content_loss(Y_hat, Y):
# We detach the target content from the tree used to dynamically compute # the gradient: this is a stated value, not a variable. Otherwise the loss # will throw an error. return torch.square(Y_hat - Y.detach()).mean()
Style loss, similar to content loss, also uses the squared loss function to measure the dif- ference in style between the synthesized image and the style image. To express the style output of any style layer, we first use the extract_features function to compute the style layer output. Suppose that the output has 1 example, ùëê channels, height ‚Ñé, and width ùë§, we can transform this output into matrix X with ùëê rows and ‚Ñéùë§ columns. This matrix can be thought of as the concatenation of ùëê vectors x1, . . .,xùëê, each of which has a length of ‚Ñéùë§. Here, vector xùëñ represents the style feature of channel ùëñ. In the Gram matrix of these vectors XXT ‚Ç¨ R¬∞*¬∞, element x; j in row 7 and column j is
the dot product of vectors xùëñ and xùëó. It represents the correlation of the style features of channels ùëñ and ùëó. We use this Gram matrix to represent the style output of any style layer. Note that when the value of ‚Ñéùë§ is larger, it likely leads to larger values in the Gram matrix. Note also that the height and width of the Gram matrix are both the number of channels ùëê. To allow style loss not to be affected by these values, the gram function below divides the Gram matrix by the number of its elements, i.e., ùëê‚Ñéùë§. def gram(X): num_channels, n = X.shape[1], X.numel() // X.shape[1] X = X.reshape((num_channels, n)) return torch.matmul(X, X.T) / (num_channels * n)
def gram(X):
Obviously, the two Gram matrix inputs of the squared loss function for style loss are based on the style layer outputs for the synthesized image and the style image. It is assumed here that the Gram matrix gram_Y based on the style image has been precomputed. def style_loss(Y_hat, gram_Y):
return torch.square(gram(Y_hat) - gram_Y.detach()).mean()
Total Variation Loss
Sometimes, the learned synthesized image has a lot of high-frequency noise, i.e., particu- larly bright or dark pixels. One common noise reduction method is total variation denois- ing. Denote by ùë•ùëñ, ùëó the pixel value at coordinate ‚Äûùëñ, ùëó‚Äù. Reducing total variation loss
¬ª xi ‚Äî xia.) + bj ‚Äîxi,j+1| (14.12.1) ij
makes values of neighboring pixels on the synthesized image closer. Style Loss
Computer Vision
672

def tv_loss(Y_hat): return 0.5 * (torch.abs(Y_hat[:, :, 1:, :] - Y_hat[:, :, :-1, :]).mean() + torch.abs(Y_hat[:, :, :, 1:] - Y_hat[:, :, :, :-1]).mean())
Loss Function
The loss function of style transfer is the weighted sum of content loss, style loss, and total variation loss. By adjusting these weight hyperparameters, we can balance among content retention, style transfer, and noise reduction on the synthesized image. content_weight, style_weight, tv_weight = 1, 1e4, 10
def compute_loss(X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram): # Calculate the content, style, and total variance losses respectively contents_l = [content_loss(Y_hat, Y) * content_weight for Y_hat, Y in zip( contents_Y_hat, contents_Y)]
styles_l = [style_loss(Y_hat, Y) * style_weight for Y_hat, Y in zip(
styles_Y_hat, styles_Y_gram)]
tv_l = tv_loss(X) * tv_weight
# Add up all the losses
l = sum(styles_l + contents_l + [tv_l])
return contents_l, styles_l, tv_l, l
14.12.6 Initializing the Synthesized Image
In style transfer, the synthesized image is the only variable that needs to be updated during training. Thus, we can define a simple model, SynthesizedImage, and treat the synthe- sized image as the model parameters.bubuIn this model, forward propagation just returns the model parameters. class SynthesizedImage(nn.Module): def __init__(self, img_shape, **kwargs): super(SynthesizedImage, self).__init__(**kwargs) self.weight = nn.Parameter(torch.rand(*img_shape)) def forward(self): return self.weight
Next, we define the get_inits function. This function creates a synthesized image model instance and initializes it to the image X. Gram matrices for the style image at various style layers, styles_Y_gram, are computed prior to training. def get_inits(X, device, lr, styles_Y): gen_img = SynthesizedImage(X.shape).to(device) gen_img.weight.data.copy_(X.data) trainer = torch.optim.Adam(gen_img.parameters(), lr=lr) styles_Y_gram = [gram(Y) for Y in styles_Y] return gen_img(), styles_Y_gram, trainer
Neural Style Transfer
673

14.12.7 Training
When training the model for style transfer, we continuously extract content features and style features of the synthesized image, and calculate the loss function. Below defines the training loop. def train(X, contents_Y, styles_Y, device, lr, num_epochs, lr_decay_epoch):
X, styles_Y_gram, trainer = get_inits(X, device, lr, styles_Y) scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_decay_epoch, 0.8) animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[10, num_epochs], legend=['content', 'style', 'TV'], ncols=2, figsize=(7, 2.5)) for epoch in range(num_epochs): trainer.zero_grad() contents_Y_hat, styles_Y_hat = extract_features( X, content_layers, style_layers) contents_l, styles_l, tv_l, l = compute_loss( X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram) l.backward() trainer.step() scheduler.step() if (epoch + 1) % 10 == 0: animator.axes[1].imshow(postprocess(X)) animator.add(epoch + 1, [float(sum(contents_l)), float(sum(styles_l)), float(tv_l)]) return X
Now we start to train the model. We rescale the height and width of the content and style images to 300 by 450 pixels.bubuWe use the content image to initialize the synthesized im- age. device, image_shape = d2l.try_gpu(), (300, 450) # PIL Image (h, w) net = net.to(device) content_X, contents_Y = get_contents(image_shape, device) _, styles_Y = get_styles(image_shape, device) output = train(content_X, contents_Y, styles_Y, device, 0.3, 500, 50)
‚Äî content
We can see that the synthesized image retains the scenery and objects of the content image, and transfers the color of the style image at the same time. For example, the synthesized

Computer Vision
674

image has blocks of color like those in the style image. Some of these blocks even have the subtle texture of brush strokes. 14.12.8 Summary
e The loss function commonly used in style transfer consists of three parts: (i) content loss
makes the synthesized image and the content image close in content features; (ii) style loss makes the synthesized image and style image close in style features; and (iii) total variation loss helps to reduce the noise in the synthesized image. e We can use a pretrained CNN to extract image features and minimize the loss function
to continuously update the synthesized image as model parameters during training. e We use Gram matrices to represent the style outputs from the style layers. 14.12.9 Exercises
1. How does the output change when you select different content and style layers? 2. Adjust the weight hyperparameters in the loss function. Does the output retain more content or have less noise?bubu3. Use different content and style images. Can you create more interesting synthesized images? 4. Can we apply style transfer for text? Hint: you may refer to the survey paper by Hu et al. (2022).bubu224
Discussions224. 14.13 Image Classification (CIFAR-10) on Kaggle
es
So far, we have been using high-level APIs of deep learning frameworks to directly obtain image datasets in tensor format. However, custom image datasets often come in the form of image files. In this section, we will start from raw image files, and organize, read, then transform them into tensor format step by step. We experimented with the CIFAR-10 dataset in Section 14.1, which is an important dataset in computer vision. In this section, we will apply the knowledge we learned in previous sections to practice the Kaggle competition of CIFAR-10 image classification. The web address of the competition is https://www.kaggle.com/c/cifar-10
Fig. 14.13.1 shows the information on the competition‚Äôs webpage. In order to submit the results, you need to register a Kaggle account. Image ClassiÔ¨Åcation (CIFAR-10) on Kaggle
675

a | wi CIFAR-10 - Object Recognition in Images Hable Identify the subject of 60,000 labeled images = 2] Yo has re 231 teams - 4 years ago Overview Data Discussion Leaderboard Rules Overview Description CIFAR-10 is an established computer-vision dataset used for object recognition. It is a subset of the 80 million tiny images dataset and consists of 60,000 32x32 color images containing one of 10 object classes, with 6000 images per class. It was collected by Alex Krizhevsky, Vinod Nair, and Geoffrey Hinton. Evaluation
tFig. 14.13.1 CIFAR-10 image classiÔ¨Åcation competition webpage information. The competition
dataset can be obtained by clicking the ‚ÄúData‚Äù tab. import collections import math import os import shutil import pandas as pd import torch import torchvision from torch import nn from d2l import torch as d2l
14.13.1 Obtaining and Organizing the Dataset
The competition dataset is divided into a training set and a test set, which contain 50000 and 300000 images, respectively. In the test set, 10000 images will be used for evaluation, while the remaining 290000 images will not be evaluated: they are included just to make it hard to cheat with manually labeled results of the test set. The images in this dataset are all png color (RGB channels) image files, whose height and width are both 32 pixels. The images cover a total of 10 categories, namely airplanes, cars, birds, cats, deer, dogs, frogs, horses, boats, and trucks. The upper-left corner of Fig. 14.13.1 shows some images of airplanes, cars, and birds in the dataset. Downloading the Dataset
After logging in to Kaggle, we can click the ‚ÄúData‚Äù tab on the CIFAR-10 image classifi- cation competition webpage shown in Fig. 14.13.1 and download the dataset by clicking the ‚ÄúDownload All‚Äù button. After unzipping the downloaded file in ../data, and un- zipping train.7z and test.7z inside it, you will find the entire dataset in the following paths:
e ../data/cifar-10/train/[1-50000]. png
e ../data/cifar-10/test/[1-300000]. png
Computer Vision
676

e ../data/cifar-10/trainLabels.csv
e ../data/cifar-10/sampleSubmission.csv
where the train and test directories contain the training and testing images, respectively, trainLabels.csv provides labels for the training images, and sample_submission.csv is a sample submission file. To make it easier to get started, we provide a small-scale sample of the dataset that contains the first 1000 training images and 5 random testing images. To use the full dataset of the Kaggle competition, you need to set the following demo variable to False. #@save d2l.DATA_HUB['cifar10_tiny'] = (d2l.DATA_URL + 'kaggle_cifar10_tiny.zip', '2068874e4b9a9f0fb07ebe0ad2b29754449ccacd') # If you use the full dataset downloaded for the Kaggle competition, set # `demo` to False demo = True if demo: data_dir = d2l.download_extract('cifar10_tiny') else: data_dir = '../data/cifar-10/'
Downloading ../data/kaggle_cifar10_tiny.zip from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/kaggle_cifar10_tiny.zip... Organizing the Dataset
We need to organize datasets to facilitate model training and testing. Let‚Äôs first read the labels from the csv file. The following function returns a dictionary that maps the non- extension part of the filename to its label. #@save def read_csv_labels(fname): """Read `fname` to return a filename to label dictionary.""" with open(fname, 'r') as f: # Skip the file header line (column name) lines = f.readlines()[1:] tokens = [l.rstrip().split(',') for l in lines] return dict(((name, label) for name, label in tokens)) labels = read_csv_labels(os.path.join(data_dir, 'trainLabels.csv')) print('# training examples:', len(labels)) print('# classes:', len(set(labels.values())))
# training examples: 1000 # classes: 10
Image ClassiÔ¨Åcation (CIFAR-10) on Kaggle
677

Next, we define the reorg_train_valid function to split the validation set out of the orig- inal training set. The argument valid_ratio in this function is the ratio of the number of examples in the validation set to the number of examples in the original training set.bubuMore concretely, let ùëõ be the number of images of the class with the least examples, and ùëü be the ratio. The validation set will split out max‚Äûbùëõùëüc,1‚Äù images for each class. Let‚Äôs use valid_ratio=0.1 as an example. Since the original training set has 50000 images, there will be 45000 images used for training in the path train_valid_test/train, while the other 5000 images will be split out as validation set in the path train_valid_test/ valid. After organizing the dataset, images of the same class will be placed under the same folder. #@save def copyfile(filename, target_dir): """Copy a file into a target directory.""" os.makedirs(target_dir, exist_ok=True) shutil.copy(filename, target_dir) #@save def reorg_train_valid(data_dir, labels, valid_ratio): """Split the validation set out of the original training set.""" # The number of examples of the class that has the fewest examples in the # training dataset n = collections.Counter(labels.values()).most_common()[-1][1] # The number of examples per class for the validation set n_valid_per_label = max(1, math.floor(n * valid_ratio)) label_count = {} for train_file in os.listdir(os.path.join(data_dir, 'train')): label = labels[train_file.split('.')[0]] fname = os.path.join(data_dir, 'train', train_file) copyfile(fname, os.path.join(data_dir, 'train_valid_test', 'train_valid', label)) if label not in label_count or label_count[label] < n_valid_per_label: copyfile(fname, os.path.join(data_dir, 'train_valid_test', 'valid', label)) label_count[label] = label_count.get(label, 0) + 1 else: copyfile(fname, os.path.join(data_dir, 'train_valid_test', 'train', label)) return n_valid_per_label
The reorg_test function below organizes the testing set for data loading during predic- tion. #@save def reorg_test(data_dir): """Organize the testing set for data loading during prediction.""" for test_file in os.listdir(os.path.join(data_dir, 'test')): copyfile(os.path.join(data_dir, 'test', test_file), os.path.join(data_dir, 'train_valid_test', 'test', 'unknown'))
Computer Vision
678

Finally, we use a function to invoke the read_csv_labels, reorg_train_valid, and re- org_test functions defined above. def reorg_cifar10_data(data_dir, valid_ratio): labels = read_csv_labels(os.path.join(data_dir, 'trainLabels.csv')) reorg_train_valid(data_dir, labels, valid_ratio) reorg_test(data_dir)
Here we only set the batch size to 32 for the small-scale sample of the dataset. When training and testing the complete dataset of the Kaggle competition, batch_size should be set to a larger integer, such as 128. We split out 10% of the training examples as the validation set for tuning hyperparameters. batch_size = 32 if demo else 128 valid_ratio = 0.1 reorg_cifar10_data(data_dir, valid_ratio)
14.13.2 Image Augmentation
We use image augmentation to address overfitting. For example, images can be flipped hor- izontally at random during training. We can also perform standardization for the three RGB channels of color images. Below lists some of these operations that you can tweak. transform_train = torchvision.transforms.Compose([
# Scale the image up to a square of 40 pixels in both height and width torchvision.transforms.Resize(40), # Randomly crop a square image of 40 pixels in both height and width to # produce a small square of 0.64 to 1 times the area of the original # image, and then scale it to a square of 32 pixels in both height and # width torchvision.transforms.RandomResizedCrop(32, scale=(0.64, 1.0), ratio=(1.0, 1.0)), torchvision.transforms.RandomHorizontalFlip(), torchvision.transforms.ToTensor(), # Standardize each channel of the image torchvision.transforms.Normalize([0.4914, 0.4822, 0.4465], [0.2023, 0.1994, 0.2010])])
During testing, we only perform standardization on images so as to remove randomness in the evaluation results. transform_test = torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), torchvision.transforms.Normalize([0.4914, 0.4822, 0.4465], [0.2023, 0.1994, 0.2010])])
14.13.3 Reading the Dataset
Next, we read the organized dataset consisting of raw image files. Each example includes an image and a label. Image ClassiÔ¨Åcation (CIFAR-10) on Kaggle
679

train_ds, train_valid_ds = [torchvision.datasets.ImageFolder( os.path.join(data_dir, 'train_valid_test', folder), transform=transform_train) for folder in ['train', 'train_valid']] valid_ds, test_ds = [torchvision.datasets.ImageFolder( os.path.join(data_dir, 'train_valid_test', folder), transform=transform_test) for folder in ['valid', 'test']]
During training, we need to specify all the image augmentation operations defined above. When the validation set is used for model evaluation during hyperparameter tuning, no randomness from image augmentation should be introduced. Before final prediction, we train the model on the combined training set and validation set to make full use of all the labeled data. train_iter, train_valid_iter = [torch.utils.data.DataLoader( dataset, batch_size, shuffle=True, drop_last=True) for dataset in (train_ds, train_valid_ds)]
valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size, shuffle=False, drop_last=True)
test_iter = torch.utils.data.DataLoader(test_ds, batch_size, shuffle=False, drop_last=False)
14.13.4 Defining the Model
We define the ResNet-18 model described in Section 8.6. def get_net(): num_classes = 10 net = d2l.resnet18(num_classes, 3) return net
loss = nn.CrossEntropyLoss(reduction="none")
14.13.5 Defining the Training Function
We will select models and tune hyperparameters according to the model‚Äôs performance on the validation set. In the following, we define the model training function train. def train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,
lr_decay): trainer = torch.optim.SGD(net.parameters(), lr=lr, momentum=0.9, weight_decay=wd) scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_period, lr_decay) num_batches, timer = len(train_iter), d2l.Timer() legend = ['train loss', 'train acc'] if valid_iter is not None: legend.append('valid acc')
(continues on next page)
Computer Vision
680

animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], legend=legend) net = nn.DataParallel(net, device_ids=devices).to(devices[0]) for epoch in range(num_epochs): net.train() metric = d2l.Accumulator(3) for i, (features, labels) in enumerate(train_iter): timer.start() l, acc = d2l.train_batch_ch13(net, features, labels, loss, trainer, devices) metric.add(l, acc, labels.shape[0]) timer.stop() if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (metric[0] / metric[2], metric[1] / metric[2], None)) if valid_iter is not None: valid_acc = d2l.evaluate_accuracy_gpu(net, valid_iter) animator.add(epoch + 1, (None, None, valid_acc)) scheduler.step() measures = (f'train loss {metric[0] / metric[2]:.3f}, ' f'train acc {metric[1] / metric[2]:.3f}') if valid_iter is not None: measures += f', valid acc {valid_acc:.3f}' print(measures + f'\n{metric[2] * num_epochs / timer.sum():.1f}' f' examples/sec on {str(devices)}')
14.13.6 Training and Validating the Model
Now, we can train and validate the model. All the following hyperparameters can be tuned.bubuFor example, we can increase the number of epochs. When lr_period and lr_decay are set to 4 and 0.9, respectively, the learning rate of the optimization algorithm will be multiplied by 0.9 after every 4 epochs. Just for ease of demonstration, we only train 20 epochs here. devices, num_epochs, lr, wd = d2l.try_all_gpus(), 20, 2e-4, 5e-4 lr_period, lr_decay, net = 4, 0.9, get_net() net(next(iter(train_iter))[0]) train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period, lr_decay)
train loss 0.654, train acc 0.789, valid acc 0.438 958.1 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
14.13.7 Classifying the Testing Set and Submitting Results on Kaggle
After obtaining a promising model with hyperparameters, we use all the labeled data (in-
cluding the validation set) to retrain the model and classify the testing set. (continued from previous page)
Image ClassiÔ¨Åcation (CIFAR-10) on Kaggle
681

‚Äî train loss 2.0 =-- train acc ‚Äî-- valid acc 15 1.0 wast 0.5 pre SNS 4 5 10 15 20 epoch
net, preds = get_net(), [] net(next(iter(train_valid_iter))[0]) train(net, train_valid_iter, None, num_epochs, lr, wd, devices, lr_period, lr_decay) for X, _ in test_iter: y_hat = net(X.to(devices[0])) preds.extend(y_hat.argmax(dim=1).type(torch.int32).cpu().numpy()) sorted_ids = list(range(1, len(test_ds) + 1)) sorted_ids.sort(key=lambda x: str(x)) df = pd.DataFrame({'id': sorted_ids, 'label': preds}) df['label'] = df['label'].apply(lambda x: train_valid_ds.classes[x]) df.to_csv('submission.csv', index=False)
train loss 0.608, train acc 0.786 1040.8 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
‚Äî train loss --~ train acc 2.0 15 1.0 0.5 aot epoch
The above code will generate a submission.csv file, whose format meets the requirement of the Kaggle competition. The method for submitting results to Kaggle is similar to that in Section 5.7. 14.13.8 Summary
e We can read datasets containing raw image files after organizing them into the required
format. Computer Vision
682

e We can use convolutional neural networks and image augmentation in an image classi-
fication competition. 14.13.9 Exercises
1.bubuUse the complete CIFAR-10 dataset for this Kaggle competition. Set hyperparameters as batch_size = 128, num_epochs = 100, lr = 0.1, lr_period = 50, and lr_decay = 0.1. See what accuracy and ranking you can achieve in this competition.bubuCan you further improve them?bubu2. What accuracy can you get when not using image augmentation?bubuDiscussions225. 225
225 & el
14.14 Dog Breed Identification (ImageNet Dogs) on Kaggle

In this section, we will practice the dog breed identification problem on Kaggle. The web address of this competition is https://www.kaggle.com/c/dog-breed-identification
In this competition, 120 different breeds of dogs will be recognized. In fact, the dataset for this competition is a subset of the ImageNet dataset. Unlike the images in the CIFAR-10 dataset in Section 14.13, the images in the ImageNet dataset are both higher and wider in varying dimensions. Fig.bubu14.14.1 shows the information on the competition‚Äôs webpage.bubuYou need a Kaggle account to submit your results. import os import torch import torchvision from torch import nn from d2l import torch as d2l
14.14.1 Obtaining and Organizing the Dataset
The competition dataset is divided into a training set and a test set, which contain 10222 and 10357 JPEG images of three RGB (color) channels, respectively. Among the training dataset, there are 120 breeds of dogs such as Labradors, Poodles, Dachshunds, Samoyeds, Huskies, Chihuahuas, and Yorkshire Terriers. Downloading the Dataset
After logging into Kaggle, you can click on the ‚ÄúData‚Äù tab on the competition webpage shown in Fig. 14.14.1 and download the dataset by clicking the ‚ÄúDownload All‚Äù button. After unzipping the downloaded file in ../data, you will find the entire dataset in the following paths:
Dog Breed IdentiÔ¨Åcation (ImageNet Dogs) on Kaggle
683

@ Playground Prediction Competition Dog Breed Identification Determine the breed of adoginan image Kaggle - 1,286 teams - 4 months ago Overview Data Kernels Discussion Leaderboard Rules. Overview Description Who's a good dog?bubuWho likes ear scratches? Well, it seems those fancy deep neural networks don't have all the answers. However, maybe they can answer that ubiquitous question we all ask when meeting a Evaluation four-legged stranger: what kind of good pup is that? In this playground competition, you are provided a strictly canine subset of ImageNet in order to practice fine-grained image categorization. How well you can tell your Norfolk Terriers from your Norwich Terriers? With 120 breeds of dogs and a limited number training images per class, you might find the problem more, err, ruff than you anticipated,
tFig. 14.14.1 The dog breed identiÔ¨Åcation competition website. The competition dataset can be
obtained by clicking the ‚ÄúData‚Äù tab. e ../data/dog-breed-identification/labels.csv
e ../data/dog-breed-identification/sample_submission.csv
e ../data/dog-breed-identification/train
e ../data/dog-breed-identification/test
YoumayhavenoticedthattheabovestructureissimilartothatoftheCIFAR-10competition in Section 14.13, where folders train/ and test/ contain training and testing dog images, respectively, and labels.csv contains the labels for the training images. Similarly, to make it easier to get started, we provide a small sample of the dataset mentioned above: train_valid_test_tiny.zip. If you are going to use the full dataset for the Kaggle competition, you need to change the demo variable below to False. #@save d2l.DATA_HUB['dog_tiny'] = (d2l.DATA_URL + 'kaggle_dog_tiny.zip', '0cb91d09b814ecdc07b50f31f8dcad3e81d6a86d') # If you use the full dataset downloaded for the Kaggle competition, change # the variable below to `False` demo = True if demo: data_dir = d2l.download_extract('dog_tiny')
(continues on next page)
Computer Vision
684

else: data_dir = os.path.join('..', 'data', 'dog-breed-identification')
Downloading ../data/kaggle_dog_tiny.zip from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/kaggle_dog_tiny.zip... Organizing the Dataset
We can organize the dataset similarly to what we did in Section 14.13, namely splitting out a validation set from the original training set, and moving images into subfolders grouped by labels. The reorg_dog_data function below reads the training data labels, splits out the validation set, and organizes the training set. def reorg_dog_data(data_dir, valid_ratio): labels = d2l.read_csv_labels(os.path.join(data_dir, 'labels.csv')) d2l.reorg_train_valid(data_dir, labels, valid_ratio) d2l.reorg_test(data_dir) batch_size = 32 if demo else 128 valid_ratio = 0.1 reorg_dog_data(data_dir, valid_ratio)
14.14.2 Image Augmentation
Recall that this dog breed dataset is a subset of the ImageNet dataset, whose images are larger than those of the CIFAR-10 dataset in Section 14.13. The following lists a few image augmentation operations that might be useful for relatively larger images.bubutransform_train = torchvision.transforms.Compose([
# Randomly crop the image to obtain an image with an area of 0.08 to 1 of # the original area and height-to-width ratio between 3/4 and 4/3. Then, # scale the image to create a new 224 x 224 image torchvision.transforms.RandomResizedCrop(224, scale=(0.08, 1.0), ratio=(3.0/4.0, 4.0/3.0)), torchvision.transforms.RandomHorizontalFlip(), # Randomly change the brightness, contrast, and saturation torchvision.transforms.ColorJitter(brightness=0.4, contrast=0.4, saturation=0.4), # Add random noise torchvision.transforms.ToTensor(), # Standardize each channel of the image torchvision.transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])
Duringprediction,weonlyuseimagepreprocessingoperationswithoutrandomness. (continued from previous page)
Dog Breed IdentiÔ¨Åcation (ImageNet Dogs) on Kaggle
685

transform_test = torchvision.transforms.Compose([ torchvision.transforms.Resize(256), # Crop a 224 x 224 square area from the center of the image torchvision.transforms.CenterCrop(224), torchvision.transforms.ToTensor(), torchvision.transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])
14.14.3 Reading the Dataset
As in Section 14.13, we can read the organized dataset consisting of raw image files. train_ds, train_valid_ds = [torchvision.datasets.ImageFolder( os.path.join(data_dir, 'train_valid_test', folder), transform=transform_train) for folder in ['train', 'train_valid']] valid_ds, test_ds = [torchvision.datasets.ImageFolder( os.path.join(data_dir, 'train_valid_test', folder), transform=transform_test) for folder in ['valid', 'test']]
Below we create data iterator instances the same way as in Section 14.13. train_iter, train_valid_iter = [torch.utils.data.DataLoader( dataset, batch_size, shuffle=True, drop_last=True) for dataset in (train_ds, train_valid_ds)]
valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size, shuffle=False, drop_last=True)
test_iter = torch.utils.data.DataLoader(test_ds, batch_size, shuffle=False, drop_last=False)
14.14.4 Fine-Tuning a Pretrained Model
Again, the dataset for this competition is a subset of the ImageNet dataset. Therefore, we can use the approach discussed in Section 14.2 to select a model pretrained on the full ImageNet dataset and use it to extract image features to be fed into a custom small-scale output network. High-level APIs of deep learning frameworks provide a wide range of modelspretrainedontheImageNetdataset. Here, wechooseapretrainedResNet-34model, where we simply reuse the input of this model‚Äôs output layer (i.e., the extracted features). Then we can replace the original output layer with a small custom output network that can be trained, such as stacking two fully connected layers. Different from the experiment in Section 14.2, the following does not retrain the pretrained model used for feature extraction. This reduces training time and memory for storing gradients. Recall that we standardized images using the means and standard deviations of the three RGB channels for the full ImageNet dataset. In fact, this is also consistent with the stan- dardization operation by the pretrained model on ImageNet. Computer Vision
686

def get_net(devices): finetune_net = nn.Sequential() finetune_net.features = torchvision.models.resnet34(pretrained=True) # Define a new output network (there are 120 output categories) finetune_net.output_new = nn.Sequential(nn.Linear(1000, 256), nn.ReLU(), nn.Linear(256, 120)) # Move the model to devices finetune_net = finetune_net.to(devices[0]) # Freeze parameters of feature layers for param in finetune_net.features.parameters(): param.requires_grad = False return finetune_net
Before calculating the loss, we first obtain the input of the pretrained model‚Äôs output layer, i.e., the extracted feature. Then we use this feature as input for our small custom output network to calculate the loss. loss = nn.CrossEntropyLoss(reduction='none') def evaluate_loss(data_iter, net, devices): l_sum, n = 0.0, 0 for features, labels in data_iter: features, labels = features.to(devices[0]), labels.to(devices[0]) outputs = net(features) l = loss(outputs, labels) l_sum += l.sum() n += labels.numel() return l_sum / n
14.14.5 Defining the Training Function
We will select the model and tune hyperparameters according to the model‚Äôs performance on the validation set. The model training function train only iterates parameters of the small custom output network. def train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period, lr_decay): # Only train the small custom output network net = nn.DataParallel(net, device_ids=devices).to(devices[0]) trainer = torch.optim.SGD((param for param in net.parameters() if param.requires_grad), lr=lr, momentum=0.9, weight_decay=wd) scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_period, lr_decay) num_batches, timer = len(train_iter), d2l.Timer() legend = ['train loss'] if valid_iter is not None: legend.append('valid loss') animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], legend=legend) for epoch in range(num_epochs): metric = d2l.Accumulator(2)
(continues on next page)
Dog Breed IdentiÔ¨Åcation (ImageNet Dogs) on Kaggle
687

for i, (features, labels) in enumerate(train_iter): timer.start() features, labels = features.to(devices[0]), labels.to(devices[0]) trainer.zero_grad() output = net(features) l = loss(output, labels).sum() l.backward() trainer.step() metric.add(l, labels.shape[0]) timer.stop() if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (metric[0] / metric[1], None)) measures = f'train loss {metric[0] / metric[1]:.3f}' if valid_iter is not None: valid_loss = evaluate_loss(valid_iter, net, devices) animator.add(epoch + 1, (None, valid_loss.detach().cpu())) scheduler.step() if valid_iter is not None: measures += f', valid loss {valid_loss:.3f}' print(measures + f'\n{metric[1] * num_epochs / timer.sum():.1f}' f' examples/sec on {str(devices)}')
14.14.6 Training and Validating the Model
Now we can train and validate the model. The following hyperparameters are all tunable.bubuFor example, the number of epochs can be increased. Because lr_period and lr_decay are set to 2 and 0.9, respectively, the learning rate of the optimization algorithm will be multiplied by 0.9 after every 2 epochs. devices, num_epochs, lr, wd = d2l.try_all_gpus(), 10, 1e-4, 1e-4 lr_period, lr_decay, net = 2, 0.9, get_net(devices) train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period, lr_decay)
train loss 1.240, valid loss 1.545 577.5 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
‚Äî train loss =-- valid loss
(continued from previous page)
Computer Vision
688

14.14.7 Classifying the Testing Set and Submitting Results on Kaggle
Similar to the final step in Section 14.13, in the end all the labeled data (including the validation set) are used for training the model and classifying the testing set. We will use the trained custom output network for classification. net = get_net(devices) train(net, train_valid_iter, None, num_epochs, lr, wd, devices, lr_period, lr_decay) preds = [] for data, label in test_iter: output = torch.nn.functional.softmax(net(data.to(devices[0])), dim=1) preds.extend(output.cpu().detach().numpy()) ids = sorted(os.listdir( os.path.join(data_dir, 'train_valid_test', 'test', 'unknown'))) with open('submission.csv', 'w') as f: f.write('id,' + ','.join(train_valid_ds.classes) + '\n') for i, output in zip(ids, preds): f.write(i.split('.')[0] + ',' + ','.join( [str(num) for num in output]) + '\n')
train loss 1.217
742.7 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
‚Äî train loss
The above code will generate a submission.csv file to be submitted to Kaggle in the same way described in Section 5.7. 14.14.8 Summary
e Images in the ImageNet dataset are larger (with varying dimensions) than CIFAR-10 im-
ages.bubuWe may modify image augmentation operations for tasks on a different dataset. e To classify a subset of the ImageNet dataset, we can leverage pre-trained models on the
full ImageNet dataset to extract features and only train a custom small-scale output network. This will lead to less computational time and memory cost. 14.14.9 Exercises
Dog Breed IdentiÔ¨Åcation (ImageNet Dogs) on Kaggle
689

1. When using the full Kaggle competition dataset, what results can you achieve when you increase batch_size (batch size) and num_epochs (number of epochs) while setting some other hyperparameters as lr = 0.01, lr_period = 10, and lr_decay = 0.1? 2.bubuDo you get better results if you use a deeper pretrained model? How do you tune hyper- parameters? Can you further improve the results?bubuDiscussions226. 226
Natural Language Processing: Pretraining
15
Humansneedtocommunicate. Outofthisbasicneedofthehumancondition, avastamount of written text has been generated on an everyday basis. Given rich text in social media, chat apps, emails, product reviews, news articles, research papers, and books, it becomes vital to enable computers to understand them to offer assistance or make decisions based on human languages. Natural language processing studies interactions between computers and humans using natural languages. In practice, it is very common to use natural language processing tech- niques to process and analyze text (human natural language) data, such as language models in Section 9.3 and machine translation models in Section 10.5. To understand text, we can begin by learning its representations. Leveraging the existing text sequences from large corpora, self-supervised learning has been extensively used to pretrain text representations, such as by predicting some hidden part of the text using some other part of their surrounding text. In this way, models learn through supervision from massive text data without expensive labeling efforts! As we will see in this chapter, when treating each word or subword as an individual token, the representation of each token can be pretrained using word2vec, GloVe, or subword embedding models on large corpora. After pretraining, representation of each token can be a vector, however, it remains the same no matter what the context is. For instance, the vector representation of ‚Äúbank‚Äù is the same in both ‚Äúgo to the bank to deposit some money‚Äù and ‚Äúgo to the bank to sit down‚Äù. Thus, many more recent pretraining models adapt representation of the same token to different contexts. Among them is BERT, a much deeper self-supervised model based on the Transformer encoder. In this chapter, we will focus on how to pretrain such representations for text, as highlighted in Fig. 15.1. For sight of the big picture, Fig. 15.1 shows that the pretrained text representations can be fed to a variety of deep learning architectures for different downstream natural language processing applications. We will cover them in Chapter 16. 690
Word Embedding (word2vec)
691

' Apolcaton Lease] Lerma | 1 Architecture z 5 2 2 Zz BD 2 z Es g Pretraining |! | word2vec Glove Subword BERT oa
tFig. 15.1
Pretrained text representations can be fed to various deep learning architectures for different downstream natural language processing applications. This chapter focuses on the upstream text representation pretraining. 15.1 Word Embedding (word2vec)
eC
Natural language is a complex system used to express meanings. In this system, words are the basic unit of the meaning. As the name implies, word vectors are vectors used to represent words, and can also be considered as feature vectors or representations of words. The technique of mapping words to real vectors is called word embedding. In recent years, word embedding has gradually become the basic knowledge of natural language process- ing. 15.1.1 One-Hot Vectors Are a Bad Choice
We used one-hot vectors to represent words (characters are words) in Section 9.5. Suppose that the number of different words in the dictionary (the dictionary size) is N, and each word corresponds to a different integer (index) from 0 to N ‚Äî 1. To obtain the one-hot vector representation for any word with index 7, we create a length-N vector with all Os and set the element at position 7 to 1. In this way, each word is represented as a vector of length N, and it can be used directly by neural networks. Although one-hot word vectors are easy to construct, they are usually not a good choice. A main reason is that one-hot word vectors cannot accurately express the similarity between different words, such as the cosine similarity that we often use. For vectors x,y 2 Rùëë, their cosine similarity is the cosine of the angle between them:
x>y
OY ey ay, (15.1.1) IIxllIlyll
Since the cosine similarity between one-hot vectors of any two different words is 0, one-hot vectors cannot encode similarities among words. 227
15.1.2 Self-Supervised word2vec
The word2vec 227 tool was proposed to address the above issue. It maps each word to a
Natural Language Processing: Pretraining
692

fixed-length vector, and these vectors can better express the similarity and analogy relation- ship among different words. The word2vec tool contains two models, namely skip-gram (Mikolov et al., 2013) and continuous bag of words (CBOW) (Mikolov et al., 2013). For semantically meaningful representations, their training relies on conditional probabilities that can be viewed as predicting some words using some of their surrounding words in cor- pora. Sincesupervisioncomesfromthedatawithoutlabels, bothskip-gramandcontinuous bag of words are self-supervised models. In the following, we will introduce these two models and their training methods. 15.1.3 The Skip-Gram Model
The skip-gram model assumes that a word can be used to generate its surrounding words in a text sequence. Take the text sequence ‚Äúthe‚Äù, ‚Äúman‚Äù, ‚Äúloves‚Äù, ‚Äúhis‚Äù, ‚Äúson‚Äù as an example. Let‚Äôs choose ‚Äúloves‚Äù as the center word and set the context window size to 2. As shown in Fig. 15.1.1, given the center word ‚Äúloves‚Äù, the skip-gram model considers the conditional probability for generating the context words: ‚Äúthe‚Äù, ‚Äúman‚Äù, ‚Äúhis‚Äù, and ‚Äúson‚Äù, which are no more than 2 words away from the center word:
ùëÉ‚Äû‚Äùthe‚Äù,‚Äùman‚Äù,‚Äùhis‚Äù,‚Äùson‚Äù j ‚Äùloves‚Äù‚Äù. (15.1.2)
Assume that the context words are independently generated given the center word (i.e., conditional independence). In this case, the above conditional probability can be rewritten as
P(‚Äôthe‚Äù | ‚Äôloves‚Äô‚Äù‚Äô) - P(‚Äôman‚Äù | ‚Äôloves‚Äù) - P(‚Äùhis‚Äù | ‚Äôloves‚Äù) - P(‚Äô‚Äôson‚Äù | ‚Äùloves‚Äù) . (15.1.3)
the man his son loves
tFig. 15.1.1
The skip-gram model considers the conditional probability of generating the surrounding context words given a center word. In the skip-gram model, each word has two ùëë-dimensional-vector representations for cal-
culating conditional probabilities. More concretely, for any word with index ùëñ in the dic- tionary, denote by vùëñ 2 Rùëë and uùëñ 2 Rùëë its two vectors when used as a center word and a context word, respectively. The conditional probability of generating any context word ùë§ùëú (with index ùëú in the dictionary) given the center word ùë§ùëê (with index ùëê in the dictionary) can be modeled by a softmax operation on vector dot products:
ùëÉ‚Äûùë§ùëú j ùë§ùëê‚Äù = Àù ùëúvùëê‚Äù ùëñ2V exp‚Äûu> ùëñ vùëê‚Äù , (15.1.4)
exp‚Äûu>
Word Embedding (word2vec)
693

where the vocabulary index set V = {0,1,...,|V| ‚Äî 1}. Given a text sequence of length T, where the word at time step ft is denoted as w‚Äú. Assume that context words are in- dependently generated given any center word. For context window size m, the likelihood function of the skip-gram model is the probability of generating all context words given any center word:
T
TT] [] Poe? tw), (15.1.5) t=1 -m<j<m, j#0
where any time step that is less than 1 or greater than ùëá can be omitted. The skip-gram model parameters are the center word vector and context word vector for each word in the vocabulary. In training, we learn the model parameters by maximizing the likelihoodfunction(i.e., maximumlikelihoodestimation). Thisisequivalenttominimizing the following loss function:
T
T =>) bog POv) |). (15.1.6) t=1 ‚Äîm<j<m, j#0
When using stochastic gradient descent to minimize the loss, in each iteration we can ran- domly sample a shorter subsequence to calculate the (stochastic) gradient for this subse- quence to update the model parameters. To calculate this (stochastic) gradient, we need to obtain the gradients of the log conditional probability with respect to the center word vector and the context word vector. In general, according to (15.1.4) the log conditional probability involving any pair of the center word ùë§ùëê and the context word ùë§ùëú is
log P(Wo | We) = ug Ve ‚Äî log [x etsve) . (15.1.7) ieV
Through differentiation, we can obtain its gradient with respect to the center word vector vùëê as
dlog P(wo | We) _ Die exp(uj Ve) Uy ¬∞ Liew exp(uy Ve) exp(tt} Ve) = Up - = YY AA | Diev exp(ul vo) = Up - ¬ª P(w; | we) uj. jEeV OVe (15.1.8)
Note that the calculation in (15.1.8) requires the conditional probabilities of all words in the dictionary with ùë§ùëê as the center word. The gradients for the other word vectors can be obtained in the same way. After training, for any word with index ùëñ in the dictionary, we obtain both word vectors
Training
! Àù
Natural Language Processing: Pretraining
694

vùëñ (as the center word) and uùëñ (as the context word). In natural language processing ap- plications, the center word vectors of the skip-gram model are typically used as the word representations. 15.1.4 The Continuous Bag of Words (CBOW) Model
The continuous bag of words (CBOW) model is similar to the skip-gram model. The major differencefromtheskip-grammodelisthatthecontinuousbagofwordsmodelassumesthat a center word is generated based on its surrounding context words in the text sequence. For example, in the same text sequence ‚Äúthe‚Äù, ‚Äúman‚Äù, ‚Äúloves‚Äù, ‚Äúhis‚Äù, and ‚Äúson‚Äù, with ‚Äúloves‚Äù as the center word and the context window size being 2, the continuous bag of words model considers the conditional probability of generating the center word ‚Äúloves‚Äù based on the context words ‚Äúthe‚Äù, ‚Äúman‚Äù, ‚Äúhis‚Äù and ‚Äúson‚Äù (as shown in Fig. 15.1.2), which is
ùëÉ‚Äû‚Äùloves‚Äù j ‚Äùthe‚Äù,‚Äùman‚Äù,‚Äùhis‚Äù,‚Äùson‚Äù‚Äù. (15.1.9)
loves the man his son
tFig. 15.1.2
The continuous bag of words model considers the conditional probability of generating the center word given its surrounding context words. Since there are multiple context words in the continuous bag of words model, these context word vectors are averaged in the calculation of the conditional probability. Specifically, for any word with index ùëñ in the dictionary, denote by vùëñ 2 Rùëë and uùëñ 2 Rùëë its two vectors when used as a context word and a center word (meanings are switched in the skip-gram model), respectively. The conditional probability of generating any center word ùë§ùëê (with index ùëê in the dictionary) given its surrounding context words ùë§ùëú1 , . .bubu., ùë§ùëú2ùëö (with index ùëú1, . . ., ùëú2ùëö in the dictionary) can be modeled by
1 T exp (shu; (Vo, +... + Voom)) P(We | Wois+++sWom) = (15.1.10) ; : Diev XP (ur (vo, +... + Von)
For brevity, let W, = {Wo,,-- +s Wor, } and Vo = (Vo, +... + Vo) /(2m). Then (15.1.10) can be simplified as
exp (uz Vo) Liew exp (ul ¬•o) P(we | Wo) = (15.1.11)
Given a text sequence of length ùëá, where the word at time step ùë° is denoted as ùë§‚Äûùë°‚Äù. For
u>
Word Embedding (word2vec)
695

context window size ùëö, the likelihood function of the continuous bag of words model is
the probability of generating all center words given their context words:
T
T I] POW | wl wD wD wt), (15.1.12) t=l
Training continuous bag of words models is almost the same as training skip-gram models. The maximum likelihood estimation of the continuous bag of words model is equivalent to minimizing the following loss function:
T
T - ¬ª log POW | wh), wD, wed wt), (15.1.13) t=l
Notice that
log P(we | Wo) = ur Vo ‚Äî log [> exp i) . (15.1.14) ieV
Through differentiation, we can obtain its gradient with respect to any context word vector vùëúùëñ(ùëñ = 1, . . .,2ùëö) as
dlog P(we | Wo) _ 1 exp(ujVo)uj 1 ‚Äî_ ‚Äî = jev Liev exp(u/ Vo) 2m OVo; ~ 2m Be 2 Pow; | Wo)uj G jEV (15.1.15)
The gradients for the other word vectors can be obtained in the same way. Unlike the skip- gram model, the continuous bag of words model typically uses context word vectors as the word representations. 15.1.5 Summary
Word vectors are vectors used to represent words, and can also be considered as feature
vectors or representations of words. The technique of mapping words to real vectors is called word embedding. The word2vec tool contains both the skip-gram and continuous bag of words models. The skip-gram model assumes that a word can be used to generate its surrounding words
in a text sequence; while the continuous bag of words model assumes that a center word is generated based on its surrounding context words. 15.1.6 Exercises
1.bubuWhat is the computational complexity for calculating each gradient? What could be the issue if the dictionary size is huge?bubuTraining
!bubu‚Äú
.bubuÔ¨Å
‚Äπ
Natural Language Processing: Pretraining
696

2. Some fixed phrases in English consist of multiple words, such as ‚Äúnew york‚Äù. How to train their word vectors? Hint: see Section 4 in the word2vec paper (Mikolov et al., 2013). 3. Let‚Äôsreflectontheword2vecdesignbytakingtheskip-grammodelasanexample. What is the relationship between the dot product of two word vectors in the skip-gram model and the cosine similarity? For a pair of words with similar semantics, why may the cosine similarity of their word vectors (trained by the skip-gram model) be high? Discussions228. 228
15.2 Approximate Training
es
Recall our discussions in Section 15.1. The main idea of the skip-gram model is using softmax operations to calculate the conditional probability of generating a context word ùë§ùëú based on the given center word ùë§ùëê in (15.1.4), whose corresponding logarithmic loss is given by the opposite of (15.1.7). Due to the nature of the softmax operation, since a context word may be anyone in the dictionary V, the opposite of (15.1.7) contains the summation of items as many as the entire size of the vocabulary. Consequently, the gradient calculation for the skip-gram model in (15.1.8) and that forthe continuous bag-of-words model in (15.1.15) both contain the summation. Unfortunately, the computational cost for such gradients that sum over a large dictionary (often with hundreds of thousands or millions of words) is huge! In order to reduce the aforementioned computational complexity, this section will introduce two approximate training methods: negative sampling and hierarchical softmax. Due to the similarity between the skip-gram model and the continuous bag of words model, we will just take the skip-gram model as an example to describe these two approximate training methods. 15.2.1 Negative Sampling
Negative sampling modifies the original objective function. Given the context window of a center word ùë§ùëê, the fact that any (context) word ùë§ùëú comes from this context window is considered as an event with the probability modeled by
ùëÉ‚Äûùê∑ = 1 j ùë§ùëê, ùë§ùëú‚Äù = ùúé‚Äûu>
ùëúvùëê‚Äù, (15.2.1)
where ùúé uses the definition of the sigmoid activation function:
(15.2.2)
Let‚Äôs begin by maximizing the joint probability of all such events in text sequences to train word embeddings. Specifically, given a text sequence of length ùëá, denote by ùë§‚Äûùë°‚Äù the word
Approximate Training
697

at time step ùë° and let the context window size be ùëö, consider maximizing the joint proba-
bility
T
T TL] [P= tlw). (15.2.3) t=1 -m<j<m, j#0
However, (15.2.3) only considers those events that involve positive examples. As a result, the joint probability in (15.2.3) is maximized to 1 only if all the word vectors are equal to infinity. Of course, such results are meaningless. To make the objective function more meaningful, negative sampling adds negative examples sampled from a predefined distri- bution. Denote by ùëÜ the event that a context word ùë§ùëú comes from the context window of a cen-
ter word ùë§ùëê. For this event involving ùë§ùëú, from a predefined distribution ùëÉ‚Äûùë§‚Äù sample ùêæ noise words that are not from this context window. Denote by ùëÅùëò the event that a noise word ùë§ùëò (ùëò = 1, . . ., ùêæ) does not come from the context window of ùë§ùëê. Assume that these events involving both the positive example and negative examples ùëÜ, ùëÅ1, . . ., ùëÅùêæ are mutu- ally independent. Negative sampling rewrites the joint probability (involving only positive examples) in (15.2.3) as
T
T TT] [] Poe? tw), (15.2.4) t=1 -m<j<m, j#0
where the conditional probability is approximated through events ùëÜ, ùëÅ1, . . ., ùëÅùêæ:
K Pw") | w) = P(D = 1 | wWO, we) I] P(D =0|w, we). (15.2.5) k=1, we~P(w)
Denote by ùëñùë° and ‚Ñéùëò the indices of a word ùë§‚Äûùë°‚Äù at time step ùë° of a text sequence and a noise word ùë§ùëò, respectively. The logarithmic loss with respect to the conditional probabilities in (15.2.5) is
log P(w"*)) | w) =‚Äî log P(D = 1 | ww) ‚Äî ¬ª log P(D =0| wwe) k=l, we~P(w)
K =-logo (uz, vi) - ¬ª log (1 -o (uj,vi,)) k=l, we~P(w)
K =-log o (uf, vi) - ¬ª logo (-uj,i,) . k=l, we~P(w)
We can see that now the computational cost for gradients at each training step has nothing to do with the dictionary size, but linearly depends on ùêæ. When setting the hyperparameter ùêæ to a smaller value, the computational cost for gradients at each training step with negative sampling is smaller. K
(15.2.6)
Natural Language Processing: Pretraining
698

15.2.2 Hierarchical Softmax
As an alternative approximate training method, hierarchical softmax uses the binary tree, a data structure illustrated in Fig. 15.2.1, where each leaf node of the tree represents a word in dictionary V. n(ws, 1) n(ws, 2)
tFig. 15.2.1 Hierarchical softmax for approximate training, where each leaf node of the tree represents
a word in the dictionary. Denote by ùêø‚Äûùë§‚Äù the number of nodes (including both ends) on the path from the root node
to the leaf node representing word ùë§ in the binary tree. Let ùëõ‚Äûùë§, ùëó‚Äù be the ùëóth node on this path, with its context word vector being uùëõ‚Äûùë§, ùëó‚Äù. For example, ùêø‚Äûùë§3‚Äù = 4 in Fig.bubu15.2.1. Hierarchical softmax approximates the conditional probability in (15.1.4) as
L(wo)-1 Pwo lwe) = [| o(IrQvo.f +1) = leftChild(n(wo, #))Il th 55,.,)¬•e) + jel
where function ùúé is defined in (15.2.2), and leftChild‚Äûùëõ‚Äù is the left child node of node ùëõ:
where function o is defined in (15.2.2), and leftChild(n) is the left child node of node n: if x is true, [[x]] = 1; otherwise [[x]] = ‚Äî-1. To illustrate, let‚Äôs calculate the conditional probability of generating word ùë§3 given word
ùë§ùëê in Fig.bubu15.2.1. This requires dot products between the word vector vùëê of ùë§ùëê and non- leaf node vectors on the path (the path in bold in Fig. 15.2.1) from the root to ùë§3, which is traversed left, right, then left:
P(w3 | we) = FW) (45.1) Vo) - (Wi (ys,9) Vo) : (Uy (ys,3)Ve)- (15.2.8)
Since o(x) + a(x) = 1, it holds that the conditional probabilities of generating all the
words in dictionary V based on any word ùë§ùëê sum up to one:
ùë§2V ùëÉ‚Äûùë§ j ùë§ùëê‚Äù = 1. (15.2.9)
Fortunately, since L(w,) ‚Äî 1 is on the order of O(log,|V]|) due to the binary tree struc- ture, when the dictionary size V is huge, the computational cost for each training step us- ing hierarchical softmax is significantly reduced compared with that without approximate training. (15.2.7)
The Dataset for Pretraining Word Embeddings
699

15.2.3 Summary
e Negative sampling constructs the loss function by considering mutually independent
events that involve both positive and negative examples. The computational cost for training is linearly dependent on the number of noise words at each step. e Hierarchical softmax constructs the loss function using the path from the root node to
the leaf node in the binary tree. The computational cost for training is dependent on the logarithm of the dictionary size at each step.bubu15.2.4 Exercises
1. How can we sample noise words in negative sampling? 2.bubuVerify that (15.2.9) holds.bubu3. How to train the continuous bag of words model using negative sampling and hierarchi- cal softmax, respectively? 229
Discussions229. 15.3 The Dataset for Pretraining Word Embeddings

Now that we know the technical details of the word2vec models and approximate training methods, let‚Äôs walk through their implementations. Specifically, we will take the skip- gram model in Section 15.1 and negative sampling in Section 15.2 as an example. In this section, we begin with the dataset for pretraining the word embedding model: the original format of the data will be transformed into minibatches that can be iterated over during training. import collections import math import os import random import torch from d2l import torch as d2l
15.3.1 Reading the Dataset
230
230
The dataset that we use here is Penn Tree Bank (PTB)230. This corpus is sampled from Wall Street Journal articles, split into training, validation, and test sets. In the original format, each line of the text file represents a sentence of words that are separated by spaces. Here we treat each word as a token. Natural Language Processing: Pretraining
700

#@save d2l.DATA_HUB['ptb'] = (d2l.DATA_URL + 'ptb.zip', '319d85e578af0cdc590547f26231e4e31cdf1e42') #@save def read_ptb(): """Load the PTB dataset into a list of text lines.""" data_dir = d2l.download_extract('ptb') # Read the training set with open(os.path.join(data_dir, 'ptb.train.txt')) as f: raw_text = f.read() return [line.split() for line in raw_text.split('\n')] sentences = read_ptb() f'# sentences: {len(sentences)}'
Downloading ../data/ptb.zip from http://d2l-data.s3-accelerate.amazonaws.com/ ‚Ü©!ptb.zip... '# sentences: 42069'
After reading the training set, we build a vocabulary for the corpus, where any word that appears less than 10 times is replaced by the ‚Äú<unk>‚Äù token. Note that the original dataset also contains ‚Äú<unk>‚Äù tokens that represent rare (unknown) words. vocab = d2l.Vocab(sentences, min_freq=10) f'vocab size: {len(vocab)}'
'vocab size: 6719'
15.3.2 Subsampling
Text data typically have high-frequency words such as ‚Äúthe‚Äù, ‚Äúa‚Äù, and ‚Äúin‚Äù: they may even occur billions of times in very large corpora. However, these words often co-occur with many different words in context windows, providing little useful signals. For instance, consider the word ‚Äúchip‚Äù in a context window: intuitively its co-occurrence with a low- frequency word ‚Äúintel‚Äù is more useful in training than the co-occurrence with a high- frequency word ‚Äúa‚Äù. Moreover, training with vast amounts of (high-frequency) words is slow. Thus, when training word embedding models, high-frequency words can be sub- sampled (Mikolov et al., 2013). Specifically, each indexed word ùë§ùëñ in the dataset will be discarded with probability
t P(w;) = max|1 - ,./‚Äî‚Äî,0], 15.3.1 6) V7 (15.3.1)
where ùëì ‚Äûùë§ùëñ‚Äù is the ratio of the number of words ùë§ùëñ to the total number of words in the
where f(w;) is the ratio of the number of words w; to the total number of words in the dataset, and the constant f is a hyperparameter (10~‚Äò in the experiment). We can see that
r
The Dataset for Pretraining Word Embeddings
701

only when the relative frequency ùëì ‚Äûùë§ùëñ‚Äù > ùë° can the (high-frequency) word ùë§ùëñ be discarded,
and the higher the relative frequency of the word, the greater the probability of being dis- carded. #@save def subsample(sentences, vocab): """Subsample high-frequency words.""" # Exclude unknown tokens ('<unk>') sentences = [[token for token in line if vocab[token] != vocab.unk] for line in sentences] counter = collections.Counter([ token for line in sentences for token in line]) num_tokens = sum(counter.values()) # Return True if `token` is kept during subsampling def keep(token): return(random.uniform(0, 1) < math.sqrt(1e-4 / counter[token] * num_tokens)) return ([[token for token in line if keep(token)] for line in sentences], counter) subsampled, counter = subsample(sentences, vocab)
The following code snippet plots the histogram of the number of tokens per sentence be- fore and after subsampling. As expected, subsampling significantly shortens sentences by dropping high-frequency words, which will lead to training speedup. d2l.show_list_len_pair_hist(['origin', 'subsampled'], '# tokens per sentence', 'count', sentences, subsampled);
25000 Em origin 20000 ll subsampled 15000 5 3 ¬© 10000 5000 0 a 0 20 40 60 80 # tokens per sentence
~
For individual tokens, the sampling rate of the high-frequency word ‚Äúthe‚Äù is less than 1/20. def compare_counts(token): return (f'# of "{token}": ' f'before={sum([l.count(token) for l in sentences])}, ' f'after={sum([l.count(token) for l in subsampled])}') compare_counts('the')
Natural Language Processing: Pretraining
702

'# of "the": before=50770, after=2010'
In contrast, low-frequency words ‚Äújoin‚Äù are completely kept. compare_counts('join')
'# of "join": before=45, after=45'
After subsampling, we map tokens to their indices for the corpus. corpus = [vocab[line] for line in subsampled] corpus[:3]
[[], [4127, 3228, 1773], [3922, 1922, 4743, 2696]]
15.3.3 Extracting Center Words and Context Words
Thefollowingget_centers_and_contextsfunctionextractsallthecenterwordsandtheir contextwordsfromcorpus. Ituniformlysamplesanintegerbetween1andmax_window_size at random as the context window size. For any center word, those words whose distance from it does not exceed the sampled context window size are its context words. #@save def get_centers_and_contexts(corpus, max_window_size): """Return center words and context words in skip-gram.""" centers, contexts = [], [] for line in corpus: # To form a "center word--context word" pair, each sentence needs to # have at least 2 words if len(line) < 2: continue centers += line for i in range(len(line)): # Context window centered at `i` window_size = random.randint(1, max_window_size) indices = list(range(max(0, i - window_size), min(len(line), i + 1 + window_size))) # Exclude the center word from the context words indices.remove(i) contexts.append([line[idx] for idx in indices]) return centers, contexts
Next, we create an artificial dataset containing two sentences of 7 and 3 words, respectively. Let the maximum context window size be 2 and print all the center words and their context words. The Dataset for Pretraining Word Embeddings
703

tiny_dataset = [list(range(7)), list(range(7, 10))] print('dataset', tiny_dataset) for center, context in zip(*get_centers_and_contexts(tiny_dataset, 2)): print('center', center, 'has contexts', context)
dataset [[0, 1, 2, 3, 4, 5, 6], [7, 8, 9]]
center 0 has contexts [1] center 1 has contexts [0, 2] center 2 has contexts [0, 1, 3, 4] center 3 has contexts [1, 2, 4, 5] center 4 has contexts [2, 3, 5, 6] center 5 has contexts [3, 4, 6] center 6 has contexts [5] center 7 has contexts [8, 9] center 8 has contexts [7, 9] center 9 has contexts [7, 8]
When training on the PTB dataset, we set the maximum context window size to 5. The following extracts all the center words and their context words in the dataset. all_centers, all_contexts = get_centers_and_contexts(corpus, 5) f'# center-context pairs: {sum([len(contexts) for contexts in all_contexts])}'
'# center-context pairs: 1503420'
15.3.4 Negative Sampling
We use negative sampling for approximate training. To sample noise words according to a predefined distribution, we define the following RandomGenerator class, where the (possi- blyunnormalized)samplingdistributionispassedviatheargumentsampling_weights. #@save class RandomGenerator: """Randomly draw among {1, ..., n} according to n sampling weights.""" def __init__(self, sampling_weights): # Exclude self.population = list(range(1, len(sampling_weights) + 1)) self.sampling_weights = sampling_weights self.candidates = [] self.i = 0 def draw(self): if self.i == len(self.candidates): # Cache `k` random sampling results self.candidates = random.choices( self.population, self.sampling_weights, k=10000) self.i = 0 self.i += 1 return self.candidates[self.i - 1]
Natural Language Processing: Pretraining
704

For example, we can draw 10 random variables ùëã among indices 1, 2, and 3 with sampling
For example, we can draw 10 random variables X among indices 1, 2, and 3 with sampling probabilities P(X = 1) = 2/9, P(X = 2) = 3/9, and P(X = 3) = 4/9 as follows. For a pair of center word and context word, we randomly sample K (5 in the experiment) noise words. According to the suggestions in the word2vec paper, the sampling probability ùëÉ‚Äûùë§‚Äù of a noise word ùë§ is set to its relative frequency in the dictionary raised to the power of 0.75 (Mikolov et al., 2013). #@save def get_negatives(all_contexts, vocab, counter, K): """Return noise words in negative sampling.""" # Sampling weights for words with indices 1, 2, ... (index 0 is the # excluded unknown token) in the vocabulary sampling_weights = [counter[vocab.to_tokens(i)]**0.75 for i in range(1, len(vocab))] all_negatives, generator = [], RandomGenerator(sampling_weights) for contexts in all_contexts: negatives = [] while len(negatives) < len(contexts) * K: neg = generator.draw() # Noise words cannot be context words if neg not in contexts: negatives.append(neg) all_negatives.append(negatives) return all_negatives
all_negatives = get_negatives(all_contexts, vocab, counter, 5)
15.3.5 Loading Training Examples in Minibatches
After all the center words together with their context words and sampled noise words are extracted, they will be transformed into minibatches of examples that can be iteratively loaded during training. In a minibatch, the ùëñth example includes a center word and its ùëõùëñ context words and ùëöùëñ noise
words. Due to varying context window sizes, ùëõùëñ ‚Äö ùëöùëñ varies for different ùëñ. Thus, for each example we concatenate its context words and noise words in the contexts_negatives variable, and pad zeros until the concatenation length reaches maxùëñ ùëõùëñ ‚Äö ùëöùëñ (max_len). To exclude paddings in the calculation of the loss, we define a mask variable masks. There is a one-to-onecorrespondencebetweenelementsinmasksandelementsincontexts_negatives, wherezeros(otherwiseones)inmaskscorrespondtopaddingsincontexts_negatives. To distinguish between positive and negative examples, we separate context words from noise words in contexts_negatives via a labels variable. Similar to masks, there is also aone-to-onecorrespondencebetweenelementsinlabelsandelementsincontexts_negatives, where ones (otherwise zeros) in labels correspond to context words (positive examples) in contexts_negatives. The above idea is implemented in the following batchify function. Its input data is a list with length equal to the batch size, where each element is an example consisting of the center word center, its context words context, and its noise words negative. This
The Dataset for Pretraining Word Embeddings
705

function returns a minibatch that can be loaded for calculations during training, such as including the mask variable. #@save def batchify(data): """Return a minibatch of examples for skip-gram with negative sampling.""" max_len = max(len(c) + len(n) for _, c, n in data) centers, contexts_negatives, masks, labels = [], [], [], [] for center, context, negative in data: cur_len = len(context) + len(negative) centers += [center] contexts_negatives += [context + negative + [0] * (max_len - cur_len)] masks += [[1] * cur_len + [0] * (max_len - cur_len)] labels += [[1] * len(context) + [0] * (max_len - len(context))] return (torch.tensor(centers).reshape((-1, 1)), torch.tensor( contexts_negatives), torch.tensor(masks), torch.tensor(labels))
Let‚Äôs test this function using a minibatch of two examples. x_1 = (1, [2, 2], [3, 3, 3, 3]) x_2 = (1, [2, 2, 2], [3, 3]) batch = batchify((x_1, x_2)) names = ['centers', 'contexts_negatives', 'masks', 'labels'] for name, data in zip(names, batch): print(name, '=', data)
centers = tensor([[1], [1]]) contexts_negatives = tensor([[2, 2, 3, 3, 3, 3], [2, 2, 2, 3, 3, 0]]) masks = tensor([[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0]]) labels = tensor([[1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0]])
15.3.6 Putting It All Together
Last, we define the load_data_ptb function that reads the PTB dataset and returns the data iterator and the vocabulary. #@save def load_data_ptb(batch_size, max_window_size, num_noise_words): """Download the PTB dataset and then load it into memory.""" num_workers = d2l.get_dataloader_workers() sentences = read_ptb() vocab = d2l.Vocab(sentences, min_freq=10) subsampled, counter = subsample(sentences, vocab) corpus = [vocab[line] for line in subsampled] all_centers, all_contexts = get_centers_and_contexts( corpus, max_window_size)
(continues on next page)
Natural Language Processing: Pretraining
706

all_negatives = get_negatives( all_contexts, vocab, counter, num_noise_words) class PTBDataset(torch.utils.data.Dataset): def __init__(self, centers, contexts, negatives): assert len(centers) == len(contexts) == len(negatives) self.centers = centers self.contexts = contexts self.negatives = negatives def __getitem__(self, index): return (self.centers[index], self.contexts[index], self.negatives[index]) def __len__(self): return len(self.centers) dataset = PTBDataset(all_centers, all_contexts, all_negatives) data_iter = torch.utils.data.DataLoader(dataset, batch_size, shuffle=True, collate_fn=batchify, num_workers=num_workers) return data_iter, vocab
Let‚Äôs print the first minibatch of the data iterator. data_iter, vocab = load_data_ptb(512, 5, 5) for batch in data_iter: for name, data in zip(names, batch): print(name, 'shape:', data.shape) break
centers shape: torch.Size([512, 1]) contexts_negatives shape: torch.Size([512, 60]) masks shape: torch.Size([512, 60]) labels shape: torch.Size([512, 60])
15.3.7 Summary
e High-frequency words may not be so useful in training. We can subsample them for
speedup in training. e For computational efficiency, we load examples in minibatches. We can define other
variables todistinguishpaddings from non-paddings, and positiveexamplesfrom neg- ative ones. 15.3.8 Exercises
1. How does the running time of code in this section changes if not using subsampling? (continued from previous page)
Pretraining word2vec
707

2. The RandomGenerator class caches k random sampling results. Set k to other values and see how it affects the data loading speed.bubu3. What other hyperparameters in the code of this section may affect the data loading speed? Discussions231. 231
15.4 Pretraining word2vec
a
We go on to implement the skip-gram model defined in Section 15.1. Then we will pretrain word2vec using negative sampling on the PTB dataset. First of all, let‚Äôs obtain the data iterator and the vocabulary for this dataset by calling the d2l.load_data_ptb function, which was described in Section 15.3
import math import torch from torch import nn from d2l import torch as d2l batch_size, max_window_size, num_noise_words = 512, 5, 5 data_iter, vocab = d2l.load_data_ptb(batch_size, max_window_size, num_noise_words)
15.4.1 The Skip-Gram Model
We implement the skip-gram model by using embedding layers and batch matrix multipli- cations. First, let‚Äôs review how embedding layers work.bubuEmbedding Layer
As described in Section 10.7, an embedding layer maps a token‚Äôs index to its feature vec- tor. The weight of this layer is a matrix whose number of rows equals to the dictio- nary size (input_dim) and number of columns equals to the vector dimension for each token (output_dim). After a word embedding model is trained, this weight is what we need. embed = nn.Embedding(num_embeddings=20, embedding_dim=4) print(f'Parameter embedding_weight ({embed.weight.shape}, ' f'dtype={embed.weight.dtype})')
Parameter embedding_weight (torch.Size([20, 4]), dtype=torch.float32)
The input of an embedding layer is the index of a token (word). For any token index ùëñ, its
Natural Language Processing: Pretraining
708

vectorrepresentationcanbeobtainedfromtheùëñth rowoftheweightmatrixintheembedding layer. Since the vector dimension (output_dim) was set to 4, the embedding layer returns vectors with shape (2, 3, 4) for a minibatch of token indices with shape (2, 3). x = torch.tensor([[1, 2, 3], [4, 5, 6]]) embed(x)
tensor([[[ 0.7606, 0.3872, -0.1864, 1.1732], [ 1.5035, 2.3623, -1.7542, -1.4990], [-1.2639, -1.5313, 2.1719, 0.4151]], [[-1.9079, 0.2434, 1.5395, 1.2990], [ 0.7470, 1.0129, 0.4039, 0.0591], [-0.6293, -0.1814, -0.4782, -0.5289]]], grad_fn=<EmbeddingBackward0>)
Defining the Forward Propagation
In the forward propagation, the input of the skip-gram model includes the center word indices center of shape (batch size, 1) and the concatenated context and noise word indices contexts_and_negatives of shape (batch size, max_len), where max_len is defined in Section15.3.5. Thesetwovariablesarefirsttransformedfromthetokenindicesintovectors viatheembeddinglayer, thentheirbatchmatrixmultiplication(describedinSection11.3.2) returns an output of shape (batch size, 1, max_len). Each element in the output is the dot product of a center word vector and a context or noise word vector. def skip_gram(center, contexts_and_negatives, embed_v, embed_u): v = embed_v(center) u = embed_u(contexts_and_negatives) pred = torch.bmm(v, u.permute(0, 2, 1)) return pred
Let‚Äôs print the output shape of this skip_gram function for some example inputs. skip_gram(torch.ones((2, 1), dtype=torch.long), torch.ones((2, 4), dtype=torch.long), embed, embed).shape
torch.Size([2, 1, 4])
15.4.2 Training
Before training the skip-gram model with negative sampling, let‚Äôs first define its loss func-
tion. Binary Cross-Entropy Loss
According to the definition of the loss function for negative sampling in Section 15.2.1, we will use the binary cross-entropy loss. Pretraining word2vec
709

class SigmoidBCELoss(nn.Module): # Binary cross-entropy loss with masking def __init__(self): super().__init__() def forward(self, inputs, target, mask=None): out = nn.functional.binary_cross_entropy_with_logits( inputs, target, weight=mask, reduction="none") return out.mean(dim=1) loss = SigmoidBCELoss()
Recall our descriptions of the mask variable and the label variable in Section 15.3.5. The following calculates the binary cross-entropy loss for the given variables. pred = torch.tensor([[1.1, -2.2, 3.3, -4.4]] * 2) label = torch.tensor([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]]) mask = torch.tensor([[1, 1, 1, 1], [1, 1, 0, 0]]) loss(pred, label, mask) * mask.shape[1] / mask.sum(axis=1)
tensor([0.9352, 1.8462])
Below shows how the above results are calculated (in a less efficient way) using the sigmoid activation function in the binary cross-entropy loss. We can consider the two outputs as two normalized losses that are averaged over non-masked predictions. def sigmd(x): return -math.log(1 / (1 + math.exp(-x))) print(f'{(sigmd(1.1) + sigmd(2.2) + sigmd(-3.3) + sigmd(4.4)) / 4:.4f}') print(f'{(sigmd(-1.1) + sigmd(-2.2)) / 2:.4f}')
0.9352
1.8462
Initializing Model Parameters
We define two embedding layers for all the words in the vocabulary when they are used as center words and context words, respectively. The word vector dimension embed_size is set to 100. embed_size = 100 net = nn.Sequential(nn.Embedding(num_embeddings=len(vocab), embedding_dim=embed_size), nn.Embedding(num_embeddings=len(vocab), embedding_dim=embed_size))
Natural Language Processing: Pretraining
710

Defining the Training Loop
The training loop is defined below. Because of the existence of padding, the calculation of
the loss function is slightly different compared to the previous training functions. def train(net, data_iter, lr, num_epochs, device=d2l.try_gpu()): def init_weights(module): if type(module) == nn.Embedding: nn.init.xavier_uniform_(module.weight) net.apply(init_weights) net = net.to(device) optimizer = torch.optim.Adam(net.parameters(), lr=lr) animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[1, num_epochs]) # Sum of normalized losses, no. of normalized losses metric = d2l.Accumulator(2) for epoch in range(num_epochs): timer, num_batches = d2l.Timer(), len(data_iter) for i, batch in enumerate(data_iter): optimizer.zero_grad() center, context_negative, mask, label = [ data.to(device) for data in batch] pred = skip_gram(center, context_negative, net[0], net[1]) l = (loss(pred.reshape(label.shape).float(), label.float(), mask) / mask.sum(axis=1) * mask.shape[1]) l.sum().backward() optimizer.step() metric.add(l.sum(), l.numel()) if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (metric[0] / metric[1],)) print(f'loss {metric[0] / metric[1]:.3f}, ' f'{metric[1] / timer.stop():.1f} tokens/sec on {str(device)}')
Now we can train a skip-gram model using negative sampling. lr, num_epochs = 0.002, 5 train(net, data_iter, lr, num_epochs)
loss 0.410, 223485.0 tokens/sec on cuda:0
epoch
Word Embedding with Global Vectors (GloVe)
711

15.4.3 Applying Word Embeddings
After training the word2vec model, we can use the cosine similarity of word vectors from the trained model to find words from the dictionary that are most semantically similar to an input word. def get_similar_tokens(query_token, k, embed):
W = embed.weight.data x = W[vocab[query_token]] # Compute the cosine similarity. Add 1e-9 for numerical stability cos = torch.mv(W, x) / torch.sqrt(torch.sum(W * W, dim=1) * torch.sum(x * x) + 1e-9) topk = torch.topk(cos, k=k+1)[1].cpu().numpy().astype('int32') for i in topk[1:]: # Remove the input words print(f'cosine sim={float(cos[i]):.3f}: {vocab.to_tokens(i)}') get_similar_tokens('chip', 3, net[0])
cosine sim=0.702: microprocessor cosine sim=0.649: mips cosine sim=0.643: intel
15.4.4 Summary
e We can train a skip-gram model with negative sampling using embedding layers and the
binary cross-entropy loss. e Applications of word embeddings include finding semantically similar words for a given
word based on the cosine similarity of word vectors.bubu15.4.5 Exercises
1. Using the trained model, find semantically similar words for other input words. Can you improve the results by tuning hyperparameters? 2. When a training corpus is huge, we often sample context words and noise words for the center words in the current minibatch when updating model parameters. In other words, thesamecenterwordmayhavedifferentcontextwordsornoisewordsindifferent training epochs. What are the benefits of this method? Try to implement this training method.bubuDiscussions232. 232
aes
15.5 Word Embedding with Global Vectors (GloVe)
a
Word-word co-occurrences within context windows may carry rich semantic information. For example, in a large corpus word ‚Äúsolid‚Äù is more likely to co-occur with ‚Äúice‚Äù than
Natural Language Processing: Pretraining
712

‚Äústeam‚Äù, but word ‚Äúgas‚Äù probably co-occurs with ‚Äústeam‚Äù more frequently than ‚Äúice‚Äù. Be- sides, global corpus statistics of such co-occurrences can be precomputed: this can lead to more efficient training. To leverage statistical information in the entire corpus for word embedding, let‚Äôs first revisit the skip-gram model in Section 15.1.3, but interpreting it using global corpus statistics such as co-occurrence counts. 15.5.1 Skip-Gram with Global Corpus Statistics
Denoting by ùëûùëñùëó the conditional probability ùëÉ‚Äûùë§ ùëó
skip-gram model, we have
ùëûùëñùëó = Àù ùëó vùëñ‚Äù ùëò2V exp‚Äûu> ùëòvùëñ‚Äù , (15.5.1)
where for any index ùëñ vectors vùëñ and uùëñ represent word ùë§ùëñ as the center word and context
where for any index i vectors v; and u; represent word w; as the center word and context word, respectively, and V = {0,1,...,|V| ‚Äî 1} is the index set of the vocabulary. Consider word ùë§ùëñ that may occur multiple times in the corpus. In the entire corpus, all the
context words wherever ùë§ùëñ is taken as their center word form a multiset Cùëñ of word indices that allows for multiple instances of the same element. For any element, its number of in- stances is called its multiplicity. To illustrate with an example, suppose that word ùë§ùëñ occurs twice in the corpus and indices of the context words that take ùë§ùëñ as their center word in the two context windows are ùëò, ùëó,ùëö, ùëò and ùëò,ùëô, ùëò, ùëó. Thus, multiset Cùëñ = fùëó, ùëó, ùëò, ùëò, ùëò, ùëò,ùëô,ùëög, where multiplicities of elements ùëó, ùëò,ùëô,ùëö are 2, 4, 1, 1, respectively. Now let‚Äôs denote the multiplicity of element ùëó in multiset Cùëñ as ùë•ùëñùëó. This is the global co-
occurrence count of word ùë§ ùëó (as the context word) and word ùë§ùëñ (as the center word) in the same context window in the entire corpus. Using such global corpus statistics, the loss function of the skip-gram model is equivalent to
_ ¬ª ¬ª xij log qij. (15.5.2) ieV jeV
We further denote by ùë•ùëñ the number of all the context words in the context windows where
We further denote by x; the number of all the context words in the context windows where w; occurs as their center word, which is equivalent to |C;|. Letting p;; be the conditional probability x,;;/x; for generating context word w,; given center word w;, (15.5.2) can be rewritten as
‚Äî Ye DY) pig log ai- (15.5.3) ieV jeV
Àù
In (15.5.3), ‚Äî
ùëó2V ùëùùëñùëó log ùëûùëñùëó calculates the cross-entropy of the conditional distribution
ùëùùëñùëó ofglobalcorpusstatisticsandtheconditionaldistribution ùëûùëñùëó ofmodelpredictions. This loss is also weighted by ùë•ùëñ as explained above. Minimizing the loss function in (15.5.3) will allow the predicted conditional distribution to get close to the conditional distribution from the global corpus statistics. Thoughbeingcommonlyusedformeasuringthedistancebetweenprobabilitydistributions, the cross-entropy loss function may not be a good choice here. On the one hand, as we mentioned in Section 15.2, the cost of properly normalizing ùëûùëñùëó results in the sum over
j ùë§ùëñ‚Äù of word ùë§ ùëó given word ùë§ùëñ in the
exp‚Äûu>
Word Embedding with Global Vectors (GloVe)
713

the entire vocabulary, which can be computationally expensive. On the other hand, a large number of rare events from a large corpus are often modeled by the cross-entropy loss to be assigned with too much weight. 15.5.2 The GloVe Model
In view of this, the GloVe model makes three changes to the skip-gram model based on squared loss (Pennington et al., 2014):
1. Use variables ùëù0
ùëñùëó = ùë•ùëñùëó and ùëû0
ùëñùëó = exp‚Äûu>
1. Use variables Pi; = x;; and %; = exp(uj vi) that are not probability distributions 2 and take the logarithm of both, so the squared loss term is (log Dj; ‚Äî log di) = 2 (uj; ‚Äî log xi) . ‚Äî log xi)
2. Add two scalar model parameters for each word ùë§ùëñ: the center word bias ùëèùëñ and the
context word bias ùëêùëñ. 3. Replace the weight of each loss term with the weight function ‚Ñé‚Äûùë•ùëñùëó‚Äù, where ‚Ñé‚Äûùë•‚Äù is
increasing in the interval of ¬ª0,1‚Ä¶. Puttingallthingstogether,trainingGloVeistominimizethefollowinglossfunction:
2 ¬ª ¬ª h(xij) (ufvit bite, ‚Äî log uj) . (15.5.4) ieV jeV
For the weight function, a suggested choice is: h(x) = (x/c)¬∞ (e.g a = 0.75) ifx < c (eg.,
ùëê = 100); otherwise ‚Ñé‚Äûùë•‚Äù = 1. In this case, because ‚Ñé‚Äû0‚Äù = 0, the squared loss term for any ùë•ùëñùëó = 0 can be omitted for computational efficiency. For example, when using minibatch stochastic gradient descent for training, at each iteration we randomly sample a minibatch of non-zero ùë•ùëñùëó to calculate gradients and update the model parameters. Note that these non-zero ùë•ùëñùëó are precomputed global corpus statistics; thus, the model is called GloVe for Global Vectors. It should be emphasized that if word ùë§ùëñ appears in the context window of word ùë§ ùëó, then vice versa. Therefore, ùë•ùëñùëó = ùë• ùëóùëñ. Unlike word2vec that fits the asymmetric conditional probability ùëùùëñùëó, GloVe fits the symmetric log ùë•ùëñùëó. Therefore, the center word vector and the context word vector of any word are mathematically equivalent in the GloVe model. However in practice, owing to different initialization values, the same word may still get different values in these two vectors after training: GloVe sums them up as the output vector. 15.5.3 Interpreting GloVe from the Ratio of Co-occurrence Probabilities
We can also interpret the GloVe model from another perspective. Using the same notation in Section 15.5.1, let ùëùùëñùëó def = ùëÉ‚Äûùë§ ùëó j ùë§ùëñ‚Äù be the conditional probability of generating the context word ùë§ ùëó given ùë§ùëñ as the center word in the corpus. tab_glove lists several co- occurrence probabilities given words ‚Äúice‚Äù and ‚Äústeam‚Äù and their ratios based on statistics from a large corpus. Natural Language Processing: Pretraining
714

:Word-word co-occurrence probabilities and their ratios from a large corpus (adapted from Table 1 in Pennington et al. (2014))
Table 15.5.1: label:tab_glove
ùë§ùëò=
Wee solid gas water | fashion Pi = P(ws | ice) 0.00019 | 0.000066 | 0.003 | 0.000017 P2 = P(w, | steam) | 0.000022 | 0.00078 | 0.0022 | 0.000018 Pilp2 8.9 0.085 136 | 0.96
We can observe the following from tab_glove:
e Fora word w, that is related to ‚Äúice‚Äù but unrelated to ‚Äústeam‚Äù, such as w, = solid, we
expect a larger ratio of co-occurence probabilities, such as 8.9. e For a word wz, that is related to ‚Äústeam‚Äù but unrelated to ‚Äúice‚Äù, such as wz = gas, we
expect a smaller ratio of co-occurence probabilities, such as 0.085. e For a word wz, that is related to both ‚Äúice‚Äù and ‚Äústeam‚Äù, such as wz = water, we expect
a ratio of co-occurence probabilities that is close to 1, such as 1.36. e For a word wz, that is unrelated to both ‚Äúice‚Äù and ‚Äústeam‚Äù, such as wz, = fashion, we
expect a ratio of co-occurence probabilities that is close to 1, such as 0.96. It can be seen that the ratio of co-occurrence probabilities can intuitively express the rela- tionship between words. Thus, we can design a function of three word vectors to fit this ratio. For the ratio of co-occurrence probabilities p;;/p; with w; being the center word and w, and wx being the context words, we want to fit this ratio using some function f:
f (uj, Uk, Vi) ¬© Pu (15.5.5) Pik
Among many possible designs for ùëì, we only pick a reasonable choice in the following. Among many possible designs for f, we only pick a reasonable choice in the following. Since the ratio of co-occurrence probabilities is a scalar, we require that f be a scalar function, such as f(uj, uz, vi) = f (Cu; - ux) vi). Switching word indices j and k in (15.5.5), it must hold that f(x) f(‚Äîx) = 1, so one possibility is f(x) = exp(x), ie.,
wy Pu (15.5.6) exp (uzvi) Pik f (aj, Ug, Vi) =
u>
= api, where a is a constant. Since p;; = x;;/x;, after taking
Now let‚Äôs pick exp (ujvi) = api, where a is a constant. Since p;; = x;;/x;, after taking the logarithm on both sides we get u;Vi ~ log a+log x;; ‚Äî log x;. We may use additional bias terms to fit ‚Äî log a + log x;, such as the center word bias b; and the context word bias cj:
u>
upwit bite; = log x;;. (15.5.7)
Measuring the squared error of (15.5.7) with weights, the GloVe loss function in (15.5.4) is obtained. ùëùùëñùëó
Subword Embedding
715

15.5.4 Summary
e The skip-gram model can be interpreted using global corpus statistics such as word-word
co-occurrence counts. e The cross-entropy loss may not be a good choice for measuring the difference of two
probability distributions, especially for a large corpus. GloVe uses squared loss to fit precomputed global corpus statistics. e The center word vector and the context word vector are mathematically equivalent for
any word in GloVe. e GloVe can be interpreted from the ratio of word-word co-occurrence probabilities. 15.5.5 Exercises
1. If words ùë§ùëñ and ùë§ ùëó co-occur in the same context window, how can we use their distance
in the text sequence to redesign the method for calculating the conditional probability ùëùùëñùëó? Hint: see Section 4.2 of the GloVe paper (Pennington et al., 2014).bubu2. For any word, are its center word bias and context word bias mathematically equivalent in GloVe? Why?bubuDiscussions233. 233
ase
15.6 Subword Embedding

In English, words such as ‚Äúhelps‚Äù, ‚Äúhelped‚Äù, and ‚Äúhelping‚Äù are inflected forms of the same word ‚Äúhelp‚Äù. The relationship between ‚Äúdog‚Äù and ‚Äúdogs‚Äù is the same as that between ‚Äúcat‚Äù and ‚Äúcats‚Äù, and the relationship between ‚Äúboy‚Äù and ‚Äúboyfriend‚Äù is the same as that between ‚Äúgirl‚Äù and ‚Äúgirlfriend‚Äù. In other languages such as French and Spanish, many verbs have over 40 inflected forms, while in Finnish, a noun may have up to 15 cases. In linguistics, morphologystudieswordformationandwordrelationships. However, theinternalstructure of words was neither explored in word2vec nor in GloVe. 15.6.1 The fastText Model
Recall how words are represented in word2vec. In both the skip-gram model and the con- tinuous bag-of-words model, different inflected forms of the same word are directly repre- sented by different vectors without shared parameters. To use morphological information, the fastText model proposed a subword embedding approach, where a subword is a charac- ter ùëõ-gram (Bojanowski et al., 2017). Instead of learning word-level vector representations, fastText can be considered as the subword-level skip-gram, where each center word is rep- resented by the sum of its subword vectors. Let‚Äôs illustrate how to obtain subwords for each center word in fastText using the word
Natural Language Processing: Pretraining
716

‚Äúwhere‚Äù. First, add special characters ‚Äú<‚Äù and ‚Äú>‚Äù at the beginning and end of the word to distinguish prefixes and suffixes from other subwords. Then, extract character ùëõ-grams from the word. For example, when ùëõ = 3, we obtain all subwords of length 3: ‚Äú<wh‚Äù, ‚Äúwhe‚Äù, ‚Äúher‚Äù, ‚Äúere‚Äù, ‚Äúre>‚Äù, and the special subword ‚Äú<where>‚Äù. In fastText, for any word ùë§, denote by Gùë§ the union of all its subwords of length between
3 and 6 and its special subword. The vocabulary is the union of the subwords of all words. Letting zùëî be the vector of subword ùëî in the dictionary, the vector vùë§ for word ùë§ as a center word in the skip-gram model is the sum of its subword vectors:
vùë§ = zùëî. ùëî2Gùë§ (15.6.1)
The rest of fastText is the same as the skip-gram model. Compared with the skip-gram model, the vocabulary in fastText is larger, resulting in more model parameters. Besides, to calculate the representation of a word, all its subword vectors have to be summed, leading to higher computational complexity. However, thanks to shared parameters from subwords among words with similar structures, rare words and even out-of-vocabulary words may obtain better vector representations in fastText. 15.6.2 Byte Pair Encoding
In fastText, all the extracted subwords have to be of the specified lengths, such as 3 to 6, thus the vocabulary size cannot be predefined. To allow for variable-length subwords in a fixed-size vocabulary, we can apply a compression algorithm called byte pair encoding (BPE) to extract subwords (Sennrich et al., 2015). Byte pair encoding performs a statistical analysis of the training dataset to discover com- mon symbols within a word, such as consecutive characters of arbitrary length. Starting from symbols of length 1, byte pair encoding iteratively merges the most frequent pair of consecutive symbols to produce new longer symbols. Note that for efficiency, pairs cross- ing word boundaries are not considered. In the end, we can use such symbols as subwords to segment words. Byte pair encoding and its variants has been used for input representa- tions in popular natural language processing pretraining models such as GPT-2 (Radford et al., 2019) and RoBERTa (Liu et al., 2019). In the following, we will illustrate how byte pair encoding works. First, we initialize the vocabulary of symbols as all the English lowercase characters, a special end-of-word symbol '_', and a special unknown symbol '[UNK]'. import collections symbols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '_', '[UNK]']
import collections
Since we do not consider symbol pairs that cross boundaries of words, we only need a dictionaryraw_token_freqsthatmapswordstotheirfrequencies(numberofoccurrences) in a dataset. Note that the special symbol '_' is appended to each word so that we can
Subword Embedding
717

easily recover a word sequence (e.g., ‚Äúa taller man‚Äù) from a sequence of output symbols ( e.g., ‚Äúa_ tall er_ man‚Äù). Since we start the merging process from a vocabulary of only single characters and special symbols, space is inserted between every pair of consecutive characters within each word (keys of the dictionary token_freqs). In other words, space is the delimiter between symbols within a word. raw_token_freqs = {'fast_': 4, 'faster_': 3, 'tall_': 5, 'taller_': 4} token_freqs = {} for token, freq in raw_token_freqs.items(): token_freqs[' '.join(list(token))] = raw_token_freqs[token] token_freqs
{'f a s t _': 4, 'f a s t e r _': 3, 't a l l _': 5, 't a l l e r _': 4}
We define the following get_max_freq_pair function that returns the most frequent pair of consecutive symbols within a word, where words come from keys of the input dictionary token_freqs. def get_max_freq_pair(token_freqs): pairs = collections.defaultdict(int) for token, freq in token_freqs.items(): symbols = token.split() for i in range(len(symbols) - 1): # Key of `pairs` is a tuple of two consecutive symbols pairs[symbols[i], symbols[i + 1]] += freq return max(pairs, key=pairs.get) # Key of `pairs` with the max value
As a greedy approach based on frequency of consecutive symbols, byte pair encoding will use the following merge_symbols function to merge the most frequent pair of consecutive symbols to produce new symbols. def merge_symbols(max_freq_pair, token_freqs, symbols): symbols.append(''.join(max_freq_pair)) new_token_freqs = dict() for token, freq in token_freqs.items(): new_token = token.replace(' '.join(max_freq_pair), ''.join(max_freq_pair)) new_token_freqs[new_token] = token_freqs[token] return new_token_freqs
Now we iteratively perform the byte pair encoding algorithm over the keys of the dictionary token_freqs. In the first iteration, the most frequent pair of consecutive symbols are 't' and 'a', thus byte pair encoding merges them to produce a new symbol 'ta'. In the second iteration, byte pair encoding continues to merge 'ta' and 'l' to result in another new symbol 'tal'. num_merges = 10 for i in range(num_merges):
(continues on next page)
Natural Language Processing: Pretraining
718

max_freq_pair = get_max_freq_pair(token_freqs) token_freqs = merge_symbols(max_freq_pair, token_freqs, symbols) print(f'merge #{i + 1}:', max_freq_pair)
merge #1: ('t', 'a') merge #2: ('ta', 'l') merge #3: ('tal', 'l') merge #4: ('f', 'a') merge #5: ('fa', 's') merge #6: ('fas', 't') merge #7: ('e', 'r') merge #8: ('er', '_') merge #9: ('tall', '_') merge #10: ('fast', '_')
After 10 iterations of byte pair encoding, we can see that list symbols now contains 10 more symbols that are iteratively merged from other symbols. print(symbols)
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p ‚Ü©!', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '_', '[UNK]', 'ta', 'tal ‚Ü©!', 'tall', 'fa', 'fas', 'fast', 'er', 'er_', 'tall_', 'fast_']
For the same dataset specified in the keys of the dictionary raw_token_freqs, each word in the dataset is now segmented by subwords ‚Äúfast_‚Äù, ‚Äúfast‚Äù, ‚Äúer_‚Äù, ‚Äútall_‚Äù, and ‚Äútall‚Äù as a result of the byte pair encoding algorithm. For instance, words ‚Äúfaster_‚Äù and ‚Äútaller_‚Äù are segmented as ‚Äúfast er_‚Äù and ‚Äútall er_‚Äù, respectively. print(list(token_freqs.keys()))
['fast_', 'fast er_', 'tall_', 'tall er_']
Note that the result of byte pair encoding depends on the dataset being used. We can also use the subwords learned from one dataset to segment words of another dataset. As a greedy approach, the following segment_BPE function tries to break words into the longest possible subwords from the input argument symbols. def segment_BPE(tokens, symbols): outputs = [] for token in tokens: start, end = 0, len(token) cur_output = [] # Segment token with the longest possible subwords from symbols while start < len(token) and start < end: if token[start: end] in symbols:
(continued from previous page)
(continues on next page)
Subword Embedding
719

cur_output.append(token[start: end]) start = end end = len(token) else: end -= 1 if start < len(token): cur_output.append('[UNK]') outputs.append(' '.join(cur_output)) return outputs
In the following, we use the subwords in list symbols, which is learned from the aforemen- tioned dataset, to segment tokens that represent another dataset. tokens = ['tallest_', 'fatter_'] print(segment_BPE(tokens, symbols))
['tall e s t _', 'fa t t er_']
15.6.3 Summary
e The fastText model proposes a subword embedding approach. Based on the skip-gram
model in word2vec, it represents a center word as the sum of its subword vectors. e Byte pair encoding performs a statistical analysis of the training dataset to discover com-
mon symbols within a word. As a greedy approach, byte pair encoding iteratively merges the most frequent pair of consecutive symbols. e Subword embedding may improve the quality of representations of rare words and out-
of-dictionary words. 15.6.4 Exercises
1. As an example, there are about 3 x 108 possible 6-grams in English. What is the issue when there are too many subwords? How to address the issue? Hint: refer to the end of Section 3.2 of the fastText paper (Bojanowski et al., 2017).bubu2. How to design a subword embedding model based on the continuous bag-of-words model? 3. To get a vocabulary of size ùëö, how many merging operations are needed when the initial
symbol vocabulary size is ùëõ? 234
4. How to extend the idea of byte pair encoding to extract phrases? Discussions234. (continued from previous page)
Natural Language Processing: Pretraining
720

15.7 Word Similarity and Analogy
a
In Section 15.4, we trained a word2vec model on a small dataset, and applied it to find semantically similar words for an input word. In practice, word vectors that are pretrained on large corpora can be applied to downstream natural language processing tasks, which will be covered later in Chapter 16. To demonstrate semantics of pretrained word vectors from large corpora in a straightforward way, let‚Äôs apply them in the word similarity and analogy tasks. import os import torch from torch import nn from d2l import torch as d2l
15.7.1 Loading Pretrained Word Vectors
Below lists pretrained GloVe embeddings of dimension 50, 100, and 300, which can be downloaded from the GloVe website235. The pretrained fastText embeddings are available in multiple languages. Here we consider one English version (300-dimensional ‚Äúwiki.en‚Äù) that can be downloaded from the fastText website236. 235
#@save
236
d2l.DATA_HUB['glove.6b.50d'] = (d2l.DATA_URL + 'glove.6B.50d.zip', '0b8703943ccdb6eb788e6f091b8946e82231bc4d')
#@save
d2l.DATA_HUB['glove.6b.100d'] = (d2l.DATA_URL + 'glove.6B.100d.zip', 'cd43bfb07e44e6f27cbcc7bc9ae3d80284fdaf5a')
#@save
d2l.DATA_HUB['glove.42b.300d'] = (d2l.DATA_URL + 'glove.42B.300d.zip', 'b5116e234e9eb9076672cfeabf5469f3eec904fa')
#@save
d2l.DATA_HUB['wiki.en'] = (d2l.DATA_URL + 'wiki.en.zip', 'c1816da3821ae9f43899be655002f6c723e91b88')
To load these pretrained GloVe and fastText embeddings, we define the following Token- Embedding class. #@save class TokenEmbedding: """Token Embedding.""" def __init__(self, embedding_name): self.idx_to_token, self.idx_to_vec = self._load_embedding( embedding_name) self.unknown_idx = 0
(continues on next page)
Word Similarity and Analogy
721

self.token_to_idx = {token: idx for idx, token in enumerate(self.idx_to_token)} def _load_embedding(self, embedding_name): idx_to_token, idx_to_vec = ['<unk>'], [] data_dir = d2l.download_extract(embedding_name) # GloVe website: https://nlp.stanford.edu/projects/glove/ # fastText website: https://fasttext.cc/ with open(os.path.join(data_dir, 'vec.txt'), 'r') as f: for line in f: elems = line.rstrip().split(' ') token, elems = elems[0], [float(elem) for elem in elems[1:]] # Skip header information, such as the top row in fastText if len(elems) > 1: idx_to_token.append(token) idx_to_vec.append(elems) idx_to_vec = [[0] * len(idx_to_vec[0])] + idx_to_vec return idx_to_token, torch.tensor(idx_to_vec) def __getitem__(self, tokens): indices = [self.token_to_idx.get(token, self.unknown_idx) for token in tokens] vecs = self.idx_to_vec[torch.tensor(indices)] return vecs def __len__(self): return len(self.idx_to_token)
Below we load the 50-dimensional GloVe embeddings (pretrained on a Wikipedia sub- set). When creating the TokenEmbedding instance, the specified embedding file has to be downloaded if it was not yet. glove_6b50d = TokenEmbedding('glove.6b.50d')
Downloading ../data/glove.6B.50d.zip from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/glove.6B.50d.zip... Output the vocabulary size. The vocabulary contains 400000 words (tokens) and a special unknown token. len(glove_6b50d)
400001
We can get the index of a word in the vocabulary, and vice versa. glove_6b50d.token_to_idx['beautiful'], glove_6b50d.idx_to_token[3367]
(continued from previous page)
Natural Language Processing: Pretraining
722

(3367, 'beautiful')
15.7.2 Applying Pretrained Word Vectors
Using the loaded GloVe vectors, we will demonstrate their semantics by applying them in the following word similarity and analogy tasks. Word Similarity
Similar to Section 15.4.3, in order to find semantically similar words for an input word based on cosine similarities between word vectors, we implement the following knn (ùëò- nearest neighbors) function. def knn(W, x, k): # Add 1e-9 for numerical stability cos = torch.mv(W, x.reshape(-1,)) / ( torch.sqrt(torch.sum(W * W, axis=1) + 1e-9) * torch.sqrt((x * x).sum())) _, topk = torch.topk(cos, k=k) return topk, [cos[int(i)] for i in topk]
Then, we search for similar words using the pretrained word vectors from the TokenEm- bedding instance embed. def get_similar_tokens(query_token, k, embed): topk, cos = knn(embed.idx_to_vec, embed[[query_token]], k + 1) for i, c in zip(topk[1:], cos[1:]): # Exclude the input word print(f'cosine sim={float(c):.3f}: {embed.idx_to_token[int(i)]}')
The vocabulary of the pretrained word vectors in glove_6b50d contains 400000 words and a special unknown token. Excluding the input word and unknown token, among this vocabulary let‚Äôs find three most semantically similar words to word ‚Äúchip‚Äù. get_similar_tokens('chip', 3, glove_6b50d)
cosine sim=0.856: chips cosine sim=0.749: intel cosine sim=0.749: electronics
Below outputs similar words to ‚Äúbaby‚Äù and ‚Äúbeautiful‚Äù. get_similar_tokens('baby', 3, glove_6b50d)
cosine sim=0.839: babies cosine sim=0.800: boy cosine sim=0.792: girl
Word Similarity and Analogy
723

get_similar_tokens('beautiful', 3, glove_6b50d)
cosine sim=0.921: lovely cosine sim=0.893: gorgeous cosine sim=0.830: wonderful
Word Analogy
Besides finding similar words, we can also apply word vectors to word analogy tasks. For example, ‚Äúman‚Äù:‚Äú‚Äòwoman‚Äù::‚Äúson‚Äô‚Äù:‚Äúdaughter‚Äù is the form of a word analogy: ‚Äúman‚Äù is to ‚Äúwoman‚Äù as ‚Äúson‚Äù is to ‚Äúdaughter‚Äù. Specifically, the word analogy completion task can be defined as: for a word analogy a: b :: c : d, given the first three words a, b and c, find d. Denote the vector of word w by vec(w). To complete the analogy, we will find the word whose vector is most similar to the result of vec(c) + vec(b) ‚Äî vec(a). def get_analogy(token_a, token_b, token_c, embed): vecs = embed[[token_a, token_b, token_c]] x = vecs[1] - vecs[0] + vecs[2] topk, cos = knn(embed.idx_to_vec, x, 1) return embed.idx_to_token[int(topk[0])] # Remove unknown words
Let‚Äôs verify the ‚Äúmale-female‚Äù analogy using the loaded word vectors. get_analogy('man', 'woman', 'son', glove_6b50d)
'daughter'
Below completes a ‚Äúcapital-country‚Äù analogy: ‚Äúbeijing‚Äù:‚Äúchina‚Äù::‚Äútokyo‚Äù:‚Äújapan‚Äù. This demonstrates semantics in the pretrained word vectors. get_analogy('beijing', 'china', 'tokyo', glove_6b50d)
'japan'
For the ‚Äúadjective-superlative adjective‚Äù analogy such as ‚Äúbad‚Äù:‚Äúworst‚Äù::‚Äúbig‚Äù:‚Äúbiggest‚Äù, we can see that the pretrained word vectors may capture the syntactic information. get_analogy('bad', 'worst', 'big', glove_6b50d)
'biggest'
To show the captured notion of past tense in the pretrained word vectors, we can test the syntax using the ‚Äúpresent tense-past tense‚Äù analogy: ‚Äúdo‚Äù:‚Äúdid‚Äù::‚Äúgo‚Äù:‚Äúwent‚Äù. Natural Language Processing: Pretraining
724

get_analogy('do', 'did', 'go', glove_6b50d)
'went'
15.7.3 Summary
e In practice, word vectors that are pretrained on large corpora can be applied to down-
stream natural language processing tasks. e Pretrained word vectors can be applied to the word similarity and analogy tasks. 15.7.4 Exercises
1. Test the fastText results using TokenEmbedding('wiki.en'). 2. When the vocabulary is extremely large, how can we find similar words or complete a word analogy faster? 237

Discussions237. 15.8 Bidirectional Encoder Representations from Transformers (BERT)
|
We have introduced several word embedding models for natural language understanding. After pretraining, the output can be thought of as a matrix where each row is a vector that represents a word of a predefined vocabulary. In fact, these word embedding models are all context-independent. Let‚Äôs begin by illustrating this property. 15.8.1 From Context-Independent to Context-Sensitive
RecalltheexperimentsinSection15.4andSection15.7. Forinstance, word2vecandGloVe both assign the same pretrained vector to the same word regardless of the context of the word (if any). Formally, a context-independent representation of any token ùë• is a func- tion ùëì ‚Äûùë•‚Äù that only takes ùë• as its input. Given the abundance of polysemy and complex semantics in natural languages, context-independent representations have obvious limita- tions. For instance, the word ‚Äúcrane‚Äù in contexts ‚Äúa crane is flying‚Äù and ‚Äúa crane driver came‚Äù has completely different meanings; thus, the same word may be assigned different representations depending on contexts. This motivates the development of context-sensitive word representations, where represen- tations of words depend on their contexts. Hence, a context-sensitive representation of
Bidirectional Encoder Representations from Transformers (BERT)
725

token ùë• is a function ùëì ‚Äûùë•, ùëê‚Äûùë•‚Äù‚Äù depending on both ùë• and its context ùëê‚Äûùë•‚Äù. Popular context-
sensitiverepresentationsincludeTagLM(language-model-augmentedsequencetagger)(Pe- ters et al., 2017), CoVe (Context Vectors) (McCann et al., 2017), and ELMo (Embeddings from Language Models) (Peters et al., 2018). For example, by taking the entire sequence as input, ELMo is a function that assigns a rep- resentation to each word from the input sequence. Specifically, ELMo combines all the intermediate layer representations from pretrained bidirectional LSTM as the output rep- resentation. Then the ELMo representation will be added to a downstream task‚Äôs existing supervised model as additional features, such as by concatenating ELMo representation and the original representation (e.g., GloVe) of tokens in the existing model. On the one hand, all the weights in the pretrained bidirectional LSTM model are frozen after ELMo representations are added. On the other hand, the existing supervised model is specifically customized for a given task. Leveraging different best models for different tasks at that time, adding ELMo improved the state of the art across six natural language processing tasks: sentiment analysis, natural language inference, semantic role labeling, coreference resolution, named entity recognition, and question answering. 15.8.2 From Task-Specific to Task-Agnostic
Although ELMo has significantly improved solutions to a diverse set of natural language processing tasks, each solution still hinges on a task-specific architecture. However, it is practically non-trivial to craft a specific architecture for every natural language processing task. The GPT (Generative Pre-Training) model represents an effort in designing a general task-agnostic model for context-sensitive representations (Radford et al., 2018). Built on a Transformer decoder, GPT pretrains a language model that will be used to represent text sequences. When applying GPT to a downstream task, the output of the language model will be fed into an added linear output layer to predict the label of the task. In sharp contrast to ELMo that freezes parameters of the pretrained model, GPT fine-tunes all the parame- ters in the pretrained Transformer decoder during supervised learning of the downstream task. GPT was evaluated on twelve tasks of natural language inference, question answer- ing, sentence similarity, and classification, and improved the state of the art in nine of them with minimal changes to the model architecture. However, due to the autoregressive nature of language models, GPT only looks forward (left-to-right). In contexts ‚Äúi went to the bank to deposit cash‚Äù and ‚Äúi went to the bank to sit down‚Äù, as ‚Äúbank‚Äù is sensitive to the context to its left, GPT will return the same representation for ‚Äúbank‚Äù, though it has different meanings. 15.8.3 BERT: Combining the Best of Both Worlds
Aswehaveseen, ELMoencodescontextbidirectionallybutusestask-specificarchitectures; while GPT is task-agnostic but encodes context left-to-right. Combining the best of both worlds, BERT (Bidirectional Encoder Representations from Transformers) encodes con- text bidirectionally and requires minimal architecture changes for a wide range of natural language processing tasks (Devlin et al., 2018). Using a pretrained Transformer encoder, BERT is able to represent any token based on its bidirectional context. During supervised
Natural Language Processing: Pretraining
726

learning of downstream tasks, BERT is similar to GPT in two aspects. First, BERT rep- resentations will be fed into an added output layer, with minimal changes to the model architecture depending on nature of tasks, such as predicting for every token vs. predicting for the entire sequence. Second, all the parameters of the pretrained Transformer encoder are fine-tuned, while the additional output layer will be trained from scratch. Fig. 15.8.1 depicts the differences among ELMo, GPT, and BERT. Label(s) of the task Label(s) of the task Label(s) of the task Architecture crafted for the given task Rep, ... Repy Rep, Repy Rep, Repy Unidirectional . architecture [X Ne \ Le Pretraining Pretraining & fine-tuning Token, Token, Token, Tokeny Token, Tokeny ELMo GPT BERT
tFig. 15.8.1 A comparison of ELMo, GPT, and BERT. BERT further improved the state of the art on eleven natural language processing tasks under broad categories of (i) single text classification (e.g., sentiment analysis), (ii) text pair classification (e.g., natural language inference), (iii) question answering, (iv) text tagging (e.g., named entity recognition). All proposed in 2018, from context-sensitive ELMo to task-agnostic GPT and BERT, conceptually simple yet empirically powerful pretraining of deep representations for natural languages have revolutionized solutions to various natural language processing tasks. In the rest of this chapter, we will dive into the pretraining of BERT. When natural language processing applications are explained in Chapter 16, we will illustrate fine-tuning of BERT for downstream applications. import torch from torch import nn from d2l import torch as d2l
15.8.4 Input Representation
In natural language processing, some tasks (e.g., sentiment analysis) take single text as input, while in some other tasks (e.g., natural language inference), the input is a pair of text sequences. The BERT input sequence unambiguously represents both single text and text pairs. In the former, the BERT input sequence is the concatenation of the special classification token ‚Äú<cls>‚Äù, tokens of a text sequence, and the special separation token ‚Äú<sep>‚Äù. In the latter, the BERT input sequence is the concatenation of ‚Äú<cls>‚Äù, tokens of the first text sequence, ‚Äú<sep>‚Äù, tokens of the second text sequence, and ‚Äú<sep>‚Äù. We will consistently distinguish the terminology ‚ÄúBERT input sequence‚Äù from other types of
Bidirectional Encoder Representations from Transformers (BERT)
727

‚Äúsequences‚Äù. For instance, one BERT input sequence may include either one text sequence or two text sequences. To distinguish text pairs, the learned segment embeddings eùê¥ and eùêµ are added to the token embeddings of the first sequence and the second sequence, respectively. For single text inputs, only eùê¥ is used. The following get_tokens_and_segments takes either one sentence or two sentences as input, then returns tokens of the BERT input sequence and their corresponding segment IDs. #@save def get_tokens_and_segments(tokens_a, tokens_b=None): """Get tokens of the BERT input sequence and their segment IDs.""" tokens = ['<cls>'] + tokens_a + ['<sep>'] # 0 and 1 are marking segment A and B, respectively segments = [0] * (len(tokens_a) + 2) if tokens_b is not None: tokens += tokens_b + ['<sep>'] segments += [1] * (len(tokens_b) + 1) return tokens, segments
BERT chooses the Transformer encoder as its bidirectional architecture. Common in the Transformer encoder, positional embeddings are added at every position of the BERT input sequence. However, different from the original Transformer encoder, BERT uses learnable positional embeddings. To sum up, Fig. 15.8.2 shows that the embeddings of the BERT input sequence are the sum of the token embeddings, segment embeddings, and positional embeddings. Input <cls> this movie is great <sep> i like it <sep> Token e ¬¢, ¬¢ ¬¢ ¬¢ e ¬¢ ¬¢ e Embeddings | ‚Äú<< i ‚Äòwove a rea | | Ccsep> ‚Äò Se ie icp + + + + + + + + + + Segment ‚Äò Embeddings |_** + + + + + + + + + + Positional Embeddings ¬´ 4 ¬¢ A & ep & op
tFig. 15.8.2
The embeddings of the BERT input sequence are the sum of the token embeddings, segment embeddings, and positional embeddings. The following BERTEncoder class is similar to the TransformerEncoder class as imple- mented in Section 11.7. Different from TransformerEncoder, BERTEncoder uses segment embeddings and learnable positional embeddings. #@save class BERTEncoder(nn.Module): """BERT encoder.""" def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout, max_len=1000, **kwargs):
(continues on next page)
Natural Language Processing: Pretraining
728

super(BERTEncoder, self).__init__(**kwargs) self.token_embedding = nn.Embedding(vocab_size, num_hiddens) self.segment_embedding = nn.Embedding(2, num_hiddens) self.blks = nn.Sequential() for i in range(num_blks): self.blks.add_module(f"{i}", d2l.TransformerEncoderBlock( num_hiddens, ffn_num_hiddens, num_heads, dropout, True)) # In BERT, positional embeddings are learnable, thus we create a # parameter of positional embeddings that are long enough self.pos_embedding = nn.Parameter(torch.randn(1, max_len, num_hiddens)) def forward(self, tokens, segments, valid_lens): # Shape of `X` remains unchanged in the following code snippet: # (batch size, max sequence length, `num_hiddens`) X = self.token_embedding(tokens) + self.segment_embedding(segments) X = X + self.pos_embedding[:, :X.shape[1], :] for blk in self.blks: X = blk(X, valid_lens) return X
Suppose that the vocabulary size is 10000. To demonstrate forward inference of BERTEn- coder, let‚Äôs create an instance of it and initialize its parameters. vocab_size, num_hiddens, ffn_num_hiddens, num_heads = 10000, 768, 1024, 4 ffn_num_input, num_blks, dropout = 768, 2, 0.2 encoder = BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout)
We define tokens to be 2 BERT input sequences of length 8, where each token is an index of the vocabulary. The forward inference of BERTEncoder with the input tokens returns the encoded result where each token is represented by a vector whose length is predefined by the hyperparameter num_hiddens. This hyperparameter is usually referred to as the hidden size (number of hidden units) of the Transformer encoder. tokens = torch.randint(0, vocab_size, (2, 8)) segments = torch.tensor([[0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1]]) encoded_X = encoder(tokens, segments, None) encoded_X.shape
torch.Size([2, 8, 768])
15.8.5 Pretraining Tasks
The forward inference of BERTEncoder gives the BERT representation of each token of the input text and the inserted special tokens ‚Äú<cls>‚Äù and ‚Äú<seq>‚Äù. Next, we will use these representations to compute the loss function for pretraining BERT. The pretraining is composed of the following two tasks: masked language modeling and next sentence prediction. (continued from previous page)
Bidirectional Encoder Representations from Transformers (BERT)
729

Masked Language Modeling
As illustrated in Section 9.3, a language model predicts a token using the context on its left. To encode context bidirectionally for representing each token, BERT randomly masks tokens and uses tokens from the bidirectional context to predict the masked tokens in a self-supervised fashion. This task is referred to as a masked language model. In this pretraining task, 15% of tokens will be selected at random as the masked tokens for prediction. To predict a masked token without cheating by using the label, one straight- forward approach is to always replace it with a special ‚Äú<mask>‚Äù token in the BERT input sequence. However, the artificial special token ‚Äú<mask>‚Äù will never appear in fine-tuning. To avoid such a mismatch between pretraining and fine-tuning, if a token is masked for prediction (e.g., ‚Äúgreat‚Äù is selected to be masked and predicted in ‚Äúthis movie is great‚Äù), in the input it will be replaced with:
e aspecial ‚Äú<mask>‚Äù token for 80% of the time (e.g., ‚Äúthis movie is great‚Äù becomes ‚Äúthis
movie is <mask>‚Äù);
e arandom token for 10% of the time (e.g., ‚Äúthis movie is great‚Äù becomes ‚Äúthis movie is
drink‚Äù);
e the unchanged label token for 10% of the time (e.g., ‚Äúthis movie is great‚Äô becomes ‚Äúthis
movie is great‚Äù). Notethatfor10%of15%timearandomtokenisinserted. Thisoccasionalnoiseencourages BERT to be less biased towards the masked token (especially when the label token remains unchanged) in its bidirectional context encoding. We implement the following MaskLM class to predict masked tokens in the masked language model task of BERT pretraining. The prediction uses a one-hidden-layer MLP (self.mlp). In forward inference, it takes two inputs: the encoded result of BERTEncoder and the token positions for prediction. The output is the prediction results at these positions. #@save class MaskLM(nn.Module): """The masked language model task of BERT.""" def __init__(self, vocab_size, num_hiddens, **kwargs): super(MaskLM, self).__init__(**kwargs) self.mlp = nn.Sequential(nn.LazyLinear(num_hiddens), nn.ReLU(), nn.LayerNorm(num_hiddens), nn.LazyLinear(vocab_size)) def forward(self, X, pred_positions): num_pred_positions = pred_positions.shape[1] pred_positions = pred_positions.reshape(-1) batch_size = X.shape[0] batch_idx = torch.arange(0, batch_size) # Suppose that `batch_size` = 2, `num_pred_positions` = 3, then # `batch_idx` is `torch.tensor([0, 0, 0, 1, 1, 1])` batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions) masked_X = X[batch_idx, pred_positions]
(continues on next page)
Natural Language Processing: Pretraining
730

masked_X = masked_X.reshape((batch_size, num_pred_positions, -1)) mlm_Y_hat = self.mlp(masked_X) return mlm_Y_hat
To demonstrate the forward inference of MaskLM, we create its instance mlm and initialize it. Recall that encoded_X from the forward inference of BERTEncoder represents 2 BERT input sequences. We define mlm_positions as the 3 indices to predict in either BERT input sequenceof encoded_X.Theforwardinferenceof mlmreturnspredictionresultsmlm_Y_hat at all the masked positions mlm_positions of encoded_X. For each prediction, the size of the result is equal to the vocabulary size. mlm = MaskLM(vocab_size, num_hiddens) mlm_positions = torch.tensor([[1, 5, 2], [6, 1, 5]]) mlm_Y_hat = mlm(encoded_X, mlm_positions) mlm_Y_hat.shape
torch.Size([2, 3, 10000])
With the ground truth labels mlm_Y of the predicted tokens mlm_Y_hat under masks, we can calculate the cross-entropy loss of the masked language model task in BERT pretrain- ing. mlm_Y = torch.tensor([[7, 8, 9], [10, 20, 30]]) loss = nn.CrossEntropyLoss(reduction='none') mlm_l = loss(mlm_Y_hat.reshape((-1, vocab_size)), mlm_Y.reshape(-1)) mlm_l.shape
torch.Size([6])
Next Sentence Prediction
Although masked language modeling is able to encode bidirectional context for represent- ing words, it does not explicitly model the logical relationship between text pairs. To help understand the relationship between two text sequences, BERT considers a binary classi- fication task, next sentence prediction, in its pretraining. When generating sentence pairs for pretraining, for half of the time they are indeed consecutive sentences with the label ‚ÄúTrue‚Äù; while for the other half of the time the second sentence is randomly sampled from the corpus with the label ‚ÄúFalse‚Äù. The following NextSentencePred class uses a one-hidden-layer MLP to predict whether the second sentence is the next sentence of the first in the BERT input sequence. Due to self-attention in the Transformer encoder, the BERT representation of the special token ‚Äú<cls>‚Äù encodes both the two sentences from the input. Hence, the output layer (self. (continued from previous page)
Bidirectional Encoder Representations from Transformers (BERT)
731

output) of the MLP classifier takes X as input, where X is the output of the MLP hidden layer whose input is the encoded ‚Äú<cls>‚Äù token. #@save class NextSentencePred(nn.Module): """The next sentence prediction task of BERT.""" def __init__(self, **kwargs): super(NextSentencePred, self).__init__(**kwargs) self.output = nn.LazyLinear(2) def forward(self, X): # `X` shape: (batch size, `num_hiddens`) return self.output(X)
We can see that the forward inference of an NextSentencePred instance returns binary predictions for each BERT input sequence. # PyTorch by default will not flatten the tensor as seen in mxnet where, if # flatten=True, all but the first axis of input data are collapsed together encoded_X = torch.flatten(encoded_X, start_dim=1) # input_shape for NSP: (batch size, `num_hiddens`) nsp = NextSentencePred() nsp_Y_hat = nsp(encoded_X) nsp_Y_hat.shape
torch.Size([2, 2])
The cross-entropy loss of the 2 binary classifications can also be computed. nsp_y = torch.tensor([0, 1]) nsp_l = loss(nsp_Y_hat, nsp_y) nsp_l.shape
torch.Size([2])
It is noteworthy that all the labels in both the aforementioned pretraining tasks can be triv- ially obtained from the pretraining corpus without manual labeling effort. The original BERT has been pretrained on the concatenation of BookCorpus (Zhu et al., 2015) and En- glish Wikipedia. These two text corpora are huge: they have 800 million words and 2.5 billion words, respectively. 15.8.6 Putting It All Together
When pretraining BERT, the final loss function is a linear combination of both the loss functions for masked language modeling and next sentence prediction. Now we can de- fine the BERTModel class by instantiating the three classes BERTEncoder, MaskLM, and NextSentencePred. The forward inference returns the encoded BERT representations en-
Natural Language Processing: Pretraining
732

coded_X, predictions of masked language modeling mlm_Y_hat, and next sentence predic- tions nsp_Y_hat. #@save class BERTModel(nn.Module): """The BERT model.""" def __init__(self, vocab_size, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout, max_len=1000): super(BERTModel, self).__init__() self.encoder = BERTEncoder(vocab_size, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout, max_len=max_len) self.hidden = nn.Sequential(nn.LazyLinear(num_hiddens), nn.Tanh()) self.mlm = MaskLM(vocab_size, num_hiddens) self.nsp = NextSentencePred() def forward(self, tokens, segments, valid_lens=None, pred_positions=None): encoded_X = self.encoder(tokens, segments, valid_lens) if pred_positions is not None: mlm_Y_hat = self.mlm(encoded_X, pred_positions) else: mlm_Y_hat = None # The hidden layer of the MLP classifier for next sentence prediction. # 0 is the index of the '<cls>' token nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, 0, :])) return encoded_X, mlm_Y_hat, nsp_Y_hat
15.8.7 Summary
Word embedding models such as word2vec and GloVe are context-independent. They
assign the same pretrained vector to the same word regardless of the context of the word (if any). It is hard for them to handle well polysemy or complex semantics in natural languages. e For context-sensitive word representations such as ELMo and GPT, representations of
words depend on their contexts. ELMo encodes context bidirectionally but uses task-specific architectures (however, it is
practically non-trivial to craft a specific architecture for every natural language pro- cessing task); while GPT is task-agnostic but encodes context left-to-right. BERT combines the best of both worlds: it encodes context bidirectionally and requires
minimal architecture changes for a wide range of natural language processing tasks. The embeddings of the BERT input sequence are the sum of the token embeddings,
segment embeddings, and positional embeddings. Pretraining BERT is composed of two tasks: masked language modeling and next sen-
tence prediction. The former is able to encode bidirectional context for representing words, while the latter explicitly models the logical relationship between text pairs. The Dataset for Pretraining BERT
733

15.8.8 Exercises
1. All other things being equal, will a masked language model require more or fewer pre- training steps to converge than a left-to-right language model? Why?bubu2. IntheoriginalimplementationofBERT,thepositionwisefeed-forwardnetworkinBERTEn- coder (via d2l.TransformerEncoderBlock) and the fully connected layer in MaskLM both use the Gaussian error linear unit (GELU) (Hendrycks and Gimpel, 2016) as the activation function. Research into the difference between GELU and ReLU.bubuDiscussions238. 238
15.9 The Dataset for Pretraining BERT
|
TopretraintheBERTmodelasimplementedinSection15.8,weneedtogeneratethedataset in the ideal format to facilitate the two pretraining tasks: masked language modeling and next sentence prediction. On the one hand, the original BERT model is pretrained on the concatenation of two huge corpora BookCorpus and English Wikipedia (see Section 15.8.5), making it hard to run for most readers of this book. On the other hand, the off- the-shelf pretrained BERT model may not fit for applications from specific domains like medicine. Thus, it is getting popular to pretrain BERT on a customized dataset. To facil- itate the demonstration of BERT pretraining, we use a smaller corpus WikiText-2 (Merity et al., 2016). Comparing with the PTB dataset used for pretraining word2vec in Section 15.3, WikiText- 2 (i) retains the original punctuation, making it suitable for next sentence prediction; (ii) retains the original case and numbers; (iii) is over twice larger. import os import random import torch from d2l import torch as d2l
In the WikiText-2 dataset, each line represents a paragraph where space is inserted be- tween any punctuation and its preceding token. Paragraphs with at least two sentences are retained.bubuTo split sentences, we only use the period as the delimiter for simplicity. We leave discussions of more complex sentence splitting techniques in the exercises at the end of this section. #@save d2l.DATA_HUB['wikitext-2'] = ( 'https://s3.amazonaws.com/research.metamind.io/wikitext/' 'wikitext-2-v1.zip', '3c914d17d80b1459be871a5039ac23e752a53cbe') #@save
#@save
(continues on next page)
Natural Language Processing: Pretraining
734

def _read_wiki(data_dir): file_name = os.path.join(data_dir, 'wiki.train.tokens') with open(file_name, 'r') as f: lines = f.readlines() # Uppercase letters are converted to lowercase ones paragraphs = [line.strip().lower().split(' . ') for line in lines if len(line.split(' . ')) >= 2] random.shuffle(paragraphs) return paragraphs
15.9.1 Defining Helper Functions for Pretraining Tasks
In the following, we begin by implementing helper functions for the two BERT pretraining tasks: next sentence prediction and masked language modeling. These helper functions will be invoked later when transforming the raw text corpus into the dataset of the ideal format to pretrain BERT. Generating the Next Sentence Prediction Task
According to descriptions of Section 15.8.5, the _get_next_sentence function generates a training example for the binary classification task. #@save def _get_next_sentence(sentence, next_sentence, paragraphs): if random.random() < 0.5: is_next = True else: # `paragraphs` is a list of lists of lists next_sentence = random.choice(random.choice(paragraphs)) is_next = False return sentence, next_sentence, is_next
The following function generates training examples for next sentence prediction from the input paragraph by invoking the _get_next_sentence function. Here paragraph is a list of sentences, where each sentence is a list of tokens. The argument max_len specifies the maximum length of a BERT input sequence during pretraining. #@save def _get_nsp_data_from_paragraph(paragraph, paragraphs, vocab, max_len): nsp_data_from_paragraph = [] for i in range(len(paragraph) - 1): tokens_a, tokens_b, is_next = _get_next_sentence( paragraph[i], paragraph[i + 1], paragraphs) # Consider 1 '<cls>' token and 2 '<sep>' tokens if len(tokens_a) + len(tokens_b) + 3 > max_len: continue tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b) nsp_data_from_paragraph.append((tokens, segments, is_next)) return nsp_data_from_paragraph
(continued from previous page)
The Dataset for Pretraining BERT
735

Generating the Masked Language Modeling Task
In order to generate training examples for the masked language modeling task from a BERT input sequence, we define the following _replace_mlm_tokens function. In its inputs, to- kens is a list of tokens representing a BERT input sequence, candidate_pred_positions is a list of token indices of the BERT input sequence excluding those of special tokens (spe- cial tokens are not predicted in the masked language modeling task), and num_mlm_preds indicates the number of predictions (recall 15% random tokens to predict). Following the definition of the masked language modeling task in Section 15.8.5, at each prediction posi- tion, the input may be replaced by a special ‚Äú<mask>‚Äù token or a random token, or remain unchanged. In the end, the function returns the input tokens after possible replacement, the token indices where predictions take place and labels for these predictions. #@save
def _replace_mlm_tokens(tokens, candidate_pred_positions, num_mlm_preds, vocab): # For the input of a masked language model, make a new copy of tokens and # replace some of them by '<mask>' or random tokens mlm_input_tokens = [token for token in tokens] pred_positions_and_labels = [] # Shuffle for getting 15% random tokens for prediction in the masked # language modeling task random.shuffle(candidate_pred_positions) for mlm_pred_position in candidate_pred_positions: if len(pred_positions_and_labels) >= num_mlm_preds: break masked_token = None # 80% of the time: replace the word with the '<mask>' token if random.random() < 0.8: masked_token = '<mask>' else: # 10% of the time: keep the word unchanged if random.random() < 0.5: masked_token = tokens[mlm_pred_position] # 10% of the time: replace the word with a random word else: masked_token = random.choice(vocab.idx_to_token) mlm_input_tokens[mlm_pred_position] = masked_token pred_positions_and_labels.append( (mlm_pred_position, tokens[mlm_pred_position])) return mlm_input_tokens, pred_positions_and_labels
By invoking the aforementioned _replace_mlm_tokens function, the following function takes a BERT input sequence (tokens) as an input and returns indices of the input tokens (after possible token replacement as described in Section 15.8.5), the token indices where predictions take place, and label indices for these predictions. #@save def _get_mlm_data_from_tokens(tokens, vocab): candidate_pred_positions = [] # `tokens` is a list of strings for i, token in enumerate(tokens):
(continues on next page)
Natural Language Processing: Pretraining
736

# Special tokens are not predicted in the masked language modeling # task if token in ['<cls>', '<sep>']: continue candidate_pred_positions.append(i) # 15% of random tokens are predicted in the masked language modeling task num_mlm_preds = max(1, round(len(tokens) * 0.15)) mlm_input_tokens, pred_positions_and_labels = _replace_mlm_tokens( tokens, candidate_pred_positions, num_mlm_preds, vocab) pred_positions_and_labels = sorted(pred_positions_and_labels, key=lambda x: x[0]) pred_positions = [v[0] for v in pred_positions_and_labels] mlm_pred_labels = [v[1] for v in pred_positions_and_labels] return vocab[mlm_input_tokens], pred_positions, vocab[mlm_pred_labels]
15.9.2 Transforming Text into the Pretraining Dataset
Now we are almost ready to customize a Dataset class for pretraining BERT. Before that, we still need to define a helper function _pad_bert_inputs to append the special ‚Äú<pad>‚Äù tokens to the inputs. Its argument examples contain the outputs from the helper func- tions _get_nsp_data_from_paragraph and _get_mlm_data_from_tokens for the two pretraining tasks. #@save
def _pad_bert_inputs(examples, max_len, vocab): max_num_mlm_preds = round(max_len * 0.15) all_token_ids, all_segments, valid_lens, = [], [], [] all_pred_positions, all_mlm_weights, all_mlm_labels = [], [], [] nsp_labels = [] for (token_ids, pred_positions, mlm_pred_label_ids, segments, is_next) in examples: all_token_ids.append(torch.tensor(token_ids + [vocab['<pad>']] * ( max_len - len(token_ids)), dtype=torch.long)) all_segments.append(torch.tensor(segments + [0] * ( max_len - len(segments)), dtype=torch.long)) # `valid_lens` excludes count of '<pad>' tokens valid_lens.append(torch.tensor(len(token_ids), dtype=torch.float32)) all_pred_positions.append(torch.tensor(pred_positions + [0] * ( max_num_mlm_preds - len(pred_positions)), dtype=torch.long)) # Predictions of padded tokens will be filtered out in the loss via # multiplication of 0 weights all_mlm_weights.append( torch.tensor([1.0] * len(mlm_pred_label_ids) + [0.0] * ( max_num_mlm_preds - len(pred_positions)), dtype=torch.float32)) all_mlm_labels.append(torch.tensor(mlm_pred_label_ids + [0] * ( max_num_mlm_preds - len(mlm_pred_label_ids)), dtype=torch.long)) nsp_labels.append(torch.tensor(is_next, dtype=torch.long)) return (all_token_ids, all_segments, valid_lens, all_pred_positions, all_mlm_weights, all_mlm_labels, nsp_labels)
Putting the helper functions for generating training examples of the two pretraining tasks,
(continued from previous page)
The Dataset for Pretraining BERT
737

and the helper function for padding inputs together, we customize the following _Wiki- TextDataset class as the WikiText-2 dataset for pretraining BERT. By implementing the __getitem__function, we can arbitrarily access the pretraining (masked language model- ing and next sentence prediction) examples generated from a pair of sentences from the WikiText-2 corpus. The original BERT model uses WordPiece embeddings whose vocabulary size is 30000 (Wu et al., 2016). The tokenization method of WordPiece is a slight modification of the original byte pair encoding algorithm in Section 15.6.2. For simplicity, we use the d2l.bubutokenize function for tokenization. Infrequent tokens that appear less than five times are filtered out. #@save
class _WikiTextDataset(torch.utils.data.Dataset): def __init__(self, paragraphs, max_len): # Input `paragraphs[i]` is a list of sentence strings representing a # paragraph; while output `paragraphs[i]` is a list of sentences # representing a paragraph, where each sentence is a list of tokens paragraphs = [d2l.tokenize( paragraph, token='word') for paragraph in paragraphs] sentences = [sentence for paragraph in paragraphs for sentence in paragraph] self.vocab = d2l.Vocab(sentences, min_freq=5, reserved_tokens=[ '<pad>', '<mask>', '<cls>', '<sep>']) # Get data for the next sentence prediction task examples = [] for paragraph in paragraphs: examples.extend(_get_nsp_data_from_paragraph( paragraph, paragraphs, self.vocab, max_len)) # Get data for the masked language model task examples = [(_get_mlm_data_from_tokens(tokens, self.vocab) + (segments, is_next)) for tokens, segments, is_next in examples] # Pad inputs (self.all_token_ids, self.all_segments, self.valid_lens, self.all_pred_positions, self.all_mlm_weights, self.all_mlm_labels, self.nsp_labels) = _pad_bert_inputs( examples, max_len, self.vocab) def __getitem__(self, idx): return (self.all_token_ids[idx], self.all_segments[idx], self.valid_lens[idx], self.all_pred_positions[idx], self.all_mlm_weights[idx], self.all_mlm_labels[idx], self.nsp_labels[idx]) def __len__(self): return len(self.all_token_ids)
By using the _read_wiki function and the _WikiTextDataset class, we define the follow- ing load_data_wiki to download and WikiText-2 dataset and generate pretraining exam- ples from it. Natural Language Processing: Pretraining
738

#@save def load_data_wiki(batch_size, max_len): """Load the WikiText-2 dataset.""" num_workers = d2l.get_dataloader_workers() data_dir = d2l.download_extract('wikitext-2', 'wikitext-2') paragraphs = _read_wiki(data_dir) train_set = _WikiTextDataset(paragraphs, max_len) train_iter = torch.utils.data.DataLoader(train_set, batch_size, shuffle=True, num_workers=num_workers) return train_iter, train_set.vocab
Setting the batch size to 512 and the maximum length of a BERT input sequence to be 64, we print out the shapes of a minibatch of BERT pretraining examples. Note that in each BERT input sequence, 10 (64 x 0.15) positions are predicted for the masked language modeling task. batch_size, max_len = 512, 64 train_iter, vocab = load_data_wiki(batch_size, max_len) for (tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y) in train_iter: print(tokens_X.shape, segments_X.shape, valid_lens_x.shape, pred_positions_X.shape, mlm_weights_X.shape, mlm_Y.shape, nsp_y.shape) break
Downloading ../data/wikitext-2-v1.zip from https://s3.amazonaws.com/research. ‚Ü©!metamind.io/wikitext/wikitext-2-v1.zip... torch.Size([512, 64]) torch.Size([512, 64]) torch.Size([512]) torch.Size([512,‚ê£ ‚Ü©!10]) torch.Size([512, 10]) torch.Size([512, 10]) torch.Size([512])
In the end, let‚Äôs take a look at the vocabulary size. Even after filtering out infrequent tokens, it is still over twice larger than that of the PTB dataset. len(vocab)
20256
15.9.3 Summary
e Comparing with the PTB dataset, the WikiText-2 dateset retains the original punctuation,
case and numbers, and is over twice larger. e We can arbitrarily access the pretraining (masked language modeling and next sentence
prediction) examples generated from a pair of sentences from the WikiText-2 corpus. 15.9.4 Exercises
Pretraining BERT
739

1. For simplicity, the period is used as the only delimiter for splitting sentences. Try other sentence splitting techniques, such as the spaCy and NLTK. Take NLTK as an exam- ple. You need to install NLTK first: pip install nltk. In the code, first import nltk. Then, download the Punkt sentence tokenizer: nltk.download('punkt'). To split sentences such as sentences = 'This is great ! Why not ?', invok- ing nltk.tokenize.sent_tokenize(sentences) will return a list of two sentence strings: ['This is great !', 'Why not ?']. 2. What is the vocabulary size if we do not filter out any infrequent token? Discussions239. 239
15.10 Pretraining BERT
|
With the BERT model implemented in Section 15.8 and the pretraining examples generated from the WikiText-2 dataset in Section 15.9, we will pretrain BERT on the WikiText-2 dataset in this section. import torch from torch import nn from d2l import torch as d2l
To start, we load the WikiText-2 dataset as minibatches of pretraining examples for masked language modeling and next sentence prediction. The batch size is 512 and the maximum lengthofaBERTinputsequenceis64. NotethatintheoriginalBERTmodel, themaximum length is 512. batch_size, max_len = 512, 64 train_iter, vocab = d2l.load_data_wiki(batch_size, max_len)
15.10.1 Pretraining BERT
The original BERT has two versions of different model sizes (Devlin et al., 2018). The base model (BERTBASE) uses 12 layers (Transformer encoder blocks) with 768 hidden units (hidden size) and 12 self-attention heads. The large model (BERTLARGE) uses 24 layers with 1024 hidden units and 16 self-attention heads. Notably, the former has 110 million parameters while the latter has 340 million parameters. For demonstration with ease, we define a small BERT, using 2 layers, 128 hidden units, and 2 self-attention heads. net = d2l.BERTModel(len(vocab), num_hiddens=128,
ffn_num_hiddens=256, num_heads=2, num_blks=2, dropout=0.2) devices = d2l.try_all_gpus() loss = nn.CrossEntropyLoss()
Natural Language Processing: Pretraining
740

Before defining the training loop, we define a helper function _get_batch_loss_bert. Given the shard of training examples, this function computes the loss for both the masked language modeling and next sentence prediction tasks. Note that the final loss of BERT pretraining is just the sum of both the masked language modeling loss and the next sentence prediction loss. #@save def _get_batch_loss_bert(net, loss, vocab_size, tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y): # Forward pass _, mlm_Y_hat, nsp_Y_hat = net(tokens_X, segments_X, valid_lens_x.reshape(-1), pred_positions_X) # Compute masked language model loss mlm_l = loss(mlm_Y_hat.reshape(-1, vocab_size), mlm_Y.reshape(-1)) *\ mlm_weights_X.reshape(-1, 1) mlm_l = mlm_l.sum() / (mlm_weights_X.sum() + 1e-8) # Compute next sentence prediction loss nsp_l = loss(nsp_Y_hat, nsp_y) l = mlm_l + nsp_l return mlm_l, nsp_l, l
Invoking the two aforementioned helper functions, the following train_bert function de- fines the procedure to pretrainBERT(net)on the WikiText-2 (train_iter)dataset. Train- ing BERT can take very long. Instead of specifying the number of epochs for training as in the train_ch13 function (see Section 14.1), the input num_steps of the following function specifies the number of iteration steps for training. def train_bert(train_iter, net, loss, vocab_size, devices, num_steps):
net(*next(iter(train_iter))[:4]) net = nn.DataParallel(net, device_ids=devices).to(devices[0]) trainer = torch.optim.Adam(net.parameters(), lr=0.01) step, timer = 0, d2l.Timer() animator = d2l.Animator(xlabel='step', ylabel='loss', xlim=[1, num_steps], legend=['mlm', 'nsp']) # Sum of masked language modeling losses, sum of next sentence prediction # losses, no. of sentence pairs, count metric = d2l.Accumulator(4) num_steps_reached = False while step < num_steps and not num_steps_reached: for tokens_X, segments_X, valid_lens_x, pred_positions_X,\ mlm_weights_X, mlm_Y, nsp_y in train_iter: tokens_X = tokens_X.to(devices[0]) segments_X = segments_X.to(devices[0]) valid_lens_x = valid_lens_x.to(devices[0]) pred_positions_X = pred_positions_X.to(devices[0]) mlm_weights_X = mlm_weights_X.to(devices[0]) mlm_Y, nsp_y = mlm_Y.to(devices[0]), nsp_y.to(devices[0]) trainer.zero_grad() timer.start() mlm_l, nsp_l, l = _get_batch_loss_bert(
(continues on next page)
Pretraining BERT
741

net, loss, vocab_size, tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y) l.backward() trainer.step() metric.add(mlm_l, nsp_l, tokens_X.shape[0], 1) timer.stop() animator.add(step + 1, (metric[0] / metric[3], metric[1] / metric[3])) step += 1 if step == num_steps: num_steps_reached = True break print(f'MLM loss {metric[0] / metric[3]:.3f}, ' f'NSP loss {metric[1] / metric[3]:.3f}') print(f'{metric[2] / timer.sum():.1f} sentence pairs/sec on ' f'{str(devices)}')
We can plot both the masked language modeling loss and the next sentence prediction loss during BERT pretraining. train_bert(train_iter, net, loss, len(vocab), devices, 50)
MLM loss 5.885, NSP loss 0.760
4413.2 sentence pairs/sec on [device(type='cuda', index=0), device(type='cuda', ‚Ü©! index=1)]
loss
15.10.2 Representing Text with BERT
After pretraining BERT, we can use it to represent single text, text pairs, or any token in them. The following function returns the BERT (net) representations for all tokens in tokens_a and tokens_b. def get_bert_encoding(net, tokens_a, tokens_b=None):
tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b) token_ids = torch.tensor(vocab[tokens], device=devices[0]).unsqueeze(0) segments = torch.tensor(segments, device=devices[0]).unsqueeze(0)
(continued from previous page)
(continues on next page)
Natural Language Processing: Pretraining
742

valid_len = torch.tensor(len(tokens), device=devices[0]).unsqueeze(0) encoded_X, _, _ = net(token_ids, segments, valid_len) return encoded_X
Consider the sentence ‚Äúa crane is flying‚Äù. Recall the input representation of BERT as dis- cussed in Section 15.8.4. After inserting special tokens ‚Äú<cls>‚Äù (used for classification) and ‚Äú<sep>‚Äù (used for separation), the BERT input sequence has a length of six. Since zero is the index of the ‚Äú<cls>‚Äù token, encoded_text[:, 0, :] is the BERT represen- tation of the entire input sentence. To evaluate the polysemy token ‚Äúcrane‚Äù, we also print out the first three elements of the BERT representation of the token. tokens_a = ['a', 'crane', 'is', 'flying'] encoded_text = get_bert_encoding(net, tokens_a) # Tokens: '<cls>', 'a', 'crane', 'is', 'flying', '<sep>' encoded_text_cls = encoded_text[:, 0, :] encoded_text_crane = encoded_text[:, 2, :] encoded_text.shape, encoded_text_cls.shape, encoded_text_crane[0][:3]
(torch.Size([1, 6, 128]),
torch.Size([1, 128]), tensor([0.8414, 1.4830, 0.8226], device='cuda:0', grad_fn=<SliceBackward0>))
Nowconsiderasentencepair‚Äúacranedrivercame‚Äùand‚Äúhejustleft‚Äù. Similarly,encoded_pair[:, 0, :] is the encoded result of the entire sentence pair from the pretrained BERT. Note that the first three elements of the polysemy token ‚Äúcrane‚Äù are different from those when the context is different. This supports that BERT representations are context-sensitive. tokens_a, tokens_b = ['a', 'crane', 'driver', 'came'], ['he', 'just', 'left'] encoded_pair = get_bert_encoding(net, tokens_a, tokens_b) # Tokens: '<cls>', 'a', 'crane', 'driver', 'came', '<sep>', 'he', 'just', # 'left', '<sep>' encoded_pair_cls = encoded_pair[:, 0, :] encoded_pair_crane = encoded_pair[:, 2, :] encoded_pair.shape, encoded_pair_cls.shape, encoded_pair_crane[0][:3]
(torch.Size([1, 10, 128]), torch.Size([1, 128]), tensor([0.0430, 1.6132, 0.0437], device='cuda:0', grad_fn=<SliceBackward0>))
In Chapter 16, we will fine-tune a pretrained BERT model for downstream natural language processing applications. 15.10.3 Summary
e The original BERT has two versions, where the base model has 110 million parameters
and the large model has 340 million parameters. (continued from previous page)
Pretraining BERT
743

e After pretraining BERT, we can use it to represent single text, text pairs, or any token in
them. e Inthe experiment, the same token has different BERT representation when their contexts
are different. This supports that BERT representations are context-sensitive. 15.10.4 Exercises
1. In the experiment, we can see that the masked language modeling loss is significantly higher than the next sentence prediction loss. Why?bubu2. SetthemaximumlengthofaBERTinputsequencetobe512(sameastheoriginalBERT model). Use the configurations of the original BERT model such as BERTLARGE. Do you encounter any error when running this section?bubuWhy?bubuDiscussions240. 240 
Natural Language Processing: Applications
16
We have seen how to represent tokens in text sequences and train their representations in Chapter 15. Such pretrained text representations can be fed to various models for different downstream natural language processing tasks. In fact, earlier chapters have already discussed some natural language processing applica- tions without pretraining, just for explaining deep learning architectures. For instance, in Chapter 9, we have relied on RNNs to design language models to generate novella-like text. In Chapter 10 and Chapter 11, we have also designed models based on RNNs and attention mechanisms for machine translation. However, this book does not intend to cover all such applications in a comprehensive man- ner. Instead, our focus is on how to apply (deep) representation learning of languages to addressing natural language processing problems. Given pretrained text representations, this chapter will explore two popular and representative downstream natural language pro- cessing tasks: sentiment analysis and natural language inference, which analyze single text and relationships of text pairs, respectively. poco ccc cc co oe eee ee eee \ Alcaton | Ls imcea | [ease | , y ~---- - - - - pe - ee 4 ; poocc cco oe \ Architecture 1] MLP.bubuNN RNN Attention | +++ 4 ~o---- - - - - e e e e - ee ee ee / f 7 aetna 1 tl ‚ÄòSubword ! Pretraining | | wordavec GloVe enpencing BERT ' 4 ,
tFig. 16.1
Pretrained text representations can be fed to various deep learning architectures for different downstream natural language processing applications. This chapter focuses on how to design models for different downstream natural language processing applications. As depicted in Fig. 16.1, this chapter focuses on describing the basic ideas of designing nat- ural language processing models using different types of deep learning architectures, such as MLPs, CNNs, RNNs, and attention. Though it is possible to combine any pretrained text representations with any architecture for either application in Fig. 16.1, we select a few representative combinations. Specifically, we will explore popular architectures based on RNNs and CNNs for sentiment analysis. For natural language inference, we choose atten-
744
Sentiment Analysis and the Dataset
745

tion and MLPs to demonstrate how to analyze text pairs. In the end, we introduce how to fine-tune a pretrained BERT model for a wide range of natural language processing appli- cations, such as on a sequence level (single text classification and text pair classification) and a token level (text tagging and question answering). As a concrete empirical case, we will fine-tune BERT for natural language inference. As we have introduced in Section 15.8, BERT requires minimal architecture changes for a wide range of natural language processing applications. However, this benefit comes at the cost of fine-tuning a huge number of BERT parameters for the downstream applications. When space or time is limited, those crafted models based on MLPs, CNNs, RNNs, and attention are more feasible. In the following, we start by the sentiment analysis application and illustrate the model design based on RNNs and CNNs, respectively. 16.1 Sentiment Analysis and the Dataset
a
With the proliferation of online social media and review platforms, a plethora of opinion- ateddatahasbeenlogged,bearinggreatpotentialforsupportingdecisionmakingprocesses. Sentiment analysis studies people‚Äôs sentiments in their produced text, such as product re- views, blog comments, and forum discussions. It enjoys wide applications to fields as diverse as politics (e.g., analysis of public sentiments towards policies), finance (e.g., anal- ysis of sentiments of the market), and marketing (e.g., product research and brand manage- ment). Since sentiments can be categorized as discrete polarities or scales (e.g., positive and neg- ative), we can consider sentiment analysis as a text classification task, which transforms a varying-length text sequence into a fixed-length text category. In this chapter, we will use Stanford‚Äôs large movie review dataset241 for sentiment analysis. It consists of a training set and a testing set, either containing 25000 movie reviews downloaded from IMDb. In both datasets, there are equal number of ‚Äúpositive‚Äù and ‚Äúnegative‚Äù labels, indicating different sentiment polarities. 241 
import os import torch from torch import nn from d2l import torch as d2l
16.1.1 Reading the Dataset
First, downloadandextractthisIMDbreviewdatasetinthepath../data/aclImdb. #@save d2l.DATA_HUB['aclImdb'] = (d2l.DATA_URL + 'aclImdb_v1.tar.gz', '01ada507287d82875905620988597833ad4e0903')
(continues on next page)
Natural Language Processing: Applications
746

data_dir = d2l.download_extract('aclImdb', 'aclImdb')
Downloading ../data/aclImdb_v1.tar.gz from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/aclImdb_v1.tar.gz... Next, read the training and test datasets. Each example is a review and its label: 1 for ‚Äúpositive‚Äù and 0 for ‚Äúnegative‚Äù. #@save def read_imdb(data_dir, is_train): """Read the IMDb review dataset text sequences and labels.""" data, labels = [], [] for label in ('pos', 'neg'): folder_name = os.path.join(data_dir, 'train' if is_train else 'test', label) for file in os.listdir(folder_name): with open(os.path.join(folder_name, file), 'rb') as f: review = f.read().decode('utf-8').replace('\n', '') data.append(review) labels.append(1 if label == 'pos' else 0) return data, labels train_data = read_imdb(data_dir, is_train=True) print('# trainings:', len(train_data[0])) for x, y in zip(train_data[0][:3], train_data[1][:3]): print('label:', y, 'review:', x[:60])
# trainings: 25000
label: 1 review: Zentropa has much in common with The Third Man, another noir label: 1 review: Zentropa is the most original movie I've seen in years. If y label: 1 review: Lars Von Trier is never backward in trying out new technique
16.1.2 Preprocessing the Dataset
Treating each word as a token and filtering out words that appear less than 5 times, we create a vocabulary out of the training dataset. train_tokens = d2l.tokenize(train_data[0], token='word') vocab = d2l.Vocab(train_tokens, min_freq=5, reserved_tokens=['<pad>'])
After tokenization, let‚Äôs plot the histogram of review lengths in tokens. d2l.set_figsize() d2l.plt.xlabel('# tokens per review') d2l.plt.ylabel('count') d2l.plt.hist([len(line) for line in train_tokens], bins=range(0, 1000, 50));
(continued from previous page)
Sentiment Analysis and the Dataset
747

6000 4000 count 2000 0 200 400 600 800 # tokens per review
As we expected, the reviews have varying lengths. To process a minibatch of such reviews at each time, we set the length of each review to 500 with truncation and padding, which is similar to the preprocessing step for the machine translation dataset in Section 10.5. num_steps = 500 # sequence length train_features = torch.tensor([d2l.truncate_pad( vocab[line], num_steps, vocab['<pad>']) for line in train_tokens]) print(train_features.shape)
torch.Size([25000, 500])
16.1.3 Creating Data Iterators
Nowwecancreatedataiterators. Ateachiteration,aminibatchofexamplesarereturned. train_iter = d2l.load_array((train_features, torch.tensor(train_data[1])), 64)
for X, y in train_iter: print('X:', X.shape, ', y:', y.shape) break print('# batches:', len(train_iter))
X: torch.Size([64, 500]) , y: torch.Size([64]) # batches: 391
16.1.4 Putting It All Together
Last, we wrap up the above steps into the load_data_imdb function. It returns training and test data iterators and the vocabulary of the IMDb review dataset. #@save def load_data_imdb(batch_size, num_steps=500): """Return data iterators and the vocabulary of the IMDb review dataset.""" data_dir = d2l.download_extract('aclImdb', 'aclImdb') train_data = read_imdb(data_dir, True) test_data = read_imdb(data_dir, False)
(continues on next page)
Natural Language Processing: Applications
748

train_tokens = d2l.tokenize(train_data[0], token='word') test_tokens = d2l.tokenize(test_data[0], token='word') vocab = d2l.Vocab(train_tokens, min_freq=5) train_features = torch.tensor([d2l.truncate_pad( vocab[line], num_steps, vocab['<pad>']) for line in train_tokens]) test_features = torch.tensor([d2l.truncate_pad( vocab[line], num_steps, vocab['<pad>']) for line in test_tokens]) train_iter = d2l.load_array((train_features, torch.tensor(train_data[1])), batch_size) test_iter = d2l.load_array((test_features, torch.tensor(test_data[1])), batch_size, is_train=False) return train_iter, test_iter, vocab
16.1.5 Summary
e Sentiment analysis studies people‚Äôs sentiments in their produced text, which is consid-
ered as a text classification problem that transforms a varying-length text sequence into a fixed-length text category. e After preprocessing, we can load Stanford‚Äôs large movie review dataset (IMDb review
dataset) into data iterators with a vocabulary. 16.1.6 Exercises
1. What hyperparameters in this section can we modify to accelerate training sentiment analysis models? 2. Can you implement a function to load the dataset of Amazon reviews 242 into data iterators and labels for sentiment analysis? 242
Discussions243. 243
16.2 Sentiment Analysis: Using Recurrent Neural Networks

Like word similarity and analogy tasks, we can also apply pretrained word vectors to sen- timent analysis. Since the IMDb review dataset in Section 16.1 is not very big, using text representations that were pretrained on large-scale corpora may reduce overfitting of the model. As a specific example illustrated in Fig. 16.2.1, we will represent each token using the pretrained GloVe model, and feed these token representations into a multilayer bidi- rectional RNN to obtain the text sequence representation, which will be transformed into sentiment analysis outputs (Maas et al., 2011). For the same downstream application, we will consider a different architectural choice later. (continued from previous page)
Sentiment Analysis: Using Recurrent Neural Networks
749

Application Architecture ' Pretraining | | word2vec GloVe Subword BERT
tFig. 16.2.1
This section feeds pretrained GloVe to an RNN-based architecture for sentiment analysis. import torch from torch import nn from d2l import torch as d2l batch_size = 64 train_iter, test_iter, vocab = d2l.load_data_imdb(batch_size)
16.2.1 Representing Single Text with RNNs
In text classifications tasks, such as sentiment analysis, a varying-length text sequence will be transformed into fixed-length categories. In the following BiRNN class, while each token of a text sequence gets its individual pretrained GloVe representation via the embedding layer (self.embedding), the entire sequence is encoded by a bidirectional RNN (self. encoder). More concretely, the hidden states (at the last layer) of the bidirectional LSTM at both the initial and final time steps are concatenated as the representation of the text sequence. This single text representation is then transformed into output categories by a fullyconnectedlayer(self.decoder)withtwooutputs(‚Äúpositive‚Äùand‚Äúnegative‚Äù). class BiRNN(nn.Module): def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, **kwargs): super(BiRNN, self).__init__(**kwargs) self.embedding = nn.Embedding(vocab_size, embed_size) # Set `bidirectional` to True to get a bidirectional RNN self.encoder = nn.LSTM(embed_size, num_hiddens, num_layers=num_layers, bidirectional=True) self.decoder = nn.Linear(4 * num_hiddens, 2) def forward(self, inputs): # The shape of `inputs` is (batch size, no. of time steps). Because # LSTM requires its input's first dimension to be the temporal # dimension, the input is transposed before obtaining token # representations. The output shape is (no. of time steps, batch size, # word vector dimension) embeddings = self.embedding(inputs.T) self.encoder.flatten_parameters() # Returns hidden states of the last hidden layer at different time
(continues on next page)
Natural Language Processing: Applications
750

# steps. The shape of `outputs` is (no. of time steps, batch size, # 2 * no. of hidden units) outputs, _ = self.encoder(embeddings) # Concatenate the hidden states at the initial and final time steps as # the input of the fully connected layer. Its shape is (batch size, # 4 * no. of hidden units) encoding = torch.cat((outputs[0], outputs[-1]), dim=1) outs = self.decoder(encoding) return outs
Let‚Äôs construct a bidirectional RNN with two hidden layers to represent single text for sen- timent analysis. embed_size, num_hiddens, num_layers, devices = 100, 100, 2, d2l.try_all_gpus() net = BiRNN(len(vocab), embed_size, num_hiddens, num_layers)
def init_weights(module): if type(module) == nn.Linear: nn.init.xavier_uniform_(module.weight) if type(module) == nn.LSTM: for param in module._flat_weights_names: if "weight" in param: nn.init.xavier_uniform_(module._parameters[param]) net.apply(init_weights);
16.2.2 Loading Pretrained Word Vectors
Below we load the pretrained 100-dimensional (needs to be consistent with embed_size) GloVe embeddings for tokens in the vocabulary. glove_embedding = d2l.TokenEmbedding('glove.6b.100d')
Print the shape of the vectors for all the tokens in the vocabulary. embeds = glove_embedding[vocab.idx_to_token] embeds.shape
torch.Size([49346, 100])
We use these pretrained word vectors to represent tokens in the reviews and will not update
these vectors during training. net.embedding.weight.data.copy_(embeds) net.embedding.weight.requires_grad = False
16.2.3 Training and Evaluating the Model
(continued from previous page)
Sentiment Analysis: Using Recurrent Neural Networks
751

Now we can train the bidirectional RNN for sentiment analysis. lr, num_epochs = 0.01, 5 trainer = torch.optim.Adam(net.parameters(), lr=lr) loss = nn.CrossEntropyLoss(reduction="none") d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
loss 0.277, train acc 0.884, test acc 0.861 2608.4 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
1.0 serene TST ET ET 08 b 06 ‚Äî train loss train acc 02 0.0 1 2 3 4 5 epoch
Wedefinethefollowingfunctiontopredictthesentimentofatextsequenceusingthetrained model net. #@save def predict_sentiment(net, vocab, sequence): """Predict the sentiment of a text sequence.""" sequence = torch.tensor(vocab[sequence.split()], device=d2l.try_gpu()) label = torch.argmax(net(sequence.reshape(1, -1)), dim=1) return 'positive' if label == 1 else 'negative'
Finally, let‚Äôsuse the trained model to predict the sentiment for two simple sentences. predict_sentiment(net, vocab, 'this movie is so great')
'positive'
predict_sentiment(net, vocab, 'this movie is so bad')
'negative'
16.2.4 Summary
e Pretrained word vectors can represent individual tokens in a text sequence. Natural Language Processing: Applications
752

e Bidirectional RNNs can represent a text sequence, such as via the concatenation of its
hidden states at the initial and final time steps. This single text representation can be transformed into categories using a fully connected layer.bubu16.2.5 Exercises
1. Increase the number of epochs. Can you improve the training and testing accuracies? How about tuning other hyperparameters? 2. Use larger pretrained word vectors, such as 300-dimensional GloVe embeddings. Does it improve classification accuracy? 3. Can we improve the classification accuracy by using the spaCy tokenization? You need to install spaCy (pip install spacy) and install the English package (python -m spacy download en). In the code, first, import spaCy (import spacy). Then, load the spaCy English package (spacy_en = spacy.load('en')). Finally, define the function def tokenizer(text): return [tok.text for tok in spacy_en. tokenizer(text)] and replace the original tokenizer function. Note the different forms of phrase tokens in GloVe and spaCy. For example, the phrase token ‚Äúnew york‚Äù takes the form of ‚Äúnew-york‚Äù in GloVe and the form of ‚Äúnew york‚Äù after the spaCy tokenization. 244 Discussions244. 16.3 Sentiment Analysis: Using Convolutional Neural Networks

In Chapter 7, we investigated mechanisms for processing two-dimensional image data with two-dimensionalCNNs,whichwereappliedtolocalfeaturessuchasadjacentpixels. Though originally designed for computer vision, CNNs are also widely used for natural language processing. Simply put, just think of any text sequence as a one-dimensional image. In this way, one-dimensional CNNs can process local features such as ùëõ-grams in text. In this section, we will use the textCNN model to demonstrate how to design a CNN ar- chitecture for representing single text (Kim, 2014). Compared with Fig. 16.2.1 that uses an RNN architecture with GloVe pretraining for sentiment analysis, the only difference in Fig. 16.3.1 lies in the choice of the architecture. import torch from torch import nn from d2l import torch as d2l batch_size = 64 train_iter, test_iter, vocab = d2l.load_data_imdb(batch_size)
Sentiment Analysis: Using Convolutional Neural Networks
753

Application Architecture z i) 2 2 Zz BD 2 z Es g ' Pretraining | | word2vec GloVe Subword BERT
tFig. 16.3.1
1!)
This section feeds pretrained GloVe to a CNN-based architecture for sentiment analysis. 16.3.1 One-Dimensional Convolutions
Before introducing the model, let‚Äôs see how a one-dimensional convolution works. Bear in mind that it is just a special case of a two-dimensional convolution based on the cross- correlation operation. Input Kemel Output oj/1)2)/3)/4])/s])e] * |4}2} = | 2)5) 8) 11) 14) 17
tFig. 16.3.2 One-dimensional cross-correlation operation. The shaded portions are the Ô¨Årst output
st 153) One-dimensional cross-correlation operation. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: Oxl+1x2=2. As shown in Fig. 16.3.2, in the one-dimensional case, the convolution window slides from left to right across the input tensor. During sliding, the input subtensor (e.g., 0 and | in Fig. 16.3.2) contained in the convolution window at a certain position and the kernel tensor (e.g., 1 and 2 in Fig. 16.3.2) are multiplied elementwise. The sum of these multiplications gives the single scalar value (e.g., 0 x 1+ 1 x2 = 2 in Fig. 16.3.2) at the corresponding position of the output tensor. We implement one-dimensional cross-correlation in the following corr1d function. Given an input tensor X and a kernel tensor K, it returns the output tensor Y. def corr1d(X, K): w = K.shape[0] Y = torch.zeros((X.shape[0] - w + 1)) for i in range(Y.shape[0]): Y[i] = (X[i: i + w] * K).sum() return Y
We can construct the input tensor X and the kernel tensor K from Fig. 16.3.2 to validate the output of the above one-dimensional cross-correlation implementation. X, K = torch.tensor([0, 1, 2, 3, 4, 5, 6]), torch.tensor([1, 2]) corr1d(X, K)
Natural Language Processing: Applications
754

tensor([ 2., 5., 8., 11., 14., 17.])
For any one-dimensional input with multiple channels, the convolution kernel needs to have the same number of input channels. Then for each channel, perform a cross-correlation operation on the one-dimensional tensor of the input and the one-dimensional tensor of the convolution kernel, summing the results over all the channels to produce the one- dimensional output tensor. Fig. 16.3.3 shows a one-dimensional cross-correlation oper- ation with 3 input channels. Input Kemel Output 2}3}4}]s5je}]7]¬∞a | -3 1}2}]3|4|s5|{e6]{7] *¬´ [3]4 = | 2] 8 | 14] 20] 26 | 32 oj}i1}/2}/3)4]/s]e6 1/2
tFig. 16.3.3 One-dimensional cross-correlation operation with 3 input channels. The shaded portions
One-dimensional cross-correlation operation with 3 input channels. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: 0x 1+1x2+1x3+2x4+2~x (-1) +3x (-3) =2. Wecanimplementtheone-dimensionalcross-correlationoperationformultipleinputchan- nels and validate the results in Fig. 16.3.3. def corr1d_multi_in(X, K): # First, iterate through the 0th dimension (channel dimension) of `X` and # `K`. Then, add them together return sum(corr1d(x, k) for x, k in zip(X, K)) X = torch.tensor([[0, 1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 7], [2, 3, 4, 5, 6, 7, 8]]) K = torch.tensor([[1, 2], [3, 4], [-1, -3]]) corr1d_multi_in(X, K)
tensor([ 2., 8., 14., 20., 26., 32.])
Note that multi-input-channel one-dimensional cross-correlations are equivalent to single- input-channel two-dimensional cross-correlations. To illustrate, an equivalent form of the multi-input-channel one-dimensional cross-correlation in Fig. 16.3.3 is the single-input- channel two-dimensional cross-correlation in Fig. 16.3.4, where the height of the convolu- tion kernel has to be the same as that of the input tensor. Both the outputs in Fig.bubu16.3.2 and Fig. 16.3.3 have only one channel. Same as two- dimensional convolutions with multiple output channels described in Section 7.4.2, we can also specify multiple output channels for one-dimensional convolutions. 16.3.2 Max-Over-Time Pooling
Similarly, we can use pooling to extract the highest value from sequence representations as the most important feature across time steps. The max-over-time pooling used in textCNN
Sentiment Analysis: Using Convolutional Neural Networks
755

Input Kernel Output 2}3]4|sle]7]ea 41/[3 1{2]3}4]s5}e]7] * |3}4] = | 2] 8 | 14] 20] 26] o}1}2}3}4a}sfe 1/2
tFig. 16.3.4
Two-dimensional cross-correlation operation with a single input channel. The shaded portions are the first output element as well as the input and kernel tensor elements used for the output computation: 2 x (-1) +3 x (-3)+1x34+2x4+0x1+1x2=2. works like the one-dimensional global max-pooling (Collobert et al., 2011). For a multi- channel input where each channel stores values at different time steps, the output at each channel is the maximum value for that channel. Note that the max-over-time pooling allows different numbers of time steps at different channels. 16.3.3 The textCNN Model
Using the one-dimensional convolution and max-over-time pooling, the textCNN model takes individual pretrained token representations as input, then obtains and transforms se- quence representations for the downstream application. For a single text sequence with ùëõ tokens represented by ùëë-dimensional vectors, the width,
height, and number of channels of the input tensor are ùëõ, 1, and ùëë, respectively. The textCNN model transforms the input into the output as follows:
1. Define multiple one-dimensional convolution kernels and perform convolution opera- tions separately on the inputs. Convolution kernels with different widths may capture local features among different numbers of adjacent tokens. 2. Perform max-over-time pooling on all the output channels, and then concatenate all the scalar pooling outputs as a vector. 3. Transform the concatenated vector into the output categories using the fully connected layer. Dropout can be used for reducing overfitting.bubuFig. 16.3.5 illustrates the model architecture of textCNN with a concrete example. The input is a sentence with 11 tokens, where each token is represented by a 6-dimensional vectors. So we have a 6-channel input with width 11. Define two one-dimensional convolution kernels of widths 2 and 4, with 4 and 5 output channels, respectively. They produce 4 output channels with width 11‚Äî2+1 = 10 and 5 output channels with width 11‚Äî4+1 = 8. Despite different widths of these 9 channels, the max-over-time pooling gives a concatenated 9- dimensional vector, which is finally transformed into a 2-dimensional output vector for binary sentiment predictions. Defining the Model
We implement the textCNN model in the following class. Compared with the bidirectional RNN model in Section 16.2, besides replacing recurrent layers with convolutional layers,
32
Natural Language Processing: Applications
756

No. of output sentiment polarities: 2 (with fully-connected layer) No. of outputs: 4 < ~ No. of outputs: 5 (Max-over-time pooling COLT) (Max-over-time pooling foreach channel) | ~~ Nv . ser each channel) No.bubuof output 9 -7~ ry No. of output channels: 4 channels: 5 Width of each Width of each output channel: output channel: 11-2+1=10 11-4+1=8 (kemel width: 2) AL SS thermo! width: 4) Input width: 11 (11 tokens) No. of input channels: 6 (each token is represented by a 6D vector) loading model and inference api is now available for scala
tFig. 16.3.5
The model architecture of textCNN. we also use two embedding layers: one with trainable weights and the other with fixed weights. class TextCNN(nn.Module):
def __init__(self, vocab_size, embed_size, kernel_sizes, num_channels, **kwargs): super(TextCNN, self).__init__(**kwargs) self.embedding = nn.Embedding(vocab_size, embed_size) # The embedding layer not to be trained self.constant_embedding = nn.Embedding(vocab_size, embed_size) self.dropout = nn.Dropout(0.5) self.decoder = nn.Linear(sum(num_channels), 2) # The max-over-time pooling layer has no parameters, so this instance # can be shared self.pool = nn.AdaptiveAvgPool1d(1) self.relu = nn.ReLU() # Create multiple one-dimensional convolutional layers self.convs = nn.ModuleList() for c, k in zip(num_channels, kernel_sizes): self.convs.append(nn.Conv1d(2 * embed_size, c, k)) def forward(self, inputs): # Concatenate two embedding layer outputs with shape (batch size, no. # of tokens, token vector dimension) along vectors embeddings = torch.cat(( self.embedding(inputs), self.constant_embedding(inputs)), dim=2) # Per the input format of one-dimensional convolutional layers, # rearrange the tensor so that the second dimension stores channels embeddings = embeddings.permute(0, 2, 1) # For each one-dimensional convolutional layer, after max-over-time # pooling, a tensor of shape (batch size, no. of channels, 1) is # obtained. Remove the last dimension and concatenate along channels encoding = torch.cat([
(continues on next page)
Sentiment Analysis: Using Convolutional Neural Networks
757

torch.squeeze(self.relu(self.pool(conv(embeddings))), dim=-1) for conv in self.convs], dim=1) outputs = self.decoder(self.dropout(encoding)) return outputs
Let‚Äôs create a textCNN instance. It has 3 convolutional layers with kernel widths of 3, 4, and 5, all with 100 output channels. embed_size, kernel_sizes, nums_channels = 100, [3, 4, 5], [100, 100, 100] devices = d2l.try_all_gpus() net = TextCNN(len(vocab), embed_size, kernel_sizes, nums_channels) def init_weights(module): if type(module) in (nn.Linear, nn.Conv1d): nn.init.xavier_uniform_(module.weight) net.apply(init_weights);
Loading Pretrained Word Vectors
Same as Section 16.2, we load pretrained 100-dimensional GloVe embeddings as the ini- tialized token representations. These token representations (embedding weights) will be trained in embedding and fixed in constant_embedding. glove_embedding = d2l.TokenEmbedding('glove.6b.100d') embeds = glove_embedding[vocab.idx_to_token] net.embedding.weight.data.copy_(embeds) net.constant_embedding.weight.data.copy_(embeds) net.constant_embedding.weight.requires_grad = False
Training and Evaluating the Model
Now we can train the textCNN model for sentiment analysis. lr, num_epochs = 0.001, 5 trainer = torch.optim.Adam(net.parameters(), lr=lr) loss = nn.CrossEntropyLoss(reduction="none") d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
loss 0.066, train acc 0.979, test acc 0.868 4354.2 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
Below we use the trained model to predict the sentiment for two simple sentences. d2l.predict_sentiment(net, vocab, 'this movie is so great')
(continued from previous page)
Natural Language Processing: Applications
758

06 ‚Äî train loss - train acc 0.4 ‚Äî-- test acc 0.2 0.0 1 2 3 4 5
'positive'
d2l.predict_sentiment(net, vocab, 'this movie is so bad')
'negative'
16.3.4 Summary
One-dimensional CNNs can process local features such as n-grams in text. Multi-input-channel one-dimensional cross-correlations are equivalent to single-input-
channel two-dimensional cross-correlations. The max-over-time pooling allows different numbers of time steps at different channels. The textCNN model transforms individual token representations into downstream appli-
cation outputs using one-dimensional convolutional layers and max-over-time pooling layers. 16.3.5 Exercises
1. Tune hyperparameters and compare the two architectures for sentiment analysis in Sec- tion 16.2 and in this section, such as in classification accuracy and computational effi- ciency. 2. Can you further improve the classification accuracy of the model by using the methods introduced in the exercises of Section 16.2? 245
3. Add positional encoding in the input representations. Does it improve the classification accuracy?bubuDiscussions245. Natural Language Inference and the Dataset
759

16.4 Natural Language Inference and the Dataset
es
In Section 16.1, we discussed the problem of sentiment analysis. This task aims to clas- sify a single text sequence into predefined categories, such as a set of sentiment polarities. However, when there is a need to decide whether one sentence can be inferred form an- other, or eliminate redundancy by identifying sentences that are semantically equivalent, knowing how to classify one text sequence is insufficient. Instead, we need to be able to reason over pairs of text sequences. 16.4.1 Natural Language Inference
Natural language inference studies whether a hypothesis can be inferred from a premise, where both are a text sequence. In other words, natural language inference determines the logical relationship between a pair of text sequences. Such relationships usually fall into three types:
e Entailment: the hypothesis can be inferred from the premise. e Contradiction: the negation of the hypothesis can be inferred from the premise. e Neutral: all the other cases. Natural language inference is also known as the recognizing textual entailment task. For example, the following pair will be labeled as entailment because ‚Äúshowing affection‚Äù in the hypothesis can be inferred from ‚Äúhugging one another‚Äù in the premise. Premise: Two women are hugging each other. Hypothesis: Two women are showing affection. The following is an example of contradiction as ‚Äúrunning the coding example‚Äù indicates ‚Äúnot sleeping‚Äù rather than ‚Äúsleeping‚Äù. Premise: A man is running the coding example from Dive into Deep Learning. Hypothesis: The man is sleeping. The third example shows a neutrality relationship because neither ‚Äúfamous‚Äù nor ‚Äúnot fa- mous‚Äù can be inferred from the fact that ‚Äúare performing for us‚Äù. Premise: The musicians are performing for us. Hypothesis: The musicians are famous. Natural language inference has been a central topic for understanding natural language. It enjoys wide applications ranging from information retrieval to open-domain question answering. Tostudythisproblem, wewillbegin byinvestigatingapopularnaturallanguage inference benchmark dataset. Natural Language Processing: Applications
760

16.4.2 The Stanford Natural Language Inference (SNLI) Dataset
Stanford Natural Language Inference (SNLI) Corpus is a collection of over 500000 labeled English sentence pairs (Bowman et al., 2015). We download and store the extracted SNLI dataset in the path ../data/snli_1.0. dataset in the path ../data/snli_1.0. import os import re import torch from torch import nn from d2l import torch as d2l #@save d2l.DATA_HUB['SNLI'] = ( 'https://nlp.stanford.edu/projects/snli/snli_1.0.zip', '9fcde07509c7e87ec61c640c1b2753d9041758e4')
data_dir = d2l.download_extract('SNLI')
Reading the Dataset
The original SNLI dataset contains much richer information than what we really need in our experiments. Thus, we define a function read_snli to only extract part of the dataset, then return lists of premises, hypotheses, and their labels. #@save def read_snli(data_dir, is_train): """Read the SNLI dataset into premises, hypotheses, and labels.""" def extract_text(s): # Remove information that will not be used by us s = re.sub('\\(', '', s) s = re.sub('\\)', '', s) # Substitute two or more consecutive whitespace with space s = re.sub('\\s{2,}', ' ', s) return s.strip() label_set = {'entailment': 0, 'contradiction': 1, 'neutral': 2} file_name = os.path.join(data_dir, 'snli_1.0_train.txt' if is_train else 'snli_1.0_test.txt') with open(file_name, 'r') as f: rows = [row.split('\t') for row in f.readlines()[1:]] premises = [extract_text(row[1]) for row in rows if row[0] in label_set] hypotheses = [extract_text(row[2]) for row in rows if row[0] in label_set] labels = [label_set[row[0]] for row in rows if row[0] in label_set] return premises, hypotheses, labels
Now let‚Äôs print the first 3 pairs of premise and hypothesis, as well as their labels (‚Äú0‚Äù, ‚Äú1‚Äù, and ‚Äú2‚Äù correspond to ‚Äúentailment‚Äù, ‚Äúcontradiction‚Äù, and ‚Äúneutral‚Äù, respectively ). train_data = read_snli(data_dir, is_train=True)
for x0, x1, y in zip(train_data[0][:3], train_data[1][:3], train_data[2][:3]): print('premise:', x0)
(continues on next page)
Natural Language Inference and the Dataset
761

print('hypothesis:', x1) print('label:', y)
premise: A person on a horse jumps over a broken down airplane . hypothesis: A person is training his horse for a competition . label: 2 premise: A person on a horse jumps over a broken down airplane . hypothesis: A person is at a diner , ordering an omelette . label: 1 premise: A person on a horse jumps over a broken down airplane . hypothesis: A person is outdoors , on a horse . label: 0
The training set has about 550000 pairs, and the testing set has about 10000 pairs. The fol- lowingshowsthatthethreelabels‚Äúentailment‚Äù, ‚Äúcontradiction‚Äù, and‚Äúneutral‚Äùarebalanced in both the training set and the testing set. in both the training set and the testing set. test_data = read_snli(data_dir, is_train=False) for data in [train_data, test_data]: print([[row for row in data[2]].count(i) for i in range(3)])
[183416, 183187, 182764] [3368, 3237, 3219]
Defining a Class for Loading the Dataset
Below we define a class for loading the SNLI dataset by inheriting from the Dataset class in Gluon. The argument num_steps in the class constructor specifies the length of a text sequence so that each minibatch of sequences will have the same shape. In other words, tokens after the first num_steps ones in longer sequence are trimmed, while special tokens ‚Äú<pad>‚Äù will be appended to shorter sequences until their length becomes num_steps. By implementingthe__getitem__function, wecanarbitrarilyaccessthepremise, hypothesis, and label with the index idx. #@save class SNLIDataset(torch.utils.data.Dataset): """A customized dataset to load the SNLI dataset.""" def __init__(self, dataset, num_steps, vocab=None): self.num_steps = num_steps all_premise_tokens = d2l.tokenize(dataset[0]) all_hypothesis_tokens = d2l.tokenize(dataset[1]) if vocab is None: self.vocab = d2l.Vocab(all_premise_tokens + all_hypothesis_tokens, min_freq=5, reserved_tokens=['<pad>']) else: self.vocab = vocab self.premises = self._pad(all_premise_tokens)
(continued from previous page)
(continues on next page)
Natural Language Processing: Applications
762

self.hypotheses = self._pad(all_hypothesis_tokens) self.labels = torch.tensor(dataset[2]) print('read ' + str(len(self.premises)) + ' examples') def _pad(self, lines): return torch.tensor([d2l.truncate_pad( self.vocab[line], self.num_steps, self.vocab['<pad>']) for line in lines]) def __getitem__(self, idx): return (self.premises[idx], self.hypotheses[idx]), self.labels[idx] def __len__(self): return len(self.premises)
return (self.premises[idx], self.hypotheses[idx]), self.labels[idx]
Putting It All Together
Now we can invoke the read_snli function and the SNLIDataset class to download the SNLI dataset and return DataLoader instances for both training and testing sets, together with the vocabulary of the training set. It is noteworthy that we must use the vocabulary constructed from the training set as that of the testing set. As a result, any new token from the testing set will be unknown to the model trained on the training set. #@save def load_data_snli(batch_size, num_steps=50): """Download the SNLI dataset and return data iterators and vocabulary.""" num_workers = d2l.get_dataloader_workers() data_dir = d2l.download_extract('SNLI') train_data = read_snli(data_dir, True) test_data = read_snli(data_dir, False) train_set = SNLIDataset(train_data, num_steps) test_set = SNLIDataset(test_data, num_steps, train_set.vocab) train_iter = torch.utils.data.DataLoader(train_set, batch_size, shuffle=True, num_workers=num_workers) test_iter = torch.utils.data.DataLoader(test_set, batch_size, shuffle=False, num_workers=num_workers) return train_iter, test_iter, train_set.vocab
Herewesetthebatchsizeto128andsequencelengthto50,andinvoketheload_data_snli
function to get the data iterators and vocabulary. Then we print the vocabulary size. train_iter, test_iter, vocab = load_data_snli(128, 50) len(vocab)
read 549367 examples read 9824 examples
(continued from previous page)
Natural Language Inference: Using Attention
763

18678
Now we print the shape of the first minibatch. Contrary to sentiment analysis, we have two inputs X[0] and X[1] representing pairs of premises and hypotheses. for X, Y in train_iter: print(X[0].shape) print(X[1].shape) print(Y.shape) break
torch.Size([128, 50]) torch.Size([128, 50]) torch.Size([128])
16.4.3 Summary
e Natural language inference studies whether a hypothesis can be inferred from a premise,
where both are a text sequence. e In natural language inference, relationships between premises and hypotheses include
entailment, contradiction, and neutral. e Stanford Natural Language Inference (SNLI) Corpus is a popular benchmark dataset of
natural language inference. 16.4.4 Exercises
1. Machine translation has long been evaluated based on superficial ùëõ-gram matching be-
tween an output translation and a ground-truth translation. Can you design a measure for evaluating machine translation results by using natural language inference? 2. How can we change hyperparameters to reduce the vocabulary size? 246 
Discussions246. 16.5 Natural Language Inference: Using Attention
a
We introduced the natural language inference task and the SNLI dataset in Section 16.4. In view of many models that are based on complex and deep architectures, Parikh et al. (2016) proposed to address natural language inference with attention mechanisms and called it a ‚Äúdecomposableattentionmodel‚Äù. Thisresultsinamodelwithoutrecurrentorconvolutional layers, achievingthebestresultatthetimeontheSNLIdatasetwithmuchfewerparameters. Natural Language Processing: Applications
764

In this section, we will describe and implement this attention-based method (with MLPs) for natural language inference, as depicted in Fig. 16.5.1. i Apolcaton Lane] 1 Architecture ' Pretraining | | word2vec GloVe Subword BERT
tFig. 16.5.1
This section feeds pretrained GloVe to an architecture based on attention and MLPs for natural language inference. 16.5.1 The Model
Simpler than preserving the order of tokens in premises and hypotheses, we can just align tokens in one text sequence to every token in the other, and vice versa, then compare and aggregate such information to predict the logical relationships between premises and hy- potheses. Similar to alignment of tokens between source and target sentences in machine translation, the alignment of tokens between premises and hypotheses can be neatly accom- plished by attention mechanisms. Prediction ry Concat Aggregate }--- sum then concat --- > Sum Sum t t t ivi ivi Compare | - word - aligned words --> do - am - need - tired - need sleep + sleep - tired voeeeeee align ¬´--eeeee iam tired i need do sleep i i do am Premise Hypothesis need tired ido need sleep iam tired sleep
tFig. 16.5.2 Natural language inference using attention mechanisms.bubuFig. 16.5.2 depicts the natural language inference method using attention mechanisms. At a high level, it consists of three jointly trained steps: attending, comparing, and aggregating. We will illustrate them step by step in the following. import torch
from torch import nn from torch.nn import functional as F from d2l import torch as d2l
Natural Language Inference: Using Attention
765

The first step is to align tokens in one text sequence to each token in the other sequence. Suppose that the premise is ‚Äúi do need sleep‚Äù and the hypothesis is ‚Äúi am tired‚Äù. Due to semantical similarity, we may wish to align ‚Äúi‚Äù in the hypothesis with ‚Äúi‚Äù in the premise, and align ‚Äútired‚Äù in the hypothesis with ‚Äúsleep‚Äù in the premise. Likewise, we may wish to align ‚Äúi‚Äù in the premise with ‚Äúi‚Äù in the hypothesis, and align ‚Äúneed‚Äù and ‚Äúsleep‚Äù in the premise with ‚Äútired‚Äù in the hypothesis. Note that such alignment is soft using weighted average, where ideally large weights are associated with the tokens to be aligned. For ease of demonstration, Fig. 16.5.2 shows such alignment in a hard way. Now we describe the soft alignment using attention mechanisms in more detail. Denote by A = ‚Äûa1, .bubu. .,aùëö‚Äù and B = ‚Äûb1, . . .,bùëõ‚Äù the premise and hypothesis, whose number of tokens are ùëö and ùëõ, respectively, where aùëñ,bùëó 2 Rùëë (ùëñ = 1, . . .,ùëö, ùëó = 1, . . .,ùëõ) is a ùëë-dimensional word vector. For soft alignment, we compute the attention weights ùëíùëñùëó 2 R as
as
ùëíùëñùëó = ùëì ‚Äûaùëñ‚Äù> ùëì ‚Äûbùëó‚Äù,
(16.5.1)
where the function ùëì is an MLP defined in the following mlp function. The output dimen-
sion of ùëì is specified by the num_hiddens argument of mlp. def mlp(num_inputs, num_hiddens, flatten):
net = [] net.append(nn.Dropout(0.2)) net.append(nn.Linear(num_inputs, num_hiddens)) net.append(nn.ReLU()) if flatten: net.append(nn.Flatten(start_dim=1)) net.append(nn.Dropout(0.2)) net.append(nn.Linear(num_hiddens, num_hiddens)) net.append(nn.ReLU()) if flatten: net.append(nn.Flatten(start_dim=1)) return nn.Sequential(*net)
It should be highlighted that, in (16.5.1) ùëì takes inputs aùëñ and bùëó separately rather than
takes a pair of them together as input. This decomposition trick leads to only ùëö‚Äöùëõ applica- tions (linear complexity) of ùëì rather than ùëöùëõ applications (quadratic complexity). Normalizing the attention weights in (16.5.1), we compute the weighted average of all the token vectors in the hypothesis to obtain representation of the hypothesis that is softly aligned with the token indexed by ùëñ in the premise:
ùú∑ùëñ = Àùùëõ ùëò=1 exp‚Äûùëíùëñùëò‚Äùbùëó. (16.5.2)
ùëó=1
Likewise, we compute soft alignment of premise tokens for each token indexed by ùëó in the
Attending
exp‚Äûùëíùëñùëó‚Äù
Natural Language Processing: Applications
766

hypothesis:
ùú∂ùëó = Àùùëö ùëò=1 exp‚Äûùëíùëò ùëó‚Äùaùëñ. (16.5.3)
ùëñ=1
Below we define the Attend class to compute the soft alignment of hypotheses (beta) with input premises A and soft alignment of premises (alpha) with input hypotheses B. class Attend(nn.Module): def __init__(self, num_inputs, num_hiddens, **kwargs): super(Attend, self).__init__(**kwargs) self.f = mlp(num_inputs, num_hiddens, flatten=False) def forward(self, A, B): # Shape of `A`/`B`: (`batch_size`, no. of tokens in sequence A/B, # `embed_size`) # Shape of `f_A`/`f_B`: (`batch_size`, no. of tokens in sequence A/B, # `num_hiddens`) f_A = self.f(A) f_B = self.f(B) # Shape of `e`: (`batch_size`, no. of tokens in sequence A, # no. of tokens in sequence B) e = torch.bmm(f_A, f_B.permute(0, 2, 1)) # Shape of `beta`: (`batch_size`, no. of tokens in sequence A, # `embed_size`), where sequence B is softly aligned with each token # (axis 1 of `beta`) in sequence A beta = torch.bmm(F.softmax(e, dim=-1), B) # Shape of `alpha`: (`batch_size`, no. of tokens in sequence B, # `embed_size`), where sequence A is softly aligned with each token # (axis 1 of `alpha`) in sequence B alpha = torch.bmm(F.softmax(e.permute(0, 2, 1), dim=-1), A) return beta, alpha
In the next step, we compare a token in one sequence with the other sequence that is softly aligned with that token. Note that in soft alignment, all the tokens from one sequence, though with probably different attention weights, will be compared with a token in the other sequence. For easy of demonstration, Fig. 16.5.2 pairs tokens with aligned tokens in a hard way. For example, suppose that the attending step determines that ‚Äúneed‚Äù and ‚Äúsleep‚Äù in the premise are both aligned with ‚Äútired‚Äù in the hypothesis, the pair ‚Äútired‚Äìneed sleep‚Äù will be compared. In the comparing step, we feed the concatenation (operator [-,-]) of tokens from one se-
quence and aligned tokens from the other sequence into a function ùëî (an MLP):
vùê¥,ùëñ = ùëî‚Äû¬ªaùëñ, ùú∑ùëñ‚Ä¶‚Äù,ùëñ = 1, . .bubu.,ùëö vùêµ, ùëó = ùëî‚Äû¬ªbùëó,ùú∂ùëó‚Ä¶‚Äù, ùëó = 1, . .bubu.,ùëõ. (16.5.4)
In (16.5.4), vùê¥,ùëñ is the comparison between token ùëñ in the premise and all the hypothesis
tokens that are softly aligned with token ùëñ; while vùêµ, ùëó is the comparison between token ùëó in
exp‚Äûùëíùëñùëó‚Äù
Comparing
7167
Natural Language Inference: Using Attention
767

the hypothesis and all the premise tokens that are softly aligned with token ùëó. The following
Compare class defines such as comparing step. class Compare(nn.Module): def __init__(self, num_inputs, num_hiddens, **kwargs): super(Compare, self).__init__(**kwargs) self.g = mlp(num_inputs, num_hiddens, flatten=False) def forward(self, A, B, beta, alpha): V_A = self.g(torch.cat([A, beta], dim=2)) V_B = self.g(torch.cat([B, alpha], dim=2)) return V_A, V_B
Aggregating
With two sets of comparison vectors vùê¥,ùëñ (ùëñ = 1, . .bubu.,ùëö) and vùêµ, ùëó (ùëó = 1, . . .,ùëõ) on hand,
in the last step we will aggregate such information to infer the logical relationship. We begin by summing up both sets:
m
vùê¥ = vùê¥,ùëñ, vùêµ = vùêµ, ùëó. ùëñ=1 ùëó=1 (16.5.5)
Next we feed the concatenation of both summarization results into function ‚Ñé (an MLP) to
obtain the classification result of the logical relationship:
ÀÜy = ‚Ñé‚Äû¬ªvùê¥,vùêµ‚Ä¶‚Äù. (16.5.6)
The aggregation step is defined in the following Aggregate class. class Aggregate(nn.Module): def __init__(self, num_inputs, num_hiddens, num_outputs, **kwargs): super(Aggregate, self).__init__(**kwargs) self.h = mlp(num_inputs, num_hiddens, flatten=True) self.linear = nn.Linear(num_hiddens, num_outputs) def forward(self, V_A, V_B): # Sum up both sets of comparison vectors V_A = V_A.sum(dim=1) V_B = V_B.sum(dim=1) # Feed the concatenation of both summarization results into an MLP Y_hat = self.linear(self.h(torch.cat([V_A, V_B], dim=1))) return Y_hat
Putting It All Together
By putting the attending, comparing, and aggregating steps together, we define the decom- posable attention model to jointly train these three steps. n
Natural Language Processing: Applications
768

class DecomposableAttention(nn.Module): def __init__(self, vocab, embed_size, num_hiddens, num_inputs_attend=100, num_inputs_compare=200, num_inputs_agg=400, **kwargs): super(DecomposableAttention, self).__init__(**kwargs) self.embedding = nn.Embedding(len(vocab), embed_size) self.attend = Attend(num_inputs_attend, num_hiddens) self.compare = Compare(num_inputs_compare, num_hiddens) # There are 3 possible outputs: entailment, contradiction, and neutral self.aggregate = Aggregate(num_inputs_agg, num_hiddens, num_outputs=3) def forward(self, X): premises, hypotheses = X A = self.embedding(premises) B = self.embedding(hypotheses) beta, alpha = self.attend(A, B) V_A, V_B = self.compare(A, B, beta, alpha) Y_hat = self.aggregate(V_A, V_B) return Y_hat
16.5.2 Training and Evaluating the Model
Now we will train and evaluate the defined decomposable attention model on the SNLI dataset. We begin by reading the dataset.bubuReading the dataset
We download and read the SNLI dataset using the function defined in Section 16.4. The batch size and sequence length are set to 256 and 50, respectively. batch_size, num_steps = 256, 50 train_iter, test_iter, vocab = d2l.load_data_snli(batch_size, num_steps)
Downloading ../data/snli_1.0.zip from https://nlp.stanford.edu/projects/snli/ ‚Ü©!snli_1.0.zip... read 549367 examples read 9824 examples
Creating the Model
We use the pretrained 100-dimensional GloVe embedding to represent the input tokens. Thus, we predefine the dimension of vectors aùëñ and bùëó in (16.5.1) as 100. The output dimension of functions ùëì in (16.5.1) and ùëî in (16.5.4) is set to 200. Then we create a model instance, initialize its parameters, and load the GloVe embedding to initialize vectors of input tokens. embed_size, num_hiddens, devices = 100, 200, d2l.try_all_gpus() net = DecomposableAttention(vocab, embed_size, num_hiddens)
(continues on next page)
Natural Language Inference: Using Attention
769

glove_embedding = d2l.TokenEmbedding('glove.6b.100d') embeds = glove_embedding[vocab.idx_to_token] net.embedding.weight.data.copy_(embeds);
Downloading ../data/glove.6B.100d.zip from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/glove.6B.100d.zip... Training and Evaluating the Model
In contrast to the split_batch function in Section 13.5 that takes single inputs such as text sequences (or images), we define a split_batch_multi_inputs function to take multiple inputs such as premises and hypotheses in minibatches. Now we can train and evaluate the model on the SNLI dataset. lr, num_epochs = 0.001, 4 trainer = torch.optim.Adam(net.parameters(), lr=lr) loss = nn.CrossEntropyLoss(reduction="none") d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
loss 0.496, train acc 0.805, test acc 0.828 20383.2 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
10 08 0.6 0.4 ‚Äî train loss 0.2 4+ --- train ace ‚Äî-- test acc 0.0 10 #15 20 25 30 35 4.0 epoch
Using the Model
Finally, define the prediction function to output the logical relationship between a pair of premise and hypothesis. #@save def predict_snli(net, vocab, premise, hypothesis): """Predict the logical relationship between the premise and hypothesis.""" net.eval() premise = torch.tensor(vocab[premise], device=d2l.try_gpu())
(continued from previous page)
(continues on next page)
Natural Language Processing: Applications
770

hypothesis = torch.tensor(vocab[hypothesis], device=d2l.try_gpu()) label = torch.argmax(net([premise.reshape((1, -1)), hypothesis.reshape((1, -1))]), dim=1) return 'entailment' if label == 0 else 'contradiction' if label == 1 \ else 'neutral'
We can use the trained model to obtain the natural language inference result for a sample pair of sentences. predict_snli(net, vocab, ['he', 'is', 'good', '.'], ['he', 'is', 'bad', '.'])
'contradiction'
16.5.3 Summary
e The decomposable attention model consists of three steps for predicting the logical rela-
tionships between premises and hypotheses: attending, comparing, and aggregating. e With attention mechanisms, we can align tokens in one text sequence to every token in
the other, and vice versa. Such alignment is soft using weighted average, where ideally large weights are associated with the tokens to be aligned. e The decomposition trick leads to a more desirable linear complexity than quadratic com-
plexity when computing attention weights. e We can use pretrained word vectors as the input representation for downstream natural
language processing task such as natural language inference. 16.5.4 Exercises
1.bubuTrain the model with other combinations of hyperparameters. Can you get better accu- racy on the test set?bubu2. What are major drawbacks of the decomposable attention model for natural language inference? 247
3. Suppose that we want to get the level of semantical similarity (e.g., a continuous value between 0 and 1) for any pair of sentences. How shall we collect and label the dataset? Can you design a model with attention mechanisms?bubuDiscussions247. (continued from previous page)
Fine-Tuning BERT for Sequence-Level and Token-Level Applications
771

16.6 Fine-Tuning BERT for Sequence-Level and Token-Level Applications

In the previous sections of this chapter, we have designed different models for natural lan- guage processing applications, such as based on RNNs, CNNs, attention, and MLPs. These modelsarehelpfulwhenthereisspaceortimeconstraint, however, craftingaspecificmodel for every natural language processing task is practically infeasible. In Section 15.8, we in- troduced a pretraining model, BERT, that requires minimal architecture changes for a wide range of natural language processing tasks. On the one hand, at the time of its proposal, BERT improved the state of the art on various natural language processing tasks. On the other hand, as noted in Section 15.10, the two versions of the original BERT model come with110millionand340millionparameters. Thus, whentherearesufficientcomputational resources, we may consider fine-tuning BERT for downstream natural language processing applications. In the following, we generalize a subset of natural language processing applications as sequence-level and token-level. On the sequence level, we introduce how to transform the BERT representation of the text input to the output label in single text classification and text pair classification or regression. On the token level, we will briefly introduce new ap- plications such as text tagging and question answering and shed light on how BERT can represent their inputs and get transformed into output labels. During fine-tuning, the ‚Äúmini- mal architecture changes‚Äù required by BERT across different applications are the extra fully connected layers. During supervised learning of a downstream application, parameters of the extra layers are learned from scratch while all the parameters in the pretrained BERT model are fine-tuned. 16.6.1 Single Text Classification
Single text classification takes a single text sequence as input and outputs its classification result. Besides sentiment analysis that we have studied in this chapter, the Corpus of Lin- guistic Acceptability (CoLA) is also a dataset for single text classification, judging whether a given sentence is grammatically acceptable or not (Warstadt et al., 2019). For instance, ‚ÄúI should study.‚Äù is acceptable but ‚ÄúI should studying.‚Äù is not. Section 15.8 describes the input representation of BERT. The BERT input sequence unam- biguously represents both single text and text pairs, where the special classification token ‚Äú<cls>‚Äù is used for sequence classification and the special classification token ‚Äú<sep>‚Äù marks the end of single text or separates a pair of text. As shown in Fig. 16.6.1, in single text classification applications, the BERT representation of the special classification token ‚Äú<cls>‚Äù encodes the information of the entire input text sequence. As the representation of the input single text, it will be fed into a small MLP consisting of fully connected (dense) layers to output the distribution of all the discrete label values. 16.6.2 Text Pair Classification or Regression
Natural Language Processing: Applications
772

Label Repccis> Rep; Rep2 Rep; Rep, Reps Reps REP sep¬ª t t t t t t t t BERT I I I I I <cls> Token; Token, Token; Token, Token; Tokens; ~~ <sep> or N fet ere x ‚Äô ae re Single text sequence
tFig. 16.6.1
Fine-tuning BERT for single text classiÔ¨Åcation applications, such as sentiment analysis and testing linguistic acceptability. Suppose that the input single text has six tokens. We have also examined natural language inference in this chapter. It belongs to text pair classification, a type of application classifying a pair of text. Taking a pair of text as input but outputting a continuous value, semantic textual similarity is a popular text pair regression task. This task measures semantic similarity of sentences. For instance, in the Semantic Textual Similarity Benchmark dataset, the similarity score of a pair of sentences is an ordinal scale ranging from 0 (no meaning overlap) to 5 (meaning equivalence) (Cer et al., 2017). The goal is to predict these scores. Examples from the Semantic Textual Similarity Benchmark dataset include (sentence 1, sentence 2, similarity score):
e ‚ÄúA plane is taking off.‚Äù, ‚ÄúAn air plane is taking off.‚Äù, 5.000;
e ‚ÄúA woman is eating something.‚Äù, ‚ÄúA woman is eating meat.‚Äù, 3.000;
e ‚ÄúA woman is dancing.‚Äù, ‚ÄúA man is talking.‚Äù, 0.000. Label ES RePccis> Rep; Rep, = ReP.sep> + Reps Rep, Reps ‚Äî REPsep> t t t t t t t t BERT <cls> Token; Token, ¬© <sep> = Token, += Token, = Tokens <sep VY Sie Text sequence 1 Text sequence 2
tFig. 16.6.2
Fine-tuning BERT for text pair classiÔ¨Åcation or regression applications, such as natural language inference and semantic textual similarity. Suppose that the input text pair has two and three tokens. Comparing with single text classification in Fig. 16.6.1, fine-tuning BERT for text pair classification in Fig. 16.6.2 is different in the input representation. For text pair regression tasks such as semantic textual similarity, trivial changes can be applied such as outputting
Fine-Tuning BERT for Sequence-Level and Token-Level Applications
773

a continuous label value and using the mean squared loss: they are common for regres- sion. 16.6.3 Text Tagging
Now let‚Äôs consider token-level tasks, such as text tagging, where each token is assigned a label. Amongtexttaggingtasks, part-of-speechtagging assignseachwordapart-of-speech tag (e.g., adjective and determiner) according to the role of the word in the sentence. For example, according to the Penn Treebank II tag set, the sentence ‚ÄúJohn Smith ‚Äôs car is new‚Äù should be tagged as ‚ÄúNNP (noun, proper singular) NNP POS (possessive ending) NN (noun, singular or mass) VB (verb, base form) JJ (adjective)‚Äù. Label Label ~‚Äî Label ~‚Äî Label ~‚ÄîLabel_‚ÄîLabel Parameters of Dense are shared RePccis> Rep; Rep, Rep; Rep, Reps Reps REP sep¬ª t t t t t t t t BERT <cls> Token, Token, ¬© Token, += Token, Tokens Token, <sep> Nf ete Sw feck Single text sequence
tFig. 16.6.3
Fine-tuning BERT for text tagging applications, such as part-of-speech tagging. Suppose that the input single text has six tokens. Fine-tuning BERT for text tagging applications is illustrated in Fig. 16.6.3. Comparing with Fig. 16.6.1, the only distinction lies in that in text tagging, the BERT representation of every token of the input text is fed into the same extra fully connected layers to output the label of the token, such as a part-of-speech tag. 16.6.4 Question Answering
Asanothertoken-levelapplication, questionansweringreflectscapabilitiesofreadingcom- prehension. Forexample, theStanfordQuestionAnsweringDataset(SQuADv1.1)consists of reading passages and questions, where the answer to every question is just a segment of text (text span) from the passage that the question is about (Rajpurkar et al., 2016). To explain, consider a passage ‚ÄúSome experts report that a mask‚Äôs efficacy is inconclusive. However, mask makers insist that their products, such as N95 respirator masks, can guard against the virus.‚Äù and a question ‚ÄúWho say that N95 respirator masks can guard against the virus?‚Äù. The answer should be the text span ‚Äúmask makers‚Äù in the passage. Thus, the goal in SQuAD v1.1 is to predict the start and end of the text span in the passage given a pair of question and passage. To fine-tune BERT for question answering, the question and passage are packed as the first and second text sequence, respectively, in the input of BERT. To predict the position of the start of the text span, the same additional fully connected layer will transform the BERT
Natural Language Processing: Applications
774

Label Parameters of Dense are shared for the same label value Repccis> Rep; Rep. ‚Äî RePsep> Reps Rep, Reps REP sep> t t t t t t t t BERT <cls> Token, Token, ~~ <sep> ~~ Tokens Token, = Tokens -‚Äî<sep> 1 N ‚Äô \ Nae Solo, ard Sle Question Passage
tFig. 16.6.4
Fine-tuning BERT for question answering. Suppose that the input text pair has two and three tokens. representation of any token from the passage of positionùëñ into a scalar score ùë†ùëñ. Such scores
of all the passage tokens are further transformed by the softmax operation into a probability distribution, so that each token positionùëñ in the passage is assigned a probability ùëùùëñ of being the start of the text span. Predicting the end of the text span is the same as above, except that parameters in its additional fully connected layer are independent from those for predicting the start. When predicting the end, any passage token of position ùëñ is transformed by the same fully connected layer into a scalar score ùëíùëñ. Fig. 16.6.4 depicts fine-tuning BERT for question answering. For question answering, the supervised learning‚Äôs training objective is as straightforward as maximizing the log-likelihoods of the ground-truth start and end positions. When predict- ing the span, we can compute the score s; + e; for a valid span from position i to position Jj @ < J), and output the span with the highest score. 16.6.5 Summary
e BERT requires minimal architecture changes (extra fully connected layers) for sequence-
levelandtoken-levelnaturallanguageprocessingapplications, suchassingletextclas- sification (e.g., sentiment analysis and testing linguistic acceptability), text pair classi- ficationorregression(e.g., naturallanguageinferenceandsemantictextualsimilarity), text tagging (e.g., part-of-speech tagging), and question answering. e During supervised learning of a downstream application, parameters of the extra layers
are learned from scratch while all the parameters in the pretrained BERT model are fine-tuned. 16.6.6 Exercises
1.bubuLet‚Äôs design a search engine algorithm for news articles. When the system receives an query (e.g., ‚Äúoil industry during the coronavirus outbreak‚Äù), it should return a ranked list of news articles that are most relevant to the query. Suppose that we have a huge pool of news articles and a large number of queries.bubuTo simplify the problem, suppose that the most relevant article has been labeled for each query. How can we apply negative sampling (see Section 15.2.1) and BERT in the algorithm design? Natural Language Inference: Fine-Tuning BERT
775

2. How can we leverage BERT in training language models? 3. Can we leverage BERT in machine translation? Discussions248. 248

16.7 Natural Language Inference: Fine-Tuning BERT

In earlier sections of this chapter, we have designed an attention-based architecture (in Section 16.5) for the natural language inference task on the SNLI dataset (as described in Section 16.4). Now we revisit this task by fine-tuning BERT. As discussed in Section 16.6, natural language inference is a sequence-level text pair classification problem, and fine-tuning BERT only requires an additional MLP-based architecture, as illustrated in Fig. 16.7.1. > 3 g 8 s \ ' 1 Architecture | MLP CNN RNN Attention oa i V 1 ears oso \ i ‚ÄòSubword ! Pretraining | | word2vec GloVe embedding BERT ! V 1
tFig. 16.7.1
This section feeds pretrained BERT to an MLP-based architecture for natural language inference. In this section, we will download a pretrained small version of BERT, then fine-tune it for natural language inference on the SNLI dataset. import json import multiprocessing import os import torch from torch import nn from d2l import torch as d2l
16.7.1 Loading Pretrained BERT
We have explained how to pretrain BERT on the WikiText-2 dataset in Section 15.9 and Section 15.10 (note that the original BERT model is pretrained on much bigger corpora). AsdiscussedinSection15.10, theoriginalBERTmodelhashundredsofmillionsofparam- eters. In the following, we provide two versions of pretrained BERT: ‚Äúbert.base‚Äù is about
Natural Language Processing: Applications
776

as big as the original BERT base model that requires a lot of computational resources to fine-tune, while ‚Äúbert.small‚Äù is a small version to facilitate demonstration. d2l.DATA_HUB['bert.base'] = (d2l.DATA_URL + 'bert.base.torch.zip', '225d66f04cae318b841a13d32af3acc165f253ac') d2l.DATA_HUB['bert.small'] = (d2l.DATA_URL + 'bert.small.torch.zip', 'c72329e68a732bef0452e4b96a1c341c8910f81f')
Either pretrained BERT model contains a ‚Äúvocab.json‚Äù file that defines the vocabulary set and a ‚Äúpretrained.params‚Äù file of the pretrained parameters. We implement the following load_pretrained_model function to load pretrained BERT parameters. def load_pretrained_model(pretrained_model, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout, max_len, devices): data_dir = d2l.download_extract(pretrained_model) # Define an empty vocabulary to load the predefined vocabulary vocab = d2l.Vocab() vocab.idx_to_token = json.load(open(os.path.join(data_dir, 'vocab.json'))) vocab.token_to_idx = {token: idx for idx, token in enumerate( vocab.idx_to_token)} bert = d2l.BERTModel( len(vocab), num_hiddens, ffn_num_hiddens=ffn_num_hiddens, num_heads=4, num_blks=2, dropout=0.2, max_len=max_len) # Load pretrained BERT parameters bert.load_state_dict(torch.load(os.path.join(data_dir, 'pretrained.params'))) return bert, vocab
To facilitate demonstration on most of machines, we will load and fine-tune the small ver- sion (‚Äúbert.small‚Äù) of the pretrained BERT in this section. In the exercise, we will show how to fine-tune the much larger ‚Äúbert.base‚Äù to significantly improve the testing accu- racy. devices = d2l.try_all_gpus() bert, vocab = load_pretrained_model( 'bert.small', num_hiddens=256, ffn_num_hiddens=512, num_heads=4, num_blks=2, dropout=0.1, max_len=512, devices=devices)
Downloading ../data/bert.small.torch.zip from http://d2l-data.s3-accelerate. ‚Ü©!amazonaws.com/bert.small.torch.zip... 16.7.2 The Dataset for Fine-Tuning BERT
For the downstream task natural language inference on the SNLI dataset, we define a cus- tomized dataset class SNLIBERTDataset. In each example, the premise and hypothesis form a pair of text sequence and is packed into one BERT input sequence as depicted in Fig. 16.6.2. Recall Section 15.8.4 that segment IDs are used to distinguish the premise and the hypothesis in a BERT input sequence. With the predefined maximum length of a BERT input sequence (max_len), the last token of the longer of the input text pair keeps
Natural Language Inference: Fine-Tuning BERT
777

getting removed until max_len is met. To accelerate generation of the SNLI dataset for fine-tuning BERT, we use 4 worker processes to generate training or testing examples in parallel. class SNLIBERTDataset(torch.utils.data.Dataset):
def __init__(self, dataset, max_len, vocab=None): all_premise_hypothesis_tokens = [[ p_tokens, h_tokens] for p_tokens, h_tokens in zip( *[d2l.tokenize([s.lower() for s in sentences]) for sentences in dataset[:2]])] self.labels = torch.tensor(dataset[2]) self.vocab = vocab self.max_len = max_len (self.all_token_ids, self.all_segments, self.valid_lens) = self._preprocess(all_premise_hypothesis_tokens) print('read ' + str(len(self.all_token_ids)) + ' examples') def _preprocess(self, all_premise_hypothesis_tokens): pool = multiprocessing.Pool(4) # Use 4 worker processes out = pool.map(self._mp_worker, all_premise_hypothesis_tokens) all_token_ids = [ token_ids for token_ids, segments, valid_len in out] all_segments = [segments for token_ids, segments, valid_len in out] valid_lens = [valid_len for token_ids, segments, valid_len in out] return (torch.tensor(all_token_ids, dtype=torch.long), torch.tensor(all_segments, dtype=torch.long), torch.tensor(valid_lens)) def _mp_worker(self, premise_hypothesis_tokens): p_tokens, h_tokens = premise_hypothesis_tokens self._truncate_pair_of_tokens(p_tokens, h_tokens) tokens, segments = d2l.get_tokens_and_segments(p_tokens, h_tokens) token_ids = self.vocab[tokens] + [self.vocab['<pad>']] \ * (self.max_len - len(tokens)) segments = segments + [0] * (self.max_len - len(segments)) valid_len = len(tokens) return token_ids, segments, valid_len def _truncate_pair_of_tokens(self, p_tokens, h_tokens): # Reserve slots for '<CLS>', '<SEP>', and '<SEP>' tokens for the BERT # input while len(p_tokens) + len(h_tokens) > self.max_len - 3: if len(p_tokens) > len(h_tokens): p_tokens.pop() else: h_tokens.pop() def __getitem__(self, idx): return (self.all_token_ids[idx], self.all_segments[idx], self.valid_lens[idx]), self.labels[idx] def __len__(self):
return len(self.all_token_ids)
After downloading the SNLI dataset, we generate training and testing examples by instan-
Natural Language Processing: Applications
778

tiating the SNLIBERTDataset class. Such examples will be read in minibatches during training and testing of natural language inference. # Reduce `batch_size` if there is an out of memory error. In the original BERT # model, `max_len` = 512 batch_size, max_len, num_workers = 512, 128, d2l.get_dataloader_workers() data_dir = d2l.download_extract('SNLI') train_set = SNLIBERTDataset(d2l.read_snli(data_dir, True), max_len, vocab) test_set = SNLIBERTDataset(d2l.read_snli(data_dir, False), max_len, vocab) train_iter = torch.utils.data.DataLoader(train_set, batch_size, shuffle=True, num_workers=num_workers) test_iter = torch.utils.data.DataLoader(test_set, batch_size, num_workers=num_workers)
read 549367 examples read 9824 examples
16.7.3 Fine-Tuning BERT
As Fig. 16.6.2 indicates, fine-tuning BERT for natural language inference requires only an extra MLP consisting of two fully connected layers (see self.hidden and self.output in the following BERTClassifier class). This MLP transforms the BERT representation of the special ‚Äú<cls>‚Äù token, which encodes the information of both the premise and the hypothesis, into three outputs of natural language inference: entailment, contradiction, and neutral. class BERTClassifier(nn.Module): def __init__(self, bert): super(BERTClassifier, self).__init__() self.encoder = bert.encoder self.hidden = bert.hidden self.output = nn.LazyLinear(3) def forward(self, inputs): tokens_X, segments_X, valid_lens_x = inputs encoded_X = self.encoder(tokens_X, segments_X, valid_lens_x) return self.output(self.hidden(encoded_X[:, 0, :]))
In the following, the pretrained BERT model bert is fed into the BERTClassifier instance net for the downstream application. In common implementations of BERT fine-tuning, only the parameters of the output layer of the additional MLP (net.output) will be learned from scratch. All the parameters of the pretrained BERT encoder (net.encoder) and the hidden layer of the additional MLP (net.hidden) will be fine-tuned. net = BERTClassifier(bert)
Recall that in Section 15.8 both the MaskLM class and the NextSentencePred class have parameters in their employed MLPs. These parameters are part of those in the pretrained BERT model bert, and thus part of parameters in net. However, such parameters are
7719
Natural Language Inference: Fine-Tuning BERT
779

only for computing the masked language modeling loss and the next sentence prediction loss during pretraining. These two loss functions are irrelevant to fine-tuning downstream applications, thustheparametersoftheemployedMLPsinMaskLMandNextSentencePred are not updated (staled) when BERT is fine-tuned. To allow parameters with stale gradients, the flag ignore_stale_grad=True is set in the step function of d2l.train_batch_ch13. We use this function to train and evaluate the model net using the training set (train_iter) and the testing set (test_iter) of SNLI. Due to the limited computational resources, the training and testing accuracy can be further improved: we leave its discussions in the exercises. lr, num_epochs = 1e-4, 5 trainer = torch.optim.Adam(net.parameters(), lr=lr) loss = nn.CrossEntropyLoss(reduction='none') net(next(iter(train_iter))[0]) d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices)
loss 0.520, train acc 0.791, test acc 0.786 10588.8 examples/sec on [device(type='cuda', index=0), device(type='cuda',‚ê£ ‚Ü©!index=1)]
1.0 ‚Äî train loss 0.24 -=> train acc ‚Äî-- test acc 0.0 1 2 3 4 5 epoch
16.7.4 Summary
e We can fine-tune the pretrained BERT model for downstream applications, such as nat-
ural language inference on the SNLI dataset. e During fine-tuning, the BERT model becomes part of the model for the downstream
application. Parameters that are only related to pretraining loss will not be updated during fine-tuning. 16.7.5 Exercises
1.bubuFine-tuneamuchlargerpretrainedBERTmodelthatisaboutasbigastheoriginalBERT basemodelifyourcomputationalresourceallows. Setargumentsintheload_pretrained_model functionas: replacing‚Äòbert.small‚Äôwith‚Äòbert.base‚Äô,increasingvaluesof num_hiddens=256, ffn_num_hiddens=512, num_heads=4, and num_blks=2 to 768, 3072, 12, and 12, re-
Natural Language Processing: Applications
780

spectively. By increasing fine-tuning epochs (and possibly tuning other hyperparame- ters), can you get a testing accuracy higher than 0.86? 2. How to truncate a pair of sequences according to their ratio of length? Compare this pair truncation method and the one used in the SNLIBERTDataset class. What are their pros and cons?bubuDiscussions249. 249
Bax
17
Reinforcement Learning
Pratik Chaudhari (University of Pennsylvania and Amazon), Rasool Fakoor (Amazon), and Kavosh Asadi (Amazon)
Reinforcement Learning (RL) is a suite of techniques that allows us to build machine learn- ingsystemsthattakedecisionssequentially. Forexample, apackagecontainingnewclothes that you purchased from an online retailer arrives at your doorstep after a sequence of de- cisions, e.g., the retailer finding the clothes in the warehouse closest to your house, putting the clothes in a box, transporting the box via land or by air, and delivering it to your house within the city.bubuThere are many variables that affect the delivery of the package along the way, e.g., whether or not the clothes were available in the warehouse, how long it took to transport the box, whether it arrived in your city before the daily delivery truck left, etc. The key idea is that at each stage these variables that we do not often control affect the entire sequence of events in the future, e.g., if there were delays in packing the box in the warehouse the retailer may need to send the package via air instead of ground to ensure a timely delivery. Reinforcement Learning methods allow us to take the appropriate action at each stage of a sequential decision making problem in order to maximize some utility eventually, e.g., the timely delivery of the package to you. Such sequential decision making problems are seen in numerous other places, e.g., while
playing Go250 your current move determines the next moves and the opponent‚Äôs moves are the variables that you cannot control‚Ä¶ a sequence of moves eventually determines whether or not you win; the movies that Netflix recommends to you now determine what you watch, whether you like the movie or not is unknown to Netflix, eventually a sequence of movie recommendations determines how satisfied you are with Netflix. Reinforcement learning is being used today to develop effective solutions to these problems (Mnih et al., 2013, Silver et al., 2016). The key distinction between reinforcement learning and standard deep learningis thatin standarddeeplearningthepredictionofa trainedmodelononetestdatum does not affect the predictions on a future test datum; in reinforcement learning decisions at future instants (in RL, decisions are also called actions) are affected by what decisions were made in the past. 250
In this chapter, we will develop the fundamentals of reinforcement learning and obtain hands-on experience in implementing some popular reinforcement learning methods. We will first develop a concept called a Markov Decision Process (MDP) which allows us to think of such sequential decision making problems. An algorithm called Value Iteration will be our first insight into solving reinforcement learning problems under the assumption that we know how the uncontrolled variables in an MDP (in RL, these controlled variables
781
Reinforcement Learning
782

are called the environment) typically behave. Using the more general version of Value Iteration, an algorithm called Q-Learning, we will be able to take appropriate actions even when we do not necessarily have full knowledge of the environment. We will then study how to use deep networks for reinforcement learning problems by imitating the actions of an expert. And finally, we will develop a reinforcement learning method that uses a deep network to take actions in unknown environments. These techniques form the basis of more advanced RL algorithms that are used today in a variety of real-world applications, some of which we will point to in the chapter. Action State s, Reward r, en _ St41
tFig. 17.1
Reinforcement Learning Structure
17.1 Markov Decision Process (MDP)
a
In this section, we will discuss how to formulate reinforcement learning problems using Markov decision processes (MDPs) and describe various components of MDPs in de- tail. 17.1.1 Definition of an MDP
A Markov decision process (MDP) (Bellman, 1957) is a model for how the state of a system evolves as different actions are applied to the system. A few different quantities come together to form an MDP. e Let S be the set of states in the MDP. As a concrete example see Fig. 17.1.1, for a robot
that is navigating a gridworld. In this case, S corresponds to the set of locations that the robot can be at any given timestep. e Let A be the set of actions that the robot can take at each state, e.g., ‚Äúgo forward‚Äù, ‚Äúturn
Markov Decision Process (MDP)
783

@ | |4 | |e ee Eee ea ae 28/6)
tFig. 17.1.1 A simple gridworld navigation task where the robot not only has to Ô¨Ånd its way to the goal
location (shown as a green house) but also has to avoid trap locations (shown as red cross signs). right‚Äù, ‚Äúturn left‚Äù, ‚Äústay at the same location‚Äù, etc. Actions can change the current state of the robot to some other state within the set S. e It may happen that we do not know how the robot moves exactly but only know it up to some approximation. We model this situation in reinforcement learning as follows: if the robot takes an action ‚Äúgo forward‚Äù, there might be a small probability that it stays at the current state, another small probability that it ‚Äúturns left‚Äù, etc. Mathematically, this amounts to defining a ‚Äútransition function‚Äù T : S x A x S ‚Äî [0,1] such that T(s,a, 5‚Äô) = P(s‚Äô | s,a) using the conditional probability of reaching a state s‚Äô given that the robot was at state s and took an action a. The transition function is a probability distribution and we therefore have }\ <5 T(s,a, 5‚Äô) = 1 for alls ‚Ç¨ S anda√© A, ie., the robot has to go to some state if it takes an action. e We now construct a notion of which actions are useful and which ones are not using the concept of a ‚Äúreward‚Äù r : S x A ‚Äî R. We say that the robot gets a reward r(s, a) if the robot takes an action a at state s. If the reward r(s,a) is large, this indicates that taking the action a at state s is more useful to achieving the goal of the robot, i.e., going to the green house. If the reward r(s,a) is small, then action a is less useful to achieving this goal. It is important to note that the reward is designed by the user (the person who creates the reinforcement learning algorithm) with the goal in mind. 17.1.2 Return and Discount Factor
The different components above together form a Markov decision process (MDP)
MDP : ‚ÄûS, A,ùëá,ùëü‚Äù. (17.1.1)
Reinforcement Learning
784

Let‚Äôs now consider the situation when the robot starts at a particular state ùë†0 2 S and
continues taking actions to result in a trajectory
ùúè = ‚Äûùë†0, ùëé0,ùëü0, ùë†1, ùëé1,ùëü1, ùë†2, ùëé2,ùëü2, . . .‚Äù. (17.1.2)
At each time step ùë° the robot is at a state ùë†ùë° and takes an action ùëéùë° which results in a reward
ùëüùë° = ùëü‚Äûùë†ùë°, ùëéùë°‚Äù. The return of a trajectory is the total reward obtained by the robot along such a trajectory
R(t) =rotritroate:. (17.1.3)
The goal in reinforcement learning is to find a trajectory that has the largest return. Think of the situation when the robot continues to travel in the gridworld without ever reaching the goal location. The sequence of states and actions in a trajectory can be in- finitely long in this case and the return of any such infinitely long trajectory will be infinite. In order to keep the reinforcement learning formulation meaningful even for such trajecto- ries, we introduce the notion of a discount factor ùõæ < 1. We write the discounted return as
R(t) =rotynitynte= yr. (17.1.4) =0
Note that if ùõæ is very small, the rewards earned by the robot in the far future, say ùë° =
1000, are heavily discounted by the factor ùõæ1000. This encourages the robot to select short trajectories that achieve its goal, namely that of going to the green house in the gridwold example (see Fig. 17.1.1). For large values of the discount factor, say ùõæ = 0.99, the robot is encouraged to explore and then find the best trajectory to go to the goal location. 17.1.3 Discussion of the Markov Assumption
Let us think of a new robot where the state ùë†ùë° is the location as above but the action ùëéùë° is
Let us think of a new robot where the state s, is the location as above but the action a; is the acceleration that the robot applies to its wheels instead of an abstract command like ‚Äúgo forward‚Äù. If this robot has some non-zero velocity at state s;, then the next location 5,41 is a function of the past location s;, the acceleration a;, also the velocity of the robot at time t which is proportional to s; ‚Äî s;-;. This indicates that we should have
St+1 = some function(s;, a7, 5;-1);
(17.1.5)
the ‚Äúsome function‚Äù in our case would be Newton‚Äôs law of motion. This is quite different from our transition function that simply depends upon ùë†ùë° and ùëéùë°. Markov systems are all systems where the next state ùë†ùë°‚Äö1 is only a function of the current
Markov systems are all systems where the next state 5,4; is only a function of the current state s; and the action a; taken at the current state. In Markov systems, the next state does not depend on which actions were taken in the past or the states that the robot was at in the past. For example, the new robot that has acceleration as the action above is not Markovian because the next location s;;; depends upon the previous state s;_; through the velocity. It may seem that Markovian nature of a system is a restrictive assumption, but it is not so. Markov Decision Processes are still capable of modeling a very large class of real systems. For example, for our new robot, if we chose our state s, to the tuple (location, velocity)
Value Iteration
785

then the system is Markovian because its next state ‚Äûlocationùë°‚Äö1,velocityùë°‚Äö1
upon the current state ‚Äûlocationùë°,velocityùë°‚Äù and the action at the current state ùëéùë°. 17.1.4 Summary
The reinforcement learning problem is typically modeled using Markov Decision Pro- cesses. A Markov decision process (MDP) is defined by a tuple of four entities ‚ÄûS, A,ùëá,ùëü‚Äù where S is the state space, A is the action space, ùëá is the transition function that encodes the transition probabilities of the MDP and ùëü is the immediate reward obtained by taking action at a particular state. 17.1.5 Exercises
1.bubuSuppose that we want to design an MDP to model MountainCar251 problem. 251
1. What would be the set of states? 2. What would be the set of actions? 3. What would be the possible reward functions? 2. How would you design an MDP for an Atari game like Pong game252? 252
Discussions253. 253
17.2 Value Iteration
ae
In this section we will discuss how to pick the best action for the robot at each state to maximize the return of the trajectory. We will describe an algorithm called Value Iteration and implement it for a simulated robot that travels over a frozen lake. 17.2.1 Stochastic Policy
A stochastic policy denoted as ùúã‚Äûùëé j ùë†‚Äù (policy for short) is a conditional distribution over
A stochastic policy denoted as (a | s) (policy for short) is a conditional distribution over the actions a ‚Ç¨ A given the state s ‚Ç¨ S, x(a | s) = P(a | s). As an example, if the robot has four actions A = {go left, go down, go right, go up}. The policy at a state s ‚Ç¨ S for such a set of actions A is a categorical distribution where the probabilities of the four actions could be [0.4, 0.2, 0.1, 0.3]; at some other state s‚Äô ‚Ç¨ S the probabilities x(a | s‚Äô) of the same four actions could be [0.1, 0.1, 0.2, 0.6]. Note that we should have Xa(a | s) = 1 for any state s. A deterministic policy is a special case of a stochastic policy in that the distribution z(a | s) only gives non-zero probability to one particular action, e.g., [1, 0,0, 0] for our example with four actions. To make the notation less cumbersome, we will often write ùúã‚Äûùë†‚Äù as the conditional distri-
bution instead of ùúã‚Äûùëé j ùë†‚Äù. ‚Äù depends only
Reinforcement Learning
786

17.2.2 Value Function
Imagine now that the robot starts at a state ùë†0 and at each time instant, it first samples
Imagine now that the robot starts at a state sg and at each time instant, it first samples an action from the policy a; ~ 2(s;) and takes this action to result in the next state St41. The trajectory T = (50, 40,70, 51,41, 11,...), can be different depending upon which particular action a; is sampled at intermediate instants. We define the average return R(t) = Do y'r(sr, ar) of all such trajectories
ùë°=0
h
V" (so) = Ea,~x(s;) [Ria)| = Ea,~n(s;) | y y'r(s1.ar)], (17.2.1) t=0
where 5,41 ~ P(s141 | 81,1) is the next state of the robot and r(s;,a;) is the instantaneous
reward obtained by taking action ùëéùë° in state ùë†ùë° at time ùë°. This is called the ‚Äúvalue function‚Äù for the policy ùúã. In simple words, the value of a state ùë†0 for a policy ùúã, denoted by ùëâ ùúã‚Äûùë†0‚Äù, is the expected ùõæ-discounted return obtained by the robot if it begins at state ùë†0 and takes actions from the policy ùúã at each time instant. We next break down the trajectory into two stages (i) the first stage which corresponds to ùë†0 !bubuùë†1 upon taking the action ùëé0, and (ii) a second stage which is the trajectory ùúè0 = ‚Äûùë†1, ùëé1,ùëü1, . .bubu.‚Äù thereafter. The key idea behind all algorithms in reinforcement learning is that the value of state ùë†0 can be written as the average reward obtained in the first stage and the value function averaged over all possible next states ùë†1. This is quite intuitive and arises from our Markov assumption: the average return from the current state is the sum of the average return from the next state and the average reward of going to the next state. Mathematically, we write the two stages as
V* (50) = "(05 40) + Eay~n(s0)[Ess~P(ilso.a0)[¬•"(s1) (17.2.2)
This decomposition is very powerful: it is the foundation of the principle of dynamic pro- gramming upon which all reinforcement learning algorithms are based. Notice that the second stage gets two expectations, one over the choices of the action ùëé0 taken in the first stage using the stochastic policy and another over the possible states ùë†1 obtained from the chosen action. We can write (17.2.2) using the transition probabilities in the Markov de- cision process (MDP) as
h
ùëâ ùúã‚Äûùë†‚Äù = ùúã‚Äûùëé j ùë†‚Äù ùëü‚Äûùë†, ùëé‚Äù ‚Äö ùõæ ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äùùëâ ùúã‚Äûùë†0‚Äù ; for all ùë† 2 S. ùëé2A ùë†02S (17.2.3)
An important thing to notice here is that the above identity holds for all states ùë† 2 S because
we can think of any trajectory that begins at that state and break down the trajectory into two stages. 17.2.3 Action-Value Function
In implementations, it is often useful to maintain a quantity called the ‚Äúaction value‚Äù func- tion which is a closely related quantity to the value function. This is defined to be the average return of a trajectory that begins at ùë†0 but when the action of the first stage is fixed
i
i
h
h
ii
i
Value Iteration
787

to be ùëé0
Q*(so0, 40) = r(s0, 40) + Ea,~n(s;) | ¬ª y'r (sr, ay)], (17.2.4) t=1
note that the summation inside the expectation is from ùë° = 1, . .bubu.,1 because the reward of
the first stage is fixed in this case. We can again break down the trajectory into two parts and write
ùëÑùúã‚Äûùë†, ùëé‚Äù = ùëü‚Äûùë†, ùëé‚Äù ‚Äö ùõæ ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äù ùúã‚Äûùëé0 j ùë†0‚Äù ùëÑùúã‚Äûùë†0, ùëé0‚Äù; for all ùë† 2 S, ùëé 2 A. ùë†02S ùëé02A
This version is the analog of (17.2.3) for the action value function. 17.2.4 Optimal Stochastic Policy
Both the value function and the action-value function depend upon the policy that the robot chooses. We will next think of the ‚Äúoptimal policy‚Äù that achieves the maximal average return
n* = argmaxV"
ùúã (17.2.6)
Of all possible stochastic policies that the robot could have taken, the optimal policy 2*
Of all possible stochastic policies that the robot could have taken, the optimal policy 2* achieves the largest average discounted return for trajectories starting from state so. Let us denote the value function and the action-value function of the optimal policy as V* = V‚Ñ¢ and Q* = Q‚Äù". Let us observe that for a deterministic policy where there is only one action that is possible under the policy at any given state. This gives us
h
T(s)= argmax|r(s,a) +y ¬ª P(s‚Äô | s,a) V*(s‚Äô)]. (17.2.7) acA sleS
A good mnemonic to remember this is that the optimal action at state ùë† (for a deterministic
policy) is the one that maximizes the sum of reward ùëü‚Äûùë†, ùëé‚Äù from the first stage and the average return of the trajectories starting from the next sate ùë†0, averaged over all possible next states ùë†0 from the second stage. 17.2.5 Principle of Dynamic Programming
Our developement in the previous section in (17.2.2) or (17.2.5) can be turned into an algorithm to compute the optimal value function V* or the action-value function Q*, re- spectively. Observe that
h
Vi(s)= ¬ª n*(a|s) [r(s,a) +y ¬ª P(s‚Äô | 5, av"(s‚Äô)|; foralls ‚Ç¨ S. (17.2.8) acA eS
For a deterministic optimal policy 2‚Äú, since there is only one action that can be taken at
state ùë†, we can also write
n
Vi(s)= argmaxgeq{"(954) +y ¬ª P(s‚Äô | s,ayv'(s')} (17.2.9) eS
i
(17.2.5)
ùëâ ùúã‚Äûùë†0‚Äù. i
i
o
Reinforcement Learning
788

for all states ùë† 2 S. This identity is called the ‚Äúprinciple of dynamic programming‚Äù (Bell-
man, 1952, Bellman, 1957). It was formulated by Richard Bellman in 1950s and we can remember it as ‚Äúthe remainder of an optimal trajectory is also optimal‚Äù. 17.2.6 Value Iteration
We can turn the principle of dynamic programming into an algorithm for finding the optimal value function called value iteration. The key idea behind value iteration is to think of this identity as a set of constraints that tie together V*(s) at different states s ‚Ç¨ S. We initialize the value function to some arbitrary values Vo(s) for all states s ‚Ç¨ S. At the k" iteration, the Value Iteration algorithm updates the value function as
n
ùëâùëò‚Äö1‚Äûùë†‚Äù = max ùëé2A ùëü‚Äûùë†, ùëé‚Äù ‚Äö ùõæ ùë†02S ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äùùëâùëò‚Äûùë†0‚Äù ; for all ùë† 2 S. (17.2.10)
It turns out that as ùëò ! 1 the value function estimated by the Value Iteration algorithm
converges to the optimal value function irrespective of the initialization ùëâ0,
V*(s) = jim Vi(s); for all states s ‚Ç¨ S. (17.2.11)
ThesameValueIterationalgorithm canbeequivalentlywrittenusingtheaction-valuefunc- tion as
ùëÑùëò‚Äö1‚Äûùë†, ùëé‚Äù = ùëü‚Äûùë†, ùëé‚Äù ‚Äö ùõæ max ùëé02A ùë†02S ùëÉ‚Äûùë†0 j ùë†, ùëé‚ÄùùëÑùëò‚Äûùë†0, ùëé0‚Äù; for all ùë† 2 S, ùëé 2 A. In this case we initialize ùëÑ0‚Äûùë†, ùëé‚Äù to some arbitrary values for all ùë† 2 S and ùëé 2 A. Again
In this case we initialize Qo(s, a) to some arbitrary values for all s ‚Ç¨ S anda ‚Ç¨ A. Again we have Q*(s,a) = limp‚Äîoo Qx(s, a) forall s‚Ç¨ S anda √© A. 17.2.7 Policy Evaluation
Value Iteration enables us to compute the optimal value function, i.e., V‚Ñ¢
Value Iteration enables us to compute the optimal value function, i.e., V‚Ñ¢ of the optimal deterministic policy z*. We can also use similar iterative updates to compute the value function associated with any other, potentially stochastic, policy 7. We again initialize V5‚Äò(s) to some arbitrary values for all states s ‚Ç¨ S and at the k'¬Æ iteration, perform the updates
h
ùëò‚Äö1 ‚Äûùë†‚Äù = ùëé2A ùúã‚Äûùëé j ùë†‚Äù ùëü‚Äûùë†, ùëé‚Äù ‚Äö ùõæ ùë†02S ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äùùëâ ùúã ùëò ‚Äûùë†0‚Äù ; for all ùë† 2 S. (17.2.13)
ùëâ ùúã
This algorithm is known as policy evaluation and is useful to compute the value function given the policy. Again, it turns out that as ùëò ! 1 these updates converge to the correct value function irrespective of the initialization ùëâ0,
ùëâ ùúã‚Äûùë†‚Äù = lim ùëò!1 ùëâ ùúã ùëò ‚Äûùë†‚Äù; for all states ùë† 2 S. (17.2.14)
The algorithm for computing the action-value function ùëÑùúã‚Äûùë†, ùëé‚Äù of a policy ùúã is analo-
gous. o
(17.2.12)
i
Value Iteration
789

17.2.8 Implementation of Value Iteration
WenextshowhowtoimplementValueIterationforanavigationproblemcalledFrozenLake
from Open AI Gym254. We first need to setup the enviroment as shown in the following code. 254

%matplotlib inline import random import numpy as np from d2l import torch as d2l seed = 0 # Random number generator seed gamma = 0.95 # Discount factor num_iters = 10 # Number of iterations random.seed(seed) # Set the random seed to ensure results can be reproduced np.random.seed(seed) # Now set up the environment env_info = d2l.make_env('FrozenLake-v1', seed=seed)
# Now set up the environment env_info = d2l.make_env('FrozenLake-v1', seed=seed)
In the FrozenLake environment, the robot moves on a 4 x 4 grid (these are the states) with
actions that are ‚Äúup‚Äù ("), ‚Äúdown‚Äù (!), ‚Äúleft‚Äù ( ), and ‚Äúright‚Äù (!). The environment contains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of which are unknown to the robot. To keep the problem simple, we assume the robot has reliable actions, i.e. ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äù = 1 for all ùë† 2 S, ùëé 2 A. If the robot reaches the goal, the trial ends and the robot receives a reward of 1 irrespective of the action; the reward at any other state is 0 for all actions. The objective of the robot is to learn a policy that reaches the goal location (G) from a given start location (S) (this is ùë†0) to maximize the return. The following function implements Value Iteration, where env_info contains MDP and environment related information and gamma is the discount factor:
def value_iteration(env_info, gamma, num_iters): env_desc = env_info['desc'] # 2D array shows what each item means prob_idx = env_info['trans_prob_idx'] nextstate_idx = env_info['nextstate_idx'] reward_idx = env_info['reward_idx'] num_states = env_info['num_states'] num_actions = env_info['num_actions'] mdp = env_info['mdp'] V = np.zeros((num_iters + 1, num_states)) Q = np.zeros((num_iters + 1, num_states, num_actions)) pi = np.zeros((num_iters + 1, num_states)) for k in range(1, num_iters + 1): for s in range(num_states): for a in range(num_actions): # Calculate \sum_{s'} p(s'\mid s,a) [r + \gamma v_k(s')] for pxrds in mdp[(s,a)]: # mdp(s,a): [(p1,next1,r1,d1),(p2,next2,r2,d2),..] pr = pxrds[prob_idx] # p(s'\mid s,a)
(continues on next page)
Reinforcement Learning
790

nextstate = pxrds[nextstate_idx] # Next state reward = pxrds[reward_idx] # Reward Q[k,s,a] += pr * (reward + gamma * V[k - 1, nextstate]) # Record max value and max action V[k,s] = np.max(Q[k,s,:]) pi[k,s] = np.argmax(Q[k,s,:]) d2l.show_value_function_progress(env_desc, V[:-1], pi[:-1])
value_iteration(env_info=env_info, gamma=gamma, num_iters=num_iters)

The above pictures show the policy (the arrow indicates the action) and value function (the change in color shows how the value function changes over time from the initial value shown by dark color to the optimal value shown by light colors.). As we see, Value Iteration finds the optimal value function after 10 iterations and the goal state (G) can be reached starting from any state as long as it is not an H cell. Another interesting aspect of the implementation is that in addition to finding the optimal value function, we also automatically found the optimal policy z* corresponding to this value function. 17.2.9 Summary
The main idea behind the Value Iteration algorithm is to use the principle of dynamic pro- gramming to find the optimal average return obtained from a given state. Note that imple-
(continued from previous page)
791

menting the Value Iteration algorithm requires that we know the Markov decision process (MDP), e.g., the transition and reward functions, completely. 17.2.10 Exercises
1. Try increasing the grid size to 8 x 8. Compared with 4 x 4 grid, how many iterations
does it take to find the optimal value function? 2. What is the computational complexity of the Value Iteration algorithm? 3. Run the Value Iteration algorithm again with ùõæ (i.e. ‚Äúgamma‚Äù in the above code) when
it equals to 0, 0.5, and 1 and analyze its results. 4. How does the value of ùõæ affect the number of iterations taken by Value Iteration to
converge? What happens when ùõæ = 1?bubuDiscussions255. 255

17.3 Q-Learning
|
Intheprevioussection, wediscussedtheValueIterationalgorithmwhichrequiresaccessing the complete Markov decision process (MDP), e.g., the transition and reward functions. In this section, we will look at Q-Learning (Watkins and Dayan, 1992) which is an algorithm to learn the value function without necessarily knowing the MDP. This algorithm embodies the central idea behind reinforcement learning: it will enable the robot to obtain its own data. 17.3.1 The Q-Learning Algorithm
Recall that value iteration for the action-value function in Value Iteration (page 785) cor- responds to the update
ùëÑùëò‚Äö1‚Äûùë†, ùëé‚Äù = ùëü‚Äûùë†, ùëé‚Äù ‚Äö ùõæ ùë†02S ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äù max ùëé02A ùëÑùëò‚Äûùë†0, ùëé0‚Äù; for all ùë† 2 S and ùëé 2 A. As we discussed, implementing this algorithm requires knowing the MDP, specifically the transition function ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äù. The key idea behind Q-Learning is to replace the summa- tion over all ùë†0 2 S in the above expression by a summation over the states visited by the robot. This allows us to subvert the need to know the transition function. 17.3.2 An Optimization Problem Underlying Q-Learning
Let us imagine that the robot uses a policy ùúãùëí‚Äûùëé j ùë†‚Äù to take actions. Just like the previous
Let us imagine that the robot uses a policy z-(a | s) to take actions. Just like the previous chapter, it collects a dataset of n trajectories of T timesteps each {(si, a!) ,=0 poses T-1}il,....¬∞ Recall that value iteration is really a set of constraints that ties together the action-value
Q-Learning
(17.3.1)
Reinforcement Learning
792

Q*(s,a) of different states and actions to each other. We can implement an approximate
version of value iteration using the data that the robot has collected using ùúãùëí as
n
T-1
n T-1 a. 1 i iy _ i qi)‚Äî i yy O= mine Dy Dy OUsinai) r(sp.4;) ‚Äî ymax Q(s;41.4'))" ¬´
| {z }
Let us first observe the similarities and differences between this expression and value iter- ation above. If the robot‚Äôs policy z- were equal to the optimal policy z*, and if it collected an infinite amount of data, then this optimization problem would be identical to the opti- mization problem underlying value iteration. But while value iteration requires us to know P(s‚Äô | s,a), the optimization objective does not have this term. We have not cheated: as the robot uses the policy 7, to take an action ai at state s!, the next state si +) iS a sample drawn from the transition function. So the optimization objective also has access to the transition function, but implicitly in terms of the data collected by the robot. The variables of our optimization problem are ùëÑ‚Äûùë†, ùëé‚Äù for all ùë† 2 S and ùëé 2 A. We can
minimize the objective using gradient descent. For every pair ‚Äûùë†ùëñ ùë°, ùëéùëñ ùë°‚Äù in our dataset, we can write
ùëÑ‚Äûùë†ùëñ
O(s),a4) ‚Äî O(s},. a4) ‚Äî @V Q¬¢s8 ay C(O) . a ; (17.3.3) = (1 = 0) 0(si,ai) ~ a(r(si, a) + ymax Q(si,.4')),
where ùõº is the learning rate. Typically in real problems, when the robot reaches the goal
location, the trajectories end. The value of such a terminal state is zero because the robot does not take any further actions beyond this state. We should modify our update to handle such states as
O(si,a}) = (1 = a) OCs}, ah) = a(r( shai) + 71 ‚Äî His teminat) MAX O(s',.4)). (17.3.4)
where esi is terminal is an indicator variable that is one if s),, is a terminal state and zero otherwise. The value of state-action tuples (s, a) that are not a part of the dataset is set to ‚Äîoo.bubuThis algorithm is known as Q-Learning. Given the solution of these updates 0, which is an approximation of the optimal value function Q*, we can obtain the optimal deterministic policy corresponding to this value function easily using
ÀÜùúã‚Äûùë†‚Äù = argmaxùëé ÀÜùëÑ‚Äûùë†, ùëé‚Äù. (17.3.5)
There can be situations when there are multiple deterministic policies that correspond to the same optimal value function; such ties can be broken arbitrarily because they have the same value function. 17.3.3 Exploration in Q-Learning
(17.3.2)
=‚Ñì‚ÄûùëÑ‚Äù
793

The policy used by the robot to collect data ùúãùëí is critical to ensure that Q-Learning works
The policy used by the robot to collect data 7, is critical to ensure that Q-Learning works well. Afterall, we have replaced the expectation over s‚Äô using the transition function P(s‚Äô | 5, a) using the data collected by the robot. If the policy z¬¢ does not reach diverse parts of the state-action space, then it is easy to imagine our estimate @ will be a poor approximation of the optimal Q*. It is also important to note that in such a situation, the estimate of Q* at all states s ‚Ç¨ S will be bad, not just the ones visited by 2. This is because the Q-Learning objective (or value iteration) is a constraint that ties together the value of all state-action pairs. It is therefore critical to pick the correct policy 7, to collect data. Wecanmitigatethisconcernbypickingacompletelyrandompolicy ùúãùëí thatsamplesactions
uniformly randomly from A. Such a policy would visit all states, but it will take a large number of trajectories before it does so. We thus arrive at the second key idea in Q-Learning, namely exploration. Typical im- plementations of Q-Learning tie together the current estimate of ùëÑ and the policy ùúãùëí to set
(
O(s,a‚Äô) with prob. 1 ‚Äî ne(a|s)= eee Q(s,a‚Äô) with pro ‚Ç¨ (17.3.6) uniform(A) with prob. e,
where ‚Ç¨ is called the ‚Äúexploration parameter‚Äù and is chosen by the user. The policy z¬¢ is called an exploration policy. This particular 7, is called an e-greedy exploration policy because it chooses the optimal action (under the current estimate 0) with probability 1 ‚Äî ‚Ç¨ but explores randomly with the remainder probability ¬´. We can also use the so-called softmax exploration policy
e(s.a)/T 5, edo ear (17.3.7) me(a|s) =
where the hyper-parameter ùëá is called temperature. A large value of ùúñ in ùúñ-greedy policy
functions similarly to a large value of temperature ùëá for the softmax policy. It is important to note that when we pick an exploration that depends upon the current estimate of the action-value function ÀÜùëÑ, we need to resolve the optimization problem peri- odically. Typical implementations of Q-Learning make one mini-batch update using a few state-action pairs in the collected dataset (typically the ones collected from the previous timestep of the robot) after taking every action using ùúãùëí. 17.3.4 The ‚ÄúSelf-correcting‚Äù Property of Q-Learning
ThedatasetcollectedbytherobotduringQ-Learninggrowswithtime. Boththeexploration policy ùúãùëí and the estimate ÀÜùëÑ evolve as the robot collects more data. This gives us a key insight into why Q-Learning works well. Consider a state ùë†: if a particular action ùëé has a large value under the current estimate ÀÜùëÑ‚Äûùë†, ùëé‚Äù, then both the ùúñ-greedy and the softmax exploration policies have a larger probability of picking this action. If this action actually is not the ideal action, then the future states that arise from this action will have poor rewards. The next update of the Q-Learning objective will therefore reduce the value ÀÜùëÑ‚Äûùë†, ùëé‚Äù, which will reduce the probability of picking this action the next time the robot visits state ùë†. Bad
Q-Learning
Reinforcement Learning
794

actions, e.g., ones whose value is overestimated in ÀÜùëÑ‚Äûùë†, ùëé‚Äù, are explored by the robot but their value is correct in the next update of the Q-Learning objective. Good actions, e.g., whose value ÀÜùëÑ‚Äûùë†, ùëé‚Äù is large, are explored more often by the robot and thereby reinforced. This property can be used to show that Q-Learning can converge to the optimal policy even if it begins with a random policy ùúãùëí (Watkins and Dayan, 1992). This ability to not only collect new data but also collect the right kind of data is the cen- tral feature of reinforcement learning algorithms, and this is what distinguishes them from supervised learning. Q-Learning, using deep neural networks (which we will see in the DQN chapeter later), is responsible for the resurgence of reinforcement learning (Mnih et al., 2013). 17.3.5 Implementation of Q-Learning
We now show how to implement Q-Learning on FrozenLake from Open AI Gym256. Note
this is the same setup as we consider in Value Iteration (page 785) experiment. 256

%matplotlib inline import random import numpy as np from d2l import torch as d2l seed = 0 # Random number generator seed gamma = 0.95 # Discount factor num_iters = 256 # Number of iterations alpha = 0.9 # Learing rate epsilon = 0.9 # Epsilon in epsilion gready algorithm random.seed(seed) # Set the random seed np.random.seed(seed) # Now set up the environment env_info = d2l.make_env('FrozenLake-v1', seed=seed)
In the FrozenLake environment, the robot moves on a 4 x 4 grid (these are the states) with
actions that are ‚Äúup‚Äù ("), ‚Äúdown‚Äù (!), ‚Äúleft‚Äù ( ), and ‚Äúright‚Äù (!). The environment contains a number of holes (H) cells and frozen (F) cells as well as a goal cell (G), all of which are unknown to the robot. To keep the problem simple, we assume the robot has reliable actions, i.e. ùëÉ‚Äûùë†0 j ùë†, ùëé‚Äù = 1 for all ùë† 2 S, ùëé 2 A. If the robot reaches the goal, the trial ends and the robot receives a reward of 1 irrespective of the action; the reward at any other state is 0 for all actions. The objective of the robot is to learn a policy that reaches the goal location (G) from a given start location (S) (this is ùë†0) to maximize the return. We first implement ùúñ-greedy method as follows:
def e_greedy(env, Q, s, epsilon): if random.random() < epsilon: return env.action_space.sample() else: return np.argmax(Q[s,:])
return np.argmax(Q[s, :])
795

We are now ready to implement Q-learning:
def q_learning(env_info, gamma, num_iters, alpha, epsilon): env_desc = env_info['desc'] # 2D array specifying what each grid item‚ê£ ‚Ü©!means env = env_info['env'] # 2D array specifying what each grid item means num_states = env_info['num_states'] num_actions = env_info['num_actions'] Q = np.zeros((num_states, num_actions)) V = np.zeros((num_iters + 1, num_states)) pi = np.zeros((num_iters + 1, num_states)) for k in range(1, num_iters + 1): # Reset environment state, done = env.reset(), False while not done: # Select an action for a given state and acts in env based on‚ê£ ‚Ü©!selected action action = e_greedy(env, Q, state, epsilon) next_state, reward, done, _ = env.step(action) # Q-update: y = reward + gamma * np.max(Q[next_state,:]) Q[state, action] = Q[state, action] + alpha * (y - Q[state,‚ê£ ‚Ü©!action]) # Move to the next state state = next_state # Record max value and max action for visualization purpose only for s in range(num_states): V[k,s] = np.max(Q[s,:]) pi[k,s] = np.argmax(Q[s,:]) d2l.show_Q_function_progress(env_desc, V[:-1], pi[:-1]) q_learning(env_info=env_info, gamma=gamma, num_iters=num_iters, alpha=alpha,‚ê£
q_learning(env_info=env_info, gamma=gamma, num_iters=num_iters, alpha=alpha,‚ê£ ‚Ü©!epsilon=epsilon)
ThisresultshowsthatQ-learningcanfindtheoptimalsolutionforthisproblemroughlyafter 250 iterations. However, when we compare this result with the Value Iteration algorithm‚Äôs result(seeImplementationofValueIteration(page789)), wecanseethattheValueIteration algorithm needs way fewer iterations to find the optimal solution for this problem. This happens because the Value Iteration algorithm has access to the full MDP whereas Q- learning does not. 17.3.6 Summary
Q-learning is one of the most fundamental reinforcement-learning algorithms. It has been at the epicenter of the recent success of reinforcement learning, most notably in learning to play video games (Mnih et al., 2013). Implementing Q-learning does not require that we know the Markov decision process (MDP), e.g., the transition and reward functions, completely. Q-Learning
Reinforcement Learning
796

Step = 201 Step = 226 Step = 251 Step = 256 peee [pe pe [pe pe pegs 8:88:83 :8:8 :-8:f er:*BBi-: :;Bo-: :
17.3.7 Exercises
1. Try increasing the grid size to 8 x 8. Compared with 4 x 4 grid, how many iterations
does it take to find the optimal value function? 2.bubuRun the Q-learning algorithm again with ùõæ (i.e. ‚Äúgamma‚Äù in the above code) when it
equals to 0, 0.5, and 1 and analyze its results. 3. Run the Q-learning algorithm again with ùúñ (i.e. ‚Äúepsilon‚Äù in the above code) when it
equals to 0, 0.5, and 1 and analyze its results.bubuDiscussions257. 257 
18  Gaussian Processes 
Andrew Gordon Wilson (New York University and Amazon)
Gaussian processes (GPs) are ubitiquous. You have already encountered many examples of GPs without realizing it. Any model that is linear in its parameters with a Gaussian distri- bution over the parameters is a Gaussian process. This class spans discrete models, includ- ing random walks, and autoregressive processes, as well as continuous models, including Bayesian linear regression models, polynomials, Fourier series, radial basis functions, and even neural networks with an infinite number of hidden units. There is a running joke that ‚Äúeverything is a special case of a Gaussian process‚Äù. Learning about Gaussian processes is important for three reasons: (1) they provide a func- tionspaceperspectiveofmodelling, whichmakesunderstandingavarietyofmodelclasses, including deep neural networks, much more approachable; (2) they have an extraordinary range of applications where they are state-of-the-art, including active learning, hyperpa- rameter learning, auto-ML, and spatiotemporal regression; (3) over the last few years, algorithmic advances have made Gaussian processes increasingly scalable and relevant, harmonizing with deep learning through frameworks such as GPyTorch 258 (Gardner et al., 2018). Indeed, GPs and and deep neural networks are not competing approaches, but highly complementary, and can be combined to great effect. These algorithmic advances are not just relevant to Gaussian processes, but provide a foundation in numerical methods that is broadly useful in deep learning. 258 
In this chapter, we introduce Gaussian processes. In the introductory notebook, we start by reasoning intuitively about what Gaussian processes are and how they directly model functions. In the priors notebook, we focus on how to specify Gaussian process priors. We directly connect the tradiational weight-space approach to modelling to function space, which will help us reason about constructing and understanding machine learning mod- els, including deep neural networks. We then introduce popular covariance functions, also known as kernels, which control the generalization properties of a Gaussian process. A GP with a given kernel defines a prior over functions. In the inference notebook, we will show how to use data to infer a posterior, in order to make predictions. This notebook contains from-scratch code for making predictions with a Gaussian process, as well as an introduction to GPyTorch. In upcoming notebooks, we will introduce the numerics behind Gaussian processes, which is useful for scaling Gaussian processes but also a powerful gen- eral foundation for deep learning, and advanced use-cases such as hyperparameter tuning in deep learning. Our examples will make use of GPyTorch, which makes Gaussian processes scale, and is closely integrated with deep learning functionality and PyTorch. 797
Gaussian Processes
798

18.1 Introduction to Gaussian Processes
a
In many cases, machine learning amounts to estimating parameters from data. These pa- rameters are often numerous and relatively uninterpretable ‚Äî such as the weights of a neu- ral network. Gaussian processes, by contrast, provide a mechanism for directly reasoning about the high-level properties of functions that could fit our data. For example, we may have a sense of whether these functions are quickly varying, periodic, involve conditional independencies, or translation invariance. Gaussian processes enable us to easily incorpo- rate these properties into our model, by directly specifying a Gaussian distribution over the function values that could fit our data. Let‚Äôs get a feel for how Gaussian processes operate, by starting with some examples. Suppose we observe the following dataset, of regression targets (outputs), ùë¶, indexed by
inputs, ùë•. As an example, the targets could be changes in carbon dioxide concentrations, and the inputs could be the times at which these targets have been recorded. What are some features of the data? How quickly does it seem to varying? Do we have data points collected at regular intervals, or are there missing inputs? How would you imagine filling in the missing regions, or forecasting up until ùë• = 25? 2fe a ¬∞ ¬∞ ¬¢ id S*)e ¬∞ . ~ e oO 2 oP o e,¬∞ w 14 e a [e) -24 e i?) 5 10 15 20 25 Inputs x
tFig.bubu18.1.1 Observed data. In order to fit the data with a Gaussian process, we start by specifying a prior distribution over what types of functions we might believe to be reasonable. Here we show several sample functions from a Gaussian process. Does this prior look reasonable? Note here we are not looking for functions that fit our dataset, but instead for specifying reasonable high-level properties of the solutions, such as how quickly they vary with inputs. Note that we will see code for reproducing all of the plots in this notebook, in the next notebooks on priors and inference. Once we condition on data, we can use this prior to infer a posterior distribution over func- tions that could fit the data. Here we show sample posterior functions. We see that each of these functions are entirely consistent with our data, perfectly running through each observation. In order to use these posterior samples to make predictions, we can average the values of every possible sample function from the posterior, to create the
Introduction to Gaussian Processes
799

te) 5 10 15 20 25
tFig. 18.1.2
Sample prior functions that we may want to represent with our model. Ly i) 5 10 15 20 25
tFig. 18.1.3
Sample posterior functions, once we have observed the data. curve below, in thick blue. Note that we do not actually have to take an infinite number of samples to compute this expectation; as we will see later, we can compute the expectation in closed form. 0 5 10 15 20 25
tFig. 18.1.4
Posterior samples, alongside posterior mean, which can be used for point predictions, in blue. We may also want a representation of uncertainty, so we know how confident we should be in our predictions. Intuitively, we should have more uncertainty where there is more variability in the sample posterior functions, as this tells us there are many more possible values the true function could take. This type of uncertainty is called epistemic uncertainty, which is the reducible uncertainty associated with lack of information. As we acquire more data, this type of uncertainty disappears, as there will be increasingly fewer solutions con- sistent with what we observe. Like with the posterior mean, we can compute the posterior variance (the variability of these functions in the posterior) in closed form. With shade, we show two times the posterior standard deviation on either side of the mean, creating a
Gaussian Processes
800

credible interval that has a 95% probability of containing the true value of the function for any input ùë•. 0 5 10 15 20 25
tFig. 18.1.5
Posterior samples, including 95% credible set. The plot looks somewhat cleaner if we remove the posterior samples, simply visualizing the data, posterior mean, and 95% credible set. Notice how the uncertainty grows away from the data, a property of epistemic uncertainty. 0 5 10 15 20 25
tFig.bubu18.1.6
Point predictions, and credible set. The properties of the Gaussian process that we used to fit the data are strongly controlled by what‚Äôs called a covariance function, also known as a kernel. The covariance function we used is called the RBF (Radial Basis Function) kernel, which has the form
kepe(t,2‚Äô) = Cov( f(a), f")) = a2 exp (-zo10 - vir] (18.1.1)
The hyperparameters of this kernel are interpretable. The amplitude parameter ùëé controls
the vertical scale over which the function is varying, and the length-scale parameter ‚Ñì con- trols the rate of variation (the wiggliness) of the function. Larger ùëé means larger function values, and larger ‚Ñì means more slowly varying functions. Let‚Äôs see what happens to our sample prior and posterior functions as we vary ùëé and ‚Ñì. The length-scale has a particularly pronounced effect on the predictions and uncertainty of a GP. At ||x ‚Äî x‚Äô|| = ‚Ç¨, the covariance between a pair of function values is a? exp(‚Äî0.5). At larger distances than ¬¢ , the values of the function values becomes nearly uncorrelated. This means that if we want to make a prediction at a point x,, then function values with inputs x such that ||x ‚Äî x‚Äô|| > ‚Ç¨ will not have a strong effect on our predictions. Let‚Äôs see how changing the lengthscale affects sample prior and posterior functions, and
Introduction to Gaussian Processes
801

credible sets. The above fits use a length-scale of 2. Let‚Äôs now consider ‚Ñì = 0.1,0.5,2,5,10
. A length-scale of 0.1 is very small relative to the range of the input domain we are consid- ering, 25. For example, the values of the function at ùë• = 5 and ùë• = 10 will have essentially no correlation at such a length-scale. On the other hand, for a length-scale of 10, the func- tion values at these inputs will be highly correlated. Note that the vertical scale changes in the following figures. Lengthscale ¬£=0.100, Amplitude a=1


Lengthscale ¬£=0.500, Amplitude a=1
24
802

Lengthscale ¬£=0.500, Amplitude a=1

Lengthscale ¬£=2.000, Amplitude a=1

Gaussian Processes
Lengthscale ¬£=2.000, Amplitude a=1
24 of u w ¬∞ Bb a N ) N a
Lengthscale ¬£=5.000, Amplitude a=1
of wu ‚Äù ¬∞ Bb uu N 3} N a
Introduction to Gaussian Processes
803

Lengthscale 2=5.000, Amplitude a=1
24
Notice as the length-scale increases the ‚Äòwiggliness‚Äô of the functions decrease, and our uncertainty decreases. If the length-scale is small, the uncertainty will quickly increase as we move away from the data, as the datapoints become less informative about the function values. Now, let‚Äôs vary the amplitude parameter, holding the length-scale fixed at 2. Note the ver- tical scale is held fixed for the prior samples, and varies for the posterior samples, so you can clearly see both the increasing scale of the function, and the fits to the data. abengthscale ¬£=2, Amplitude a=0.100
abengthscale 20 ‚Äî20 -40
Lengthscale ¬£=2, Amplitude a=0.100
24
Gaussian Processes
804

abengthscale ¬£=2, Amplitude a=2.000 20 Or SSS ‚Äî20 ‚Äî40
Lengthscale ¬£=2, Amplitude a=2.000
ad
abengthscale
¬£=2, Amplitude a=8.000
20 ‚Äî20 -40
Lengthscale ¬£=2, Amplitude a=8.000
10 0 Pre -10
Weseetheamplitudeparameteraffectsthescaleofthefunction,butnottherateofvariation. At this point, we also have the sense that the generalization performance of our procedure willdependonhavingreasonablevaluesforthesehyperparameters. Valuesof‚Ñì = 2and ùëé = 1 appeared to provide reasonable fits, while some of the other values did not. Fortunately, there is a robust and automatic way to specify these hyperparameters, using what is called the marginal likelihood, which we will return to in the notebook on inference. Introduction to Gaussian Processes
805

So what is a GP, really? As we started, a GP simply says that any collection of function values ùëì ‚Äûùë•1‚Äù, .bubu. ., ùëì ‚Äûùë•ùëõ‚Äù, indexed by any collection of inputs ùë•1, . . .,ùë•ùëõ has a joint multi- variate Gaussian distribution. The mean vector ùúá of this distribution is given by a mean function, which is typically taken to be a constant or zero. The covariance matrix of this distribution is given by the kernel evaluated at all pairs of the inputs ùë•. 3
2
2
fx) K(x,x) k(x)...bubuK(X, Xn) fi) K(x1,x) kOe)... KOI, Xn) . | ~Nle . .bubu.bubu. (18.1.2) fn) K(xn.X) Kn. x1) --. K(Xns Xn)
Equation(18.1.2)specifiesaGPprior. Wecancomputetheconditionaldistributionof ùëì ‚Äûùë•‚Äù
for any ùë• given ùëì ‚Äûùë•1‚Äù, . .bubu., ùëì ‚Äûùë•ùëõ‚Äù, the function values we have observed. This conditional distribution is called the posterior, and it is what we use to make predictions. In particular,
FRF OI). FOn) ~ Nm, 5‚Äù) (18.1.3)
where
m= k(x.Xn)k (Cin Xin) | fin) (18.1.4)
8 = k(x,x) ‚Äî kin) K(ttn Xin) kX in) (18.1.5)
where k(x,x1:,) is a 1 x n vector formed by evaluating k(x,x;) fori = 1,...,n and k(X1:n,X1:n) is an n X n matrix formed by evaluating k(x;,x;) for i,j = 1,...,n. m is what we can use as a point predictor for any x, and s? is what we use for uncertainty: if we want to create an interval with a 95% probability that f(x) is in the interval, we would use m+ 2s. The predictive means and uncertainties for all the above figures were created using these equations. The observed data points were given by f(x1),..., f(x) and chose a fine grained set of x points to make predictions. Let‚Äôs suppose we observe a single datapoint, ùëì ‚Äûùë•1‚Äù, and we want to determine the value of ùëì ‚Äûùë•‚Äù at some ùë•. Because ùëì ‚Äûùë•‚Äù is described by a Gaussian process, we know the joint distribution over ‚Äû ùëì ‚Äûùë•‚Äù, ùëì ‚Äûùë•1‚Äù‚Äù is Gaussian:
fx) | k(x,x) k(x, x1) Ha N (Ho ol) (18.1.6)
The off-diagonal expression k(x, x) = k(x1,x) tells us how correlated the function values will be ‚Äî how strongly determined f(x) will be from f(x1). We have seen already that if we use a large length-scale, relative to the distance between x and x1, ||x ‚Äî x;||, then the function values will be highly correlated. We can visualize the process of determining f(x) from f (x1) both in the space of functions, and in the joint distribution over f(x1), f(x). Let‚Äôs initially consider an x such that k(x,x1) = 0.9, and k(x,x) = 1, meaning that the value of f(x) is moderately correlated with the value of f(x1). In the joint distribution, the contours of constant probability will be relatively narrow ellipses. Suppose we observe ùëì ‚Äûùë•1‚Äù = 1.2. To condition on this value of ùëì ‚Äûùë•1‚Äù, we can draw a
3
Gaussian Processes
806

horizontal line at 1.2 on our plot of the density, and see that the value of ùëì ‚Äûùë•‚Äù is mostly
constrained to ¬ª0.64,1.52‚Ä¶. We have also drawn this plot in function space, showing the observed point ùëì ‚Äûùë•1‚Äù in orange, and 1 standard deviation of the Gaussian process predictive distribution for ùëì ‚Äûùë•‚Äù in blue, about the mean value of 1.08. Correlation = 0.9 0.56 0.48 2 0.40 0.32 f(x1) 0 0.24 0.16 -2 0.08 0.00 -2 O f(x)
Correlation = 0.9 r co) r & r N e 2 a0 Observations y 2 a x x Inputs x
Now suppose we have a stronger correlation, ùëò‚Äûùë•,ùë•1‚Äù = 0.95. Now the ellipses have nar-
rowed further, and the value of ùëì ‚Äûùë•‚Äù is even more strongly determined by ùëì ‚Äûùë•1‚Äù. Draw- ing a horizontal line at 1.2, we see the contours for ùëì ‚Äûùë•‚Äù support values mostly within ¬ª0.83,1.45‚Ä¶. Again, we also show the plot in function space, with one standard deviation about the mean predictive value of 1.14. Correlation = 0.95 0.56 0.48 2 0.40 0.32 i} 0.24 0.16 -2 0.08 0.00 f(x1) -2 0 f(x)
Introduction to Gaussian Processes
807

Correlation = 0.95 Pr a Pr B Pr nu e Observations y | I So a xX x Inputs x
We see that the posterior mean predictor of our Gaussian process is closer to 1.2, be-
cause there is now a stronger correlation. We also see that our uncertainty (the error bars) have somewhat decreased. Despite the strong correlation between these function values, our uncertainty is still righly quite large, because we have only observed a single data point! This procedure can give us a posterior on ùëì ‚Äûùë•‚Äù for any ùë•, for any number of points we have
observed. Suppose we observe ùëì ‚Äûùë•1‚Äù, ùëì ‚Äûùë•2‚Äù. We now visualize the posterior for ùëì ‚Äûùë•‚Äù at a particular ùë• = ùë•0 in function space. The exact distribution for ùëì ‚Äûùë•‚Äù is given by the above equations. ùëì ‚Äûùë•‚Äù is Gaussian distributed, with mean
m = k(x, x1:3)k(a13.413) fOr) (18.1.7)
and variance
8 = k(x,x) ‚Äî k(x, x13) k(a13.413) kt x13) (18.1.8)
In this introductory notebook, we have been considering noise free observations. As we will see, it is easy to include observation noise. If we assume that the data are generated from a latent noise free function f(x) plus iid Gaussian noise e(x) ~ N(0, 0?) with variance o, then our covariance function simply becomes k(x;,x;) > k(xi,xj) + 5ijo¬∞, where 6;; = 1 if i = 7 and 0 otherwise. We have already started getting some intuition about how we can use a Gaussian process to specify a prior and posterior over solutions, and how the kernel function affects the properties of these solutions. In the following notebooks, we will precisely show how to specify a Gaussian process prior, introduce and derive various kernel functions, and then go through the mechanics of how to automatically learn kernel hyperparameters, and form a Gaussian process posterior to make predictions. While it takes time and practice to get used to concepts such as a ‚Äúdistributions over functions‚Äù, the actual mechanics of finding the GP predictive equations is actually quite simple ‚Äî making it easy to get practice to form an intuitive understanding of these concepts. 18.1.1 Summary
In typical machine learning, we specify a function with some free parameters (such as a neural network and its weights), and we focus on estimating those parameters, which
Gaussian Processes
808

may not be interpretable. With a Gaussian process, we instead reason about distributions over functions directly, which enables us to reason about the high-level properties of the solutions. These properties are controlled by a covariance function (kernel), which often has a few highly interpretable hyperparameters. These hyperparameters include the length- scale, whichcontrolshowrapidly(howwiggily)thefunctionsare. Anotherhyperparameter is the amplitude, which controls the vertical scale over which our functions are varying. Representing many different functions that can fit the data, and combining them all together into a predictive distribution, is a distinctive feature of Bayesian methods. Because there is a greater amount of variability between possible solutions far away from the data, our uncertainty intuitively grows as we move from the data. A Gaussian process represents a distribution over functions by specifying a multivariate normal (Gaussian) distribution over all possible function values. It is possible to easily manipulate Gaussian distributions to find the distribution of one function value based on the values of any set of other values. In other words, if we observe a set of points, then we can condition on these points and infer a distribution over what the value of the function might look like at any other input. How we model the correlations between these points is determined by the covariance function and is what defines the generalization properties of the Gaussian process. While it takes time to get used to Gaussian processes, they are easy to work with, have many applications, and help us understand and develop other model classes, like neural networks. 18.1.2 Exercises
1. What is the difference between epistemic uncertainty versus observation uncertainty? 2. Besides rate of variation and amplitude, what other properties of functions might we want to consider, and what would be real-world examples of functions that have those properties? 3. The RBF covariance function we considered says that covariances (and correlations) between observations decrease with their distance in the input space (times, spatial lo- cations, etc.). Is this a reasonable assumption?bubuWhy or why not?bubu4. Is a sum of two Gaussian variables Gaussian? Is a product of two Gaussian variables Gaussian? If (a,b) have a joint Gaussian distribution, is a|b (a given b) Gaussian? Is a Gaussian?bubu5. Repeat the exercise where we observe a data point at ùëì ‚Äûùë•1‚Äù = 1.2, but now suppose we
additionally observe ùëì ‚Äûùë•2‚Äù = 1.4. Let ùëò‚Äûùë•,ùë•1‚Äù = 0.9, and ùëò‚Äûùë•,ùë•2‚Äù = 0.8. Will we be more or less certain about the value of ùëì ‚Äûùë•‚Äù, than when we had only observed ùëì ‚Äûùë•1‚Äù? What is the mean and 95% credible set for our value of ùëì ‚Äûùë•‚Äù now? 6. Do you think increasing our estimate of observation noise would increase or decrease our estimate of the length-scale of the ground truth function? 7. As we move away from the data, suppose the uncertainty in our predictive distribution increases to a point, then stops increasing. Why might that happen? Gaussian Process Priors
809

Discussions259. 259
18.2 Gaussian Process Priors
ae
Understanding Gaussian processes (GPs) is important for reasoning about model construc- tion and generalization, and for achieving state-of-the-art performance in a variety of appli- cations, including active learning, and hyperparameter tuning in deep learning. GPs are ev- erywhere, and it is in our interests to know what they are and how we can use them. In this section, we introduce Gaussian process priors over functions. In the next notebook, we show how to use these priors to do posterior inference and make predictions. The next section can be viewed as ‚ÄúGPs in a nutshell‚Äù, quickly giving what you need to apply Gaussian processes in practice. import numpy as np from scipy.spatial import distance_matrix from d2l import torch as d2l
d2l.set_figsize()
18.2.1 Definition
A Gaussian process is defined as a collection of random variables, any finite number of which have a joint Gaussian distribution. If a function f(x) is a Gaussian process, with mean function m(x) and covariance function or kernel k(x, x‚Äô), f(x) ~ GP. (m, k), then any collection of function values queried at any collection of input points x (times, spatial lo- cations, image pixels, etc.), has a joint multivariate Gaussian distribution with mean vector jand covariance matrix K: f(x1),...,f(%n) ~ N(u, K), where yu; = E[f(x;)] = m(x;) and Kj; = Cov( f (xi), f(xj)) = k@i.x;). This definition may seem abstract and inaccessible, but Gaussian processes are in fact very simple objects. Any function
ùëì ‚Äûùë•‚Äù = ùë§>ùúô‚Äûùë•‚Äù = hùë§, ùúô‚Äûùë•‚Äùi,
(18.2.1)
with ùë§ drawn from a Gaussian (normal) distribution, and ùúô being any vector of basis func- tions, for example ùúô‚Äûùë•‚Äù = ‚Äû1,ùë•,ùë•2, ...,ùë•ùëë‚Äù>, is a Gaussian process. Moreover, any Gaus- sian process f(x) can be expressed in the form of equation (18.2.1). Let‚Äôs consider a few concrete examples, to begin getting acquainted with Gaussian processes, after which we can appreciate how simple and useful they really are. 18.2.2 A Simple Gaussian Process
Gaussian Processes
810

Suppose f(x) = wo + wix, and wo, wi ~ N(0, 1), with wo, w1,x all in one dimension. We can equivalently write this function as the inner product ùëì ‚Äûùë•‚Äù = ‚Äûùë§0, ùë§1‚Äù‚Äû1,ùë•‚Äù>. In (18.2.1) above, ùë§ = ‚Äûùë§0, ùë§1‚Äù> and ùúô‚Äûùë•‚Äù = ‚Äû1,ùë•‚Äù>. For any ùë•, ùëì ‚Äûùë•‚Äù is a sum of two Gaussian random variables. Since Gaussians are closed
under addition, ùëì ‚Äûùë•‚Äù is also a Gaussian random variable for any ùë•. In fact, we can compute for any particular ùë• that ùëì ‚Äûùë•‚Äù is N‚Äû0,1 ‚Äö ùë•2‚Äù. Similarly, the joint distribution for any col- lection of function values, ‚Äû ùëì ‚Äûùë•1‚Äù, . . ., ùëì ‚Äûùë•ùëõ‚Äù‚Äù, for any collection of inputs ùë•1, . . .,ùë•ùëõ, is a multivariate Gaussian distribution. Therefore ùëì ‚Äûùë•‚Äù is a Gaussian process. In short, ùëì ‚Äûùë•‚Äù is a random function, or a distribution over functions. We can gain some
insights into this distribution by repeatedly sampling values for ùë§0, ùë§1, and visualizing the corresponding functions ùëì ‚Äûùë•‚Äù, which are straight lines with slopes and different intercepts, as follows:
def lin_func(x, n_sample): preds = np.zeros((n_sample, x.shape[0])) for ii in range(n_sample): w = np.random.normal(0, 1, 2) y = w[0] + w[1] * x preds[ii, :] = y return preds x_points = np.linspace(-5, 5, 50) outs = lin_func(x_points, 10) lw_bd = -2 * np.sqrt((1 + x_points ** 2)) up_bd = 2 * np.sqrt((1 + x_points ** 2)) d2l.plt.fill_between(x_points, lw_bd, up_bd, alpha=0.25) d2l.plt.plot(x_points, np.zeros(len(x_points)), linewidth=4, color='black') d2l.plt.plot(x_points, outs.T) d2l.plt.xlabel("x", fontsize=20) d2l.plt.ylabel("f(x)", fontsize=20) d2l.plt.show()
10
If ùë§0 and ùë§1 are instead drawn from N‚Äû0,ùõº2‚Äù, how do you imagine varying ùõº affects the distribution over functions? 18.2.3 From Weight Space to Function Space
Gaussian Process Priors
811

In the plot above, we saw how a distribution over parameters in a model induces a distri- bution over functions. While we often have ideas about the functions we want to model ‚Äî whether they‚Äôre smooth, periodic, quickly varying, etc. ‚Äî it is relatively tedious to reason about the parameters, which are largely uninterpretable. Fortunately, Gaussian processes provide an easy mechanism to reason directly about functions. Since a Gaussian distribu- tion is entirely defined by its first two moments, its mean and covariance matrix, a Gaussian process by extension is defined by its mean function and covariance function. In the above example, the mean function
ùëö‚Äûùë•‚Äù = ùê∏¬ª ùëì ‚Äûùë•‚Äù‚Ä¶ = ùê∏¬ªùë§0 ‚Äö ùë§1ùë•‚Ä¶ = ùê∏¬ªùë§0‚Ä¶ ‚Äö ùê∏¬ªùë§1‚Ä¶ùë• = 0 ‚Äö 0 = 0. (18.2.2)
Similarly, the covariance function is
k(x,x‚Äô) = Cov( f(x), f(Q‚Äô)) = ELFf@)f¬£Q‚Äô)] - ELFO)IELFO‚Äô)] = Elwi + wow Xx‚Äô + wi wox + wixx‚Äô] =1l+xx‚Äô. (18.2.3)
Our distribution over functions can now be directly specified and sampled from, without needing to sample from the distribution over parameters. For example, to draw from ùëì ‚Äûùë•‚Äù, we can simplyform our multivariate Gaussian distribution associated with anycollection of ùë• we want to query, and sample from it directly. We will begin to see just how advantageous this formulation will be. First, we note that essentially the same derivation for the simple straight line model above can be applied to find the mean and covariance function for any model of the form f(x) = w' d(x), with w ~ N(u,S). In this case, the mean function m(x) = u' d(x), and the covariance function k(x, x‚Äô) = 6(x)'S¬¢(x‚Äô). Since ¬¢(x) can represent a vector of any non- linear basis functions, we are considering a very general model class, including models with an even an infinite number of parameters. 18.2.4 The Radial Basis Function (RBF) Kernel
The radial basis function (RBF) kernel is the most popular covariance function for Gaus- sian processes, and kernel machines in general. This kernel has the form kgpr(x,x‚Äô) = a‚Äô exp (-sbllx - IP), where a is an amplitude parameter, and @ is a lengthscale hyper- parameter. Let‚Äôs derive this kernel starting from weight space. Consider the function
J
J 2 2 o xX- Cj fQ) = 2, widi(x),wi ~N (0 =) ¬ª Pi(X) = exp (-*) . (18.2.4)
ùëì ‚Äûùë•‚Äù is a sum of radial basis functions, with width ‚Ñì, centred at the points ùëêùëñ, as shown in
the following figure. We can recognize ùëì ‚Äûùë•‚Äù as having the form ùë§>ùúô‚Äûùë•‚Äù, where ùë§ = ‚Äûùë§1, . . ., ùë§ùêΩ‚Äù> and ùúô‚Äûùë•‚Äù
is a vector containing each of the radial basis functions. The covariance function of this
Gaussian Processes
812

Gaussian process is then
ùëò‚Äûùë•,ùë•0‚Äù = ùúé2 ùêΩ ùëñ=1 ùúôùëñ‚Äûùë•‚Äùùúôùëñ‚Äûùë•0‚Äù. (18.2.5)
Now let‚Äôs consider what happens as we take the number of parameters (and basis functions) to infinity. Let cy = logJ, cy = ‚ÄîlogJ, and cj41 ‚Äî c; = Ac = geet and J ‚Äî oo. The covariance function becomes the Riemann sum:
JS
ùëò‚Äûùë•,ùë•0‚Äù = lim ùêΩ!1 ùúé2 ùêΩ ùëñ=1 ùúôùëñ‚Äûùë•‚Äùùúôùëñ‚Äûùë•0‚Äù = ùëê0 ùúôùëê‚Äûùë•‚Äùùúôùëê‚Äûùë•0‚Äùùëëùëê. (18.2.6)
By setting co = ‚Äî00 and Cc. = ¬©, we spread the infinitely many basis functions across the
whole real line, each a distance Œîùëê ! 0 apart:
‚Äû 1
(x= xy) aVa0)? co 2 , tna‚Äô) = [exw SoD exp HO Ode = Vito? exp(- 2a) (18.2.7) o kepp(x, x‚Äô).bubuIt is worth taking a moment to absorb what we have done here. By moving into the function space representation, we have derived how to represent a model with an infinite number of parameters, using a finite amount of computation. A Gaussian process with an RBF kernel is a universal approximator, capable of representing any continuous function to arbitrary precision. We can intuitively see why from the above derivation. We can collapse each radial basis function to a point mass taking ‚Ñì ! 0, and give each point mass any height we wish. So a Gaussian process with an RBF kernel is a model with an infinite number of param- eters and much more flexibility than any finite neural network. Perhaps all the fuss about overparametrized neural networks is misplaced. As we will see, GPs with RBF kernels do not overfit, and in fact provide especially compelling generalization performance on small datasets. Moreover, the examples in (Zhang et al., 2021), such as the ability to fit images with random labels perfectly, but still generalize well on structured problems, (can be perfectly reproduced using Gaussian processes) (Wilson and Izmailov, 2020). Neural networks are not as distinct as we make them out to be. We can build further intuition about Gaussian processes with RBF kernels, and hyperpa- rameters such as length-scale, by sampling directly from the distribution over functions. As before, this involves a simple procedure:
1.bubuChoose the input ùë• points we want to query the GP: ùë•1, . .bubu.,ùë•ùëõ.bubu2. Evaluate m(x;),i = 1,...,n, and k(x;,x;) for i,j = 1,...,n to respectively form the mean vector and covariance matrix 4 and K, where (f(x1),..., f(%n)) ~ N(u, K). 3. Sample from this multivariate Gaussian distribution to obtain the sample function val- ues. 4. Sample more times to visualize more sample functions queried at those points.bubuWe illustrate this process in the figure below. ‚Äû ùëê1
Gaussian Process Priors
813

def rbfkernel(x1, x2, ls=4.): #@save dist = distance_matrix(np.expand_dims(x1, 1), np.expand_dims(x2, 1)) return np.exp(-(1. / ls / 2) * (dist ** 2)) x_points = np.linspace(0, 5, 50) meanvec = np.zeros(len(x_points)) covmat = rbfkernel(x_points,x_points, 1)
prior_samples= np.random.multivariate_normal(meanvec, covmat, size=5); d2l.plt.plot(x_points, prior_samples.T, alpha=0.5) d2l.plt.show()

18.2.5 The Neural Network Kernel
Research on Gaussian processes in machine learning was triggered by research on neu- ral networks. Radford Neal was pursuing ever larger Bayesian neural networks, ultimately showing in 1994 (later published in 1996, as it was one of the most infamous NeurIPS rejections) that such networks with an infinite number of hidden units become Gaussian processes with particular kernel functions (Neal, 1996). Interest in this derivation has re- surfaced, with ideas like the neural tangent kernel being used to investigate the generaliza- tion properties of neural networks (Matthews et al., 2018) (Novak et al., 2018). We can derive the neural network kernel as follows. Consider a neural network function ùëì ‚Äûùë•‚Äù with one hidden layer:
ùëì ‚Äûùë•‚Äù = ùëè ‚Äö ùë£ùëñ‚Ñé‚Äûùë•;ùë¢ùëñ‚Äù. (18.2.8) ùëñ=1
ùëè is a bias, ùë£ùëñ are the hidden to output weights, ‚Ñé is any bounded hidden unit transfer
b is a bias, v; are the hidden to output weights, h is any bounded hidden unit transfer function, u; are the input to hidden weights, and J is the number of hidden units. Let b and v; be independent with zero mean and variances o; and o2/ J, respectively, and let the u; have independent identical distributions. We can then use the central limit theorem to show that any collection of function values f(x1),..., f(%n) has a joint multivariate Gaussian distribution. The mean and covariance function of the corresponding Gaussian process are:
ùëö‚Äûùë•‚Äù = ùê∏¬ª ùëì ‚Äûùë•‚Äù‚Ä¶ = 0
(18.2.9)
J
Gaussian Processes
814

ùëò‚Äûùë•,ùë•0‚Äù = cov¬ª ùëì ‚Äûùë•‚Äù, ùëì ‚Äûùë•0‚Äù‚Ä¶ = ùê∏¬ª ùëì ‚Äûùë•‚Äù ùëì ‚Äûùë•0‚Äù‚Ä¶ = ùúé2 ùëè ‚Äö 1 ùêΩ ùëñ=1 ùë£ùê∏¬ª‚Ñéùëñ‚Äûùë•;ùë¢ùëñ‚Äù‚Ñéùëñ‚Äûùë•0;ùë¢ùëñ‚Äù‚Ä¶ ùúé2
In some cases, we can essentially evaluate this covariance function in closed form. Let . P 2 Z 42 h(x;u) = erf(up + Yj-) ujx;), where erf(z) = va e' dt, andu ~ N(0,2). Then 2487S (14287 ER) (1425 k(x,x") = 2sin( =
The RBF kernel is stationary, meaning that it is translation invariant, and therefore can be written as a function of t = x ‚Äî x‚Äô. Intuitively, stationarity means that the high-level properties of the function, such as rate of variation, do not change as we move in input space. The neural network kernel, however, is non-stationary. Below, we show sample functions from a Gaussian process with this kernel. We can see that the function looks qualitatively different near the origin. 18.2.6 Summary
The first step in performing Bayesian inference involves specifying a prior. Gaussian pro- cesses can be used to specify a whole prior over functions. Starting from a traditional ‚Äúweight space‚Äù view of modelling, we can induce a prior over functions by starting with the functional form of a model, and introducing a distribution over its parameters. We can al- ternatively specify a prior distribution directly in function space, with properties controlled by a kernel. The function-space approach has many advantages. We can build models that actually correspond to an infinite number of parameters, but use a finite amount of com- putation! Moreover, while these models have a great amount of flexibility, they also make strong assumptions about what types of functions are a priori likely, leading to relatively good generalization on small datasets. Theassumptionsofmodelsinfunctionspaceareintuitivelycontrolledbykernels, whichof- ten encode higher level properties of functions, such as smoothness and periodicity. Many kernels are stationary, meaning that they are translation invariant. Functions drawn from a Gaussian process with a stationary kernel have roughly the same high-level properties (such as rate of variation) regardless of where we look in the input space. Gaussian processes are a relatively general model class, containing many examples of mod- els we are already familiar with, including polynomials, Fourier series, and so on, as long as we have a Gaussian prior over the parameters. They also include neural networks with an infinite number of parameters, even without Gaussian distributions over the parameters. This connection, discovered by Radford Neal, triggered machine learning researchers to move away from neural networks, and towards Gaussian processes. 18.2.7 Exercises
1. DrawsamplepriorfunctionsfromaGPwithanOrnstein-Uhlenbeck(OU)kernel, ùëòOU‚Äûùë•,ùë•0‚Äù =
1. Draw sample prior functions from a GP with an Ornstein-Uhlenbeck (OU) kernel, kou(x, x‚Äô) = exp (-sllx - x'|). If you fix the lengthscale f to be the same, how do these functions look different than sample functions from a GP with an RBF kernel? J
(18.2.10)
Gaussian Process Inference
815

2. How does changing the amplitude ùëé2 of the RBF kernel affect the distribution over functions? 3. Suppose we form u(x) = f(x)+2g(x), where f(x) ~ GP(m), k,) and g(x) ~ GP (my, k2). Is ùë¢‚Äûùë•‚Äù a Gaussian process, and if so, what is its mean and covariance function? 4. Suppose we form g(x) = a(x) f(x), where f(x) ~ GP(0,k) and a(x) = x?. Is g(x)
a Gaussian process, and if so, what is its mean and covariance function? What is the effect of ùëé‚Äûùë•‚Äù? What do sample functions drawn from ùëî‚Äûùë•‚Äù look like? 5. Suppose we form u(x) = f(x)g(x), where f(x) ~ GP(m, k1) and g(x) ~ GP (mo, kz). Is u(x) a Gaussian process, and if so, what is its mean and covariance function? Discussions? ,
260

18.3 Gaussian Process Inference
a
In this section, we will show how to perform posterior inference and make predictions using the GP priors we introduced in the last section. We will start with regression, where we can perform inference in closed form. This is a ‚ÄúGPs in a nutshell‚Äù section to quickly get up and running with Gaussian processes in practice. We‚Äôll start coding all the basic operations from scratch, and then introduce GPyTorch261, which will make working with state-of-the- art Gaussian processes and integration with deep neural networks much more convenient. We will consider these more advanced topics in depth in the next section. In that section, we will also consider settings where approximate inference is required ‚Äî classification, point processes, or any non-Gaussian likelihoods. 261 
18.3.1 Posterior Inference for Regression
An observation model relates the function we want to learn, ùë¶‚Äûùë•‚Äù, both indexed by some input ùë•. In classification, ùë• could be the pixels of an image, and ùë¶ could be the associated class label. In regression, ùë¶ typically represents a continuous output, such as a land surface temperature, a sea-level, a ùê∂ùëÇ2 concentration, etc. In regression, we often assume the outputs are given by a latent noise-free function ùëì ‚Äûùë•‚Äù
plus i.i.d. Gaussian noise ùúñ‚Äûùë•‚Äù:
ùë¶‚Äûùë•‚Äù = ùëì ‚Äûùë•‚Äù ‚Äö ùúñ‚Äûùë•‚Äù,
(18.3.1)
with e(x) ~ N(0,07). Let y = y(X) = (y(x1),...,¬•(Xn))7 be a vector of our training
observations, and f = ‚Äû ùëì ‚Äûùë•1‚Äù, . . ., ùëì ‚Äûùë•ùëõ‚Äù‚Äù> be a vector of the latent noise-free function values, queried at the training inputs ùëã = ùë•1, . .bubu.,ùë•ùëõ. We will assume f(x) ~ GP(m, k), which means that any collection of function values f
We will assume f(x) ~ GP(m, k), which means that any collection of function values f has a joint multivariate Gaussian distribution, with mean vector pz; = m(x;) and covariance matrix Kj; = k(x;,x;). The RBF kernel k(x;,x;) = a‚Äô exp (falls - xIP) would be a
ùëì ‚Äûùë•‚Äù, to our observations
2‚Ñì2
Gaussian Processes
816

standard choice of covariance function. For notational simplicity, we will assume the mean function ùëö‚Äûùë•‚Äù = 0; our derivations can easily be generalized later on. Suppose we want to make predictions at a set of inputs
Xx = Xa, X42,---,Xam-
(18.3.2)
Then we want to find x? and p(f,|y, X). In the regression setting, we can conveniently
Then we want to find x? and p(f,|y, X). In the regression setting, we can conveniently find this distribution by using Gaussian identities, after finding the joint distribution over f, = f(X,) andy. If we evaluate equation (18.3.1) at the training inputs ùëã, we have y = f ‚Äö Ô¨Ñ. By the
If we evaluate equation (18.3.1) at the training inputs X, we have y = f + ffl. By the definition of a Gaussian process (see last section), f ~ N(0, K(X, X)) where K(X, X) is an n X n matrix formed by evaluating our covariance function (aka kernel) at all possible pairs of inputs x;,x; ‚Ç¨ X. ff is simply a vector comprised of iid samples from N(0, a?) and thus has distribution N (0, 07/). y is therefore a sum of two independent multivariate Gaussian variables, and thus has distribution (0, K(X, X) + 071). One can also show that cov(f,, y) = cov(y, f.)' = K(X., X) where K(X,, X) is an m xX n matrix formed by evaluating the kernel at all pairs of test and training inputs. y _ [K(X,X) +071 K(X,X.) . fx] wfo.a=[SeO KO gs
We can then use standard Gaussian identities to find the conditional distribution from the joint distribution (see, e.g., Bishop Chapter 2), f.|y,X,X. ~ N(m.,S.), where m, = K(X,,X)[K(X, X)+o71] ly, and S = K(X., X.)‚ÄîK(X., X) [K(X, X)+o71]-' K(X, X.). Typically, we do not need to make use of the full predictive covariance matrix ùëÜ, and in-
Typically, we do not need to make use of the full predictive covariance matrix S, and in- stead use the diagonal of S for uncertainty about each prediction. Often for this reason we write the predictive distribution for a single test point x,, rather than a collection of test points. The kernel matrix has parameters ùúÉ that we also wish to estimate, such the amplitude ùëé and
The kernel matrix has parameters 6 that we also wish to estimate, such the amplitude a and lengthscale ‚Ç¨ of the RBF kernel above. For these purposes we use the marginal likelihood, p(y|@, X), which we already derived in working out the marginal distributions to find the joint distribution over y, f,. As we will see, the marginal likelihood compartmentalizes into model fit and model complexity terms, and automatically encodes a notion of Occam‚Äôs razor for learning hyperparameters. For a full discussion, see MacKay Ch.bubu28 (MacKay, 2003), and Rasmussen and Williams Ch.bubu5 (Rasmussen and Williams, 2006). import math import os import gpytorch import matplotlib.pyplot as plt import numpy as np import torch from scipy import optimize from scipy.spatial import distance_matrix from d2l import torch as d2l
d2l.set_figsize()
Gaussian Process Inference
817

18.3.2 Equations for Making Predictions and Learning Kernel
Hyperparameters in GP Regression
We list here the equations you will use for learning hyperparameters and making predictions in Gaussian process regression. Again, we assume a vector of regression targets y, indexed by inputs X = {x1,...,%,}, and we wish to make a prediction at a test input x,.bubuWe assume iid. additive zero-mean Gaussian noise with variance 77. We use a Gaussian process prior f(x) ~ GP(m, k) for the latent noise-free function, with mean function m and kernel function k. The kernel itself has parameters 6 that we want to learn. For example, if we use an RBF kernel, k(x;,x;) = a‚Äô exp (-sfalke ‚Äî x‚Äô||?), we want to learn @ = {a?, ¬£7}. Let K(X, X) represent an n X n matrix corresponding to evaluating the kernel for all possible pairs of n training inputs. Let K(x,.,X) represent a 1 x n vector formed by evaluating k(xs,x;), i = 1,...,n. Let pw be a mean vector formed by evaluating the mean function m(x) at every training points x. Typically in working with Gaussian processes, we follow a two-step procedure. 1. Learn kernel hyperparameters ÀÜùúÉ by maximizing the marginal likelihood with respect to these hy- perparameters. 2. Use the predictive mean as a point predictor, and 2 times the predictive standard deviation to form a 95% credible set, conditioning on these learned hyperparam- eters ÀÜùúÉ. The log marginal likelihood is simply a log Gaussian density, which has the form:
log p(yl@. X) = -5Y[Ko(X.X) tort} ty ; log|Ka(X,X)|+¬¢ (18.3.4)
The predictive distribution has the form:
P(yulXe, Y,9) = N (as, Vs) (18.3.5)
as = ko (xe, X)[Ko(X, X) +07 My -p) +p (18.3.6)
Va = ko(Xe,Xx) ‚Äî Ko (x2, X)[Ko(X, X) + 07 I]! kg (X, x.) (18.3.7)
18.3.3 Interpreting Equations for Learning and Predictions
There are some key points to note about the predictive distributions for Gaussian pro- cesses:
e Despite the flexibility of the model class, it is possible to do exact Bayesian inference for
GP regression in closed form. Aside from learning the kernel hyperparameters, there is no training. We can write down exactly what equations we want to use to make predictions. Gaussian processes are relatively exceptional in this respect, and it has greatly contributed to their convenience, versatility, and continued popularity. e The predictive mean a, is a linear combination of the training targets y, weighted by the
e The predictive mean a, is a linear combination of the training targets y, weighted by the kernel kg(x., X)[Ko(X, X)+07/]~!. As we will see, the kernel (and its hyperparam- eters) thus plays a crucial role in the generalization properties of the model. Gaussian Processes
818

e The predictive mean explicitly depends on the target values y but the predictive variance
e The predictive mean explicitly depends on the target values y but the predictive variance does not. The predictive uncertainty instead grows as the test input x, moves away from the target locations X, as governed by the kernel function. However, uncertainty will implicitly depend on the values of the targets y through the kernel hyperparameters 6, which are learned from the data. e The marginal likelihood compartmentalizes into model fit and model complexity (log
determinant) terms. The marginal likelihood tends to select for hyperparameters that provide the simplest fits that are still consistent with the data. e The key computational bottlenecks come from solving a linear system and computing a log determinant over an n X n symmetric positive definite matrix K(X, X) for n training points. Naively, these operations each incur O(n) computations, as well as O(n?) storage for each entry of the kernel (covariance) matrix, often starting with a Cholesky decomposition. Historically, these bottlenecks have limited GPs to problems with fewer than about 10,000 training points, and have given GPs a reputation for ‚Äúbeing slow‚Äù that has been inaccurate now for almost a decade. In advanced topics, we will discuss how GPs can be scaled to problems with millions of points. e For popular choices of kernel functions, K(X, X) is often close to singular, which can cause numerical issues when performing Cholesky decompositions or other opera- tions intended to solve linear systems. Fortunately, in regression we are often working with Kg(X, X) + oI, such that the noise variance a2 gets added to the diagonal of K(X, X), significantly improving its conditioning. If the noise variance is small, or we are doing noise free regression, it is common practice to add a small amount of ‚Äújitter‚Äù to the diagonal, on the order of 10~¬∞, to improve conditioning. 18.3.4 Worked Example from Scratch
Let‚Äôs create some regression data, and then fit the data with a GP, implementing every step from scratch. We‚Äôll sample data from
ùë¶‚Äûùë•‚Äù = sin‚Äûùë•‚Äù ‚Äö 1 2 sin‚Äû4ùë•‚Äù ‚Äö ùúñ, (18.3.8)
with e ~ N(0,c7). The noise free function we wish to find is f(x) = sin(x) + 5 sin(4x). We'll start by using a noise standard deviation 0 = 0.25. def data_maker1(x, sig): return np.sin(x) + 0.5 * np.sin(4 * x) + np.random.randn(x.shape[0]) * sig sig = 0.25 train_x, test_x = np.linspace(0, 5, 50), np.linspace(0, 5, 500) train_y, test_y = data_maker1(train_x, sig=sig), data_maker1(test_x, sig=0.) d2l.plt.scatter(train_x, train_y) d2l.plt.plot(test_x, test_y) d2l.plt.xlabel("x", fontsize=20) d2l.plt.ylabel("Observations y", fontsize=20) d2l.plt.show()
Gaussian Process Inference
819

Observations y
Here we see the noisy observations as circles, and the noise-free function in blue that we wish to find. Now, let‚Äôs specify a GP prior over the latent noise-free function, f(x) ~ GP(m, k). We'll
use a mean function ùëö‚Äûùë•‚Äù = 0, and an RBF covariance function (kernel)
1 al -¬•1F} . (18.3.9) k(xj,xj) = a‚Äô exp (-
mean = np.zeros(test_x.shape[0]) cov = d2l.rbfkernel(test_x, test_x, ls=0.2)
We have started with a length-scale of 0.2. Before we fit the data, it is important to consider whether we have specified a reasonable prior. Let‚Äôs visualize some sample functions from this prior, as well as the 95% credible set (we believe there‚Äôs a 95% chance that the true function is within this region). prior_samples = np.random.multivariate_normal(mean=mean, cov=cov, size=5) d2l.plt.plot(test_x, prior_samples.T, color='black', alpha=0.5) d2l.plt.plot(test_x, mean, linewidth=2.) d2l.plt.fill_between(test_x, mean - 2 * np.diag(cov), mean + 2 * np.diag(cov), alpha=0.25) d2l.plt.show()

Do these samples look reasonable? Are the high-level properties of the functions aligned with the type of data we are trying to model? Nowlet‚Äôsformthemeanandvarianceoftheposteriorpredictivedistributionatanyarbitrary
Gaussian Processes
820

test point x,. fe = K(x,.x4)" (K(x, x) +0? Dl y (18.3.10)
V( fs) = K(%0,X4) ‚Äî K(x,4)7 (K(x, x) + 07D) K(x, x4) (18.3.11)
Before we make predictions, we should learn our kernel hyperparameters ùúÉ and noise vari-
ance ùúé2. Let‚Äôs initialize our length-scale at 0.75, as our prior functions looked too quickly varying compared to the data we are fitting. We‚Äôll also guess a noise standard deviation ùúé of 0.75. In order to learn these parameters, we will maximize the marginal likelihood with respect to these parameters. log ùëù‚Äûùë¶jùëã‚Äù = log ùëù‚Äûùë¶j ùëì, ùëã‚Äùùëù‚Äû ùëì jùëã‚Äùùëëùëì (18.3.12)
1 1 log p(y|X) = 5" (Ke) +071 ly- 3 log |K(x,x) +071 - 5 log 2n (18.3.13)
Perhaps our prior functions were too quickly varying. Let‚Äôs guess a length-scale of 0.4. We‚Äôll also guess a noise standard deviation of 0.75. These are simply hyperparameter ini- tializations ‚Äî we will learn these parameters from the marginal likelihood. ell_est = 0.4 post_sig_est = 0.5 def neg_MLL(pars): K = d2l.rbfkernel(train_x, train_x, ls=pars[0]) kernel_term = -0.5 * train_y @ \ np.linalg.inv(K + pars[1] ** 2 * np.eye(train_x.shape[0])) @ train_y logdet = -0.5 * np.log(np.linalg.det(K + pars[1] ** 2 * \ np.eye(train_x.shape[0]))) const = -train_x.shape[0] / 2. * np.log(2 * np.pi) return -(kernel_term + logdet + const) learned_hypers = optimize.minimize(neg_MLL, x0=np.array([ell_est,post_sig_ ‚Ü©!est]), bounds=((0.01, 10.), (0.01, 10.))) ell = learned_hypers.x[0] post_sig_est = learned_hypers.x[1]
In this instance, we learn a length-scale of 0.299, and a noise standard deviation of 0.24. Note that the learned noise is extremely close to the true noise, which helps indicate that our GP is a very well-specified to this problem. In general, it is crucial to put careful thought into selecting the kernel and initializing the hyperparameters. While marginal likelihood optimization can be relatively robust to ini- tialization, it is not immune to poor initializations. Try running the above script with a variety of initializations and see what results you find. Now, let‚Äôs make predictions with these learned hypers. ‚Äû
Gaussian Process Inference
821

K_x_xstar = d2l.rbfkernel(train_x, test_x, ls=ell) K_x_x = d2l.rbfkernel(train_x, train_x, ls=ell) K_xstar_xstar = d2l.rbfkernel(test_x, test_x, ls=ell) post_mean = K_x_xstar.T @ np.linalg.inv((K_x_x + \ post_sig_est ** 2 * np.eye(train_x.shape[0]))) @ train_y post_cov = K_xstar_xstar - K_x_xstar.T @ np.linalg.inv((K_x_x + \ post_sig_est ** 2 * np.eye(train_x.shape[0]))) @ K_x_xstar lw_bd = post_mean - 2 * np.sqrt(np.diag(post_cov)) up_bd = post_mean + 2 * np.sqrt(np.diag(post_cov)) d2l.plt.scatter(train_x, train_y) d2l.plt.plot(test_x, test_y, linewidth=2.) d2l.plt.plot(test_x, post_mean, linewidth=2.) d2l.plt.fill_between(test_x, lw_bd, up_bd, alpha=0.25) d2l.plt.legend(['Observed Data', 'True Function', 'Predictive Mean', '95% Set‚ê£ ‚Ü©!on True Func']) d2l.plt.show()
@ Observed Data ‚Äî‚Äî True Function ‚Äî‚Äî Predictive Mean 95% Set on True Func % i) 1 2 3 4 5
We see the posterior mean in orange almost perfectly matches the true noise free function! Note that the 95% credible set we are showing is for the latent noise free (true) function, and not the data points. We see that this credible set entirely contains the true function, and does not seem overly wide or narrow. We would not want nor expect it to contain the data points. If we wish to have a credible set for the observations, we should compute
lw_bd_observed = post_mean - 2 * np.sqrt(np.diag(post_cov) + post_sig_est ** 2) up_bd_observed = post_mean + 2 * np.sqrt(np.diag(post_cov) + post_sig_est ** 2)
There are two sources of uncertainty, epistemic uncertainty, representing reducible uncer- tainty, and aleatoric or irreducible uncertainty. The epistemic uncertainty here represents uncertainty about the true values of the noise free function. This uncertainty should grow as we move away from the data points, as away from the data there are a greater variety of function values consistent with our data. As we observe more and more data, our beliefs about the true function become more confident, and the epistemic uncertainty disappears. The aleatoric uncertainty in this instance is the observation noise, since the data are given to us with this noise, and it cannot be reduced. Theepistemicuncertaintyinthedataiscapturedbyvarianceofthelatentnoisefreefunction np.diag(post_cov). Thealeatoricuncertaintyiscapturedbythenoisevariancepost_sig_est**2. Gaussian Processes
822

Unfortunately, people are often careless about how they represent uncertainty, with many papers showing error bars that are completely undefined, no clear sense of whether we are visualizing epistemic or aleatoric uncertainty or both, and confusing noise variances with noise standard deviations, standard deviations with standard errors, confidence intervals with credible sets, and so on. Without being precise about what the uncertainty represents, it is essentially meaningless. In the spirit of playing close attention to what our uncertainty represents, it is crucial to note that we are taking two times the square root of our variance estimate for the noise free function. Since our predictive distribution is Gaussian, this quantity enables us to form a 95% credible set, representing our beliefs about the interval which is 95% likely to contain the ground truth function. The noise variance is living on a completely different scale, and is much less interpretable. Finally, let‚Äôs take a look at 20 posterior samples. These samples tell us what types of functions we believe might fit our data, a posteriori. post_samples = np.random.multivariate_normal(post_mean, post_cov, size=20) d2l.plt.scatter(train_x, train_y) d2l.plt.plot(test_x, test_y, linewidth=2.) d2l.plt.plot(test_x, post_mean, linewidth=2.) d2l.plt.plot(test_x, post_samples.T, color='gray', alpha=0.25) d2l.plt.fill_between(test_x, lw_bd, up_bd, alpha=0.25) plt.legend(['Observed Data', 'True Function', 'Predictive Mean', 'Posterior‚ê£ ‚Ü©!Samples']) d2l.plt.show()
@ Observed Data ‚Äî‚Äî True Function ‚Äî‚Äî Predictive Mean Posterior Samples 0 1 2 3 4 5
In basic regression applications, it is most common to use the posterior predictive mean and standard deviation as a point predictor and metric for uncertainty, respectively. more advanced applications, such as Bayesian optimization with Monte Carlo acquisition functions, or Gaussian processes for model-based RL, it often necessary to take posterior samples. However, even if not strictly required in the basic applications, these samples give us more intuition about the fit we have for the data, and are often useful to include in visualizations. In
18.3.5 Making Life Easy with GPyTorch
As we have seen, it is actually pretty easy to implement basic Gaussian process regres- sion entirely from scratch. However, as soon as we want to explore a variety of kernel
Gaussian Process Inference
823

choices, consider approximate inference (which is needed even for classification), combine GPs with neural networks, or even have a dataset larger than about 10,000 points, then an implementation from scratch becomes unwieldy and cumbersome. Some of the most effec- tive methods for scalable GP inference, such as SKI (also known as KISS-GP), can require hundredsoflinesofcodeimplementingadvancednumericallinearalgebraroutines. In these cases, the GPyTorch library will make our lives a lot easier. We‚Äôll be discussing GPyTorch more in future notebooks on Gaussian process numerics, and advanced methods. The GPyTorch library contains many examples262. To get a feel for the package, we will walkthroughthesimpleregressionexample263,showinghowitcanbeadaptedtoreproduce our above results using GPyTorch. This may seem like a lot of code to simply reproduce the basicregressionabove, andinasense, itis. Butwecanimmediatelyuseavarietyofkernels, scalable inference techniques, and approximate inference, by only changing a few lines of code from below, instead of writing potentially thousands of lines of new code. 262
263
# First let's convert our data into tensors for use with PyTorch train_x = torch.tensor(train_x) train_y = torch.tensor(train_y) test_y = torch.tensor(test_y) # We are using exact GP inference with a zero mean and RBF kernel class ExactGPModel(gpytorch.models.ExactGP): def __init__(self, train_x, train_y, likelihood): super(ExactGPModel, self).__init__(train_x, train_y, likelihood) self.mean_module = gpytorch.means.ZeroMean() self.covar_module = gpytorch.kernels.ScaleKernel( gpytorch.kernels.RBFKernel()) def forward(self, x): mean_x = self.mean_module(x) covar_x = self.covar_module(x) return gpytorch.distributions.MultivariateNormal(mean_x, covar_x)
This code block puts the data in the right format for GPyTorch, and specifies that we are using exact inference, as well the mean function (zero) and kernel function (RBF) that we want to use. We can use any other kernel very easily, by calling, for instance, gpy- torch.kernels.matern_kernel(), or gpyotrch.kernels.spectral_mixture_kernel(). So far, we have only discussed exact inference, where it is possible to infer a predictive distribution without making any approximations. For Gaussian processes, we can only perform exact inference when we have a Gaussian likelihood; more specifically, when we assume that our observations are generated as a noise-free function represented by a Gaussian process, plus Gaussian noise. In future notebooks, we will consider other settings, such as classification, where we cannot make these assumptions. # Initialize Gaussian likelihood likelihood = gpytorch.likelihoods.GaussianLikelihood() model = ExactGPModel(train_x, train_y, likelihood) training_iter = 50 # Find optimal model hyperparameters
(continues on next page)
Gaussian Processes
824

model.train() likelihood.train() # Use the adam optimizer, includes GaussianLikelihood parameters optimizer = torch.optim.Adam(model.parameters(), lr=0.1) # Set our loss as the negative log GP marginal likelihood mll = gpytorch.mlls.ExactMarginalLogLikelihood(likelihood, model)
Here, we explicitly specify the likelihood we want to use (Gaussian), the objective we will use for training kernel hyperparameters (here, the marginal likelihood), and the procedure we we want to use for optimizing that objective (in this case, Adam). We note that while we are using Adam, which is a ‚Äústochastic‚Äù optimizer, in this case, it is full-batch Adam. Because the marginal likelihood does not factorize over data instances, we cannot use an optimizer over ‚Äúmini-batches‚Äù of data and be guaranteed convergence. Other optimizers, such as L-BFGS, are also supported by GPyTorch. Unlike in standard deep learning, doing a good job of optimizing the marginal likelihood corresponds strongly with good general- ization, which often inclines us towards powerful optimizers like L-BFGS, assuming they are not prohibitively expensive. are not prohibitively expensive. for i in range(training_iter): # Zero gradients from previous iteration optimizer.zero_grad() # Output from model output = model(train_x) # Calc loss and backprop gradients loss = -mll(output, train_y) loss.backward() if i % 10 == 0: print(f'Iter {i+1:d}/{training_iter:d} - Loss: {loss.item():.3f} ' f'squared lengthscale: ' f'{model.covar_module.base_kernel.lengthscale.item():.3f} ' f'noise variance: {model.likelihood.noise.item():.3f}') optimizer.step()
Iter 1/50 - Loss: 1.000 squared lengthscale: 0.693 noise variance: 0.693 Iter 11/50 - Loss: 0.711 squared lengthscale: 0.490 noise variance: 0.312 Iter 21/50 - Loss: 0.451 squared lengthscale: 0.506 noise variance: 0.127 Iter 31/50 - Loss: 0.330 squared lengthscale: 0.485 noise variance: 0.055 Iter 41/50 - Loss: 0.344 squared lengthscale: 0.472 noise variance: 0.038
Here we actually run the optimization procedure, outputting the values of the loss every 10 iterations. # Get into evaluation (predictive posterior) mode test_x = torch.tensor(test_x) model.eval() likelihood.eval() observed_pred = likelihood(model(test_x))
The above codeblock enables us to make predictions on our test inputs. (continued from previous page)
Gaussian Process Inference
825

with torch.no_grad(): # Initialize plot f, ax = d2l.plt.subplots(1, 1, figsize=(4, 3)) # Get upper and lower bounds for 95\% credible set (in this case, in # observation space) lower, upper = observed_pred.confidence_region() ax.scatter(train_x.numpy(), train_y.numpy()) ax.plot(test_x.numpy(), test_y.numpy(), linewidth=2.) ax.plot(test_x.numpy(), observed_pred.mean.numpy(), linewidth=2.) ax.fill_between(test_x.numpy(), lower.numpy(), upper.numpy(), alpha=0.25) ax.set_ylim([-1.5, 1.5]) ax.legend(['True Function', 'Predictive Mean', 'Observed Data', '95% Credible Set'])
1.5 1.0 0.5 0.0 @ = = True Function ‚Äî‚Äî Predictive Mean ¬Æ ~1.0 | ‚Äî‚Äî Observed Data 95% Credible Set -0.5 -15 0 1 2 3 4 5
Finally, we plot the fit. We see the fits are virtually identical. A few things to note: GPyTorch is working with squared length-scales and observation noise. For example, our learned noise standard de- viation in the for scratch code is about 0.283. The noise variance found by GPyTorch is 0.81 ~ 0.2837. In the GPyTorch plot, we also show the credible set in the observation space rather than the latent function space, to demonstrate that they indeed cover the ob- served datapoints. 18.3.6 Summary
We can combine a Gaussian process prior with data to form a posterior, which we use to make predictions. We can also form a marginal likelihood, which is useful for automatic learning of kernel hyperparameters, which control properties such as the rate of variation of the Gaussian process. The mechanics of forming the posterior and learning kernel hyperpa- rameters for regression are simple, involving about a dozen lines of code. This notebook is a good reference for any reader wanting to quickly get ‚Äúup and running‚Äù with Gaussian pro- cesses. We also introduced the GPyTorch library. Although the GPyTorch code for basic regression is relatively long, it can be trivially modified for other kernel functions, or more advanced functionality we will discuss in future notebooks, such as scalable inference, or non-Gaussian likelihoods for classification. 18.3.7 Exercises
Gaussian Processes
826

1. We have emphasized the importance of learning kernel hyperparameters, and the effect of hyperparameters and kernels on the generalization properties of Gaussian processes. Try skipping the step where we learn hypers, and instead guess a variety of length-scales and noise variances, and check their effect on predictions. What happens when you use a large length-scale? A small length-scale? A large noise variance? A small noise variance? 2. We have said that the marginal likelihood is not a convex objective, but that hyperpa- rameters like length-scale and noise variance can be reliably estimated in GP regression. Thisisgenerallytrue‚Äîinfact, themarginallikelihoodismuchbetteratlearninglength- scale hyperparameters than conventional approaches in spatial statistics, which involve fitting empirical autocorrelation functions (‚Äúcovariograms‚Äù). Arguably, the biggest con- tributionfrommachinelearningtoGaussianprocessresearch,atleastbeforerecentwork on scalable inference, was the introduction of the marginal lkelihood for hyperparameter learning. However, different pairings of even these parameters provide interpretably different plau- sible explanations for many datasets, leading to local optima in our objective. If we use a large length-scale, then we assume the true underlying function is slowly varying. If the observed data are varying significantly, then the only we can plausibly have a large length- scale is with a large noise-variance. If we use a small length-scale, on the other hand, our fit will be very sensitive to the variations in the data, leaving little room to explain variations with noise (aleatoric uncertainty). Try seeing if you can find these local optima: initialize with very large length-scale with large noise, and small length-scales with small noise. Do you converge to different solu- tions?bubu3. We have said that a fundamental advantage of Bayesian methods is in naturally repre- senting epistemic uncertainty. In the above example, we cannot fully see the effects of epistemic uncertainty. Try instead to predict with test_x = np.linspace(0, 10, 1000). What happens to the 95% credible set as your predictions move beyond the data? Does it cover the true function in that interval? What happens if you only visual- ize aleatoric uncertainty in that region? 4. Try running the above example, but instead with 10,000, 20,000 and 40,000 training points, and measure the runtimes. How does the training time scale? Alternatively, how do the runtimes scale with the number of test points? Is it different for the predictive mean and the predictive variance? Answer this question both by theoretically working out the training and testing time complexities, and by running the code above with a different number of points.bubu5. Try running the GPyTorch example with different covariance functions, such as the Matern kernel. How do the results change? How about the spectral mixture kernel, found in the GPyTorch library? Are some easier to train the marginal likelihood than others? Are some more valuable for long-range versus short-range predictions? 6. In our GPyTorch example, we plotted the predictive distribution including observation
Gaussian Process Inference
827

noise, while in our ‚Äúfrom scratch‚Äù example, we only included epistemic uncertainty. Re-do the GPyTorch example, but this time only plotting epistemic uncertainty, and compare to the from-scratch results. Do the predictive distributions now look the same?bubu(They should.)
Discussions264. 264
19  Hyperparameter Optimization 
Aaron Klein (Amazon), Matthias Seeger (Amazon), and Cedric Archambeau (Ama- zon)
The performance of every machine learning model depends on its hyperparameters. They control the learning algorithm or the structure of the underlying statistical model. However, there is no general way to choose hyperparameters in practice. Instead, hyperparameters are often set in a trial-and-error manner or sometimes left to their default values by practi- tioners, leading to suboptimal generalization. Hyperparameter optimization provides a systematic approach to this problem, by casting it as an optimization problem: a good set of hyperparameters should (at least) minimize a validation error. Compared to most other optimization problems arising in machine learn- ing, hyperparameter optimization is a nested one, where each iteration requires training and validating a machine learning model. In this chapter, we will first introduce the basics of hyperparameter optimization. We will also present some recent advancements that improve the overall efficiency of hyperparame- ter optimization by exploiting cheap-to-evaluate proxies of the original objective function. At the end of this chapter, you should be able to apply state-of-the-art hyperparameter optimization techniques to optimize the hyperparameter of your own machine learning al- gorithm. 19.1 What Is Hyperparameter Optimization? ee
As we have seen in the previous chapters, deep neural networks come with a large number of parameters or weights that are learned during training. On top of these, every neural net- work has additional hyperparameters that need to be configured by the user. For example, to ensure that stochastic gradient descent converges to a local optimum of the training loss (see Chapter 12), we have to adjust the learning rate and batch size. To avoid overfitting on training datasets, we might have to set regularization parameters, such as weight decay (see Section 3.7) or dropout (see Section 5.6). We can define the capacity and inductive bias of the model by setting the number of layers and number of units or filters per layer (i.e., the effective number of weights). 828
What Is Hyperparameter Optimization? 829

Unfortunately, we cannot simply adjust these hyperparameters by minimizing the training loss, because this would lead to overfitting on the training data. For example, setting reg- ularization parameters, such as dropout or weight decay to zero leads to a small training loss, but might hurt the generalization performance. ‚ÄòSet Hyperparameters Loop until validation performance is maximised Evaluate
tFig. 19.1.1
Typical workÔ¨Çow in machine learning that consists of training the model multiple times with different hyperparameters. Without a different form of automation, hyperparameters have to be set manually in a trial- and-error fashion, in what amounts to a time-consuming and difficult part of machine learn- ing workflows. For example, consider training a ResNet (see Section 8.6) on CIFAR-10, which requires more than 2 hours on an Amazon Elastic Cloud Compute (EC2) g4dn. xlarge instance. Even just trying ten hyperparameter configurations in sequence, this would already take us roughly one day. To make matters worse, hyperparameters are usu- ally not directly transferable across architectures and datasets (Bardenet et al., 2013, Feurer et al., 2022, Wistuba et al., 2018), and need to be re-optimized for every new task. Also, for most hyperparameters, there are no rule-of-thumbs, and expert knowledge is required to find sensible values. Hyperparameter optimization (HPO) algorithms are designed to tackle this problem in a principled and automated fashion (Feurer and Hutter, 2018), by framing it as a global op- timization problem. The default objective is the error on a hold-out validation dataset, but could in principle be any other business metric. It can be combined with or constrained by secondary objectives, such as training time, inference time, or model complexity. Recently, hyperparameter optimization has been extended to neural architecture search (NAS) (Elsken et al., 2018, Wistuba et al., 2019), where the goal is to find entirely new neural network architectures. Compared to classical HPO, NAS is even more expensive in terms of computation and requires additional efforts to remain feasible in practice. Both, HPO and NAS can be considered as sub-fields of AutoML (Hutter et al., 2019), which aims to automate the entire ML pipeline. In this section we will introduce HPO and show how we can automatically find the best hyperparameters of the logistic regression example introduced in Section 4.5. 19.1.1 The Optimization Problem
We will start with a simple toy problem: searching for the learning rate of the multi-class logistic regression model SoftmaxRegression from Section 4.5 to minimize the validation
Hyperparameter Optimization
830

error on the Fashion MNIST dataset. While other hyperparameters like batch size or num-
ber of epochs are also worth tuning, we focus on learning rate alone for simplicity. import numpy as np import torch from scipy import stats from torch import nn from d2l import torch as d2l
Before we can run HPO, we first need to define two ingredients: the objective function and the configuration space. The Objective Function
The performance of a learning algorithm can be seen as a function ùëì : X ! R that maps
from the hyperparameter space x 2 X to the validation loss. For every evaluation of ùëì ‚Äûx‚Äù, we have to train and validate our machine learning model, which can be time and compute intensive in the case of deep neural networks trained on large datasets. Given our criterion ùëì ‚Äûx‚Äù our goal is to find x‚òÖ 2 argminx2X ùëì ‚Äûx‚Äù. Thereisnosimplewaytocomputegradientsof ùëì withrespecttox, becauseitwouldrequire
to propagate the gradient through the entire training process. While there is recent work (Franceschi et al., 2017, Maclaurin et al., 2015) to drive HPO by approximate ‚Äúhypergradi- ents‚Äù, none of the existing approaches are competitive with the state-of-the-art yet, and we will not discuss them here. Furthermore, the computational burden of evaluating ùëì requires HPO algorithms to approach the global optimum with as few samples as possible. The training of neural networks is stochastic (e.g., weights are randomly initialized, mini- batches are randomly sampled), so that our observations will be noisy: y ~ f(x) +e, where we usually assume that the e ~ N(0, a) observation noise is Gaussian distributed. Faced with all these challenges, we usually try to identify a small set of well performing hyperparameter configurations quickly, instead of hitting the global optima exactly. How- ever, due to large computational demands of most neural networks models, even this can take days or weeks of compute. We will explore in Section 19.4 how we can speed-up the optimization process by either distributing the search or using cheaper-to-evaluate approx- imations of the objective function. We begin with a method for computing the validation error of a model. class HPOTrainer(d2l.Trainer): #@save def validation_error(self): self.model.eval() accuracy = 0 val_batch_idx = 0 for batch in self.val_dataloader: with torch.no_grad(): x, y = self.prepare_batch(batch) y_hat = self.model(x)
(continues on next page)
What Is Hyperparameter Optimization? 831

accuracy += self.model.accuracy(y_hat, y) val_batch_idx += 1 return 1 - accuracy / val_batch_idx
We optimize validation error with respect to the hyperparameter configuration config, consisting of the learning_rate. For each evaluation, we train our model for max_epochs epochs, then compute and return its validation error:
def hpo_objective_softmax_classification(config, max_epochs=8): learning_rate = config["learning_rate"] trainer = d2l.HPOTrainer(max_epochs=max_epochs) data = d2l.FashionMNIST(batch_size=16) model = d2l.SoftmaxRegression(num_outputs=10, lr=learning_rate) trainer.fit(model=model, data=data) return trainer.validation_error().detach().numpy()
The Configuration Space
Along with the objective function ùëì ‚Äûx‚Äù, we also need to define the feasible set x 2 X to
optimize over, known as configuration space or search space. For our logistic regression example, we will use:
config_space = {"learning_rate": stats.loguniform(1e-4, 1)}
Here we use the use the loguniform object from SciPy, which represents a uniform distri- bution between -4 and -1 in the logarithmic space. This object allows us to sample random variables from this distribution. Each hyperparameter has a data type, such as float for learning_rate, as well as a closed bounded range (i.e., lower and upper bounds). We usually assign a prior distribution (e.g, uniformorlog-uniform)toeachhyperparametertosamplefrom. Somepositiveparameters, such as learning_rate, are best represented on a logarithmic scale as optimal values can differ by several orders of magnitude, while others, such as momentum, come with linear scale. Below we show a simple example of a configuration space consisting of typical hyperpa- rameters of a multi-layer perceptron including their type and standard ranges. : Example configuration space of multi-layer perceptron
Table 19.1.1: label:tab_example_configspace
(continued from previous page)
Hyperparameter Optimization
832

Name Type Hyperparameter log-scale Ranges learning rate float :math:‚Äò [10‚Äú{- | yes 6},10*{-1}]* batch size integer [8, 256] yes momentum float [0, 0.99] no activation function | categorical mat e h:{textrm{tanh} , textrm{relu} } number of units integer [32, 1024] yes number of layers integer [1,6] no
In general, the structure of the configuration space X can be complex and it can be quite
different from Rùëë. In practice, some hyperparameters may depend on the value of others. For example, assume we try to tune the number of layers for a multi-layer perceptron, and for each layer the number of units. The number of units of the ùëô-th layer is relevant only if the network has at least ùëô ‚Äö 1 layers. These advanced HPO problems are beyond the scope of this chapter. We refer the interested reader to (Baptista and Poloczek, 2018, Hutter et al., 2011, Jenatton et al., 2017). The configuration space plays an important role for hyperparameter optimization, since no algorithms can find something that is not included in the configuration space. On the other hand, if the ranges are too large, the computation budget to find well performing configurations might become infeasible. 19.1.2 Random Search
Random search is the first hyperparameter optimization algorithm we will consider. The main idea of random search is to independently sample from the configuration space until a predefined budget (e.g maximum number of iterations) is exhausted, and to return the best observed configuration. All evaluations can be executed independently in parallel (see Section 19.3), but here we use a sequential loop for simplicity. errors, values = [], [] num_iterations = 5 for i in range(num_iterations): learning_rate = config_space["learning_rate"].rvs() print(f"Trial {i}: learning_rate = {learning_rate}") y = hpo_objective_softmax_classification({"learning_rate": learning_rate}) print(f" validation_error = {y}") values.append(learning_rate) errors.append(y)
validation_error = 0.17070001363754272
The best learning rate is then simply the one with the lowest validation error. 19.1 What Is Hyperparameter Optimization? 833

1.75 1.50 1.25 1.00 0.75 ‚Äî train_loss ‚Äî-- val_loss ‚Äî-- val_ace 0 2 4 6 8 epoch
1.0 09 0.8 0.7 0.6 05 o ‚Äî ‚Äòtrain_loss =-- val_loss ‚Äî-- val_acc
08 0.7 0.6 0.5 04 ‚Äî train loss === val_loss ‚Äî-- val_acc ness, SS. ran Seeeee‚Äù NY 2 4 6 8 epoch
08 07 0.6 05 a 2 Fal ‚Äî train_loss i\ === val_loss / Ul \ ‚Äî-- val_ace ‚Äò ‚Äò iN Oo 2 4 6 8
Hyperparameter Optimization
834

2.5 \ ‚Äî‚Äî train_loss \ --- valloss 2.0 \ ‚Äî- val_acce ‚Äò \ 15 \ See ‚Äúy 1.0 ~~ ono eee: - - 0 2 4 6 8 epoch
best_idx = np.argmin(errors) print(f"optimal learning rate = {values[best_idx]}")
optimal learning rate = 0.09844872561810249
Due to its simplicity and generality, random search is one of the most frequently used HPO algorithms. It does not require any sophisticated implementation and can be applied to any configuration space as long as we can define some probability distribution for each hyperparameter. Unfortunately random search also comes with a few shortcomings. First, it does not adapt the sampling distribution based on the previous observations it collected so far. Hence, it is equally likely to sample a poorly performing configuration than a better performing configuration. Second, the same amount of resources are spent for all configurations, even thoughsomemayshowpoorinitialperformanceandarelesslikelytooutperformpreviously seen configurations. In the next sections we will look at more sample efficient hyperparameter optimization algorithms that overcome the shortcomings of random search by using a model to guide the search. We will also look at algorithms that automatically stop the evaluation process of poorly performing configurations to speed up the optimization process. 19.1.3 Summary
In this section we introduced hyperparameter optimization (HPO) and how we can phrase it as a global optimization by defining a configuration space and an objective function. We also implemented our first HPO algorithm, random search, and applied it on a simple softmax classification problem. While random search is very simple, it is the better alternative to grid search, which simply evaluates a fixed set of hyperparameters. Random search somewhat mitigates the curse of dimensionality (Bellman, 1966), and can be far more efficient than grid search if the criterion most strongly depends on a small subset of the hyperparameters. 19.1.4 Exercises
What Is Hyperparameter Optimization?bubu835

1. In this chapter, we optimize the validation error of a model after training on a disjoint training set. For simplicity, our code uses Trainer.val_dataloader, which maps to a loader around FashionMNIST.val. 1. Convince yourself (by looking at the code) that this means we use the original Fash- ionMNIST training set (60000 examples) for training, and the original test set (10000 examples) for validation. 2. Why could this practice be problematic? Hint: Re-read Section 3.6, especially about model selection. 3.bubuWhat should we have done instead?bubu2. Westatedabovethathyperparameteroptimizationbygradientdescentisveryhardtodo. Considerasmallproblem, suchastrainingatwo-layerperceptronontheFashionMNIST dataset (Section 5.2) with a batch size of 256. We would like to tune the learning rate of SGD in order to minimize a validation metric after one epoch of training. 1. Why cannot we use validation error for this purpose? What metric on the validation set would you use?bubu2. Sketch (roughly) the computational graph of the validation metric after training for one epoch. You may assume that initial weights and hyperparameters (such as learn- ing rate) are input nodes to this graph. Hint: Re-read about computational graphs in Section 5.3.bubu3. Give a rough estimate of the number of floating point values you need to store during a forward pass on this graph. Hint: FashionMNIST has 60000 cases. Assume the required memory is dominated by the activations after each layer, and look up the layer widths in Section 5.2. 4. Apart from the sheer amount of compute and storage required, what other issues would gradient-based hyperparameter optimization run into? Hint: Re-read about vanishing and exploding gradients in Section 5.4. 5. Advanced: Read (Maclaurin et al., 2015) for an elegant (yet still somewhat unprac- tical) approach to gradient-based HPO. 3. Grid search is another HPO baseline, where we define an equi-spaced grid for each hy- perparameter, then iterate over the (combinatorial) Cartesian product in order to suggest configurations. 1. We stated above that random search can be much more efficient than grid search for HPO on a sizable number of hyperparameters, if the criterion most strongly depends on a small subset of the hyperparameters. Why is this?bubuHint: Read (Bergstra et al., 2011).bubu265
Discussions265. Hyperparameter Optimization
836

19.2 Hyperparameter Optimization API
a
Before we dive into the methodology, we will first discuss a basic code structure that al- lows us to efficiently implement various HPO algorithms. In general, all HPO algorithms considered here need to implement two decision making primitives, searching and schedul- ing. First, they need to sample new hyperparameter configurations, which often involves some kind of search over the configuration space. Second, for each configuration, an HPO algorithm needs to schedule its evaluation and decide how many resources to allocate for it. Once we start to evaluate a configuration, we will refer to it as a trial. We map these decisions to two classes, HPOSearcher and HPOScheduler. On top of that, we also provide a HPOTuner class that executes the optimization process. This concept of scheduler and searcher is also implemented in popular HPO libraries, such as Syne Tune (Salinas et al., 2022), Ray Tune (Liaw et al., 2018) or Optuna (Akiba et al., 2019). import time from scipy import stats from d2l import torch as d2l
19.2.1 Searcher
Below we define a base class for searchers, which provides a new candidate configuration through the sample_configuration function. A simple way to implement this function would be to sample configurations uniformly at random, as we did for random search in Section 19.1. More sophisticated algorithms, such as Bayesian optimization, will make these decisions based on the performance of previous trials. As a result, these algorithms are able to sample more promising candidates over time. We add the update function in order to update the history of previous trials, which can then be exploited to improve our sampling distribution. class HPOSearcher(d2l.HyperParameters): #@save
def sample_configuration() -> dict:
raise NotImplementedError
def update(self, config: dict, error: float, additional_info=None): pass
The following code shows how to implement our random search optimizer from the pre- vious section in this API. As a slight extension, we allow the user to prescribe the first configuration to be evaluated via initial_config, while subsequent ones are drawn at random. class RandomSearcher(HPOSearcher): #@save
(continues on next page)
Hyperparameter Optimization API
837

def __init__(self, config_space: dict, initial_config=None): self.save_hyperparameters() def sample_configuration(self) -> dict: if self.initial_config is not None: result = self.initial_config self.initial_config = None else: result = { name: domain.rvs() for name, domain in self.config_space.items() } return result
19.2.2 Scheduler
Beyond sampling configurations for new trials, we also need to decide when and for how long to run a trial. In practice, all these decisions are done by the HPOScheduler, which delegates the choice of new configurations to a HPOSearcher. The suggest method is called whenever some resource for training becomes available. Apart from invoking sam- ple_configuration of a searcher, it may also decide upon parameters like max_epochs (i.e., how long to train the model for). The update method is called whenever a trial returns a new observation. class HPOScheduler(d2l.HyperParameters): #@save def suggest(self) -> dict: raise NotImplementedError def update(self, config: dict, error: float, info=None): raise NotImplementedError
To implement random search, but also other HPO algorithms, we only need a basic sched- uler that schedules a new configuration every time new resources become available. class BasicScheduler(HPOScheduler): #@save def __init__(self, searcher: HPOSearcher): self.save_hyperparameters() def suggest(self) -> dict: return self.searcher.sample_configuration() def update(self, config: dict, error: float, info=None): self.searcher.update(config, error, additional_info=info)
19.2.3 Tuner
Finally, we need a component that runs the scheduler/searcher and does some book-keeping of the results. The following code implements a sequential execution of the HPO trials that
(continued from previous page)
Hyperparameter Optimization
838

evaluates one training job after the next and will serve as a basic example. We will later use Syne Tune for more scalable distributed HPO cases. class HPOTuner(d2l.HyperParameters): #@save def __init__(self, scheduler: HPOScheduler, objective: callable): self.save_hyperparameters() # Bookeeping results for plotting self.incumbent = None self.incumbent_error = None self.incumbent_trajectory = [] self.cumulative_runtime = [] self.current_runtime = 0 self.records = [] def run(self, number_of_trials): for i in range(number_of_trials): start_time = time.time() config = self.scheduler.suggest() print(f"Trial {i}: config = {config}") error = self.objective(**config) error = float(error.cpu().detach().numpy()) self.scheduler.update(config, error) runtime = time.time() - start_time self.bookkeeping(config, error, runtime) print(f" error = {error}, runtime = {runtime}")
19.2.4 Bookkeeping the Performance of HPO Algorithms
With any HPO algorithm, we are mostly interested in the best performing configuration (called incumbent) and its validation error after a given wall-clock time. This is why we track runtime per iteration, which includes both the time to run an evaluation (call of objective) and the time to make a decision (call of scheduler.suggest). In the se- quel, we will plot cumulative_runtime against incumbent_trajectory in order to visu- alize the any-time performance of the HPO algorithm defined in terms of scheduler (and searcher). This allows us to quantify not only how well the configuration found by an optimizer works, but also how quickly an optimizer is able to find it. @d2l.add_to_class(HPOTuner) #@save
def bookkeeping(self, config: dict, error: float, runtime: float): self.records.append({"config": config, "error": error, "runtime": runtime}) # Check if the last hyperparameter configuration performs better # than the incumbent
if self.incumbent is None or self.incumbent_error > error:
self.incumbent = config
self.incumbent_error = error
# Add current best observed performance to the optimization trajectory
self.incumbent_trajectory.append(self.incumbent_error)
# Update runtime
self.current_runtime += runtime
self.cumulative_runtime.append(self.current_runtime)
Hyperparameter Optimization API
839

19.2.5 Example: Optimizing the Hyperparameters of a Convolutional
We now use our new implementation of random search to optimize the batch size and learning rate of the LeNet convolutional neural network from Section 7.6. We being by defining the objective function, which will once more be validation error. def hpo_objective_lenet(learning_rate, batch_size, max_epochs=10): #@save model = d2l.LeNet(lr=learning_rate, num_classes=10) trainer = d2l.HPOTrainer(max_epochs=max_epochs, num_gpus=1) data = d2l.FashionMNIST(batch_size=batch_size) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) trainer.fit(model=model, data=data) validation_error = trainer.validation_error() return validation_error
We also need to define the configuration space. Moreover, the first configuration to be evaluated is the default setting used in Section 7.6. config_space = { "learning_rate": stats.loguniform(1e-2, 1), "batch_size": stats.randint(32, 256), } initial_config = { "learning_rate": 0.1, "batch_size": 128, }
Now we can start our random search:
searcher = RandomSearcher(config_space, initial_config=initial_config) scheduler = BasicScheduler(searcher=searcher) tuner = HPOTuner(scheduler=scheduler, objective=hpo_objective_lenet) tuner.run(number_of_trials=5)
error = 0.9000097513198853, runtime = 62.85189199447632
‚Äî train_loss 2.0 ‚Äî-- val_loss ‚Äî-- val_ace 15 1.0 0.5 a Ra ee 0.0 0 2 4 6 8 10
Below we plot the optimization trajectory of the incumbent to get the any-time performance of random search:
Neural Network
840

Hyperparameter Optimization
2.0 15 1.0 0.5 0.0 ‚Äî train_loss val_loss val_acc 2 4 6 8 10 epoch
2.0 15 1.0 0.5 0.0 ee ‚Äî train_loss - val_loss ‚Äî-- val_ace eee ee. ee 2 4 6 8 10
2.0 15 1.0 0.5 0.0 ‚Äî train_loss val_loss val_acc
2.0 15 1.0 0.5 0.0 ‚Äî train_loss ==¬ª val_loss ‚Äî-- val_ace 2 4 6 8 10 epoch
Hyperparameter Optimization API
841

board = d2l.ProgressBoard(xlabel="time", ylabel="error") for time_stamp, error in zip( tuner.cumulative_runtime, tuner.incumbent_trajectory ): board.draw(time_stamp, error, "random search", every_n=1)
‚Äî random search error 0.27 0.26 100 150 200 250 300 time
19.2.6 Comparing HPO Algorithms
Just as with training algorithms or model architectures, it is important to understand how to best compare different HPO algorithms. Each HPO run depends on two major sources of randomness: the random effects of the training process, such as random weight initial- ization or mini-batch ordering, and the intrinsic randomness of the HPO algorithm itself, such as the random sampling of random search. Hence, when comparing different algo- rithms, it is crucial to run each experiment several times and report statistics, such as mean or median, across a population of multiple repetitions of an algorithm based on different seeds of the random number generator. To illustrate this, we compare random search (see Section 19.1.2) and Bayesian optimiza- tion (Snoek et al., 2012) on tuning the hyperparameters of a feed-forward neural network. Each algorithm was evaluated 50 times with a different random seed. The solid line indi- cates the average performance of the incumbent across these 50 repetitions and the dashed line the standard deviation. We can see that random search and Bayesian optimization per- form roughly the same up to ~1000 seconds, but Bayesian optimization can make use of the past observation to identify better configurations and thus quickly outperforms random search afterwards. ‚Äî Bayesian optimization ‚Äî random search 0 2000 4000 6000 wall-clock time (seconds)
tFig. 19.2.1
Example any-time performance plot to compare two algorithms A and B. Hyperparameter Optimization
842

19.2.7 Summary
This section laid out a simple, yet flexible interface to implement various HPO algorithms that we will look at in this chapter. Similar interfaces can be found in popular open-source HPO frameworks. We also looked at how we can compare HPO algorithms, and potential pitfall one needs to be aware. 19.2.8 Exercises
1. The goal of this exercise is to implement the objective function for a slightly more chal- lengingHPOproblem,andtorunmorerealisticexperiments. Wewillusethetwohidden layer MLP DropoutMLP implemented in Section 5.6. 1. Code up the objective function, which should depend on all hyperparameters of the modelandbatch_size. Usemax_epochs=50. GPUsdonothelphere,sonum_gpus=0. Hint: Modify hpo_objective_lenet.bubu2. Chooseasensiblesearchspace, wherenum_hiddens_1, num_hiddens_2areintegers in ¬ª8,1024‚Ä¶, and dropout values lie in ¬ª0,0.95‚Ä¶, while batch_size lies in ¬ª16,384‚Ä¶. Provide code for config_space, using sensible distributions from scipy.stats.bubu3. Run random search on this example with number_of_trials=20 and plot the re- sults. Make sure to first evaluate the default configuration of Section 5.6, which is initial_config = {'num_hiddens_1': 256, 'num_hiddens_2': 256, 'dropout_1': 0.5, 'dropout_2': 0.5, 'lr': 0.1, 'batch_size': 256}. 2. In this exercise, you will implement a new searcher (subclass of HPOSearcher) which makesdecisionsbasedonpastdata. Itdependsonparametersprobab_local,num_init_random. Its sample_configuration method works as follows. For the first num_init_random calls,dothesameasRandomSearcher.sample_configuration. Otherwise,withprob- ability 1 - probab_local, do the same as RandomSearcher.sample_configuration. Otherwise, pick the configuration which attained the smallest validation error so far, select one of its hyperparameters at random, and sample its value randomly like in RandomSearcher.sample_configuration, but leave all other values the same. Re- turn this configuration, which is identical to the best configuration so far, except in this one hyperparameter.bubu1. Code up this new LocalSearcher. Hint: Your searcher requires config_space as argument at construction. Feel free to use a member of type RandomSearcher. You will also have to implement the update method. 2. Re-run the experiment from the previous exercise, but using your new searcher in- stead of RandomSearcher. Experiment with different values for probab_local, num_init_random. However, note that a proper comparison between different HPO methods requires repeating experiments several times, and ideally considering a number of benchmark tasks. 266
oo :
Discussions266. Asynchronous Random Search
843

19.3 Asynchronous Random Search

As we have seen in the previous Section 19.2, we might have to wait hours or even days be- fore random search returns a good hyperparameter configuration, because of the expensive evaluation of hyperparameter configurations. In practice, we have often access to a pool of resources such as multiple GPUs on the same machine or multiple machines with a single GPU. This begs the question: How do we eÔ¨Äiciently distribute random search? In general, we distinguish between synchronous and asynchronous parallel hyperparameter optimization (see Fig. 19.3.1). In the synchronous setting, we wait for all concurrently running trials to finish, before we start the next batch. Consider configuration spaces that contain hyperparameters such as the number of filters or number of layers of a deep neural network. Hyperparameter configurations that contain a larger number of layers of filters will naturally take more time to finish, and all other trials in the same batch will have to wait at synchronisation points (grey area in Fig. 19.3.1) before we can continue the optimization process. In the asynchronous setting we immediately schedule a new trial as soon as resources be- come available. This will optimally exploit our resources, since we can avoid any synchro- nisation overhead. For random search, each new hyperparameter configuration is chosen independentlyofallothers, andinparticularwithoutexploitingobservationsfromanyprior evaluation. This means we can trivially parallelize random search asynchronously. This is not straight-forward with more sophisticated methods that make decision based on previ- ous observations (see Section 19.5). While we need access to more resources than in the sequential setting, asynchronous random search exhibits a linear speed-up, in that a certain performance is reached ùêæ times faster if ùêæ trials can be run in parallel. ‚ÄòSequential Tia | Trial Tal Thala | Taha | Tals Tako Tak Taka ‚ÄòSynchronous Tah Tals Tras Tako | Tala | Thala ‚ÄòAsynchronous Tah Tale Tals Time
tFig. 19.3.1 Distributing the hyperparameter optimization process either synchronously or
asynchronously. Compared to the sequential setting, we can reduce the overall wall-clock time while keep the total compute constant. Synchronous scheduling might lead to idling workers in the case of stragglers. In this notebook, we will look at asynchronous random search that, where trials are exe- cuted in multiple python processes on the same machine. Distributed job scheduling and execution is difficult to implement from scratch. We will use Syne Tune (Salinas et al., 2022), which provides us with a simple interface for asynchronous HPO. Syne Tune is de-
Hyperparameter Optimization
844

signed to be run with different execution back-ends, and the interested reader is invited to study its simple APIs in order to learn more about distributed HPO. import logging from d2l import torch as d2l logging.basicConfig(level=logging.INFO) from syne_tune import StoppingCriterion, Tuner from syne_tune.backend.python_backend import PythonBackend from syne_tune.config_space import loguniform, randint from syne_tune.experiments import load_experiment from syne_tune.optimizer.baselines import RandomSearch
import logging from d2l import torch as d2l
INFO:root:SageMakerBackend is not imported since dependencies are missing. You‚ê£
‚Ü©!can install them with pip install 'syne-tune[extra]' AWS dependencies are not imported since dependencies are missing. You can‚ê£ ‚Ü©!install them with pip install 'syne-tune[aws]' or (for everything) pip install 'syne-tune[extra]' AWS dependencies are not imported since dependencies are missing. You can‚ê£ ‚Ü©!install them with pip install 'syne-tune[aws]' or (for everything) pip install 'syne-tune[extra]' INFO:root:Ray Tune schedulers and searchers are not imported since‚ê£ ‚Ü©!dependencies are missing. You can install them with pip install 'syne-tune[raytune]' or (for everything) pip install 'syne-tune[extra]'
19.3.1 Objective Function
First, we have to define a new objective function such that it now returns the performance back to Syne Tune via the report callback. def hpo_objective_lenet_synetune(learning_rate, batch_size, max_epochs): from syne_tune import Reporter from d2l import torch as d2l model = d2l.LeNet(lr=learning_rate, num_classes=10) trainer = d2l.HPOTrainer(max_epochs=1, num_gpus=1) data = d2l.FashionMNIST(batch_size=batch_size) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) report = Reporter() for epoch in range(1, max_epochs + 1): if epoch == 1: # Initialize the state of Trainer trainer.fit(model=model, data=data) else: trainer.fit_epoch()
(continues on next page)
Asynchronous Random Search
845

validation_error = trainer.validation_error().cpu().detach().numpy() report(epoch=epoch, validation_error=float(validation_error))
Note that the PythonBackend of Syne Tune requires dependencies to be imported inside the function definition. 19.3.2 Asynchronous Scheduler
First, we define the number of workers that evaluate trials concurrently.bubuWe also need to specify how long we want to run random search, by defining an upper limit on the total wall-clock time. n_workers = 2 # Needs to be <= the number of available GPUs max_wallclock_time = 12 * 60 # 12 minutes
Next, we state which metric we want to optimize and whether we want to minimize or maximize this metric. Namely, metric needs to correspond to the argument name passed to the report callback.bubumode = "min" metric = "validation_error"
We use the configuration space from our previous example. In Syne Tune, this dictionary can also be used to pass constant attributes to the training script. We make use of this feature in order to pass max_epochs. Moreover, we specify the first configuration to be evaluated in initial_config. config_space = { "learning_rate": loguniform(1e-2, 1), "batch_size": randint(32, 256), "max_epochs": 10, } initial_config = { "learning_rate": 0.1, "batch_size": 128, }
Next, we need to specify the back-end for job executions. Here we just consider the distri- bution on a local machine where parallel jobs are executed as sub-processes. However, for large scale HPO, we could run this also on a cluster or cloud environment, where each trial consumes a full instance. trial_backend = PythonBackend( tune_function=hpo_objective_lenet_synetune, config_space=config_space, )
(continued from previous page)
Hyperparameter Optimization
846

We can now create the scheduler for asynchronous random search, which is similar in be- haviour to our BasicScheduler from Section 19.2. scheduler = RandomSearch( config_space, metric=metric, mode=mode, points_to_evaluate=[initial_config], )
INFO:syne_tune.optimizer.schedulers.fifo:max_resource_level = 10, as inferred‚ê£ ‚Ü©!from config_space INFO:syne_tune.optimizer.schedulers.fifo:Master random_seed = 2737092907
Syne Tune also features a Tuner, where the main experiment loop and bookkeeping is centralized, and interactions between scheduler and back-end are mediated. stop_criterion = StoppingCriterion(max_wallclock_time=max_wallclock_time)
tuner = Tuner( trial_backend=trial_backend, scheduler=scheduler, stop_criterion=stop_criterion, n_workers=n_workers, print_update_interval=int(max_wallclock_time * 0.6), )
Let us run our distributed HPO experiment. According to our stopping criterion, it will run for about 12 minutes. tuner.run()
INFO:syne_tune.tuner:results of trials will be saved on /home/ci/syne-tune/
‚Ü©!python-entrypoint-2023-08-18-19-45-39-958 INFO:root:Detected 4 GPUs INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.1 --batch_size 128 --max_epochs 10 --tune_function_root‚ê£ ‚Ü©!/home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/tune_function -- ‚Ü©!tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_checkpoint_dir / ‚Ü©!home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/0/checkpoints INFO:syne_tune.tuner:(trial 0) - scheduled config {'learning_rate': 0.1, ‚Ü©!'batch_size': 128, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/
INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.1702844732454753 --batch_size 114 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!1/checkpoints
INFO:syne_tune.tuner:(trial 1) - scheduled config {'learning_rate': 0. (continues on next page)
Asynchronous Random Search
847

‚Ü©!1702844732454753, 'batch_size': 114, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 0 completed. INFO:syne_tune.tuner:Trial trial_id 1 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.34019846567238493 --batch_size 221 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!2/checkpoints INFO:syne_tune.tuner:(trial 2) - scheduled config {'learning_rate': 0. ‚Ü©!34019846567238493, 'batch_size': 221, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.014628124155727769 --batch_size 88 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!3/checkpoints INFO:syne_tune.tuner:(trial 3) - scheduled config {'learning_rate': 0. ‚Ü©!014628124155727769, 'batch_size': 88, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 2 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.1114831485450576 --batch_size 142 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!4/checkpoints INFO:syne_tune.tuner:(trial 4) - scheduled config {'learning_rate': 0. ‚Ü©!1114831485450576, 'batch_size': 142, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 3 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.014076038679980779 --batch_size 223 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!5/checkpoints INFO:syne_tune.tuner:(trial 5) - scheduled config {'learning_rate': 0. ‚Ü©!014076038679980779, 'batch_size': 223, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 4 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.02558173674804846 --batch_size 62 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!6/checkpoints INFO:syne_tune.tuner:(trial 6) - scheduled config {'learning_rate': 0. ‚Ü©!02558173674804846, 'batch_size': 62, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 5 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.026035979388614055 --batch_size 139 --max_epochs 10 --
(continued from previous page)
(continues on next page)
Hyperparameter Optimization
848

‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!7/checkpoints INFO:syne_tune.tuner:(trial 7) - scheduled config {'learning_rate': 0. ‚Ü©!026035979388614055, 'batch_size': 139, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 6 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.24202494130424274 --batch_size 231 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!8/checkpoints INFO:syne_tune.tuner:(trial 8) - scheduled config {'learning_rate': 0. ‚Ü©!24202494130424274, 'batch_size': 231, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 7 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.10483132064775551 --batch_size 145 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!9/checkpoints INFO:syne_tune.tuner:(trial 9) - scheduled config {'learning_rate': 0. ‚Ü©!10483132064775551, 'batch_size': 145, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 8 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.017898854850751864 --batch_size 51 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!10/checkpoints INFO:syne_tune.tuner:(trial 10) - scheduled config {'learning_rate': 0. ‚Ü©!017898854850751864, 'batch_size': 51, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 9 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.9645419978270817 --batch_size 200 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!11/checkpoints INFO:syne_tune.tuner:(trial 11) - scheduled config {'learning_rate': 0. ‚Ü©!9645419978270817, 'batch_size': 200, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 11 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.10559888854748693 --batch_size 40 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!12/checkpoints INFO:syne_tune.tuner:(trial 12) - scheduled config {'learning_rate': 0. (continued from previous page)
(continues on next page)
Asynchronous Random Search
849

‚Ü©!10559888854748693, 'batch_size': 40, 'max_epochs': 10} INFO:syne_tune.tuner:tuning status (last metric is reported) trial_id status iter learning_rate batch_size max_epochs epoch ‚ê£ ‚Ü©!validation_error worker-time 0 Completed 10 0.100000 128 10 10.0 ‚ê£ ‚Ü©! 0.277195 64.928907 1 Completed 10 0.170284 114 10 10.0 ‚ê£ ‚Ü©!bubu0.286225 65.434195 2 Completed 10 0.340198 221 10 10.0 ‚ê£ ‚Ü©! 0.218990 59.729758 3 Completed 10 0.014628 88 10 10.0 ‚ê£ ‚Ü©! 0.899920 81.001636 4 Completed 10 0.111483 142 10 10.0 ‚ê£ ‚Ü©! 0.268684 64.427400 5 Completed 10 0.014076 223 10 10.0 ‚ê£ ‚Ü©! 0.899922 61.264475 6 Completed 10 0.025582 62 10 10.0 ‚ê£ ‚Ü©! 0.399520 75.966186 7 Completed 10 0.026036 139 10 10.0 ‚ê£ ‚Ü©! 0.899988 62.261541 8 Completed 10 0.242025 231 10 10.0 ‚ê£ ‚Ü©! 0.257636 58.186485 9 Completed 10 0.104831 145 10 10.0 ‚ê£ ‚Ü©! 0.273898 59.771699 10 InProgress 8 0.017899 51 10 8.0 ‚ê£ ‚Ü©! 0.496118 66.999746 11 Completed 10 0.964542 200 10 10.0 ‚ê£ ‚Ü©! 0.181600 59.159662 12 InProgress 0 0.105599 40 10 - ‚ê£ ‚Ü©! 2 trials running, 11 finished (11 until the end), 436.60s wallclock-time
INFO:syne_tune.tuner:Trial trial_id 10 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/
‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.5846051207380589 --batch_size 35 --max_epochs 10 --tune_
‚Ü©!function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/
‚Ü©!tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_
‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/
‚Ü©!13/checkpoints
INFO:syne_tune.tuner:(trial 13) - scheduled config {'learning_rate': 0. ‚Ü©!5846051207380589, 'batch_size': 35, 'max_epochs': 10}
INFO:syne_tune.tuner:Trial trial_id 12 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/
‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.2468891379769198 --batch_size 146 --max_epochs 10 --
‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-
‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_
‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/
‚Ü©!14/checkpoints
INFO:syne_tune.tuner:(trial 14) - scheduled config {'learning_rate': 0. ‚Ü©!2468891379769198, 'batch_size': 146, 'max_epochs': 10}
INFO:syne_tune.tuner:Trial trial_id 13 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/
‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. (continued from previous page)
(continues on next page)
Hyperparameter Optimization
850

‚Ü©!py --learning_rate 0.12956867470224812 --batch_size 218 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!15/checkpoints INFO:syne_tune.tuner:(trial 15) - scheduled config {'learning_rate': 0. ‚Ü©!12956867470224812, 'batch_size': 218, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 14 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.24900745354561854 --batch_size 103 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!16/checkpoints INFO:syne_tune.tuner:(trial 16) - scheduled config {'learning_rate': 0. ‚Ü©!24900745354561854, 'batch_size': 103, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 15 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.03903577426988046 --batch_size 80 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!17/checkpoints INFO:syne_tune.tuner:(trial 17) - scheduled config {'learning_rate': 0. ‚Ü©!03903577426988046, 'batch_size': 80, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 16 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.01846559300690354 --batch_size 183 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39- ‚Ü©!958/tune_function --tune_function_hash 4d7d5b85e4537ad0c5d0a202623dcec5 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958/ ‚Ü©!18/checkpoints INFO:syne_tune.tuner:(trial 18) - scheduled config {'learning_rate': 0. ‚Ü©!01846559300690354, 'batch_size': 183, 'max_epochs': 10} INFO:syne_tune.stopping_criterion:reaching max wallclock time (720), stopping‚ê£ ‚Ü©!there. INFO:syne_tune.tuner:Stopping trials that may still be running. INFO:syne_tune.tuner:Tuning finished, results of trials can be found on /home/ ‚Ü©!ci/syne-tune/python-entrypoint-2023-08-18-19-45-39-958 -------------------- Resource summary (last result is reported): trial_id status iter learning_rate batch_size max_epochs epoch ‚ê£ ‚Ü©!validation_error worker-time 0 Completed 10 0.100000 128 10 10 ‚ê£ ‚Ü©! 0.277195 64.928907 1 Completed 10 0.170284 114 10 10 ‚ê£ ‚Ü©!bubu0.286225 65.434195 2 Completed 10 0.340198 221 10 10 ‚ê£ ‚Ü©! 0.218990 59.729758 3 Completed 10 0.014628 88 10 10 ‚ê£ ‚Ü©! 0.899920 81.001636 4 Completed 10 0.111483 142 10 10 ‚ê£
(continued from previous page)
(continues on next page)
Asynchronous Random Search
851

‚Ü©! 0.268684 64.427400 5 Completed 10 0.014076 223 10 10 ‚Ü©! 0.899922 61.264475 6 Completed 10 0.025582 62 10 10 ‚Ü©! 0.399520 75.966186 7 Completed 10 0.026036 139 10 10 ‚Ü©! 0.899988 62.261541 8 Completed 10 0.242025 231 10 10 ‚Ü©! 0.257636 58.186485 9 Completed 10 0.104831 145 10 10 ‚Ü©! 0.273898 59.771699 10 Completed 10 0.017899 51 10 10 ‚Ü©! 0.405545 83.778503 11 Completed 10 0.964542 200 10 10 ‚Ü©! 0.181600 59.159662 12 Completed 10 0.105599 40 10 10 ‚Ü©! 0.182500 94.734384 13 Completed 10 0.584605 35 10 10 ‚Ü©! 0.153846 110.965637 14 Completed 10 0.246889 146 10 10 ‚Ü©! 0.215050 65.142847 15 Completed 10 0.129569 218 10 10 ‚Ü©! 0.313873 61.310455 16 Completed 10 0.249007 103 10 10 ‚Ü©! 0.196101 72.519127 17 InProgress 9 0.039036 80 10 9 ‚Ü©! 0.369000 73.403000 18 InProgress 5 0.018466 183 10 5 ‚Ü©! 0.900263 34.714568 2 trials running, 17 finished (17 until the end), 722.84s wallclock-time validation_error: best 0.14451533555984497 for trial-id 13 -------------------- ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£ ‚ê£
The logs of all evaluated hyperparameter configurations are stored for further analysis. At any time during the tuning job, we can easily get the results obtained so far and plot the incumbent trajectory. d2l.set_figsize() tuning_experiment = load_experiment(tuner.name) tuning_experiment.plot()
WARNING:matplotlib.legend:No artists with labels found to put in legend. Note‚ê£ ‚Ü©!that artists whose label start with an underscore are ignored when legend()‚ê£ ‚Ü©!is called with no argument. 19.3.3 Visualize the Asynchronous Optimization Process
Below we visualize how the learning curves of every trial (each color in the plot represents a trial) evolve during the asynchronous optimization process. At any point in time, there are as many trials running concurrently as we have workers. Once a trial finishes, we
(continued from previous page)
Hyperparameter Optimization
852

Best result over time python-entrypoint-2023-08-18-19-45-39-958
nd ad 2 B a co validation_error So nu i} 200 400 600 wallclock time
immediately start the next trial, without waiting for the other trials to finish. Idle time of workers is reduced to a minimum with asynchronous scheduling. d2l.set_figsize([6, 2.5]) results = tuning_experiment.results for trial_id in results.trial_id.unique(): df = results[results["trial_id"] == trial_id] d2l.plt.plot( df["st_tuner_time"], df["validation_error"], marker="o" ) d2l.plt.xlabel("wall-clock time") d2l.plt.ylabel("objective function")
Text(0, 0.5, 'objective function')
5084 es] 2 2 0.67 v 2 3 0.44 = 8 0.24 0 100 ¬´200-300. 400s: 500 ¬´600-700 wall-clock time
19.3.4 Summary
We can reduce the waiting time for random search substantially by distribution trials across parallel resources.bubuIn general, we distinguish between synchronous scheduling and asyn- chronous scheduling. Synchronous scheduling means that we sample a new batch of hy- perparameter configurations once the previous batch finished. If we have a stragglers - trials that takes more time to finish than other trials - our workers need to wait at synchro- nization points. Asynchronous scheduling evaluates a new hyperparameter configurations
Multi-Fidelity Hyperparameter Optimization
853

as soon as resources become available, and, hence, ensures that all workers are busy at any point in time. While random search is easy to distribute asynchronously and does not require any change of the actual algorithm, other methods require some additional modifi- cations. 19.3.5 Exercises
1.bubuConsider the DropoutMLP model implemented in Section 5.6, and used in Exercise 1 of Section 19.2. 1. Implementanobjectivefunctionhpo_objective_dropoutmlp_synetunetobeused with Syne Tune. Make sure that your function reports the validation error after every epoch. 2. Using the setup of Exercise 1 in Section 19.2, compare random search to Bayesian optimization. If you use SageMaker, feel free to use Syne Tune‚Äôs benchmarking facilities in order to run experiments in parallel. Hint: Bayesian optimization is provided as syne_tune.optimizer.baselines.BayesianOptimization. 3. For this exercise, you need to run on an instance with at least 4 CPU cores. For one of the methods used above (random search, Bayesian optimization), run experiments with n_workers=1, n_workers=2, n_workers=4, and compare results (incumbent trajectories). At least for random search, you should observe linear scaling with respect to the number of workers. Hint: For robust results, you may have to average over several repetitions each.bubu2.bubuAdvanced. The goal of this exercise is to implement a new scheduler in Syne Tune. 1. Create a virtual environment containing both the d2lbook 267 and syne-tune 268
sources. 267
2. Implement the LocalSearcher from Exercise 2 in Section 19.2 as a new searcher in Syne Tune. Hint: Read this tutorial269.bubuAlternatively, you may follow this example 270.bubu268
3. Compare your new LocalSearcher with RandomSearch on the DropoutMLP bench- mark. 269
Discussions271. 19.4 Multi-Fidelity Hyperparameter Optimization
270
a
Training neural networks can be expensive even on moderate size datasets. Depending on the configuration space (Section 19.1.1), hyperparameter optimization requires tens to hundreds of function evaluations to find a well-performing hyperparameter configuration. AswehaveseeninSection19.3, wecansignificantlyspeeduptheoverallwall-clocktimeof
271
Hyperparameter Optimization
854

HPO by exploiting parallel resources, but this does not reduce the total amount of compute required. In this section, we will show how the evaluation of hyperparameter configurations can be sped up. Methods such as random search allocate the same amount of resources (e.g., number of epochs, training data points) to each hyperparameter evaluation. Fig. 19.4.1 depicts learning curves of a set of neural networks trained with different hyperparameter configurations. After a few epochs we are already able to visually distinguish between well- performing and suboptimal configurations. However, the learning curves are noisy, and we might still require the full amount of 100 epochs to identify the best performing one. 0.50 0.45 0.40 validation loss 0.35 0.30 0.25 epochs
tFig. 19.4.1
Learning curves of random hyperparameter conÔ¨Ågurations
Multi-fidelity hyperparameter optimization allocates more resources to promising configu- rations and stop evaluations of poorly performing ones early. This speeds up the optimiza- tion process, since we can try a larger number of configurations for the same total amount of resources. More formally, we expand our definition in Section 19.1.1, such that our objective function ùëì ‚Äûx,ùëü‚Äù gets an additional input ùëü 2 ¬ªùëümin,ùëüùëöùëéùë•‚Ä¶, specifying the amount of resources that we are willing to spend for the evaluation of configuration x. We assume that the error ùëì ‚Äûx,ùëü‚Äù decreases with ùëü, whereas the computational cost ùëê‚Äûx,ùëü‚Äù increases. Typically, ùëü represents the number of epochs for training the neural network, but it could also be the training subset size or the number of cross-validation folds. from collections import defaultdict import numpy as np from scipy import stats from d2l import torch as d2l
(continues on next page)
Multi-Fidelity Hyperparameter Optimization
855

d2l.set_figsize()
19.4.1 Successive Halving
One of the simplest ways to adapt random search to the multi-fidelity setting is successive halving (Jamieson and Talwalkar, 2016, Karnin et al., 2013). The basic idea is to start with ùëÅ configurations, for example randomly sampled from the configuration space, and to train each of them for ùëümin epochs only. We then discard a fraction of the worst performing trials and train the remaining ones for longer. Iterating this process, fewer trials run for longer, until at least one trial reaches ùëüùëöùëéùë• epochs. More formally, consider a minimum budget ùëümin (for example 1 epoch), a maximum bud-
get ùëüùëöùëéùë•, for example max_epochs in our previous example, and a halving constant ùúÇ 2 f2,3, . .bubu.bubug. For simplicity, assume that ùëüùëöùëéùë• = ùëüminùúÇùêæ, with ùêæ 2 I . The number of initial configurationsisthen ùëÅ = ùúÇùêæ. LetusdefinethesetofrungsR = fùëümin,ùëüminùúÇ,ùëüminùúÇ2, . .bubu.,ùëüùëöùëéùë•g. One round of successive halving proceeds as follows. We start with running ùëÅ trials un-
One round of successive halving proceeds as follows. We start with running N trials un- til the first rung rpin. Sorting the validation errors, we keep the top 1/7 fraction (which amounts to 7*~! configurations) and discard all the rest. The surviving trials are trained for the next rung (*min7) epochs), and the process is repeated. At each rung, a 1/7 fraction of trials survives and their training continues with a 7 times larger budget. With this particular choice of N, only a single trial will be trained to the full budget r,~.. Once such a round of successive halving is done, we start the next one with a new set of initial configurations, iterating until the total budget is spent. rung levels n a 0.50 0.45 0.40 validation loss i i i i i i i i i i i i i i i i i i i i 0.35 \ 1 i i i I 0.30 Se ee 0.25 0 20 40 60 80 1 epochs
tFig. 19.4.2
Learning curves of random hyperparameter conÔ¨Ågurations. (continued from previous page)
Hyperparameter Optimization
856

We subclass the HPOScheduler base class from Section 19.2 in order to implement succes- sive halving, allowing for a generic HPOSearcher object to sample configurations (which, in our example below, will be a RandomSearcher). Additionally, the user has to pass the minimum resource ùëümin, the maximum resource ùëüùëöùëéùë• and ùúÇ as input. Inside our scheduler, we maintain a queue of configurations that still need to be evaluated for the current rung ùëüùëñ. We update the queue every time we jump to the next rung. class SuccessiveHalvingScheduler(d2l.HPOScheduler): #@save def __init__(self, searcher, eta, r_min, r_max, prefact=1): self.save_hyperparameters() # Compute K, which is later used to determine the number of‚ê£ ‚Ü©!configurations self.K = int(np.log(r_max / r_min) / np.log(eta)) # Define the rungs self.rung_levels = [r_min * eta ** k for k in range(self.K + 1)] if r_max not in self.rung_levels: # The final rung should be r_max self.rung_levels.append(r_max) self.K += 1 # Bookkeeping self.observed_error_at_rungs = defaultdict(list) self.all_observed_error_at_rungs = defaultdict(list) # Our processing queue self.queue = []
In the beginning our queue is empty, and we fill it with n = prefact - 7* configurations,
which are first evaluated on the smallest rung ùëümin. Here, prefact allows us to reuse our code in a different context.bubuFor the purpose of this section, we fix prefact = 1. Every time resources become available and the HPOTuner object queries the suggest function, we return an element from the queue. Once we finish one round of successive halving, which means that we evaluated all surviving configurations on the highest resource levelùëüùëöùëéùë• and our queue is empty, we start the entire process again with a new, randomly sampled set of configurations. @d2l.add_to_class(SuccessiveHalvingScheduler) #@save def suggest(self): if len(self.queue) == 0: # Start a new round of successive halving # Number of configurations for the first rung: n0 = int(self.prefact * self.eta ** self.K) for _ in range(n0): config = self.searcher.sample_configuration() config["max_epochs"] = self.r_min # Set r = r_min self.queue.append(config) # Return an element from the queue return self.queue.pop()
When we collected a new data point, we first update the searcher module. Afterwards we check if we already collect all data points on the current rung. If so, we sort all configura- tions and push the top 1 ùúÇ configurations into the queue. Multi-Fidelity Hyperparameter Optimization
857

@d2l.add_to_class(SuccessiveHalvingScheduler) #@save
def update(self, config: dict, error: float, info=None): ri = int(config["max_epochs"]) # Rung r_i # Update our searcher, e.g if we use Bayesian optimization later self.searcher.update(config, error, additional_info=info) self.all_observed_error_at_rungs[ri].append((config, error)) if ri < self.r_max: # Bookkeeping self.observed_error_at_rungs[ri].append((config, error)) # Determine how many configurations should be evaluated on this rung ki = self.K - self.rung_levels.index(ri) ni = int(self.prefact * self.eta ** ki) # If we observed all configuration on this rung r_i, we estimate the # top 1 / eta configuration, add them to queue and promote them for # the next rung r_{i+1} if len(self.observed_error_at_rungs[ri]) >= ni: kiplus1 = ki - 1 niplus1 = int(self.prefact * self.eta ** kiplus1) best_performing_configurations = self.get_top_n_configurations( rung_level=ri, n=niplus1 ) riplus1 = self.rung_levels[self.K - kiplus1] # r_{i+1} # Queue may not be empty: insert new entries at the beginning self.queue = [ dict(config, max_epochs=riplus1) for config in best_performing_configurations ] + self.queue self.observed_error_at_rungs[ri] = [] # Reset
Configurations are sorted based on their observed performance on the current rung. @d2l.add_to_class(SuccessiveHalvingScheduler) #@save def get_top_n_configurations(self, rung_level, n): rung = self.observed_error_at_rungs[rung_level] if not rung: return [] sorted_rung = sorted(rung, key=lambda x: x[1]) return [x[0] for x in sorted_rung[:n]]
Let us see how successive halving is doing on our neural network example. We will use ùëümin = 2, ùúÇ = 2, ùëüùëöùëéùë• = 10, so that rung levels are 2,4,8,10. min_number_of_epochs = 2 max_number_of_epochs = 10 eta = 2 num_gpus=1 config_space = { "learning_rate": stats.loguniform(1e-2, 1), "batch_size": stats.randint(32, 256), } initial_config = { "learning_rate": 0.1,
(continues on next page)
Hyperparameter Optimization
858

"batch_size": 128,
}
We just replace the scheduler with our new SuccessiveHalvingScheduler. searcher = d2l.RandomSearcher(config_space, initial_config=initial_config) scheduler = SuccessiveHalvingScheduler( searcher=searcher, eta=eta, r_min=min_number_of_epochs, r_max=max_number_of_epochs, ) tuner = d2l.HPOTuner( scheduler=scheduler, objective=d2l.hpo_objective_lenet, ) tuner.run(number_of_trials=30)
error = 0.17762434482574463, runtime = 53.576584339141846
2.0 15 10 ‚Äî train_loss 0.54 ‚Äî‚Äî- val_loss ‚Äî-- val_ace 0.0 0.0 0.5 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 -=- valloss od] ‚Äî- val_acc a - 0.0 0.0 0.5 1.0 15 2.0 epoch
We can visualize the learning curves of all configurations that we evaluated. Most of the configurations are stopped early and only the better performing configurations survive until ùëüùëöùëéùë•. Compare this to vanilla random search, which would allocate ùëüùëöùëéùë• to every config- uration. (continued from previous page)
19.4 Multi-Fidelity Hyperparameter Optimization
859

2.0 15 10 ‚Äî train_loss 0.54 --- valloss ‚Äî-- val_ace 0.0 : r = 0.0 0.5 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 --- valloss ‚Äî-- val_ace 0.0 Se 0.0 0.5 1.0 15 2.0 epoch
‚Äî train_loss 2.0 --- val_loss ‚Äî-- val_acc 15 10 os rer 0.0 0.5 1.0 15 2.0 epoch
2.0 15 10 ‚Äî train_loss 0.54 -=- valloss ‚Äî-- val_ace 0,0 $$ | 0.0 0.5 1.0 15 2.0
860

Hyperparameter Optimization
‚Äî train_loss 2.0 val_loss val_acc 15 10 | 05 ea 0.0 0.5 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 -=- valloss ‚Äî-- val_acc eee 0.0 1 0.0 0.5 1.0 15 2.0 epoch
2.0 1.5 | ‚Äî train_loss S. === val_loss y 10 - val_acc 0.5 0.0 0 1 2 3 4 epoch
‚Äî train_loss 2.0 --- val_loss ‚Äî-- val_acc 15 1.0 + 0.5 0.0 i} 1 2 3 4
19.4 Multi-Fidelity Hyperparameter Optimization
861

‚Äî train_loss 2.0 = val_loss 15 1.0 Sas] 05 i} 1 2 3 4 epoch
‚Äî train_loss 2.0 = val_loss 15 1.0 05 y SSs==-+ ra 7 0.0 0 1 2 3 4 epoch
‚Äî train_loss 2.0 =-- val_loss ‚Äî-- val_acc 15 1.0 05 i) 2 4 6 8 epoch
‚Äî train_loss 2.0 ‚Äî-- val_loss ‚Äî-- val_acc 15 1.0 SS 05 ‚Äî i} 2 4 6 8
862

Hyperparameter Optimization
‚Äî train_loss 2.0 === val_loss val_acc 15 1.0 0.5 =-~.| 0.0 1 ; ; r 0 2 4 6 8 10 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 -=- val_loss aa sr valacc | 0.0 0.0 0.5 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 === val_loss ss valacc | 0.0 | 0.0 0.5 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 -=- val_loss ‚Äî-- val_ace 0.0 $$ 1 0.0 0.5 1.0 15 2.0
19.4 Multi-Fidelity Hyperparameter Optimization
863

2.0 15 1.0 ‚Äî train_loss 0.54 ‚Äî-- val_loss ‚Äî-+ val_ace 0.0 7 ; = 0.0 0.5 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 === val_loss ‚Äî-- val_acc 0.0 ane 0.0 05 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 -=- val_loss <q ‚Äî-+ val_acc 0.0 0.0 0.5 1.0 15 2.0 epoch
2.0 15 1.0 ‚Äî train_loss 0.54 ‚Äî-- val_loss | ‚Äî-= valace eo 0.0 0.0 0.5 1.0 15 2.0 epoch
864

Hyperparameter Optimization
‚Äî train_loss 2.0 val_loss val_acc 15 1.0 ms os ‚Äî 0.0 0.5 1.0 15 2.0 epoch
‚Äî train_loss 2.0 = val_loss 15 1.0 05 0.0 0 1 2 3 4 epoch
‚Äî train_loss 2.0 --- val_loss ‚Äî-- val_acc 15 1.0 ‚Äî‚Äî ==] _ 0.5 : 0 1 2 3 4 epoch
2.0 15 | ‚Äî train_loss === val_loss 1.07 ‚Äî-- val_acc on. 05 0.0 i} 1 2 3 4
19.4 Multi-Fidelity Hyperparameter Optimization
865

2.0 15 1.0 05 ‚Äî train_loss = val_loss i} 1 2 3 4 epoch
2.0 15 1.0 0.5 0.0 ‚Äî train_loss === val_loss ‚Äî- valacc i} 2 4 6 8 epoch
2.0 15 1.0 05 4 ‚Äî train_loss ‚Äò --- val_loss ‚Äò a \ val_acc 1 1 1 ‚Äò i) 2 4 6 8 epoch
2.0 15 1.0 0.5 0.0 ‚Äî train_loss === val_loss ‚Äî-- val_ace
Hyperparameter Optimization
866

for rung_index, rung in scheduler.all_observed_error_at_rungs.items(): errors = [xi[1] for xi in rung] d2l.plt.scatter([rung_index] * len(errors), errors) d2l.plt.xlim(min_number_of_epochs - 0.5, max_number_of_epochs + 0.5) d2l.plt.xticks( np.arange(min_number_of_epochs, max_number_of_epochs + 1), np.arange(min_number_of_epochs, max_number_of_epochs + 1) ) d2l.plt.ylabel("validation error") d2l.plt.xlabel("epochs")
Text(0.5, 0, 'epochs')
3 087¬∞ 8 20.6 So e 30418 ¬∞ $ e j e ¬∞? s 8 epochs
Finally, note some slight complexity in our implementation of SuccessiveHalvingSched- uler.bubuSay that a worker is free to run a job, and suggest is called when the current rung has almost been completely filled, but another worker is still busy with an evaluation. Since we lack the metric value from this worker, we cannot determine the top 1/7 fraction to open up the next rung. On the other hand, we want to assign a job to our free worker, so it does not remain idle. Our solution is to start a new round of successive halving and assign our worker to the first trial there. However, once a rung is completed in update, we make sure to insert new configurations at the beginning of the queue, so they take precedence over configurations from the next round. 19.4.2 Summary
In this section, we introduced the concept of multi-fidelity hyperparameter optimization, where we assume to have access to cheap-to-evaluate approximations of the objective func- tion, such as validation error after a certain number of epochs of training as proxy to val- idation error after the full number of epochs. Multi-fidelity hyperparameter optimization allows to reduce the overall computation of the HPO instead of just reducing the wall-clock time. Weimplementedandevaluatedsuccessivehalving, asimpleyetefficientmulti-fidelityHPO algorithm. 272
Discussions272. Asynchronous Successive Halving
867

19.5 Asynchronous Successive Halving
es
As we have seen in Section 19.3, we can accelerate HPO by distributing the evaluation of hyperparameter configurations across either multiple instances or multiples CPUs / GPUs on a single instance. However, compared to random search, it is not straightforward to run successive halving (SH) asynchronously in a distributed setting. Before we can decide which configuration to run next, we first have to collect all observations at the current rung level. This requires to synchronize workers at each rung level. For example, for the lowest rung level ùëümin, we first have to evaluate all ùëÅ = ùúÇùêæ configurations, before we can promote the 1 ùúÇ of them to the next rung level. In any distributed system, synchronization typically implies idle time for workers. First, we often observe high variations in training time across hyperparameter configurations. For example, assuming the number of filters per layer is a hyperparameter, then networks with less filters finish training faster than networks with more filters, which implies idle worker time due to stragglers. Moreover, the number of slots in a rung level is not always a multiple of the number of workers, in which case some workers may even sit idle for a full batch. Figure Fig. 19.5.1 shows the scheduling of synchronous SH with ùúÇ = 2 for four different
trials with two workers. We start with evaluating Trial-0 and Trial-1 for one epoch and immediately continue with the next two trials once they are finished. We first have to wait until Trial-2 finishes, which takes substantially more time than the other trials, before we can promote the best two trials, i.e., Trial-0 and Trial-3 to the next rung level. This causes idle time for Worker-1. Then, we continue with Rung 1. Also, here Trial-3 takes longer thanTrial-0, whichleadstoanadditionalidelingtimeofWorker-0. Once, wereachRung-2, only the best trial, Trial-0, remains which occupies only one worker. To avoidthat Worker-1 idles during that time, most implementaitons of SH continue already with the next round, and start evaluating new trials (e.g Trial-4) on the first rung. wener were ‚Ñ¢ Le [= | mm SA te > Rung 0 Rung i } Rung 2
tFig. 19.5.1
Synchronous successive halving with two workers. Asynchronous successive halving (ASHA) (Li et al., 2018) adapts SH to the asynchronous parallel scenario. The main idea of ASHA is to promote configurations to the next rung level as soon as we collected at least ùúÇ observations on the current rung level. This decision rule may lead to suboptimal promotions: configurations can be promoted to the next rung level, which in hindsight do not compare favourably against most others at the same rung
‚ÄòSynchronous Successive Halving
Hyperparameter Optimization
868

level. On the other hand, we get rid of all synchronization points this way. In practice, such suboptimal initial promotions have only a modest impact on performance, not only because the ranking of hyperparameter configurations is often fairly consistent across rung levels, but also because rungs grow over time and reflect the distribution of metric values at this level better and better. If a worker is free, but no configuration can be promoted, we start a new configuration with ùëü = ùëümin, i.e the first rung level. Fig. 19.5.2 shows the scheduling of the same configurations for ASHA. Once Trial-1 fin- ishes, we collect the results of two trials (i.e Trial-0 and Trial-1) and immediately promote the better of them (Trial-0) to the next rung level. After Trial-0 finishes on rung 1, there are too few trials there in order to support a further promotion. Hence, we continue with rung 0 and evaluate Trial-3. Once Trial-3 finishes, Trial-2 is still pending. At this point we have 3 trials evaluated on rung 0 and one trial evaluated already on rung 1. Since Trial-3 performs worse than Trial-0 at rung 0, and ùúÇ = 2, we cannot promote any new trial yet, and Worker-1 starts Trial-4 from scratch instead. However, once Trial-2 finishes and scores worse than Trial-3, the latter is promoted towards rung 1. Afterwards, we collected 2 eval- uations on rung 1, which means we can now promote Trial-0 towards rung 2. At the same time, Worker-1 continues with evaluating new trials (i.e., Trial-5) on rung 0. Promotion to Rung 2 Promotion to Rung 1 Worker-0 Twial-2 Worker-2 Trial Taka Tals ‚ÄòStart new tial on Rung 0 Promotion to Rung 1 Start new tial on Rung 0
tFig. 19.5.2 Asynchronous successive halving (ASHA) with two workers. import logging from d2l import torch as d2l logging.basicConfig(level=logging.INFO) import matplotlib.pyplot as plt from syne_tune import StoppingCriterion, Tuner from syne_tune.backend.python_backend import PythonBackend from syne_tune.config_space import loguniform, randint from syne_tune.experiments import load_experiment from syne_tune.optimizer.baselines import ASHA
import logging from d2l import torch as d2l
INFO:root:SageMakerBackend is not imported since dependencies are missing. You‚ê£ ‚Ü©!can install them with pip install 'syne-tune[extra]' AWS dependencies are not imported since dependencies are missing. You can‚ê£ ‚Ü©!install them with pip install 'syne-tune[aws]' or (for everything) pip install 'syne-tune[extra]'
(continues on next page)
Asynchronous Successive Halving
869

AWS dependencies are not imported since dependencies are missing. You can‚ê£ ‚Ü©!install them with pip install 'syne-tune[aws]' or (for everything) pip install 'syne-tune[extra]' INFO:root:Ray Tune schedulers and searchers are not imported since‚ê£ ‚Ü©!dependencies are missing. You can install them with pip install 'syne-tune[raytune]' or (for everything) pip install 'syne-tune[extra]'
19.5.1 Objective Function
We will use Syne Tune with the same objective function as in Section 19.3. def hpo_objective_lenet_synetune(learning_rate, batch_size, max_epochs): from syne_tune import Reporter from d2l import torch as d2l model = d2l.LeNet(lr=learning_rate, num_classes=10) trainer = d2l.HPOTrainer(max_epochs=1, num_gpus=1) data = d2l.FashionMNIST(batch_size=batch_size) model.apply_init([next(iter(data.get_dataloader(True)))[0]], d2l.init_cnn) report = Reporter() for epoch in range(1, max_epochs + 1): if epoch == 1: # Initialize the state of Trainer trainer.fit(model=model, data=data) else: trainer.fit_epoch() validation_error = trainer.validation_error().cpu().detach().numpy() report(epoch=epoch, validation_error=float(validation_error))
We will also use the same configuration space as before:
min_number_of_epochs = 2 max_number_of_epochs = 10 eta = 2 config_space = { "learning_rate": loguniform(1e-2, 1), "batch_size": randint(32, 256), "max_epochs": max_number_of_epochs, } initial_config = { "learning_rate": 0.1, "batch_size": 128, }
19.5.2 Asynchronous Scheduler
(continued from previous page)
Hyperparameter Optimization
870

First, we define the number of workers that evaluate trials concurrently. We also need to specify how long we want to run random search, by defining an upper limit on the total wall-clock time. n_workers = 2 # Needs to be <= the number of available GPUs max_wallclock_time = 12 * 60 # 12 minutes
The code for running ASHA is a simple variation of what we did for asynchronous random search. mode = "min" metric = "validation_error" resource_attr = "epoch" scheduler = ASHA( config_space, metric=metric, mode=mode, points_to_evaluate=[initial_config], max_resource_attr="max_epochs", resource_attr=resource_attr, grace_period=min_number_of_epochs, reduction_factor=eta, )
INFO:syne_tune.optimizer.schedulers.fifo:max_resource_level = 10, as inferred‚ê£ ‚Ü©!from config_space
INFO:syne_tune.optimizer.schedulers.fifo:Master random_seed = 3140976097
Here, metric and resource_attr specify the key names used with the report callback, andmax_resource_attrdenoteswhichinputtotheobjectivefunctioncorrespondstoùëümax. Moreover, grace_period provides ùëümin, and reduction_factor is ùúÇ. We can run Syne Tune as before (this will take about 12 minutes):
trial_backend = PythonBackend( tune_function=hpo_objective_lenet_synetune, config_space=config_space, ) stop_criterion = StoppingCriterion(max_wallclock_time=max_wallclock_time) tuner = Tuner( trial_backend=trial_backend, scheduler=scheduler, stop_criterion=stop_criterion, n_workers=n_workers, print_update_interval=int(max_wallclock_time * 0.6), ) tuner.run()
Asynchronous Successive Halving
871

INFO:syne_tune.tuner:results of trials will be saved on /home/ci/syne-tune/
‚Ü©!python-entrypoint-2023-08-18-20-01-52-046 INFO:root:Detected 4 GPUs INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.1 --batch_size 128 --max_epochs 10 --tune_function_root‚ê£ ‚Ü©!/home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/tune_function -- ‚Ü©!tune_function_hash e03d187e043d2a17cae636d6af164015 --st_checkpoint_dir / ‚Ü©!home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/0/checkpoints INFO:syne_tune.tuner:(trial 0) - scheduled config {'learning_rate': 0.1, ‚Ü©!'batch_size': 128, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.44639554136672527 --batch_size 196 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!1/checkpoints INFO:syne_tune.tuner:(trial 1) - scheduled config {'learning_rate': 0. ‚Ü©!44639554136672527, 'batch_size': 196, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.011548051321691994 --batch_size 254 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!2/checkpoints INFO:syne_tune.tuner:(trial 2) - scheduled config {'learning_rate': 0. ‚Ü©!011548051321691994, 'batch_size': 254, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.14942487313193167 --batch_size 132 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!3/checkpoints INFO:syne_tune.tuner:(trial 3) - scheduled config {'learning_rate': 0. ‚Ü©!14942487313193167, 'batch_size': 132, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 1 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.06317157191455719 --batch_size 242 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!4/checkpoints INFO:syne_tune.tuner:(trial 4) - scheduled config {'learning_rate': 0. ‚Ü©!06317157191455719, 'batch_size': 242, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.48801815412811467 --batch_size 41 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!5/checkpoints INFO:syne_tune.tuner:(trial 5) - scheduled config {'learning_rate': 0. (continues on next page)
Hyperparameter Optimization
872

‚Ü©!48801815412811467, 'batch_size': 41, 'max_epochs': 10}
INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.5904067586747807 --batch_size 244 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!6/checkpoints INFO:syne_tune.tuner:(trial 6) - scheduled config {'learning_rate': 0. ‚Ü©!5904067586747807, 'batch_size': 244, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.08812857364095393 --batch_size 148 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!7/checkpoints INFO:syne_tune.tuner:(trial 7) - scheduled config {'learning_rate': 0. ‚Ü©!08812857364095393, 'batch_size': 148, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.012271314788363914 --batch_size 235 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!8/checkpoints INFO:syne_tune.tuner:(trial 8) - scheduled config {'learning_rate': 0. ‚Ü©!012271314788363914, 'batch_size': 235, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 5 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.08845692598296777 --batch_size 236 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!9/checkpoints INFO:syne_tune.tuner:(trial 9) - scheduled config {'learning_rate': 0. ‚Ü©!08845692598296777, 'batch_size': 236, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.0825770880068151 --batch_size 75 --max_epochs 10 --tune_ ‚Ü©!function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!10/checkpoints INFO:syne_tune.tuner:(trial 10) - scheduled config {'learning_rate': 0. ‚Ü©!0825770880068151, 'batch_size': 75, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.20235201406823256 --batch_size 65 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!11/checkpoints INFO:syne_tune.tuner:(trial 11) - scheduled config {'learning_rate': 0. (continued from previous page)
(continues on next page)
Asynchronous Successive Halving
873

‚Ü©!20235201406823256, 'batch_size': 65, 'max_epochs': 10}
INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.3359885631737537 --batch_size 58 --max_epochs 10 --tune_ ‚Ü©!function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!12/checkpoints INFO:syne_tune.tuner:(trial 12) - scheduled config {'learning_rate': 0. ‚Ü©!3359885631737537, 'batch_size': 58, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.7892434579795236 --batch_size 89 --max_epochs 10 --tune_ ‚Ü©!function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!13/checkpoints INFO:syne_tune.tuner:(trial 13) - scheduled config {'learning_rate': 0. ‚Ü©!7892434579795236, 'batch_size': 89, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.1233786579597858 --batch_size 176 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!14/checkpoints INFO:syne_tune.tuner:(trial 14) - scheduled config {'learning_rate': 0. ‚Ü©!1233786579597858, 'batch_size': 176, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 13 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.13707981127012328 --batch_size 141 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!15/checkpoints INFO:syne_tune.tuner:(trial 15) - scheduled config {'learning_rate': 0. ‚Ü©!13707981127012328, 'batch_size': 141, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.02913976299993913 --batch_size 116 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!16/checkpoints INFO:syne_tune.tuner:(trial 16) - scheduled config {'learning_rate': 0. ‚Ü©!02913976299993913, 'batch_size': 116, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.033362897489792855 --batch_size 154 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!17/checkpoints INFO:syne_tune.tuner:(trial 17) - scheduled config {'learning_rate': 0. (continued from previous page)
(continues on next page)
Hyperparameter Optimization
874

‚Ü©!033362897489792855, 'batch_size': 154, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.29442952580755816 --batch_size 210 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!18/checkpoints INFO:syne_tune.tuner:(trial 18) - scheduled config {'learning_rate': 0. ‚Ü©!29442952580755816, 'batch_size': 210, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.10214259921521483 --batch_size 239 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!19/checkpoints INFO:syne_tune.tuner:(trial 19) - scheduled config {'learning_rate': 0. ‚Ü©!10214259921521483, 'batch_size': 239, 'max_epochs': 10} INFO:syne_tune.tuner:tuning status (last metric is reported) trial_id status iter learning_rate batch_size max_epochs epoch ‚ê£ ‚Ü©!validation_error worker-time 0 Stopped 4 0.100000 128 10 4.0 ‚ê£ ‚Ü©! 0.430578 29.093798 1 Completed 10 0.446396 196 10 10.0 ‚ê£ ‚Ü©!bubu0.205652 72.747496 2 Stopped 2 0.011548 254 10 2.0 ‚ê£ ‚Ü©! 0.900570 13.729115 3 Stopped 8 0.149425 132 10 8.0 ‚ê£ ‚Ü©! 0.259171 58.980305 4 Stopped 4 0.063172 242 10 4.0 ‚ê£ ‚Ü©! 0.900579 27.773950 5 Completed 10 0.488018 41 10 10.0 ‚ê£ ‚Ü©! 0.140488 113.171314 6 Stopped 10 0.590407 244 10 10.0 ‚ê£ ‚Ü©! 0.193776 70.364757 7 Stopped 2 0.088129 148 10 2.0 ‚ê£ ‚Ü©! 0.899955 14.169738 8 Stopped 2 0.012271 235 10 2.0 ‚ê£ ‚Ü©! 0.899840 13.434274 9 Stopped 2 0.088457 236 10 2.0 ‚ê£ ‚Ü©! 0.899801 13.034437 10 Stopped 4 0.082577 75 10 4.0 ‚ê£ ‚Ü©! 0.385970 35.426524 11 Stopped 4 0.202352 65 10 4.0 ‚ê£ ‚Ü©! 0.543102 34.653495 12 Stopped 10 0.335989 58 10 10.0 ‚ê£ ‚Ü©! 0.149558 90.924182 13 Completed 10 0.789243 89 10 10.0 ‚ê£ ‚Ü©! 0.144887 77.365970 14 Stopped 2 0.123379 176 10 2.0 ‚ê£ ‚Ü©! 0.899987 12.422906 15 Stopped 2 0.137080 141 10 2.0 ‚ê£ ‚Ü©! 0.899983 13.395153 16 Stopped 4 0.029140 116 10 4.0 ‚ê£
(continued from previous page)
(continues on next page)
Asynchronous Successive Halving
875

‚Ü©! 0.900532 27.834111 17 Stopped 2 0.033363 154 10 2.0 ‚ê£ ‚Ü©! 0.899996 13.407285 18 InProgress 1 0.294430 210 10 1.0 ‚ê£ ‚Ü©! 0.899878 6.126259 19 InProgress 0 0.102143 239 10 - ‚ê£
18 InProgress 1 0.294430 210 10 1.0 ‚ê£ ‚Ü©! 0.899878 6.126259 19 InProgress 0 0.102143 239 10 - ‚ê£ ‚Ü©! - - 2 trials running, 18 finished (3 until the end), 437.07s wallclock-time INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.02846298236356246 --batch_size 115 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!20/checkpoints INFO:syne_tune.tuner:(trial 20) - scheduled config {'learning_rate': 0. ‚Ü©!02846298236356246, 'batch_size': 115, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.037703019195187606 --batch_size 91 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!21/checkpoints INFO:syne_tune.tuner:(trial 21) - scheduled config {'learning_rate': 0. ‚Ü©!037703019195187606, 'batch_size': 91, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.0741039859356903 --batch_size 192 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!22/checkpoints INFO:syne_tune.tuner:(trial 22) - scheduled config {'learning_rate': 0. ‚Ü©!0741039859356903, 'batch_size': 192, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.3032613031191755 --batch_size 252 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!23/checkpoints INFO:syne_tune.tuner:(trial 23) - scheduled config {'learning_rate': 0. ‚Ü©!3032613031191755, 'batch_size': 252, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.019823425532533637 --batch_size 252 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!24/checkpoints INFO:syne_tune.tuner:(trial 24) - scheduled config {'learning_rate': 0. ‚Ü©!019823425532533637, 'batch_size': 252, 'max_epochs': 10}
INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/
(continued from previous page)
(continues on next page)
Hyperparameter Optimization
876

‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.8203370335228594 --batch_size 77 --max_epochs 10 --tune_ ‚Ü©!function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!25/checkpoints INFO:syne_tune.tuner:(trial 25) - scheduled config {'learning_rate': 0. ‚Ü©!8203370335228594, 'batch_size': 77, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.2960420911378594 --batch_size 104 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!26/checkpoints INFO:syne_tune.tuner:(trial 26) - scheduled config {'learning_rate': 0. ‚Ü©!2960420911378594, 'batch_size': 104, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.2993874715754653 --batch_size 192 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!27/checkpoints INFO:syne_tune.tuner:(trial 27) - scheduled config {'learning_rate': 0. ‚Ü©!2993874715754653, 'batch_size': 192, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.08056711961080017 --batch_size 36 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!28/checkpoints INFO:syne_tune.tuner:(trial 28) - scheduled config {'learning_rate': 0. ‚Ü©!08056711961080017, 'batch_size': 36, 'max_epochs': 10} INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.26868380288030347 --batch_size 151 --max_epochs 10 -- ‚Ü©!tune_function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52- ‚Ü©!046/tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!29/checkpoints INFO:syne_tune.tuner:(trial 29) - scheduled config {'learning_rate': 0. ‚Ü©!26868380288030347, 'batch_size': 151, 'max_epochs': 10} INFO:syne_tune.tuner:Trial trial_id 29 completed. INFO:root:running subprocess with command: /usr/bin/python /home/ci/.local/lib/ ‚Ü©!python3.8/site-packages/syne_tune/backend/python_backend/python_entrypoint. ‚Ü©!py --learning_rate 0.9197404791177789 --batch_size 66 --max_epochs 10 --tune_ ‚Ü©!function_root /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!tune_function --tune_function_hash e03d187e043d2a17cae636d6af164015 --st_ ‚Ü©!checkpoint_dir /home/ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046/ ‚Ü©!30/checkpoints INFO:syne_tune.tuner:(trial 30) - scheduled config {'learning_rate': 0. ‚Ü©!9197404791177789, 'batch_size': 66, 'max_epochs': 10} INFO:syne_tune.stopping_criterion:reaching max wallclock time (720), stopping‚ê£
(continued from previous page)
(continues on next page)
Asynchronous Successive Halving
877

‚Ü©!there. INFO:syne_tune.tuner:Stopping trials that may still be running. INFO:syne_tune.tuner:Tuning finished, results of trials can be found on /home/ ‚Ü©!ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046
‚Ü©!ci/syne-tune/python-entrypoint-2023-08-18-20-01-52-046 -------------------- Resource summary (last result is reported): trial_id status iter learning_rate batch_size max_epochs epoch ‚ê£ ‚Ü©!validation_error worker-time 0 Stopped 4 0.100000 128 10 4 ‚ê£ ‚Ü©! 0.430578 29.093798 1 Completed 10 0.446396 196 10 10 ‚ê£ ‚Ü©!bubu0.205652 72.747496 2 Stopped 2 0.011548 254 10 2 ‚ê£ ‚Ü©! 0.900570 13.729115 3 Stopped 8 0.149425 132 10 8 ‚ê£ ‚Ü©! 0.259171 58.980305 4 Stopped 4 0.063172 242 10 4 ‚ê£ ‚Ü©! 0.900579 27.773950 5 Completed 10 0.488018 41 10 10 ‚ê£ ‚Ü©! 0.140488 113.171314 6 Stopped 10 0.590407 244 10 10 ‚ê£ ‚Ü©! 0.193776 70.364757 7 Stopped 2 0.088129 148 10 2 ‚ê£ ‚Ü©! 0.899955 14.169738 8 Stopped 2 0.012271 235 10 2 ‚ê£ ‚Ü©! 0.899840 13.434274 9 Stopped 2 0.088457 236 10 2 ‚ê£ ‚Ü©! 0.899801 13.034437 10 Stopped 4 0.082577 75 10 4 ‚ê£ ‚Ü©! 0.385970 35.426524 11 Stopped 4 0.202352 65 10 4 ‚ê£ ‚Ü©! 0.543102 34.653495 12 Stopped 10 0.335989 58 10 10 ‚ê£ ‚Ü©! 0.149558 90.924182 13 Completed 10 0.789243 89 10 10 ‚ê£ ‚Ü©! 0.144887 77.365970 14 Stopped 2 0.123379 176 10 2 ‚ê£ ‚Ü©! 0.899987 12.422906 15 Stopped 2 0.137080 141 10 2 ‚ê£ ‚Ü©! 0.899983 13.395153 16 Stopped 4 0.029140 116 10 4 ‚ê£ ‚Ü©! 0.900532 27.834111 17 Stopped 2 0.033363 154 10 2 ‚ê£ ‚Ü©! 0.899996 13.407285 18 Stopped 8 0.294430 210 10 8 ‚ê£ ‚Ü©! 0.241193 52.089688 19 Stopped 2 0.102143 239 10 2 ‚ê£ ‚Ü©! 0.900002 12.487762 20 Stopped 2 0.028463 115 10 2 ‚ê£ ‚Ü©! 0.899995 14.100359 21 Stopped 2 0.037703 91 10 2 ‚ê£ ‚Ü©! 0.900026 14.664848 22 Stopped 2 0.074104 192 10 2 ‚ê£ ‚Ü©! 0.901730 13.312770 23 Stopped 2 0.303261 252 10 2 ‚ê£
(continued from previous page)
(continues on next page)
Hyperparameter Optimization
878

‚Ü©! 0.900009 12.725821 24 Stopped 2 0.019823 252 10 2 ‚Ü©! 0.899917 12.533380 25 Stopped 10 0.820337 77 10 10 ‚Ü©! 0.196842 81.816103 26 Stopped 10 0.296042 104 10 10 ‚Ü©! 0.198453 81.121330 27 Stopped 4 0.299387 192 10 4 ‚Ü©! 0.336183 24.610689 28 InProgress 9 0.080567 36 10 9 ‚Ü©! 0.203052 104.303746 29 Completed 10 0.268684 151 10 10 ‚Ü©!bubu0.222814 68.217289 30 InProgress 1 0.919740 66 10 1 ‚Ü©! 0.900037 10.070776 2 trials running, 29 finished (4 until the end), 723.70s wallclock-time validation_error: best 0.1404876708984375 for trial-id 5 --------------------
Note that we are running a variant of ASHA where underperforming trials are stopped early. This is different to our implementation in Section 19.4.1, where each training job is started with a fixed max_epochs. In the latter case, a well-performing trial which reaches the full 10 epochs, first needs to train 1, then 2, then 4, then 8 epochs, each time starting from scratch. This type of pause-and-resume scheduling can be implemented efficiently by checkpointing the training state after each epoch, but we avoid this extra complexity here. After the experiment has finished, we can retrieve and plot results. d2l.set_figsize() e = load_experiment(tuner.name) e.plot()
WARNING:matplotlib.legend:No artists with labels found to put in legend. Note‚ê£ ‚Ü©!that artists whose label start with an underscore are ignored when legend()‚ê£ ‚Ü©!is called with no argument. Best result over time python-entrypoint-2023-08-18-20-01-52-046
nd 2 2¬∞ & a 0 validation_error ¬∞ Nu 0 200 400 600 wallclock time
19.5.3 Visualize the Optimization Process
(continued from previous page)
‚ê£
‚ê£
‚ê£
‚ê£
‚ê£
‚ê£
‚ê£
Asynchronous Successive Halving
879

Once more, we visualize the learning curves of every trial (each color in the plot represents a trial). Compare this to asynchronous random search in Section 19.3. As we have seen for successive halving in Section 19.4, most of the trials are stopped at 1 or 2 epochs (rmin or 7] * min). However, trials do not stop at the same point, because they require different amount of time per epoch. If we ran standard successive halving instead of ASHA, we would need to synchronize our workers, before we can promote configurations to the next rung level. d2l.set_figsize([6, 2.5]) results = e.results for trial_id in results.trial_id.unique(): df = results[results["trial_id"] == trial_id] d2l.plt.plot( df["st_tuner_time"], df["validation_error"], marker="o" ) d2l.plt.xlabel("wall-clock time") d2l.plt.ylabel("objective function")
Text(0, 0.5, 'objective function')
tad e < 0.85 2 S 50.64 A 2 S04] a 8 0.24 0 100 200 ¬´= 300:¬´ 400s 5500S 600‚ÄîSs 700 wall-clock time
19.5.4 Summary
Compared to random search, successive halving is not quite as trivial to run in an asyn- chronous distributed setting. To avoid synchronisation points, we promote configurations as quickly as possible to the next rung level, even if this means promoting some wrong ones.bubuIn practice, this usually does not hurt much, and the gains of asynchronous versus synchronous scheduling are usually much higher than the loss of the suboptimal decision making. Discussions273.bubu273

20
Generative Adversarial Networks
20.1 Generative Adversarial Networks

Throughout most of this book, we have talked about how to make predictions. In some form or another, we used deep neural networks to learn mappings from data examples to labels. This kind of learning is called discriminative learning, as in, we‚Äôd like to be able to discriminate between photos of cats and photos of dogs. Classifiers and regressors are both examples of discriminative learning. And neural networks trained by backpropaga- tion have upended everything we thought we knew about discriminative learning on large complicated datasets. Classification accuracies on high-res images have gone from useless to human-level (with some caveats) in just 5-6 years. We will spare you another spiel about all the other discriminative tasks where deep neural networks do astoundingly well. But there is more to machine learning than just solving discriminative tasks. For example, given a large dataset, without any labels, we might want to learn a model that concisely captures the characteristics of this data. Given such a model, we could sample synthetic data examples that resemble the distribution of the training data. For example, given a large corpus of photographs of faces, we might want to be able to generate a new photorealistic image that looks like it might plausibly have come from the same dataset. This kind of learning is called generative modeling. Until recently, we had no method that could synthesize novel photorealistic images. But the success of deep neural networks for discriminative learning opened up new possibilities. One big trend over the last three years has been the application of discriminative deep nets to overcome challenges in problems that we do not generally think of as supervised learningproblems. Therecurrentneuralnetworklanguagemodelsareoneexampleofusing a discriminative network (trained to predict the next character) that once trained can act as a generative model. In 2014, a breakthrough paper introduced Generative adversarial networks (GANs) (Good- fellow et al., 2014), a clever new way to leverage the power of discriminative models to get good generative models. At their heart, GANs rely on the idea that a data generator is good if we cannot tell fake data apart from real data. In statistics, this is called a two-sample test - a test to answer the question whether datasets ùëã = fùë•1, . .bubu.,ùë•ùëõg and ùëã0 = fùë•0 1 , . .bubu.,ùë•0 were drawn from the same distribution. The main difference between most statistics papers ùëõg
880
Generative Adversarial Networks
881

and GANs is that the latter use this idea in a constructive way. In other words, rather than just training a model to say ‚Äúhey, these two datasets do not look like they came from the same distribution‚Äù, they use the two-sample test274 to provide training signals to a gener- ative model. This allows us to improve the data generator until it generates something that resembles the real data. At the very least, it needs to fool the classifier even if our classifier is a state of the art deep neural network. 274
Is real or fake F Discriminator ZS Fake G(z) Real x f Generator t Noise z
tFig. 20.1.1 Generative Adversarial Networks
The GAN architecture is illustrated in Fig. 20.1.1. As you can see, there are two pieces in GAN architecture - first off, we need a device (say, a deep network but it really could be anything, such as a game rendering engine) that might potentially be able to generate data that looks just like the real thing. If we are dealing with images, this needs to generate images. If we are dealing with speech, it needs to generate audio sequences, and so on. We call this the generator network. The second component is the discriminator network. It attemptstodistinguishfakeandreal datafromeachother. Bothnetworksareincompetition with each other. The generator network attempts to fool the discriminator network. At that point, the discriminator network adapts to the new fake data. This information, in turn is used to improve the generator network, and so on. The discriminator is a binary classifier to distinguish if the input ùë• is real (from real data) or
The discriminator is a binary classifier to distinguish if the input x is real (from real data) or fake (from the generator). Typically, the discriminator outputs a scalar prediction o ‚Ç¨ R for input x, such as using a fully connected layer with hidden size 1, and then applies sigmoid function to obtain the predicted probability D(x) = 1/(1 + e~¬∞). Assume the label y for the true data is 1 and 0 for the fake data. We train the discriminator to minimize the cross-entropy loss, i.e.,
min{‚Äîy log D(x) ~ (1 ‚Äî y) log(1 ‚Äî D@))}, (20.1.1)
For the generator, it first draws some parameter z ‚Ç¨ R@ from a source of randomness, e.g., a normal distribution z ~ N(0, 1). We often call z as the latent variable. It then applies a function to generate x‚Äô = G(z). The goal of the generator is to fool the discriminator to classify x‚Äô = G(z) as true data, i.e, we want D(G(z)) ~ 1. In other words, for a given discriminator D, we update the parameters of the generator G to maximize the cross- entropy loss when y = 0, i.e.,
max{‚Äî(1 ‚Äî y) log(1 ‚Äî D(G(z)))} = max{‚Äîlog(1 ‚Äî D(G(z)))}. (20.1.2)
If the generator does a perfect job, then D(x‚Äô) ~ 1, so the above loss is near 0, which
Generative Adversarial Networks
882

results in the gradients that are too small to make good progress for the discriminator. So commonly, we minimize the following loss:
min{‚Äîy log(D(G(z)))} = min{‚Äî log(D(G(z)))}, (20.1.3)
which is just feeding x0 = ùê∫‚Äûz‚Äù into the discriminator but giving label ùë¶ = 1. To sum up, ùê∑ and ùê∫ are playing a ‚Äúminimax‚Äù game with the comprehensive objective
function:
min max{‚ÄîE x~pata log D(x) ‚Äî Ez~Noise log(1 ‚Äî D(G(z)))}- (20.1.4)
Many of the GANs applications are in the context of images. As a demonstration purpose, we are going to content ourselves with fitting a much simpler distribution first. We will illustrate what happens if we use GANs to build the world‚Äôs most inefficient estimator of parameters for a Gaussian. Let‚Äôs get started. %matplotlib inline import torch from torch import nn from d2l import torch as d2l
20.1.1 Generate Some ‚ÄúReal‚Äù Data
Since this is going to be the world‚Äôs lamest example, we simply generate data drawn from a Gaussian. X = torch.normal(0.0, 1, (1000, 2)) A = torch.tensor([[1, 2], [-0.1, 0.5]]) b = torch.tensor([1, 2]) data = torch.matmul(X, A) + b
Let‚Äôs see what we got. This should be a Gaussian shifted in some rather arbitrary way with mean ùëè and covariance matrix ùê¥ùëáùê¥. d2l.set_figsize() d2l.plt.scatter(data[:100, (0)].detach().numpy(), data[:100, (1)].detach(). ‚Ü©!numpy()); print(f'The covariance matrix is\n{torch.matmul(A.T, A)}')
The covariance matrix is tensor([[1.0100, 1.9500], [1.9500, 4.2500]])
batch_size = 8 data_iter = d2l.load_array((data,), batch_size)
Generative Adversarial Networks
883

6 4 2 0 -2 ee e -4i¬Æ -2 0 2
20.1.2 Generator
Our generator network will be the simplest network possible - a single layer linear model. This is since we will be driving that linear network with a Gaussian data generator. Hence, it literally only needs to learn the parameters to fake things perfectly. net_G = nn.Sequential(nn.Linear(2, 2))
20.1.3 Discriminator
For the discriminator we will be a bit more discriminating: we will use an MLP with 3 layers to make things a bit more interesting. net_D = nn.Sequential( nn.Linear(2, 5), nn.Tanh(), nn.Linear(5, 3), nn.Tanh(), nn.Linear(3, 1))
20.1.4 Training
First we define a function to update the discriminator. #@save def update_D(X, Z, net_D, net_G, loss, trainer_D): """Update discriminator.""" batch_size = X.shape[0] ones = torch.ones((batch_size,), device=X.device) zeros = torch.zeros((batch_size,), device=X.device) trainer_D.zero_grad() real_Y = net_D(X) fake_X = net_G(Z) # Do not need to compute gradient for `net_G`, detach it from # computing gradients. fake_Y = net_D(fake_X.detach()) loss_D = (loss(real_Y, ones.reshape(real_Y.shape)) + loss(fake_Y, zeros.reshape(fake_Y.shape))) / 2 loss_D.backward() trainer_D.step() return loss_D
Generative Adversarial Networks
884

The generator is updated similarly. Here we reuse the cross-entropy loss but change the label of the fake data from 0 to 1. #@save def update_G(Z, net_D, net_G, loss, trainer_G): """Update generator.""" batch_size = Z.shape[0] ones = torch.ones((batch_size,), device=Z.device) trainer_G.zero_grad() # We could reuse `fake_X` from `update_D` to save computation fake_X = net_G(Z) # Recomputing `fake_Y` is needed since `net_D` is changed fake_Y = net_D(fake_X) loss_G = loss(fake_Y, ones.reshape(fake_Y.shape)) loss_G.backward() trainer_G.step() return loss_G
Both the discriminator and the generator performs a binary logistic regression with the cross-entropy loss. We use Adam to smooth the training process. In each iteration, we first update the discriminator and then the generator. We visualize both losses and generated examples. def train(net_D, net_G, data_iter, num_epochs, lr_D, lr_G, latent_dim, data): loss = nn.BCEWithLogitsLoss(reduction='sum') for w in net_D.parameters(): nn.init.normal_(w, 0, 0.02) for w in net_G.parameters(): nn.init.normal_(w, 0, 0.02) trainer_D = torch.optim.Adam(net_D.parameters(), lr=lr_D) trainer_G = torch.optim.Adam(net_G.parameters(), lr=lr_G) animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[1, num_epochs], nrows=2, figsize=(5, 5), legend=['discriminator', 'generator']) animator.fig.subplots_adjust(hspace=0.3) for epoch in range(num_epochs): # Train one epoch timer = d2l.Timer() metric = d2l.Accumulator(3) # loss_D, loss_G, num_examples for (X,) in data_iter: batch_size = X.shape[0] Z = torch.normal(0, 1, size=(batch_size, latent_dim)) metric.add(update_D(X, Z, net_D, net_G, loss, trainer_D), update_G(Z, net_D, net_G, loss, trainer_G), batch_size) # Visualize generated examples Z = torch.normal(0, 1, size=(100, latent_dim)) fake_X = net_G(Z).detach().numpy() animator.axes[1].cla() animator.axes[1].scatter(data[:, 0], data[:, 1]) animator.axes[1].scatter(fake_X[:, 0], fake_X[:, 1]) animator.axes[1].legend(['real', 'generated']) # Show the losses loss_D, loss_G = metric[0]/metric[2], metric[1]/metric[2]
(continues on next page)
Generative Adversarial Networks
885

animator.add(epoch + 1, (loss_D, loss_G)) print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, ' f'{metric[2] / timer.stop():.1f} examples/sec')
Now we specify the hyperparameters to fit the Gaussian distribution. lr_D, lr_G, latent_dim, num_epochs = 0.05, 0.005, 2, 20 train(net_D, net_G, data_iter, num_epochs, lr_D, lr_G, latent_dim, data[:100].detach().numpy())
loss_D 0.693, loss_G 0.693, 1020.0 examples/sec
14f. ‚Äî discriminator 124+. --- generator 1.0 loss 08 0.6 0.4 61 @ real @ generated 4 2 ¬∞ ¬´ = ee ? ee? -4L¬Æ -2 -1 0 1 2 3
20.1.5 Summary
Generative adversarial networks (GANs) composes of two deep networks, the generator
and the discriminator. The generator generates the image as much closer to the true image as possible to fool
the discriminator, via maximizing the cross-entropy loss, i.e., maxlog‚Äûùê∑‚Äûx0‚Äù‚Äù. The discriminator tries to distinguish the generated images from the true images, via
The discriminator tries to distinguish the generated images from the true images, via minimizing the cross-entropy loss, i.e., min ‚Äîy log D(x) ‚Äî (1 ‚Äî y) log(1 ‚Äî D(x)). 20.1.6 Exercises
e Does an equilibrium exist where the generator wins, i.e. the discriminator ends up unable
to distinguish the two distributions on finite samples? 275
Discussions275. (continued from previous page)
Generative Adversarial Networks
886

20.2 Deep Convolutional Generative Adversarial Networks

In Section 20.1, we introduced the basic ideas behind how GANs work. We showed that they can draw samples from some simple, easy-to-sample distribution, like a uniform or normal distribution, and transform them into samples that appear to match the distribution of some dataset. And while our example of matching a 2D Gaussian distribution got the point across, it is not especially exciting. In this section, we will demonstrate how you can use GANs to generate photorealistic im- ages. We will be basing our models on the deep convolutional GANs (DCGAN) introduced in Radford et al. (2015). We will borrow the convolutional architecture that have proven so successful for discriminative computer vision problems and show how via GANs, they can be leveraged to generate photorealistic images. import warnings import torch import torchvision from torch import nn from d2l import torch as d2l
20.2.1 The Pokemon Dataset
The dataset we will use is a collection of Pokemon sprites obtained from pokemondb276. First download, extract and load this dataset. 276

#@save d2l.DATA_HUB['pokemon'] = (d2l.DATA_URL + 'pokemon.zip', 'c065c0e2593b8b161a2d7873e42418bf6a21106c') data_dir = d2l.download_extract('pokemon') pokemon = torchvision.datasets.ImageFolder(data_dir)
Downloading ../data/pokemon.zip from http://d2l-data.s3-accelerate.amazonaws. ‚Ü©!com/pokemon.zip... We resize each image into 64 x 64. The ToTensor transformation will project the pixel
We resize each image into 64 x 64. The ToTensor transformation will project the pixel value into [0, 1], while our generator will use the tanh function to obtain outputs in [-1, 1]. Therefore we normalize the data with 0.5 mean and 0.5 standard deviation to match the value range. batch_size = 256 transformer = torchvision.transforms.Compose([ torchvision.transforms.Resize((64, 64)),
(continues on next page)
Deep Convolutional Generative Adversarial Networks
887

torchvision.transforms.ToTensor(), torchvision.transforms.Normalize(0.5, 0.5) ]) pokemon.transform = transformer data_iter = torch.utils.data.DataLoader( pokemon, batch_size=batch_size, shuffle=True, num_workers=d2l.get_dataloader_workers())
Let‚Äôs visualize the first 20 images. warnings.filterwarnings('ignore') d2l.set_figsize((4, 4)) for X, y in data_iter: imgs = X[:20,:,:,:].permute(0, 2, 3, 1)/2+0.5 d2l.show_images(imgs, num_rows=4, num_cols=5) break


ep
ae



Da
>

20.2.2 The Generator
The generator needs to map the noise variable z 2 Rùëë, a length-ùëë vector, to a RGB image
The generator needs to map the noise variable z ¬¢ R@, a length-d vector, to a RGB image with width and height to be 6464. In Section 14.11 we introduced the fully convolutional network that uses transposed convolution layer (refer to Section 14.10) to enlarge input size. The basic block of the generator contains a transposed convolution layer followed by the batch normalization and ReLU activation. class G_block(nn.Module):
def __init__(self, out_channels, in_channels=3, kernel_size=4, strides=2, padding=1, **kwargs):
(continued from previous page)
D, Ga ~



GE
oa

2
‚Äúy

B
as
(continues on next page)
Generative Adversarial Networks
888

super(G_block, self).__init__(**kwargs) self.conv2d_trans = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, strides, padding, bias=False) self.batch_norm = nn.BatchNorm2d(out_channels) self.activation = nn.ReLU() def forward(self, X): return self.activation(self.batch_norm(self.conv2d_trans(X)))
In default, the transposed convolution layer uses a ùëò‚Ñé = ùëòùë§ = 4 kernel, a ùë†‚Ñé = ùë†ùë§ = 2
In default, the transposed convolution layer uses a kp = ky = 4 kernel, a sy, = sy = 2 strides, and a pn = pw = | padding. With a input shape of n, xn, = 16x 16, the generator block will double input‚Äôs width and height. ùëõ0
X By
ny, X By = [nkn ‚Äî tn - Ykn = 8n) ‚Äî 2Pal X [Cwkw ‚Äî tw ‚Äî Daw = Sw) - 2Pw] = [(kn + sn(th ‚Äî 1) _ 2p) x [(kw + Sw(My ‚Äî 1) _ 2pwl = [(442x (16-1) -2x 1] x [(44+2x (16-1) -2x 1] = 32 x 32. x = torch.zeros((2, 3, 16, 16)) g_blk = G_block(20) g_blk(x).shape
torch.Size([2, 20, 32, 32])
If changing the transposed convolution layer to a 4x4 kernel, 1 x 1 strides and zero padding. If changing the transposed convolution layer to a 4x4 kernel, 1 x 1 strides and zero padding. With a input size of 1 x 1, the output will have its width and height increased by 3 respec- tively. x = torch.zeros((2, 3, 1, 1)) g_blk = G_block(20, strides=1, padding=0) g_blk(x).shape
torch.Size([2, 20, 4, 4])
The generator consists of four basic blocks that increase input‚Äôs both width and height from 1 to 32. At the same time, it first projects the latent variable into 64 x 8 channels, and then halve the channels each time. At last, a transposed convolution layer is used to generate the output. It further doubles the width and height to match the desired 64 x 64 shape, and reduces the channel size to 3. The tanh activation function is applied to project output values into the (‚Äî1, 1) range. n_G = 64 net_G = nn.Sequential(
(continued from previous page)
(20.2.1)
(continues on next page)
Deep Convolutional Generative Adversarial Networks
889

G_block(in_channels=100, out_channels=n_G*8, strides=1, padding=0), # Output: (64 * 8, 4, 4) G_block(in_channels=n_G*8, out_channels=n_G*4), # Output: (64 * 4, 8, 8) G_block(in_channels=n_G*4, out_channels=n_G*2), # Output: (64 * 2, 16, 16) G_block(in_channels=n_G*2, out_channels=n_G), # Output: (64, 32, 32) nn.ConvTranspose2d(in_channels=n_G, out_channels=3, kernel_size=4, stride=2, padding=1, bias=False), nn.Tanh()) # Output: (3, 64, 64)
Generate a 100 dimensional latent variable to verify the generator‚Äôs output shape. x = torch.zeros((1, 100, 1, 1)) net_G(x).shape
torch.Size([1, 3, 64, 64])
20.2.3 Discriminator
The discriminator is a normal convolutional network network except that it uses a leaky ReLU as its activation function. Given ùõº 2 ¬ª0,1‚Ä¶, its definition is
leaky ReLU‚Äûùë•‚Äù = ùë• ùõºùë• if ùë• > 0 otherwise . (20.2.2)
As it can be seen, it is normal ReLU if ùõº = 0, and an identity function if ùõº = 1. For ùõº 2 ‚Äû0,1‚Äù, leaky ReLU is a nonlinear function that give a non-zero output for a negative input. Itaims tofixthe ‚ÄúdyingReLU‚Äùproblemthataneuron mightalwaysoutputanegative value and therefore cannot make any progress since the gradient of ReLU is 0. alphas = [0, .2, .4, .6, .8, 1] x = torch.arange(-2, 1, 0.1) Y = [nn.LeakyReLU(alpha)(x).detach().numpy() for alpha in alphas] d2l.plot(x.detach().numpy(), Y, 'x', 'y', alphas)
1.0 0.5
Thebasicblockofthediscriminatorisaconvolutionlayerfollowedbyabatchnormalization layerandaleakyReLUactivation. Thehyperparametersoftheconvolutionlayeraresimilar to the transpose convolution layer in the generator block. (continued from previous page)
(
Generative Adversarial Networks
890

class D_block(nn.Module): def __init__(self, out_channels, in_channels=3, kernel_size=4, strides=2, padding=1, alpha=0.2, **kwargs): super(D_block, self).__init__(**kwargs) self.conv2d = nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding, bias=False) self.batch_norm = nn.BatchNorm2d(out_channels) self.activation = nn.LeakyReLU(alpha, inplace=True) def forward(self, X): return self.activation(self.batch_norm(self.conv2d(X)))
A basic block with default settings will halve the width and height of the inputs, as we demonstrated in Section 7.3. For example, given a input shape ùëõ‚Ñé = ùëõùë§ = 16, with a kernel shape ùëò‚Ñé = ùëòùë§ = 4, a stride shape ùë†‚Ñé = ùë†ùë§ = 2, and a padding shape ùëù‚Ñé = ùëùùë§ = 1, the output shape will be:
ùëõ0
X My
ny, X My = Lan ‚Äî kn + 2p + $n)/Sn] X (tw ‚Äî kw + 2pw + Sw)/Sw] =((16-44+2x1+4+2)/2] x |(6-44+2x 1+2)/2] =8x8. (20.2.3)
x = torch.zeros((2, 3, 16, 16)) d_blk = D_block(20) d_blk(x).shape
torch.Size([2, 20, 8, 8])
The discriminator is a mirror of the generator. n_D = 64 net_D = nn.Sequential( D_block(n_D), # Output: (64, 32, 32) D_block(in_channels=n_D, out_channels=n_D*2), # Output: (64 * 2, 16, 16) D_block(in_channels=n_D*2, out_channels=n_D*4), # Output: (64 * 4, 8, 8) D_block(in_channels=n_D*4, out_channels=n_D*8), # Output: (64 * 8, 4, 4) nn.Conv2d(in_channels=n_D*8, out_channels=1, kernel_size=4, bias=False)) # Output: (1, 1, 1)
Itusesaconvolutionlayerwithoutputchannel1asthelastlayertoobtainasingleprediction value. x = torch.zeros((1, 3, 64, 64)) net_D(x).shape
torch.Size([1, 1, 1, 1])
20.2.4 Training
Deep Convolutional Generative Adversarial Networks
891

Compared to the basic GAN in Section 20.1, we use the same learning rate for both gen- erator and discriminator since they are similar to each other. In addition, we change ùõΩ1 in Adam (Section 12.10) from 0.9 to 0.5. It decreases the smoothness of the momentum, the exponentially weighted moving average of past gradients, to take care of the rapid changing gradients because the generator and the discriminator fight with each other. Besides, the random generated noise Z, is a 4-D tensor and we are using GPU to accelerate the compu- tation. def train(net_D, net_G, data_iter, num_epochs, lr, latent_dim, device=d2l.try_gpu()): loss = nn.BCEWithLogitsLoss(reduction='sum') for w in net_D.parameters(): nn.init.normal_(w, 0, 0.02) for w in net_G.parameters(): nn.init.normal_(w, 0, 0.02) net_D, net_G = net_D.to(device), net_G.to(device) trainer_hp = {'lr': lr, 'betas': [0.5,0.999]} trainer_D = torch.optim.Adam(net_D.parameters(), **trainer_hp) trainer_G = torch.optim.Adam(net_G.parameters(), **trainer_hp) animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[1, num_epochs], nrows=2, figsize=(5, 5), legend=['discriminator', 'generator']) animator.fig.subplots_adjust(hspace=0.3) for epoch in range(1, num_epochs + 1): # Train one epoch timer = d2l.Timer() metric = d2l.Accumulator(3) # loss_D, loss_G, num_examples for X, _ in data_iter: batch_size = X.shape[0] Z = torch.normal(0, 1, size=(batch_size, latent_dim, 1, 1)) X, Z = X.to(device), Z.to(device) metric.add(d2l.update_D(X, Z, net_D, net_G, loss, trainer_D), d2l.update_G(Z, net_D, net_G, loss, trainer_G), batch_size) # Show generated examples Z = torch.normal(0, 1, size=(21, latent_dim, 1, 1), device=device) # Normalize the synthetic data to N(0, 1) fake_x = net_G(Z).permute(0, 2, 3, 1) / 2 + 0.5 imgs = torch.cat( [torch.cat([ fake_x[i * 7 + j].cpu().detach() for j in range(7)], dim=1) for i in range(len(fake_x)//7)], dim=0) animator.axes[1].cla() animator.axes[1].imshow(imgs) # Show the losses loss_D, loss_G = metric[0] / metric[2], metric[1] / metric[2] animator.add(epoch, (loss_D, loss_G)) print(f'loss_D {loss_D:.3f}, loss_G {loss_G:.3f}, ' f'{metric[2] / timer.stop():.1f} examples/sec on {str(device)}')
We train the model with a small number of epochs just for demonstration. For better per- formance, the variable num_epochs can be set to a larger number. Generative Adversarial Networks
892

latent_dim, lr, num_epochs = 100, 0.005, 20 train(net_D, net_G, data_iter, num_epochs, lr, latent_dim)
loss_D 0.023, loss_G 7.359, 2292.7 examples/sec on cuda:0
N a= poe Nee receet < ete a oe Oa Lee j-+->
: ‚Äî discriminator
64
--- generator
a4 3
24
oS RGM GB "RED Bie
0
50
100 150 200 250 300 350 400
20.2.5 Summary
DCGAN architecture has four convolutional layers for the Discriminator and four ‚Äúfractionally-
strided‚Äù convolutional layers for the Generator. The Discriminator is a 4-layer strided convolutions with batch normalization (except its
input layer) and leaky ReLU activations. Leaky ReLU is a nonlinear function that give a non-zero output for a negative input. It
aims to fix the ‚Äúdying ReLU‚Äù problem and helps the gradients flow easier through the architecture. 20.2.6 Exercises
1. What will happen if we use standard ReLU activation rather than leaky ReLU? 2. Apply DCGAN on Fashion-MNIST and see which category works well and which does not.bubuDiscussions277. 277 
21  Recommender Systems 
Shuai Zhang (Amazon), Aston Zhang (Amazon), and Yi Tay (Google)
Recommender systems are widely employed in industry and are ubiquitous in our daily lives. These systems are utilized in a number of areas such as online shopping sites (e.g., amazon.com), music/movie services site (e.g., Netflix and Spotify), mobile application stores (e.g., IOS app store and google play), online advertising, just to name a few. The major goal of recommender systems is to help users discover relevant items such as movies to watch, text to read or products to buy, so as to create a delightful user experience. Moreover, recommender systems are among the most powerful machine learning systems that online retailers implement in order to drive incremental revenue. Recommender sys- tems are replacements of search engines by reducing the efforts in proactive searches and surprising users with offers they never searched for. Many companies managed to position themselves ahead of their competitors with the help of more effective recommender sys- tems. As such, recommender systems are central to not only our everyday lives but also highly indispensable in some industries. Inthis chapter, wewill coverthe fundamentals and advancements of recommendersystems, alongwithexploringsomecommonfundamentaltechniquesforbuildingrecommendersys- tems with different data sources available and their implementations. Specifically, you will learn how to predict the rating a user might give to a prospective item, how to generate a recommendation list of items and how to predict the click-through rate from abundant fea- tures. These tasks are commonplace in real-world applications. By studying this chapter, you will get hands-on experience pertaining to solving real world recommendation prob- lems with not only classical methods but the more advanced deep learning based models as well. 21.1 Overview of Recommender Systems
ee
In the last decade, the Internet has evolved into a platform for large-scale online services, which profoundly changed the way we communicate, read news, buy products, and watch movies. Inthemeanwhile, theunprecedentednumberofitems(weusethetermitemtorefer to movies, news, books, and products.) offered online requires a system that can help us discoveritemsthatwepreferred. Recommendersystemsarethereforepowerfulinformation
893
Recommender Systems
894

filtering tools that can facilitate personalized services and provide tailored experience to individual users. In short, recommender systems play a pivotal role in utilizing the wealth of data available to make choices manageable. Nowadays, recommender systems are at the core of a number of online services providers such as Amazon, Netflix, and YouTube. Recall the example of Deep learning books recommended by Amazon in Fig. 1.3.3. The benefits of employing recommender systems are two-folds: On the one hand, it can largely reduce users‚Äô effort in finding items and alleviate the issue of information overload. On the other hand, it can add business value to online service providers and is an important source of revenue. This chapter will introduce the fundamental concepts, classic models and recent advances with deep learning in the field of recommender systems, together with implemented examples. User Feedback
tFig. 21.1.1
Illustration of the Recommendation Process
21.1.1 Collaborative Filtering
We start the journey with the important concept in recommender systems‚Äîcollaborative filtering (CF), which was first coined by the Tapestry system (Goldberg et al., 1992), re- ferring to ‚Äúpeople collaborate to help one another perform the filtering process in order to handle the large amounts of email and messages posted to newsgroups‚Äù. This term has been enriched with more senses. In a broad sense, it is the process of filtering for information or patterns using techniques involving collaboration among multiple users, agents, and data sources. CF has many forms and numerous CF methods proposed since its advent. Overall, CF techniques can be categorized into: memory-based CF, model-based CF, and their hybrid (Su and Khoshgoftaar, 2009). Representative memory-based CF techniques are nearest neighbor-based CF such as user-based CF and item-based CF (Sarwar et al., 2001). Latent factor models such as matrix factorization are examples of model-based CF. Memory-based CF has limitations in dealing with sparse and large-scale data since it com- putes the similarity values based on common items. Model-based methods become more popular with its better capability in dealing with sparsity and scalability. Many model- based CF approaches can be extended with neural networks, leading to more flexible and scalable models with the computation acceleration in deep learning (Zhang et al., 2019). In general, CF only uses the user-item interaction data to make predictions and recom- mendations. Besides CF, content-based and context-based recommender systems are also useful in incorporating the content descriptions of items/users and contextual signals such
Overview of Recommender Systems
895

as timestamps and locations. Obviously, we may need to adjust the model types/structures when different input data is available. 21.1.2 Explicit Feedback and Implicit Feedback
To learn the preference of users, the system shall collect feedback from them. The feedback can be either explicit or implicit (Hu et al., 2008). For example, IMDb 278 collects star ratings ranging from one to ten stars for movies. YouTube provides the thumbs-up and thumbs-down buttons for users to show their preferences. It is apparent that gathering explicit feedback requires users to indicate their interests proactively. Nonetheless, explicit feedback is not always readily available as many users may be reluctant to rate products. Relativelyspeaking, implicitfeedbackisoftenreadilyavailablesinceitismainlyconcerned with modeling implicit behavior such as user clicks. As such, many recommender systems are centered on implicit feedback which indirectlyreflects user‚Äôs opinion through observing user behavior. There are diverse forms of implicit feedback including purchase history, browsing history, watches and even mouse movements. For example, a user that purchased many books by the same author probably likes that author. Note that implicit feedback is inherently noisy. We can only guess their preferences and true motives. A user watched a movie does not necessarily indicate a positive view of that movie. 278 
21.1.3 Recommendation Tasks
A number of recommendation tasks have been investigated in the past decades. Based on the domain of applications, there are movies recommendation, news recommendations, point-of-interest recommendation (Ye et al., 2011) and so forth. It is also possible to dif- ferentiate the tasks based on the types of feedback and input data, for example, the rating prediction task aims to predict the explicit ratings. Top-ùëõ recommendation (item ranking) ranks all items for each user personally based on the implicit feedback. If time-stamp infor- mation is also included, we can build sequence-aware recommendation (Quadrana et al., 2018). Another popular task is called click-through rate prediction, which is also based on implicit feedback, but various categorical features can be utilized. Recommending for new users and recommending new items to existing users are called cold-start recommendation (Schein et al., 2002). 21.1.4 Summary
e Recommender systems are important for individual users and industries. Collaborative
filtering is a key concept in recommendation. e There are two types of feedbacks: implicit feedback and explicit feedback. A number of
recommendation tasks have been explored during the last decade. 21.1.5 Exercises
1. Can you explain how recommender systems influence your daily life? 2. What interesting recommendation tasks do you think can be investigated?bubu896

Discussions279. 279
Recommender Systems
Mathematics for Deep Learning
A
Brent Werness (Amazon), Rachel Hu (Amazon), and authors of this book
One of the wonderful parts of modern deep learning is the fact that much of it can be understood and used without a full understanding of the mathematics below it. This is a sign that the field is maturing. Just as most software developers no longer need to worry about the theory of computable functions, neither should deep learning practitioners need to worry about the theoretical foundations of maximum likelihood learning. But, we are not quite there yet. In practice, you will sometimes need to understand how architectural choices influence gradient flow, or the implicit assumptions you make by training with a certain loss function. You might need to know what in the world entropy measures, and how it can help you understand exactly what bits-per-character means in your model. These all require deeper mathematical understanding. This appendix aims to provide you the mathematical background you need to understand the core theory of modern deep learning, but it is not exhaustive. We will begin with examining linear algebra in greater depth. We develop a geometric understanding of all the common linear algebraic objects and operations that will enable us to visualize the effects of various transformations on our data. A key element is the development of the basics of eigen-decompositions. We next develop the theory of differential calculus to the point that we can fully understand why the gradient is the direction of steepest descent, and why back-propagation takes the form it does. Integral calculus is then discussed to the degree needed to support our next topic, probability theory. Problems encountered in practice frequently are not certain, and thus we need a language to speak about uncertain things. We review the theory of random variables and the most com- monly encountered distributions so we may discuss models probabilistically. This provides the foundation for the naive Bayes classifier, a probabilistic classification technique. Closely related to probability theory is the study of statistics. While statistics is far too large a field to do justice in a short section, we will introduce fundamental concepts that all machine learning practitioners should be aware of, in particular: evaluating and comparing estimators, conducting hypothesis tests, and constructing confidence intervals. Last, we turn to the topic of information theory, which is the mathematical study of infor-
897
Mathematics for Deep Learning
898

mation storage and transmission. This provides the core language by which we may discuss quantitatively how much information a model holds on a domain of discourse. Taken together, these form the core of the mathematical concepts needed to begin down the path towards a deep understanding of deep learning. A.1 Geometry and Linear Algebraic Operations
a
In Section 2.3, we encountered the basics of linear algebra and saw how it could be used to express common operations for transforming our data. Linear algebra is one of the key mathematical pillars underlying much of the work that we do in deep learning and in ma- chine learning more broadly. While Section 2.3 contained enough machinery to commu- nicate the mechanics of modern deep learning models, there is a lot more to the subject. In this section, we will go deeper, highlighting some geometric interpretations of linear algebra operations, and introducing a few fundamental concepts, including of eigenvalues and eigenvectors. A.1.1 Geometry of Vectors
First, we need to discuss the two common geometric interpretations of vectors, as either points or directions in space. Fundamentally, a vector is a list of numbers such as the Python list below. v = [1, 7, 0, 1]
Mathematicians most often write this as either a column or row vector, which is to say either as
or
x> =
1 7 0 1 . (A.2)
These often have different interpretations, where data examples are column vectors and weights used to form weighted sums are row vectors. However, it can be beneficial to be flexible. As we have described in Section 2.3, though a single vector‚Äôs default orientation is a column vector, for any matrix representing a tabular dataset, treating each data example as a row vector in the matrix is more conventional. Given a vector, the first interpretation that we should give it is as a point in space. In two or three dimensions, we can visualize these points by using the components of the vectors
2
3
x = 6 6 6 6 6 6 4 1 7 0 1 7 7 7 7 7 7 5 , (A.1)
Geometry and Linear Algebraic Operations
899

to define the location of the points in space compared to a fixed reference called the origin. This can be seen in Fig.bubuA.1. tFig. A.1
An illustration of visualizing vectors as points in the plane. The Ô¨Årst component of the vector gives the x-coordinate, the second component gives the y-coordinate. Higher dimensions are analogous, although much harder to visualize. This geometric point of view allows us to consider the problem on a more abstract level. No longer faced with some insurmountable seeming problem like classifying pictures as either cats or dogs, we can start considering tasks abstractly as collections of points in space and picturing the task as discovering how to separate two distinct clusters of points. In parallel, there is a second point of view that people often take of vectors: as directions in space. Not only can we think of the vector v = ¬ª3,2‚Ä¶> as the location 3 units to the right and 2 units up from the origin, we can also think of it as the direction itself to take 3 steps to the right and 2 steps up. In this way, we consider all the vectors in figure Fig.bubuA.2 the same. tFig. A.2
Any vector can be visualized as an arrow in the plane. In this case, every vector drawn is a representation of the vector ‚Äû3,2‚Äù>. One of the benefits of this shift is that we can make visual sense of the act of vector addition. In particular, we follow the directions given by one vector, and then follow the directions given by the other, as is seen in Fig. A.3. Vector subtraction has a similar interpretation. By considering the identity that u = v ‚Äö
Vector subtraction has a similar interpretation. By considering the identity that u = v + (u ‚Äî v), we see that the vector u ‚Äî v is the direction that takes us from the point v to the point u. A.1.2 Dot Products and Angles
Mathematics for Deep Learning
900


tFig. A.3
We can visualize vector addition by Ô¨Årst following one vector, and then another. As we saw in Section 2.3, if we take two column vectors u and v, we can form their dot product by computing:
uv = lui vi. (A.3)
Because (A.3) is symmetric, we will mirror the notation of classical multiplication and write
u-v=ulv=v'u,
(A.4)
tohighlightthefactthatexchangingtheorderofthevectorswillyieldthesameanswer. The dot product (A.3) also admits a geometric interpretation: it is closely related to the angle between two vectors. Consider the angle shown in Fig.bubuA.4. tFig. A.4
Between any two vectors in the plane there is a well deÔ¨Åned angle ùúÉ. We will see this
angle is intimately tied to the dot product. To start, let‚Äôs consider two specific vectors:
v = ‚Äûùëü,0‚Äù and w = ‚Äûùë† cos‚ÄûùúÉ‚Äù, ùë† sin‚ÄûùúÉ‚Äù‚Äù. (A.5)
The vector v is length ùëü and runs parallel to the ùë•-axis, and the vector w is of length ùë†
and at angle ùúÉ with the ùë•-axis. If we compute the dot product of these two vectors, we see that
v-w=rscos(@) = ||v||||w]| cos(@). (A.6)
With some simple algebraic manipulation, we can rearrange terms to obtain
ùúÉ = arccos . kvkkwk (A.7)
Geometry and Linear Algebraic Operations
901

In short, for these two specific vectors, the dot product combined with the norms tell us the angle between the two vectors. This same fact is true in general. We will not derive the expression here, however, if we consider writing ||v ‚Äî wl|? in two ways: one with the dot product, and the other geometrically using the law of cosines, we can obtain the full relationship. Indeed, for any two vectors v and w, the angle between the two vectors is
6 = arccos (Gol : (A.8) lviiliwil
This is a nice result since nothing in the computation references two-dimensions. Indeed, we can use this in three or three million dimensions without issue. As a simple example, let‚Äôs see how to compute the angle between a pair of vectors:
%matplotlib inline import torch import torchvision from IPython import display from torchvision import transforms from d2l import torch as d2l def angle(v, w): return torch.acos(v.dot(w) / (torch.norm(v) * torch.norm(w)))
angle(torch.tensor([0, 1, 2], dtype=torch.float32), torch.tensor([2.0, 3, 4]))
tensor(0.4190)
We will not use it right now, but it is useful to know that we will refer to vectors for which the angle is 2/2 (or equivalently 90¬∞) as being orthogonal. By examining the equation above, we see that this happens when 6 = 7/2, which is the same thing as cos(@) = 0. The only way this can happen is if the dot product itself is zero, and two vectors are orthogonal if and only if v- w = 0. This will prove to be a helpful formula when understanding objects geometrically. It is reasonable to ask: why is computing the angle useful? The answer comes in the kind of invariance we expect data to have. Consider an image, and a duplicate image, where every pixel value is the same but 10% the brightness. The values of the individual pixels are in general far from the original values. Thus, if one computed the distance between the original image and the darker one, the distance can be large. However, for most ML applications, the content is the same‚Äîit is still an image of a cat as far as a cat/dog classifier is concerned. However, if we consider the angle, it is not hard to see that for any vector v, the angle between v and 0.1 - v is zero. This corresponds to the fact that scaling vectors keeps the same direction and just changes the length. The angle considers the darker image identical. Examples like this are everywhere. In text, we might want the topic being discussed to not change if we write twice as long of document that says the same thing. For some
Mathematics for Deep Learning
902

encoding (such as counting the number of occurrences of words in some vocabulary), this corresponds to a doubling of the vector encoding the document, so again we can use the angle. Cosine Similarity
In ML contexts where the angle is employed to measure the closeness of two vectors, prac- titioners adopt the term cosine similarity to refer to the portion
cos‚ÄûùúÉ‚Äù = kvkkwk . (A.9)
The cosine takes a maximum value of 1 when the two vectors point in the same direction, a minimum value of ‚Äî1 when they point in opposite directions, and a value of 0 when the two vectors are orthogonal. Note that if the components of high-dimensional vectors are sampled randomly with mean 0, their cosine will nearly always be close to 0. A.1.3 Hyperplanes
In addition to working with vectors, another key object that you must understand to go far in linear algebra is the hyperplane, a generalization to higher dimensions of a line (two di- mensions) or of a plane (three dimensions). In an d-dimensional vector space, a hyperplane has d ‚Äî | dimensions and divides the space into two half-spaces. Let‚Äôs start with an example.bubuSuppose that we have a column vector w = ¬ª2,1‚Ä¶>. We want
Let‚Äôs start with an example. Suppose that we have a column vector w = [2, 1]'. We want to know, ‚Äúwhat are the points v with w- v = 1?‚Äù By recalling the connection between dot products and angles above (A.8), we can see that this is equivalent to
kvkkwk cos‚ÄûùúÉ‚Äù = 1 () kvk cos‚ÄûùúÉ‚Äù = 1 kwk = 1 p 5 . (A.10)
IIvIl - cos(@) ‚Äô
tFig. A.5
Recalling trigonometry, we see the formula kvk cos‚ÄûùúÉ‚Äù is the length of the projection of
the vector v onto the direction of w
If we consider the geometric meaning of this expression, we see that this is equivalent to saying that the length of the projection of v onto the direction of w is exactly 1/||w||, as is shown in Fig. A.5.bubuThe set of all points where this is true is a line at right angles to the vector w. If we wanted, we could find the equation for this line and see that it is 2x + y = 1 or equivalently y = 1 ‚Äî 2x. vw
Geometry and Linear Algebraic Operations
903

If we now look at what happens when we ask about the set of points with w-v > 1 or
If we now look at what happens when we ask about the set of points with w-v > 1 or wv < 1, we can see that these are cases where the projections are longer or shorter than 1/|| w]|, respectively. Thus, those two inequalities define either side of the line. In this way, we have found a way to cut our space into two halves, where all the points on one side have dot product below a threshold, and the other side above as we see in Fig. A.6. vew<l 9 vew=1 vew>1
tFig. A.6
If we now consider the inequality version of the expression, we see that our hyperplane (in this case: just a line) separates the space into two halves. The story in higher dimension is much the same. If we now take w = ¬ª1,2,3‚Ä¶> and ask
The story in higher dimension is much the same. If we now take w = [1,2,3]* and ask about the points in three dimensions with w - v = 1, we obtain a plane at right angles to the given vector w. The two inequalities again define the two sides of the plane as is shown in Fig. A.7. vews1 vew>1
tFig. A.7
Hyperplanes in any dimension separate the space into two halves. While our ability to visualize runs out at this point, nothing stops us from doing this in tens, hundreds, or billions of dimensions. This occurs often when thinking about machine learned models. For instance, we can understand linear classification models like those from Section 4.1, as methods to find hyperplanes that separate the different target classes. In this context, such hyperplanes are often referred to as decision planes. The majority of deep learned classification models end with a linear layer fed into a softmax, so one can interpret the role of the deep neural network to be to find a non-linear embedding such that the target classes can be separated cleanly by hyperplanes. To give a hand-built example, notice that we can produce a reasonable model to classify tiny images of t-shirts and trousers from the Fashion-MNIST dataset (seen in Section 4.2) by just taking the vector between their means to define the decision plane and eyeball a crude threshold. First we will load the data and compute the averages. # Load in the dataset trans = []
(continues on next page)
Mathematics for Deep Learning
904

trans.append(transforms.ToTensor()) trans = transforms.Compose(trans) train = torchvision.datasets.FashionMNIST(root="../data", transform=trans, train=True, download=True) test = torchvision.datasets.FashionMNIST(root="../data", transform=trans, train=False, download=True) X_train_0 = torch.stack( [x[0] * 256 for x in train if x[1] == 0]).type(torch.float32) X_train_1 = torch.stack( [x[0] * 256 for x in train if x[1] == 1]).type(torch.float32) X_test = torch.stack( [x[0] * 256 for x in test if x[1] == 0 or x[1] == 1]).type(torch.float32) y_test = torch.stack([torch.tensor(x[1]) for x in test if x[1] == 0 or x[1] == 1]).type(torch.float32) # Compute averages ave_0 = torch.mean(X_train_0, axis=0) ave_1 = torch.mean(X_train_1, axis=0)
It can be informative to examine these averages in detail, so let‚Äôs plot what they look like. In this case, we see that the average indeed resembles a blurry image of a t-shirt. # Plot average t-shirt d2l.set_figsize() d2l.plt.imshow(ave_0.reshape(28, 28).tolist(), cmap='Greys') d2l.plt.show()

10
15
20
25
Inthesecondcase,weagainseethattheaverageresemblesablurryimageoftrousers. # Plot average trousers d2l.plt.imshow(ave_1.reshape(28, 28).tolist(), cmap='Greys') d2l.plt.show()
In a fully machine learned solution, we would learn the threshold from the dataset. In this case, I simply eyeballed a threshold that looked good on the training data by hand. # Print test set accuracy with eyeballed threshold w = (ave_1 - ave_0).T
(continued from previous page)
(continues on next page)
Geometry and Linear Algebraic Operations
905


10
15
20
25
# '@' is Matrix Multiplication operator in pytorch. predictions = X_test.reshape(2000, -1) @ (w.flatten()) > -1500000
# Accuracy
torch.mean((predictions.type(y_test.dtype) == y_test).float(), dtype=torch. ‚Ü©!float64)
tensor(0.7870, dtype=torch.float64)
A.1.4 Geometry of Linear Transformations
Through Section 2.3 and the above discussions, we have a solid understanding of the geom- etry of vectors, lengths, and angles. However, there is one important object wehaveomitted discussing, and that is a geometric understanding of linear transformations represented by matrices. Fully internalizing what matrices can do to transform data between two poten- tially different high dimensional spaces takes significant practice, and is beyond the scope of this appendix. However, we can start building up intuition in two dimensions. Suppose that we have some matrix:
A = ùëé ùëê ùëè ùëë . (A.11)
If we want to apply this to an arbitrary vector v = ¬ªùë•, ùë¶‚Ä¶>, we multiply and see that
hl y _ jax+ by ~ lex +dy -+{{J-¬ª [i -abllots th a b Av=|‚Äô d (A.12)
This may seem like an odd computation, where something clear became somewhat impen- etrable. However, it tells us that we can write the way that a matrix transforms any vector
(continued from previous page)
Mathematics for Deep Learning
906

in terms of how it transforms two specific vectors: ¬ª1,0‚Ä¶> and ¬ª0,1‚Ä¶>. This is worth con-
sidering for a moment. We have essentially reduced an infinite problem (what happens to any pair of real numbers) to a finite one (what happens to these specific vectors). These vectors are an example a basis, where we can write any vector in our space as a weighted sum of these basis vectors. Let‚Äôs draw what happens when we use the specific matrix
A= [- ‚Äò|: (A.13)
If we look at the specific vector v = [2,‚Äî1]", we see this is 2 - [1,0]' +-1- [0,1]", and
If we look at the specific vector v = [2,‚Äî1]", we see this is 2 - [1,0]' +-1- [0,1]", and thus we know that the matrix A will send this to 2(A[1,0]")+‚Äî-1(A[0, 1])‚Ñ¢ =2[1,-1]'- [2,3]" = [0,-5]‚Ñ¢. If we follow this logic through carefully, say by considering the grid of all integer pairs of points, we see that what happens is that the matrix multiplication can skew, rotate, and scale the grid, but the grid structure must remain as you see in Fig. A8.bubuJa, 0)! A
tFig. A.8
The matrix A acting on the given basis vectors. Notice how the entire grid is transported along with it. This is the most important intuitive point to internalize about linear transformations rep- resented by matrices. Matrices are incapable of distorting some parts of space differently than others. All they can do is take the original coordinates on our space and skew, rotate, and scale them. Some distortions can be severe. For instance the matrix
2 -1
compresses the entire two-dimensional plane down to a single line. Identifying and working with such transformations are the topic of a later section, but geometrically we can see that this is fundamentally different from the types of transformations we saw above. For instance, the result from matrix A can be ‚Äúbent back‚Äù to the original grid. The results from matrix B cannot because we will never know where the vector [1,2] came from‚Äîwas it [1,1] or [0,-1]7? While this picture was for a 2x2 matrix, nothing prevents us from taking the lessons learned
into higher dimensions. If we take similar basis vectors like ¬ª1,0, . . .,0‚Ä¶ and see where our matrix sends them, we can start to get a feeling for how the matrix multiplication distorts the entire space in whatever dimension space we are dealing with. Geometry and Linear Algebraic Operations
907

A.1.5 Linear Dependence
Consider again the matrix
B= |; I. (A.15)
This compresses the entire plane down to live on the single line y = 2x. The question now arises: is there some way we can detect this just looking at the matrix itself? The answer is that indeed we can. Let‚Äôs take b, = [2,4]' and by = [-1, -2]‚Ñ¢ be the two columns of B. Remember that we can write everything transformed by the matrix B as a weighted sum of the columns of the matrix: like a,b, + ajb 2. We call this a linear combination. The fact that b; = ‚Äî2- by means that we can write any linear combination of those two columns entirely in terms of say bz since
a,b, + agb2 = ‚Äî2a;b2 + agb2 = (a2 ‚Äî 2a1)bo. (A.16)
This means that one of the columns is, in a sense, redundant because it does not define a unique direction in space. This should not surprise us too much since we already saw that this matrix collapses the entire plane down into a single line. Moreover, we see that the linear dependence b; = ‚Äî2- b2 captures this. To make this more symmetrical between the two vectors, we will write this as
b, +2-b2 =0. (A.17)
In general, we will say that a collection of vectors v1, .bubu. .,vùëò are linearly dependent if there exist coefficients ùëé1, . .bubu., ùëéùëò not all equal to zero so that
ùëéùëñvi = 0. ùëñ=1 (A.18)
In this case, we can solve for one of the vectors in terms of some combination of the others, and effectively render it redundant. Thus, a linear dependence in the columns of a matrix is a witness to the fact that our matrix is compressing the space down to some lower di- mension. If there is no linear dependence we say the vectors are linearly independent. If the columns of a matrix are linearly independent, no compression occurs and the operation can be undone. A.1.6 Rank
If we have a general n X m matrix, it is reasonable to ask what dimension space the matrix
maps into. A concept known as the rank will be our answer. In the previous section, we notedthatalineardependencebearswitnesstocompressionofspaceintoalowerdimension and so we will be able to use this to define the notion of rank. In particular, the rank of a matrix A is the largest number of linearly independent columns amongst all subsets of columns. For example, the matrix
B-|?bubu‚Äò|. (A.19)
k
Mathematics for Deep Learning
908

has rank‚Äûùêµ‚Äù = 1, since the two columns are linearly dependent, but either column by itself
is not linearly dependent. For a more challenging example, we can consider
2
1 3 0 -1 O -1 0 1 1 =! C=|5 394 0 ot (A.20) 2 3 -1 -2 1
and show that C has rank two since, for instance, the first two columns are linearly inde- pendent, however any of the four collections of three columns are dependent. This procedure, as described, is very inefficient. It requires looking at every subset of the columns of our given matrix, and thus is potentially exponential in the number of columns. Later we will see a more computationally efficient way to compute the rank of a matrix, but for now, this is sufficient to see that the concept is well defined and understand the meaning. A.1.7 Invertibility
We have seen above that multiplication by a matrix with linearly dependent columns cannot be undone, i.e., there is no inverse operation that can always recover the input. However, multiplication by a full-rank matrix (i.e., some A that is n x n matrix with rank n), we should always be able to undo it. Consider the matrix
I=].bubu(A.21)
which is the matrix with ones along the diagonal, and zeros elsewhere. We call this the identity matrix. It is the matrix which leaves our data unchanged when applied. To find a matrix which undoes what our matrix A has done, we want to find a matrix A~! such that
ATA=AATE=L (A.22)
If we look at this as a system, we have n x n unknowns (the entries of Av!) andnxn
If we look at this as a system, we have n x n unknowns (the entries of Av!) andnxn equations (the equality that needs to hold between every entry of the product A~'A and every entry of I) so we should generically expect a solution to exist. Indeed, in the next section we will see a quantity called the determinant, which has the property that as long as the determinant is not zero, we can find a solution. We call such a matrix A~! the inverse matrix. As an example, if A is the general 2 x 2 matrix
A = ùëê ùëë , (A.23)
then we can see that the inverse is
ad-bc|-c a u qd HM (A.24)
3
1
2
3
ùëé
ùëè
Geometry and Linear Algebraic Operations
909

We can test to see this by seeing that multiplying by the inverse given by the formula above works in practice. M = torch.tensor([[1, 2], [1, 4]], dtype=torch.float32) M_inv = torch.tensor([[2, -1], [-0.5, 0.5]]) M_inv @ M
tensor([[1., 0.], [0., 1.]])
Numerical Issues
While the inverse of a matrix is useful in theory, we must say that most of the time we do not wish to use the matrix inverse to solve a problem in practice. In general, there are far more numerically stable algorithms for solving linear equations like
than computing the inverse and multiplying to get
Just as division by a small number can lead to numerical instability, so can inversion of a matrix which is close to having low rank. Moreover, it is common that the matrix A is sparse, which is to say that it contains only a small number of non-zero values. If we were to explore examples, we would see that this does not mean the inverse is sparse. Even if A was a 1 million by 1 million matrix with only 5 million non-zero entries (and thus we need only store those 5 million), the inverse will typically have almost every entry non-negative, requiring us to store all 1M2 entries‚Äîthat is 1 trillion entries! While we do not have time to dive all the way into the thorny numerical issues frequently encountered when working with linear algebra, we want to provide you with some intuition about when to proceed with caution, and generally avoiding inversion in practice is a good rule of thumb. A.1.8 Determinant
The geometric view of linear algebra gives an intuitive way to interpret a fundamental quantity known as the determinant. Consider the grid image from before, but now with a highlighted region (Fig.bubuA.9).bubuLook at the highlighted square. This is a square with edges given by ‚Äû0,1‚Äù and ‚Äû1,0‚Äù and
thus it has area one. After A transforms this square, we see that it becomes a parallelogram. There is no reason this parallelogram should have the same area that we started with, and
Ax = b,
(A.25)
x=A'b. (A.26)
Mathematics for Deep Learning
910


tFig. A.9
The matrix A again distorting the grid. This time, I want to draw particular attention to what happens to the highlighted square. indeed in the specific case shown here of
1 2 A= | ; (A.27)
it is an exercise in coordinate geometry to compute the area of this parallelogram and obtain that the area is 5. In general, if we have a matrix
A = ùëé ùëê ùëè ùëë , (A.28)
we can see with some computation that the area of the resulting parallelogram is ad ‚Äî bc. This area is referred to as the determinant.bubuLet‚Äôs check this quickly with some example code. torch.det(torch.tensor([[1, -1], [2, 3]], dtype=torch.float32))
tensor(5.)
The eagle-eyed amongst us will notice that this expression can be zero or even negative. For the negative term, this is a matter of convention taken generally in mathematics: if the matrix flips the figure, we say the area is negated. Let‚Äôs see now that when the determinant is zero, we learn more.bubuLet‚Äôs consider
B= 2. 4 . (A.29)
If we compute the determinant of this matrix, we get 2 - (‚Äî2) ‚Äî 4- (-1) = 0. Given our
understanding above, this makes sense. B compresses the square from the original image down to a line segment, which has zero area. And indeed, being compressed into a lower dimensional space is the only way to have zero area after the transformation. Thus we see the following result is true: a matrix ùê¥ is invertible if and only if the determinant is not equal to zero. Geometry and Linear Algebraic Operations
911

As a final comment, imagine that we have any figure drawn on the plane. Thinking like computer scientists, we can decompose that figure into a collection of little squares so that the area of the figure is in essence just the number of squares in the decomposition. If we nowtransformthatfigurebyamatrix, wesendeachofthesesquarestoparallelograms, each one of which has area given by the determinant. We see that for any figure, the determinant gives the (signed) number that a matrix scales the area of any figure. Computing determinants for larger matrices can be laborious, but the intuition is the same. The determinant remains the factor that nxn matrices scale n-dimensional volumes. A.1.9 Tensors and Common Linear Algebra Operations
In Section 2.3 the concept of tensors was introduced. In this section, we will dive more deeply into tensor contractions (the tensor equivalent of matrix multiplication), and see how it can provide a unified view on a number of matrix and vector operations. With matrices and vectors we knew how to multiply them to transform data. We need to have a similar definition for tensors if they are to be useful to us. Think about matrix multiplication:
or equivalently
ùëêùëñ, ùëó = ùëéùëñ,ùëòùëèùëò, ùëó. ùëò (A.31)
This pattern is one we can repeat for tensors. For tensors, there is no one case of what to sum over that can be universally chosen, so we need specify exactly which indices we want to sum over. For instance we could consider
ùë¶ùëñùëô = ùë•ùëñùëóùëòùëôùëé ùëóùëò. ùëóùëò (A.32)
Such a transformation is called a tensor contraction. It can represent a far more flexible family of transformations that matrix multiplication alone. As a often-used notational simplification, we can notice that the sum is over exactly those indices that occur more than once in the expression, thus people often work with Einstein notation, where the summation is implicitly taken over all repeated indices. This gives the compact expression:
ùë¶ùëñùëô = ùë•ùëñùëóùëòùëôùëé ùëóùëò. Vil = XijklGjk- (A.33)
Common Examples from Linear Algebra
Let‚Äôs see how many of the linear algebraic definitions we have seen before can be expressed in this compressed tensor notation:
Àù
ùëñ ùë£ùëñùë§ùëñ
evew=divini
Àù
bd IIMs = Livivi
C = AB,
(A.30)
(A.33)
Mathematics for Deep Learning
912

Àù
¬© (Av) =
ùëó ùëéùëñùëóùë£ ùëó
¬© (Av) = 2; aij;
Àù
¬© (AB)ix =
ùëó ùëéùëñùëóùëè ùëóùëò
¬© (AB)ix = Dj aipb jx
Àù
e tr(A) =
ùëñ ùëéùëñùëñ
e tr(A) = 3 ai
In this way, we can replace a myriad of specialized notations with short tensor expres- sions. Expressing in Code
Tensors may flexibly be operated on in code as well. As seen in Section 2.3, we can create tensors as is shown below. # Define tensors B = torch.tensor([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]) A = torch.tensor([[1, 2], [3, 4]]) v = torch.tensor([1, 2]) # Print out the shapes A.shape, B.shape, v.shape
(torch.Size([2, 2]), torch.Size([2, 2, 3]), torch.Size([2]))
Einstein summation has been implemented directly. The indices that occurs in the Einstein summation can be passed as a string, followed by the tensors that are being acted upon. For instance, to implement matrix multiplication, we can consider the Einstein summation seen above (Av = ùëéùëñùëóùë£ ùëó) and strip out the indices themselves to get the implementation:
# Reimplement matrix multiplication torch.einsum("ij, j -> i", A, v), A@v
(tensor([ 5, 11]), tensor([ 5, 11]))
This is a highly flexible notation. For instance if we want to compute what would be tradi- tionally written as
ùëêùëòùëô = bùëñùëóùëòaùëñùëôùë£ ùëó. ùëñùëó (A.34)
it can be implemented via Einstein summation as:
torch.einsum("ijk, il, j -> kl", B, A, v)
tensor([[ 90, 126], [102, 144], [114, 162]])
Geometry and Linear Algebraic Operations
913

This notation is readable and efficient for humans, however bulky if for whatever reason we need to generate a tensor contraction programmatically. For this reason, einsum provides an alternative notation by providing integer indices for each tensor. For example, the same tensor contraction can also be written as:
# PyTorch does not support this type of notation. Either notation allows for concise and efficient representation of tensor contractions in code. A.1.10 Summary
Vectors can be interpreted geometrically as either points or directions in space. Dot products define the notion of angle to arbitrarily high-dimensional spaces. Hyperplanes are high-dimensional generalizations of lines and planes. They can be used
to define decision planes that are often used as the last step in a classification task. Matrix multiplication can be geometrically interpreted as uniform distortions of the un-
derlying coordinates. They represent a very restricted, but mathematically clean, way to transform vectors. Linear dependence is a way to tell when a collection of vectors are in a lower dimensional
space than we would expect (say you have 3 vectors living in a 2-dimensional space). The rank of a matrix is the size of the largest subset of its columns that are linearly independent. When a matrix‚Äôs inverse is defined, matrix inversion allows us to find another matrix that
undoes the action of the first. Matrix inversion is useful in theory, but requires care in practice owing to numerical instability. Determinants allow us to measure how much a matrix expands or contracts a space. A
nonzero determinant implies an invertible (non-singular) matrix and a zero-valued determinant means that the matrix is non-invertible (singular). e Tensor contractions and Einstein summation provide for a neat and clean notation for
expressing many of the computations that are seen in machine learning. A.1.11 Exercises
1.bubuWhat is the angle between
1 3 = 0 = 1], 2 Bi=| a] V2=]5 ? (A.35) 2 1
| are inverses of one another?bubu1 2 1 2. True or false: \ | and I 1
Mathematics for Deep Learning
914

3. Suppose that we draw a shape in the plane with area 100m2. What is the area after
transforming the figure by the matrix
4. Which of the following sets of vectors are linearly independent? 8>>><
9>>>=
1 2 3 ¬∞ O},) 1 f.J1 -1} \-1}) \l 3\ /1\ [0 @ s11].j1].)0 1} \1} \O 1 0 1 e ae ae o
5. Suppose that you have a matrix written as ùê¥ =
ùëë for some choice of values
ùëé, ùëè, ùëê, and ùëë. True or false: the determinant of such a matrix is always 0? 6. The vectors ùëí1 = 1 0 and ùëí2 = 0 1 are orthogonal. What is the condition on a matrix ùê¥ so that ùê¥ùëí1 and ùê¥ùëí2 are orthogonal? so that Ae; and Ae, are orthogonal? 7. How can you write tr‚ÄûA4‚Äù in Einstein notation for an arbitrary matrix ùê¥? 280
Discussions280. A.2 Eigendecompositions
|
Eigenvaluesareoftenoneofthemostusefulnotionswewillencounterwhenstudyinglinear algebra, however, asabeginner, itiseasytooverlooktheirimportance. Below, weintroduce eigendecomposition and try to convey some sense of just why it is so important. Suppose that we have a matrix ùê¥ with the following entries:
2 0 A= \ -1 (A.l)
If we apply A to any vector v = [x, y]', we obtain a vector Av = [2x,‚Äîy]". This has an
intuitive interpretation: stretch the vector to be twice as wide in the ùë•-direction, and then flip it in the ùë¶-direction. 2 1 3 2 . (A.36)
ùëê
:
ùëé
ùëè
Eigendecompositions
915

However, there are some vectors for which something remains unchanged. Namely ¬ª1,0‚Ä¶>
However, there are some vectors for which something remains unchanged. Namely [1,0] gets sent to [2,0]" and [0,1]" gets sent to [0,-1]". These vectors are still in the same line, and the only modification is that the matrix stretches them by a factor of 2 and -1 respectively. We call such vectors eigenvectors and the factor they are stretched by eigen- values. In general, if we can find a number ùúÜ and a vector v such that
We say that v is an eigenvector for ùê¥ and ùúÜ is an eigenvalue. A.2.1 Finding Eigenvalues
Let‚Äôs figure out how to find them. By subtracting off the ùúÜv from both sides, and then
factoring out the vector, we see the above is equivalent to:
(A-ADv =0. (A.3)
For (A.3) to happen, we see that (A ‚Äî AI) must compress some direction down to zero,
For (A.3) to happen, we see that (A ‚Äî AI) must compress some direction down to zero, hence it is not invertible, and thus the determinant is zero. Thus, we can find the eigenvalues by finding for what 2 is det(A ‚Äî AI) = 0. Once we find the eigenvalues, we can solve Av = Av to find the associated eigenvector(s). An Example
Let‚Äôs see this with a more challenging matrix
A = 2 2 1 3 . (A.4)
If we consider det(A ‚Äî AI) = 0, we see this is equivalent to the polynomial equation
If we consider det(A ‚Äî AI) = 0, we see this is equivalent to the polynomial equation 0 = (2-A)(3-A) ‚Äî2 = (4-A)(1‚Äî- A). Thus, two eigenvalues are 4 and 1. To find the associated vectors, we then need to solve
2 1 2 3 ùë• ùë¶ = ùë• ùë¶ and 2 1 2 3 ùë• ùë¶ = 4ùë• 4ùë¶ . (A.5)
We can solve this with the vectors [1,‚Äî1]" and [1,2]" respectively. We can check this in code using the built-in numpy.linalg.eig routine. %matplotlib inline import torch from IPython import display from d2l import torch as d2l
torch.linalg.eig(torch.tensor([[2, 1], [2, 3]], dtype=torch.float64))
Av = ùúÜv. (A.2)
Mathematics for Deep Learning
916

torch.return_types.linalg_eig( eigenvalues=tensor([1.+0.j, 4.+0.j], dtype=torch.complex128), eigenvectors=tensor([[-0.7071+0.j, -0.4472+0.j], [ 0.7071+0.j, -0.8944+0.j]], dtype=torch.complex128))
Note that numpy normalizes the eigenvectors to be of length one, whereas we took ours to be of arbitrary length. Additionally, the choice of sign is arbitrary. However, the vectors computed are parallel to the ones we found by hand with the same eigenvalues. A.2.2 Decomposing Matrices
Let‚Äôs continue the previous example one step further. Let
1 1 . welt 3) as
be the matrix where the columns are the eigenvectors of the matrix A. Let
ùö∫ = 1 0 0 4 , (A.7)
be the matrix with the associated eigenvalues on the diagonal. Then the definition of eigen- values and eigenvectors tells us that
(A.8)
The matrix W is invertible, so we may multiply both sides by W~! on the right, we see that
we may write
A=Wrw"!. (A.9)
In the next section we will see some nice consequences of this, but for now we need only know that such a decomposition will exist as long as we can find a full collection of linearly independent eigenvectors (so that ùëä is invertible). A.2.3 Operations on Eigendecompositions
One nice thing about eigendecompositions (A.9) is that we can write many operations we usually encounter cleanly in terms of the eigendecomposition. As a first example, con- sider:
ùëõ times
n times n times n times ‚Äî‚Äî ‚Äî_‚Äî (A.10) A"=A---A=(WEW"!)---(WEW"!)=WE--- DW! = Wwr'w!. This tells us that for any positive power of a matrix, the eigendecomposition is obtained by just raising the eigenvalues to the same power. The same can be shown for negative powers, so if we want to invert a matrix we need only consider
At=wz'!wl, (A.11)
AW = Wùö∫. Eigendecompositions
917

or in other words, just invert each eigenvalue. This will work as long as each eigenvalue is non-zero, so we see that invertible is the same as having no zero eigenvalues. Indeed, additional work can show that if ùúÜ1, .bubu. .,ùúÜùëõ are the eigenvalues of a matrix, then the determinant of that matrix is
det(A) =A, -+-An,
(A.12)
or the product of all the eigenvalues. This makes sense intuitively because whatever stretch- ing W does, W~! undoes it, so in the end the only stretching that happens is by multipli- cation by the diagonal matrix X, which stretches volumes by the product of the diagonal elements. Finally, recall that the rank was the maximum number of linearly independent columns of your matrix. By examining the eigendecomposition closely, we can see that the rank is the same as the number of non-zero eigenvalues of A. The examples could continue, but hopefully the point is clear: eigendecomposition can simplify many linear-algebraic computations and is a fundamental operation underlying many numerical algorithms and much of the analysis that we do in linear algebra. A.2.4 Eigendecompositions of Symmetric Matrices
It is not always possible to find enough linearly independent eigenvectors for the above process to work. For instance the matrix
A = 1 0 1 1 , (A.13)
has only a single eigenvector, namely ‚Äû1,0‚Äù>. To handle such matrices, we require more
advanced techniques than we can cover (such as the Jordan Normal Form, or Singular Value Decomposition). We will often need to restrict our attention to those matrices where we can guarantee the existence of a full set of eigenvectors. The most commonly encountered family are the symmetric matrices, which are those ma- trices where A = A‚Äù. In this case, we may take W to be an orthogonal matrix‚Äîa matrix whose columns are all length one vectors that are at right angles to one another, where W‚Ñ¢ = W7!‚Äîand all the eigenvalues will be real. Thus, in this special case, we can write (A.9) as
A = Wùö∫W>. (A.14)
A.2.5 Gershgorin Circle Theorem
Eigenvalues are often difficult to reason with intuitively. If presented an arbitrary matrix, thereislittlethatcanbesaidaboutwhattheeigenvaluesarewithoutcomputingthem. There is, however, one theorem that can make it easy to approximate well if the largest values are on the diagonal. Let A = (a;;) be any square matrix (n x n). We will define r; =
Àù
ùëó‚â†ùëñ jùëéùëñùëój. Let Dùëñ
Mathematics for Deep Learning
918

represent the disc in the complex plane with center ùëéùëñùëñ radius ùëüùëñ. Then, every eigenvalue of
A is contained in one of the Dùëñ. This can be a bit to unpack, so let‚Äôs look at an example. Consider the matrix:
2
A = 6 6 6 6 6 6 4 1.0 0.1 0.1 0.1 3.0 0.2 0.1 0.2 5.0 0.1 0.3 0.5 0.1 0.3 0.5 9.0 7 7 7 7 7 7 5 . (A.15)
We have ùëü1 = 0.3, ùëü2 = 0.6, ùëü3 = 0.8 and ùëü4 = 0.9. The matrix is symmetric, so all eigenvalues are real. This means that all of our eigenvalues will be in one of the ranges of
{ai -ri,ai+ri] = (0.7, 1.3],
(A.16)
[a22 - r2,a22 +12] = [2.4, 3.6], (A.17)
[a33 ‚Äî 3,433 +13] = [4.2,5.8], (A.18)
[a4 - 14, a44 +14] = [8.1,9.9]. (A.19)
Performing the numerical computation shows that the eigenvalues are approximately 0.99,
2.97, 4.95, 9.08, all comfortably inside the ranges provided. A = torch.tensor([[1.0, 0.1, 0.1, 0.1], [0.1, 3.0, 0.2, 0.3], [0.1, 0.2, 5.0, 0.5], [0.1, 0.3, 0.5, 9.0]]) v, _ = torch.linalg.eig(A) v
tensor([0.9923+0.j, 9.0803+0.j, 4.9539+0.j, 2.9734+0.j])
Inthisway, eigenvaluescanbeapproximated, andtheapproximationswillbefairlyaccurate in the case that the diagonal is significantly larger than all the other elements. It is a small thing, but with a complex and subtle topic like eigendecomposition, it is good to get any intuitive grasp we can. A.2.6 A Useful Application: The Growth of Iterated Maps
Now that we understand what eigenvectors are in principle, let‚Äôs see how they can be used to provide a deep understanding of a problem central to neural network behavior: proper weight initialization. 3
Eigendecompositions
919

Eigenvectors as Long Term Behavior
The full mathematical investigation of the initialization of deep neural networks is beyond the scope of the text, but we can see a toy version here to understand how eigenvalues can help us see how these models work. As we know, neural networks operate by interspersing layers of linear transformations with non-linear operations. For simplicity here, we will assume that there is no non-linearity, and that the transformation is a single repeated matrix operation ùê¥, so that the output of our model is
Vou = A+ A+++ Avin = AN Vin. (A.20)
When these models are initialized, ùê¥ is taken to be a random matrix with Gaussian entries,
When these models are initialized, A is taken to be a random matrix with Gaussian entries, so let‚Äôs make one of those. To be concrete, we start with a mean zero, variance one Gaussian distributed 5 x 5 matrix. torch.manual_seed(42)
torch.manual_seed(42) k = 5 A = torch.randn(k, k, dtype=torch.float64) A
tensor([[ 0.2996, 0.2424, 0.2832, -0.2329, 0.6712], [ 0.7818, -1.7903, -1.7484, 0.1735, -0.1182], [-1.7446, -0.4695, 0.4573, 0.5177, -0.2771], [-0.6641, 0.6551, 0.2616, -1.5265, -0.3311], [-0.6378, 0.1072, 0.7096, 0.3009, -0.2869]], dtype=torch.float64)
Behavior on Random Data
For simplicity in our toy model, we will assume that the data vector we feed in vùëñùëõ is a random five dimensional Gaussian vector. Let‚Äôs think about what we want to have happen.bubuFor context, lets think of a generic ML problem, where we are trying to turn input data, like an image, into a prediction, like the probability the image is a picture of a cat. If repeated application of A stretches a random vector out to be very long, then small changes in input will be amplified into large changes in output‚Äîtiny modifications of the input image would lead to vastly different predictions. This does not seem right! On the flip side, if A shrinks random vectors to be shorter, then after running through many layers, the vector will essentially shrink to nothing, and the output will not depend on the input. This is also clearly not right either! We need to walk the narrow line between growth and decay to make sure that our output changes depending on our input, but not much! Let‚Äôs see what happens when we repeatedly multiply our matrix A against a random input vector, and keep track of the norm. Mathematics for Deep Learning
920

# Calculate the sequence of norms after repeatedly applying `A` v_in = torch.randn(k, 1, dtype=torch.float64) norm_list = [torch.norm(v_in).item()] for i in range(1, 100): v_in = A @ v_in norm_list.append(torch.norm(v_in).item())
d2l.plot(torch.arange(0, 100), norm_list, 'Iteration', 'Value')
1e38 4 Value 0 20 40 60 80 100 Iteration
The norm is growing uncontrollably! Indeed if we take the list of quotients, we will see a pattern. # Compute the scaling factor of the norms norm_ratio_list = [] for i in range(1, 100): norm_ratio_list.append(norm_list[i]/norm_list[i - 1])
d2l.plot(torch.arange(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
i} 20 40 60 80 100 Iteration
If we look at the last portion of the above computation, we see that the random vector is stretched by a factor of 1.974459321485[...], where the portion at the end shifts a little, but the stretching factor is stable. Eigendecompositions
921

Relating Back to Eigenvectors
We have seen that eigenvectors and eigenvalues correspond to the amount something is stretched, but that was for specific vectors, and specific stretches. Let‚Äôs take a look at what they are for A.bubuA bit of a caveat here: it turns out that to see them all, we will need to go to complex numbers. You can think of these as stretches and rotations. By taking the norm of the complex number (square root of the sums of squares of real and imaginary parts) we can measure that stretching factor. Let‚Äôs also sort them. # Compute the eigenvalues eigs = torch.linalg.eig(A).eigenvalues.tolist() norm_eigs = [torch.abs(torch.tensor(x)) for x in eigs] norm_eigs.sort() print(f'norms of eigenvalues: {norm_eigs}')
norms of eigenvalues: [tensor(0.3490), tensor(1.1296), tensor(1.1296),‚ê£ ‚Ü©!tensor(1.1828), tensor(2.4532)]
An Observation
Weseesomethingabitunexpectedhappeninghere: thatnumberweidentifiedbeforeforthe long term stretching of our matrix A applied to a random vector is exactly (accurate to thir- teen decimal places!) the largest eigenvalue of A. This is clearly not a coincidence!bubuBut, if we now think about what is happening geometrically, this starts to make sense. Con- sider a random vector. This random vector points a little in every direction, so in particular, it points at least a little bit in the same direction as the eigenvector of A associated with the largest eigenvalue. This is so important that it is called the principle eigenvalue and principle eigenvector. After applying A, our random vector gets stretched in every possi- ble direction, as is associated with every possible eigenvector, but it is stretched most of all in the direction associated with this principle eigenvector. What this means is that after apply in ùê¥, our random vector is longer, and points in a direction closer to being aligned with the principle eigenvector. After applying the matrix many times, the alignment with the principle eigenvector becomes closer and closer until, for all practical purposes, our random vector has been transformed into the principle eigenvector! Indeed this algorithm is the basis for what is known as the power iteration for finding the largest eigenvalue and eigenvector of a matrix. For details see, for example, (Golub and Van Loan, 1996). Fixing the Normalization
Now, from above discussions, we concluded that we do not want a random vector to be stretched or squished at all, we would like random vectors to stay about the same size throughout the entire process. To do so, we now rescale our matrix by this principle eigen- value so that the largest eigenvalue is instead now just one. Let‚Äôs see what happens in this case. Mathematics for Deep Learning
922

# Rescale the matrix `A` A /= norm_eigs[-1] # Do the same experiment again v_in = torch.randn(k, 1, dtype=torch.float64) norm_list = [torch.norm(v_in).item()] for i in range(1, 100): v_in = A @ v_in norm_list.append(torch.norm(v_in).item())
d2l.plot(torch.arange(0, 100), norm_list, 'Iteration', 'Value')
0 20 40 60 80 100 Iteration
We can also plot the ratio between consecutive norms as before and see that indeed it sta- bilizes. # Also plot the ratio norm_ratio_list = [] for i in range(1, 100): norm_ratio_list.append(norm_list[i]/norm_list[i-1])
d2l.plot(torch.arange(1, 100), norm_ratio_list, 'Iteration', 'Ratio')
20 40 60 80 100 Iteration of
A.2.7 Discussion
We now see exactly what we hoped for! After normalizing the matrices by the principal eigenvalue, we see that the random data does not explode as before, but rather eventually equilibrates to a specific value. It would be nice to be able to do these things from first
Eigendecompositions
923

principles, and it turns out that if we look deeply at the mathematics of it, we can see that the largest eigenvalue of a large random matrix with independent mean zero, variance one Gaussian entries is on average about Yj, or in our case V5 ~ 2.2, due to a fascinating fact known as the circular law (Ginibre, 1965). The relationship between the eigenvalues (and a related object called singular values) of random matrices has been shown to have deep connections to proper initialization of neural networks as was discussed in Pennington et al. (2017) and subsequent works. A.2.8 Summary
e Eigenvectors are vectors which are stretched by a matrix without changing direction. e Eigenvalues are the amount that the eigenvectors are stretched by the application of the
matrix. e The eigendecomposition of a matrix can allow for many operations to be reduced to
operations on the eigenvalues. e The Gershgorin Circle Theorem can provide approximate values for the eigenvalues of
a matrix. e The behavior of iterated matrix powers depends primarily on the size of the largest eigen-
value. This understanding has many applications in the theory of neural network ini- tialization. A.2.9 Exercises
1. What are the eigenvalues and eigenvectors of
2. What are the eigenvalues and eigenvectors of the following matrix, and what is strange about this example compared to the previous one? 3. Without computing the eigenvalues, is it possible that the smallest eigenvalue of the following matrix is less that 0.5? Note: this problem can be done in your head.bubu2
A = 6 6 6 6 6 6 4 3.0 0.1 0.3 0.1 1.0 0.1 0.3 0.1 5.0 1.0 0.2 0.0 1.0 0.2 0.0 1.8 7 7 7 7 7 7 5 . (A.23)
281
Discussions281. A = 2 1 1 2 ?bubu(A.21)
A = 2 1 0 2 . (A.22)
3
Mathematics for Deep Learning
924

A.3 Single Variable Calculus
es
In Section 2.4, we saw the basic elements of differential calculus. This section takes a deeper dive into the fundamentals of calculus and how we can understand and apply it in the context of machine learning. A.3.1 Differential Calculus
Differentialcalculusisfundamentallythestudyofhowfunctionsbehaveundersmallchanges. To see why this is so core to deep learning, let‚Äôs consider an example. Suppose that we have a deep neural network where the weights are, for convenience, con- catenated into a single vector w = ‚Äûùë§1, . .bubu., ùë§ùëõ‚Äù. Given a training dataset, we consider the loss of our neural network on this dataset, which we will write as L‚Äûw‚Äù. This function is extraordinarily complex, encoding the performance of all possible models of the given architecture on this dataset, so it is nearly impossible to tell what set of weights w will minimize the loss. Thus, in practice, we often start by initializing our weights ran- domly, and then iteratively take small steps in the direction which makes the loss decrease as rapidly as possible. The question then becomes something that on the surface is no easier: how do we find the direction which makes the weights decrease as quickly as possible? To dig into this, let‚Äôs first examine the case with only a single weight: ùêø‚Äûw‚Äù = ùêø‚Äûùë•‚Äù for a single real value ùë•. x. Let‚Äôs take ùë• and try to understand what happens when we change it by a small amount to
ùë• ‚Äö ùúñ. If you wish to be concrete, think a number like ùúñ = 0.0000001. To help us visualize what happens, let‚Äôs graph an example function, ùëì ‚Äûùë•‚Äù = sin‚Äûùë•ùë•‚Äù, over the ¬ª0,3‚Ä¶. %matplotlib inline import torch from IPython import display from d2l import torch as d2l
torch.pi = torch.acos(torch.zeros(1)).item() * 2 # Define pi in torch
# Plot a function in a normal range x_big = torch.arange(0.01, 3.01, 0.01) ys = torch.sin(x_big**x_big) d2l.plot(x_big, ys, 'x', 'f(x)')
At this large scale, the function‚Äôs behavior is not simple. However, if we reduce our range to something smaller like ¬ª1.75,2.25‚Ä¶, we see that the graph becomes much simpler. # Plot a the same function in a tiny range x_med = torch.arange(1.75, 2.25, 0.001)
(continues on next page)
Single Variable Calculus
925

1.0 05 0.0 -10 ¬∞ a N w
F(x)
ys = torch.sin(x_med**x_med) d2l.plot(x_med, ys, 'x', 'f(x)')
0.5 0.0 z -0.5 -1.0 1.8 1.9 2.0 2.1 2.2 x
Takingthistoanextreme, ifwezoomintoatinysegment, thebehaviorbecomesfarsimpler: it is just a straight line. # Plot a the same function in a tiny range x_small = torch.arange(2.0, 2.01, 0.0001) ys = torch.sin(x_small**x_small) d2l.plot(x_small, ys, 'x', 'f(x)')
‚Äî0.76 -0.77 f(x) -0.78 -0.79 ‚Äî0.80 2.000 2.002 2.004 2.006 2.008 2.010 x
This is the key observation of single variable calculus: the behavior of familiar functions can be modeled by a line in a small enough range. This means that for most functions, it is reasonable to expect that as we shift the ùë• value of the function by a little bit, the output ùëì ‚Äûùë•‚Äù will also be shifted by a little bit. The only question we need to answer is, ‚ÄúHow large
(continued from previous page)
Mathematics for Deep Learning
926

is the change in the output compared to the change in the input? Is it half as large? Twice as large?‚Äù
Thus, we can consider the ratio of the change in the output of a function for a small change in the input of the function. We can write this formally as
L(x +6) ‚Äî L(x)
L(x +6) ‚Äî L(x) _ L(x +) ‚Äî L(x) (v+ey-x ‚Ç¨ , (A.1)
This is already enough to start to play around with in code. For instance, suppose that we know that L(x) = x? + 1701(x ‚Äî 4), then we can see how large this value is at the point x = 4 as follows. # Define our function def L(x): return x**2 + 1701*(x-4)**3 # Print the difference divided by epsilon for several epsilon for epsilon in [0.1, 0.001, 0.0001, 0.00001]: print(f'epsilon = {epsilon:.5f} -> {(L(4+epsilon) - L(4)) / epsilon:.5f}')
epsilon = 0.10000 -> 25.11000 epsilon = 0.00100 -> 8.00270 epsilon = 0.00010 -> 8.00012 epsilon = 0.00001 -> 8.00001
Now, if we are observant, we will notice that the output of this number is suspiciously close to 8. Indeed, if we decrease ùúñ, we will see value becomes progressively closer to 8. Thus we may conclude, correctly, that the value we seek (the degree a change in the input changes the output) should be 8 at the point ùë• = 4. The way that a mathematician encodes this fact
is
jim LG+9-LAM _g (A.2) ¬´30 ‚Ç¨
As a bit of a historical digression: in the first few decades of neural network research, sci- entists used this algorithm (the method of finite differences) to evaluate how a loss function changed under small perturbation: just change the weights and see how the loss changed. Thisiscomputationallyinefficient, requiringtwoevaluationsofthelossfunctiontoseehow a single change of one variable influenced the loss. If we tried to do this with even a pal- try few thousand parameters, it would require several thousand evaluations of the network over the entire dataset! It was not solved until 1986 that the backpropagation algorithm introduced in Rumelhart et al. (1988) provided a way to calculate how any change of the weights together would change the loss in the same computation time as a single prediction of the network over the dataset. Back in our example, this value 8 is different for different values of ùë•, so it makes sense to
define it as a function of ùë•. More formally, this value dependent rate of change is referred to as the derivative which is written as
ùëëùëì
ùëëùë• ‚Äûùë•‚Äù = lim ùúñ!0 ùúñ . (A.3)
L(x +) ‚Äî L(x)
Single Variable Calculus
927

Different texts will use different notations for the derivative. For instance, all of the below notations indicate the same thing:
ùëëùëì
ùëë
ùëëùë• = ùëëùë• ùëì = ùëì 0 = rùë• ùëì = ùê∑ùë• ùëì = ùëìùë•. (A.4)
Most authors will pick a single notation and stick with it, however even that is not guaran- ùëë ùëì teed. It is best to be familiar with all of these. We will use the notation ùëëùë• throughout this text, unless we want to take the derivative of a complex expression, in which case we will use ùëë ùëëùë• ùëì to write expressions like
d 4 cos rt dx |* 7S Vox . (A.5)
Oftentimes, it is intuitively useful to unravel the definition of derivative (A.3) again to see how a function changes when we make a small change of ùë•:
ùëëùëì
fat) - f(x)
af fat) - f(x) Ff xy ~ Leto ~ fo) dx ‚Ç¨ dx - ‚Ç¨ = Liye pero-se) ‚Äî (A6) LX => f(xte) x f(x) +L. The last equation is worth explicitly calling out. It tells us that if you take any function and change the input by a small amount, the output would change by that small amount scaled by the derivative. In this way, we can understand the derivative as the scaling factor that tells us how large of change we get in the output from a change in the input. A.3.2 Rules of Calculus
We now turn to the task of understanding how to compute the derivative of an explicit function. A full formal treatment of calculus would derive everything from first principles. We will not indulge in this temptation here, but rather provide an understanding of the common rules encountered. Common Derivatives
As was seen in Section 2.4, when computing derivatives one can oftentimes use a series of rules to reduce the computation to a few core functions. We repeat them here for ease of reference.bubue Derivative of constants. ùëëùë•ùëê = 0. e Derivative of linear functions. ùëëùë• ‚Äûùëéùë•‚Äù = ùëé. e Power rule. ox" =nx"!,
e Power rule. ox" =nx"!,
Derivative of exponentials. ùëëùë•ùëíùë• = ùëíùë•. Derivative of the logarithm. a
ùëëùë• log‚Äûùë•‚Äù = 1
i x? Derivative of the logarithm. a log(x) =
ùëëùëì
Leto ~ fo)
ùë•. Mathematics for Deep Learning
928

Derivative Rules
If every derivative needed to be separately computed and stored in a table, differential cal- culus would be near impossible. It is a gift of mathematics that we can generalize the above derivatives and compute more complex derivatives like finding the derivative of f(x) = log (1+ (x- 1)!¬∞). As was mentioned in Section 2.4, the key to doing so is to codify what happens when we take functions and combine them in various ways, most importantly: sums, products, and compositions. ¬© Sum rule. (g(x) + h(x) = $8(x) + 400). ¬© Product rule. ¬© (g(x) - A(x) = g(x) 24 (x) + 2) A(x). ¬© Chain rule. g(h(x)) = & (h(x) - 24(2). Let‚Äôs see how we may use (A.6) to understand these rules. For the sum rule, consider following chain of reasoning:
ùëì ‚Äûùë• ‚Äö ùúñ‚Äù = ùëî‚Äûùë• ‚Äö ùúñ‚Äù ‚Äö ‚Ñé‚Äûùë• ‚Äö ùúñ‚Äù
= g(x) + 8x) + h(x) + cy) = g(x) + h(x) +‚Ç¨ (seo + a) (4.7)
By comparing this result with the fact that f(x +e) ~ f(x) +
ùëëùë• ‚Äûùë•‚Äù, we see that ùëëùëî ùëëùë• ‚Äûùë•‚Äù‚Äö ùëë‚Ñé ùëëùë• ‚Äûùë•‚Äù as desired. The intuition here is: when we change the input ùë•, ùëî and ‚Ñé jointly ùëëùëî ùëëùë• ‚Äûùë•‚Äù and ùëë‚Ñé ùëëùë• ‚Äûùë•‚Äù. contribute to the change of the output by ùëëùë• ‚Äûùë•‚Äù =
The product is more subtle, and will require a new observation about how to work with these expressions. We will begin as before using (A.6):
f(xte) =a(xte)-h(x+e)
= (209 +e 0o) (100) +e 09] = 902) hay +(e Han Hepney) +e yay OY dg, dh = Fx) ¬¢e(209 FE) + Henin) +e ye. This resembles the computation done above, and indeed we see our answer (420%) = g(x) 2 (x) + 48 (x)h(x)) sitting next to ‚Ç¨, but there is the issue of that term of size e?. We will refer to this as a higher-order term, since the power of ‚Ç¨? is higher than the power of e!. We will see in a later section that we will sometimes want to keep track of these, however for now observe that if ‚Ç¨ = 0.0000001, then e? = 0.0000000000001, which is vastly smaller. As we send ‚Ç¨ ‚Äî 0, we may safely ignore the higher order terms. As a eu? general convention in this appendix, we will use ‚Äú~‚Äù to denote that the two terms are equal
ùëë ùëì
ùëë ùëì
Single Variable Calculus
929

up to higher order terms. However, if we wish to be more formal we may examine the difference quotient
f(x+e6) - fQ)
ùëë‚Ñé
ùúñ = ùëî‚Äûùë•‚Äù ùëëùë• ‚Äûùë•‚Äù ‚Äö ùëëùë• ‚Äûùë•‚Äù‚Ñé‚Äûùë•‚Äù ‚Äö ùúñ ùëëùë• ‚Äûùë•‚Äù ùëëùë• ‚Äûùë•‚Äù, (A.9)
and see that as we send ùúñ ! 0, the right hand term goes to zero as well. Finally, with the chain rule, we can again progress as before using (A.6) and see that
ùëì ‚Äûùë• ‚Äö ùúñ‚Äù = ùëî‚Äû‚Ñé‚Äûùë• ‚Äö ùúñ‚Äù‚Äù
f(x+e) =g(h(x+6)) xg (11 + a") (A.10) = g(a(a)) +(x a F (n(x )) =f +e aey Leo,
where in the second line we view the function ùëî as having its input (‚Ñé‚Äûùë•‚Äù) shifted by the
tiny quantity ùúñ ùëë‚Ñé ùëëùë• ‚Äûùë•‚Äù. These rule provide us with a flexible set of tools to compute essentially any expression desired. For instance,
h
ùëë
4 [tog (1 +(x- y‚Äù)| = (1 +(r- ¬ª") = (1400-1) -ld de 1 [1+(- 19] 1+ F10-9")) =(1+(x- yn") betaine (A.11) 10(1 +(x- yr) ‚Äò= 1)? _ 10(x- 1)? ~14+(- 210
Where each line has used the following rules:
1. The chain rule and derivative of logarithm. 2. The sum rule. 3. The derivative of constants, chain rule, and power rule. 4. The sum rule, derivative of linear functions, derivative of constants. Two things should be clear after doing this example:
1. Any function we can write down using sums, products, constants, powers, exponentials, and logarithms can have its derivate computed mechanically by following these rules. 2. Having a human follow these rules can be tedious and error prone! Thankfully, these two facts together hint towards a way forward: this is a perfect candidate
ùëëùëî
ùëëùëî
ùëë‚Ñé
ld
Mathematics for Deep Learning
930

for mechanization! Indeed backpropagation, which we will revisit later in this section, is exactly that. Linear Approximation
When working with derivatives, it is often useful to geometrically interpret the approxima- tion used above. In particular, note that the equation
f(x+6) x f(xy teLcny, (A.12) dx
approximates the value of ùëì by a line which passes through the point ‚Äûùë•, ùëì ‚Äûùë•‚Äù‚Äù and has
ùëë ùëì ùëëùë• ‚Äûùë•‚Äù. In this way we say that the derivative gives a linear approximation to the slope function ùëì, as illustrated below:
# Compute sin xs = torch.arange(-torch.pi, torch.pi, 0.01) plots = [torch.sin(xs)] # Compute some linear approximations. Use d(sin(x))/dx = cos(x) for x0 in [-1.5, 0.0, 2.0]: plots.append(torch.sin(torch.tensor(x0)) + (xs - x0) * torch.cos(torch.tensor(x0))) d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])

f(x)
Higher Order Derivatives
Let‚Äôs now do something that may on the surface seem strange. Take a function ùëì and
ùëë ùëì ùëëùë•.bubuThis gives us the rate of change of ùëì at any point. compute the derivative
ùëë ùëì
soe dd . co . However, the derivative, at can be viewed as a function itself, so nothing stops us from cia = af at . We will call this the second deriva- x? x \dx tive of f. This function is the rate of change of the rate of change of f, or in other words, how the rate of change is changing. We may apply the derivative any number of times to obtain what is called the n-th derivative. To keep the notation clean, we will denote the computing the derivative of af to get
ùëëùëì
Single Variable Calculus
931

ùëõ-th derivative as
ùëì ‚Äûùëõ‚Äù‚Äûùë•‚Äù = ùëëùëõ ùëì ùëëùë•ùëõ = ùëë ùëëùë• ùëì . (A.13)
Let‚Äôs try to understand why this is a useful notion. Below, we visualize ùëì ‚Äû2‚Äù‚Äûùë•‚Äù, ùëì ‚Äû1‚Äù‚Äûùë•‚Äù,
and ùëì ‚Äûùë•‚Äù. First, consider the case that the second derivative ùëì ‚Äû2‚Äù‚Äûùë•‚Äù is a positive constant. This means that the slope of the first derivative is positive. As a result, the first derivative ùëì ‚Äû1‚Äù‚Äûùë•‚Äù may start out negative, becomes zero at a point, and then becomes positive in the end. This tells us the slope of our original function ùëì and therefore, the function ùëì itself decreases, flattens out, then increases. In other words, the function ùëì curves up, and has a single minimum as is shown in Fig. A.1. f") fF) F@)
tFig. A.1
If we assume the second derivative is a positive constant, then the Ô¨Åst derivative in increasing, which implies the function itself has a minimum. Second, if the second derivative is a negative constant, that means that the first derivative is decreasing. This implies the first derivative may start out positive, becomes zero at a point, and then becomes negative. Hence, the function ùëì itself increases, flattens out, then decreases. In other words, the function ùëì curves down, and has a single maximum as is shown in Fig. A.2. - > > < > > < > Y f") F'@) fF)
tFig. A.2
If we assume the second derivative is a negative constant, then the Ô¨Åst derivative in decreasing, which implies the function itself has a maximum. Third, if the second derivative is a always zero, then the first derivative will never change‚Äî it is constant! This means that ùëì increases (or decreases) at a fixed rate, and ùëì is itself a straight line as is shown in Fig. A.3. To summarize, the second derivative can be interpreted as describing the way that the func- tion ùëì curves. A positive second derivative leads to a upwards curve, while a negative sec- ond derivative means that ùëì curves downwards, and a zero second derivative means that ùëì does not curve at all. Mathematics for Deep Learning
932

| | | | Le fe) f@
tFig. A.3
If we assume the second derivative is zero, then the Ô¨Åst derivative is constant, which implies the function itself is a straight line. Let‚Äôs take this one step further.bubuConsider the function ùëî‚Äûùë•‚Äù = ùëéùë•2 ‚Äö ùëèùë• ‚Äö ùëê. We can then
compute that
ùëëùë• ‚Äûùë•‚Äù = 2ùëéùë• ‚Äö ùëè ùëë2ùëî ùëëùë•2 ‚Äûùë•‚Äù = 2ùëé. (A.14)
If we have some original function ùëì ‚Äûùë•‚Äù in mind, we may compute the first two derivatives
and find the values for ùëé, ùëè, and ùëê that make them match this computation. Similarly to the previous section where we saw that the first derivative gave the best approximation with a straight line, this construction provides the best approximation by a quadratic. Let‚Äôs visualize this for ùëì ‚Äûùë•‚Äù = sin‚Äûùë•‚Äù. # Compute sin xs = torch.arange(-torch.pi, torch.pi, 0.01) plots = [torch.sin(xs)] # Compute some quadratic approximations. Use d(sin(x)) / dx = cos(x) for x0 in [-1.5, 0.0, 2.0]: plots.append(torch.sin(torch.tensor(x0)) + (xs - x0) * torch.cos(torch.tensor(x0)) - (xs - x0)**2 * torch.sin(torch.tensor(x0)) / 2) d2l.plot(xs, plots, 'x', 'f(x)', ylim=[-1.5, 1.5])
f(x)
We will extend this idea to the idea of a Taylor series in the next section. ùëëùëî
Single Variable Calculus
933

Taylor Series
TheTaylorseriesprovidesamethodtoapproximatethefunction ùëì ‚Äûùë•‚Äù ifwearegivenvalues
The Taylor series provides a method to approximate the function f(x) if we are given values for the first n derivatives at a point x9, i.e., {f(20), fF) (x0), Ff (x0), +s f‚Ñ¢ (x0) }- The idea will be to find a degree n polynomial that matches all the given derivatives at xo. We saw the case of ùëõ = 2 in the previous section and a little algebra shows this is
1d d fe) ~5Faoyr m0) F (xo)(x ‚Äî x0) + f (0). (A.15)
As we can see above, the denominator of 2 is there to cancel out the 2 we get when we take two derivatives of ùë•2, while the other terms are all zero. Same logic applies for the first derivative and the value itself. If we push the logic further to ùëõ = 3, we will conclude that
a af (x0) (229) + 2S (a= ap)? + Leap) ‚Äî0) + Flo). x af fos & (0) (A.16)
where the 6 = 3x2 = 3! comes from the constant we get in front if we take three derivatives
of ùë•3. Furthermore, we can get a degree ùëõ polynomial by
LC) - Pala) = iL {0} (x ‚Äîx0)!. (A.17) i=0 ¬∞
where the notation
ùëì ‚Äûùëõ‚Äù‚Äûùë•‚Äù = ùëëùëõ ùëì ùëëùë•ùëõ = ùëë ùëëùë• ùëì . (A.18)
Indeed, ùëÉùëõ‚Äûùë•‚Äù can be viewed as the best ùëõ-th degree polynomial approximation to our func-
tion ùëì ‚Äûùë•‚Äù. While we are not going to dive all the way into the error of the above approximations, it is worth mentioning the infinite limit. In this case, for well behaved functions (known as real analytic functions) like cos‚Äûùë•‚Äù or ùëíùë•, we can write out the infinite number of terms and approximate the exactly same function
SS (x0) FQ) =D) S20)", (A.19) n=0
ùëõ=0
Take ùëì ‚Äûùë•‚Äù = ùëíùë• as am example. Since ùëíùë• is its own derivative, we know that ùëì ‚Äûùëõ‚Äù‚Äûùë•‚Äù = ùëíùë•. Therefore, ùëíùë• can be reconstructed by taking the Taylor series at ùë•0 = 0, i.e.,
oo
oo yn ye 3 x + ‚Äî ‚Äî_‚Äî wee e = tltst at et . (A.20) n=0
ùëõ=0
Let‚Äôs see how this works in code and observe how increasing the degree of the Taylor approximation brings us closer to the desired function ùëíùë•. Mathematics for Deep Learning
934

# Compute the exponential function xs = torch.arange(0, 3, 0.01) ys = torch.exp(xs) # Compute a few Taylor series approximations P1 = 1 + xs P2 = 1 + xs + xs**2 / 2 P5 = 1 + xs + xs**2 / 2 + xs**3 / 6 + xs**4 / 24 + xs**5 / 120 d2l.plot(xs, [ys, P1, P2, P5], 'x', 'f(x)', legend=[ "Exponential", "Degree 1 Taylor Series", "Degree 2 Taylor Series", "Degree 5 Taylor Series"])
‚Äî Exponential =-- Degree 1 Taylor Series 15 - Degree 2 Taylor Series ee fed Degree 5 Taylor Series / = 10 . Taylor series have two primary applications:
1.bubuTheoretical applications: Often when we try to understand a too complex function, using Taylor series enables us to turn it into a polynomial that we can work with directly. 2. Numerical applications: Some functions like ùëíùë• or cos‚Äûùë•‚Äù are difficult for machines to
compute. They can store tables of values at a fixed precision (and this is often done), but it still leaves open questions like ‚ÄúWhat is the 1000-th digit of cos‚Äû1‚Äù?‚Äù Taylor series are often helpful to answer such questions. A.3.3 Summary
e Derivatives can be used to express how functions change when we change the input by a
small amount. e Elementary derivatives can be combined using derivative rules to create arbitrarily com-
plex derivatives. e Derivatives can be iterated to get second or higher order derivatives. Each increase in
order provides more fine grained information on the behavior of the function. e Using information in the derivatives of a single data example, we can approximate well
behaved functions by polynomials obtained from the Taylor series. A.3.4 Exercises
1. What is the derivative of x3 ‚Äî 4x + 1? Multivariable Calculus
935

2. What is the derivative of log‚Äû 1
ùë•‚Äù? 3. True or False: If ùëì 0‚Äûùë•‚Äù = 0 then ùëì has a maximum or minimum at ùë•? 4. Where is the minimum of f(x) = x log(x) for x => 0 (where we assume that f takes the
limiting value of 0 at ùëì ‚Äû0‚Äù)? Discussions282. 282
A.4 Multivariable Calculus
ae
Now that we have a fairly strong understanding of derivatives of a function of a single variable, let‚Äôs return to our original question where we were considering a loss function of potentially billions of weights. A.4.1 Higher-Dimensional Differentiation
What Section A.3 tells us is that if we change a single one of these billions of weights leaving every other one fixed, we know what will happen! This is nothing more than a function of a single variable, so we can write
d L(w1 + ‚Ç¨1,W2,.-., Wn) ¬© L(w1,W2,..-,WN) + 1 Fp LOW 2¬ª .e.,wy). (AL)
Wewillcallthederivativeinonevariablewhilefixingtheothervariablesthepartialderiva- tive, and we will use the notation ùúï for the derivative in (A.1). ùúïùë§1
Now, let‚Äôs take this and change ùë§2 a little bit to ùë§2 ‚Äö ùúñ2:
a) L(wi + ‚Ç¨1,wa + ‚Ç¨2,...,.w) * L(wi,wa + ‚Ç¨2,....Ww) +617 ‚ÄîL(wi,wa + ‚Ç¨2,..-. WN +en) Wi = L(w1,W2,...,WNn) a] + e‚Äî‚ÄîL(w1,W2,..., wn) Ow2 a] + ‚Ç¨;‚Äî‚ÄîL(w1,W2,..., wn) Ow, + 3 L( ) ‚Ç¨1‚Ç¨2-‚Äî ~‚ÄîL(w1, W2,...,W 125 aw) 1,W2 'N = L(w1,W2,-..,Wn) a] + e‚Äî‚ÄîL(w1,W2,..., wn) Ow2 a] + ‚Ç¨;‚Äî L(w1, W2,.-.,WN)- Ow,
We have again used the idea that ùúñ1ùúñ2 is a higher order term that we can discard in the same
ùëë
(A.1)
(A.2)
Mathematics for Deep Learning
936

way we could discard ùúñ2 in the previous section, along with what we saw in (A.1). By
continuing in this manner, we may write that
a) L(w, +‚Ç¨1,W2t+ &,...,Wn ten) ¬© L(y, W2,.--, Wn) + a E(w W2, ..,Wy). 7 Wi i (A.3)
This may look like a mess, but we can make this more familiar by noting that the sum on the right looks exactly like a dot product, so if we let
ùùê = ¬ªùúñ1, . .bubu.,ùúñùëÅ‚Ä¶> and rxùêø = ùúïùêø ùúïùë•1 , . . ., ùúïùêø ùúïùë•ùëÅ , (A.4)
then
L(wt+e) ¬ª L(w) +‚Ç¨- VwL(w). (A.5)
We will call the vector rwùêø the gradient of ùêø. Equation (A.5) is worth pondering for a moment. It has exactly the format that we encoun- tered in one dimension, just we have converted everything to vectors and dot products. It allows us to tell approximately how the function ùêø will change given any perturbation to the input. As we will see in the next section, this will provide us with an important tool in understanding geometrically how we can learn using information contained in the gradient. Butfirst, let‚Äôsseethisapproximationatworkwithanexample. Supposethatweareworking with the function
ùëì ‚Äûùë•, ùë¶‚Äù = log‚Äûùëíùë• ‚Äö ùëíùë¶‚Äù with gradient rùëì ‚Äûùë•, ùë¶‚Äù = ùëíùë• ‚Äö ùëíùë¶ , ùëíùë• ‚Äö ùëíùë¶ . (A.6)
If we look at a point like ‚Äû0,log‚Äû2‚Äù‚Äù, we see that
ùëì ‚Äûùë•, ùë¶‚Äù = log‚Äû3‚Äù with gradient rùëì ‚Äûùë•, ùë¶‚Äù = 1 3 , 2 3 . (A.7)
Thus, if we want to approximate ùëì at ‚Äûùúñ1,log‚Äû2‚Äù ‚Äö ùúñ2‚Äù, we see that we should have the specific instance of (A.5):
f(e1,log(2) +6) ~ log(3) + 361 + Fe. (A8)
We can test this in code to see how good the approximation is. %matplotlib inline import numpy as np import torch from IPython import display from mpl_toolkits import mplot3d from d2l import torch as d2l
def f(x, y):
ùúï
|"
ùëíùë•
ùëíùë¶
(continues on next page)
Multivariable Calculus
937

return torch.log(torch.exp(x) + torch.exp(y)) def grad_f(x, y): return torch.tensor([torch.exp(x) / (torch.exp(x) + torch.exp(y)), torch.exp(y) / (torch.exp(x) + torch.exp(y))]) epsilon = torch.tensor([0.01, -0.03]) grad_approx = f(torch.tensor([0.]), torch.log( torch.tensor([2.]))) + epsilon.dot( grad_f(torch.tensor([0.]), torch.log(torch.tensor(2.)))) true_value = f(torch.tensor([0.]) + epsilon[0], torch.log( torch.tensor([2.])) + epsilon[1]) f'approximation: {grad_approx}, true Value: {true_value}'
'approximation: tensor([1.0819]), true Value: tensor([1.0821])'
A.4.2 Geometry of Gradients and Gradient Descent
Consider the expression from (A.5) again:
L(wt+e) ¬ª L(w) +‚Ç¨-VwL(w). (A.9)
Let‚Äôs suppose that I want to use this to help minimize our loss ùêø. Let‚Äôs understand geomet-
rically the algorithm of gradient descent first described in Section 2.5. What we will do is the following:
1.bubuStart with a random choice for the initial parameters w. 2. Find the direction v that makes ùêø decrease the most rapidly at w. 3. Take a small step in that direction: w ! w ‚Äö ùúñv.bubu4. Repeat. The only thing we do not know exactly how to do is to compute the vector v in the second step. We will call such a direction the direction of steepest descent. Using the geometric understanding of dot products from Section A.1, we see that we can rewrite (A.5) as
L(wt+v) = L(w)+v-VwL(w) = L(w) + ||VwL(w)|| cos(@). (A.10)
Note that we have taken our direction to have length one for convenience, and used @ for the angle between v and VyL(w). If we want to find the direction that decreases L as rapidly as possible, we want to make this expression as negative as possible. The only way the direction we pick enters into this equation is through cos(@), and thus we wish to make this cosine as negative as possible. Now, recalling the shape of cosine, we can make this as negative as possible by making cos(@) = ‚Äî1 or equivalently making the angle between the gradient and our chosen direction to be 7 radians, or equivalently 180 degrees. The only way to achieve this is to head in the exact opposite direction: pick v to point in the exact opposite direction to VyL(w)! This brings us to one of the most important mathematical concepts in machine learning:
(continued from previous page)
Mathematics for Deep Learning
938

the direction of steepest decent points in the direction of -VyL(w). Thus our informal
algorithm can be rewritten as follows.bubu1. Start with a random choice for the initial parameters w. 2.bubuCompute rwùêø‚Äûw‚Äù. 3. Take a small step in the opposite of that direction: w ‚Äî w ‚Äî eVwL(w). 4.bubuRepeat. This basic algorithm has been modified and adapted many ways by many researchers, but the core concept remains the same in all of them. Use the gradient to find the direction that decreases the loss as rapidly as possible, and update the parameters to take a step in that direction. A.4.3 A Note on Mathematical Optimization
Throughoutthisbook, wefocussquarelyonnumericaloptimizationtechniquesfortheprac- tical reason that all functions we encounter in the deep learning setting are too complex to minimize explicitly. However, it is a useful exercise to consider what the geometric understanding we obtained above tells us about optimizing functions directly. Suppose that we wish to find the value of x0 which minimizes some function ùêø‚Äûx‚Äù. Let‚Äôs
suppose that moreover someone gives us a value and tells us that it is the value that mini- mizes ùêø. Is there anything we can check to see if their answer is even plausible? Again consider (A.5):
L(xo + ‚Ç¨) ¬ª L(xo) + ‚Ç¨- VxL (Xo). (A.11)
If the gradient is not zero, we know that we can take a step in the direction ‚ÄîeV,L(xo) to find a value of L that is smaller. Thus, if we truly are at a minimum, this cannot be the case! We can conclude that if xo is a minimum, then VxL(xo) = 0. We call points with Vx L(xo0) = 0 critical points. This is nice, because in some rare settings, we can explicitly find all the points where the gradient is zero, and find the one with the smallest value. For a concrete example, consider the function
f(x) = 3x4 = 493 = 1227. (A.12)
This function has derivative
af = 12x3 ‚Äî 12x? ‚Äî 24x = 12x(x - 2)(x + 1). (A.13)
The only possible location of minima are at x = ‚Äî1,0,2, where the function takes the values ‚Äî5,0, ‚Äî32 respectively, and thus we can conclude that we minimize our function when x = 2. A quick plot confirms this. Multivariable Calculus
939

x = torch.arange(-2, 3, 0.01) f = (3 * x**4) - (4 * x**3) - (12 * x**2) d2l.plot(x, f, 'x', 'f(x)')
20 F(x) ¬∞ -20
This highlights an important fact to know when working either theoretically or numerically: theonlypossiblepointswherewecanminimize(ormaximize)afunctionwillhavegradient equal to zero, however, not every point with gradient zero is the true global minimum (or maximum). A.4.4 Multivariate Chain Rule
Let‚Äôs suppose that we have a function of four variables (ùë§,ùë•, ùë¶, and ùëß) which we can make
by composing many terms:
ùëì ‚Äûùë¢,ùë£‚Äù = ‚Äûùë¢ ‚Äö ùë£‚Äù2
f(u,v) = (ut u(a,b) =(a+b)‚Äô, v(a, b) = (a-b)?, (A.14) a(w,x,y,z)=(w+xty4z), ‚Äî bw.x,y.z) = (wtx-y-‚Äù‚Äô. Such chains of equations are common when working with neural networks, so trying to understand how to compute gradients of such functions is key. We can start to see visual hints of this connection in Fig.bubuA.1 if we take a look at what variables directly relate to one another. tFig. A.1
The function relations above where nodes represent values and edges show functional dependence. Nothing stops us from just composing everything from (A.14) and writing out that
2 f(w,x,y,2) = ((o+xey+0" +0v4x-y-2)") + ((w trey te)? -(w+x-y- 2) | : (A.15)
2
Mathematics for Deep Learning
940

We may then take the derivative by just using single variable derivatives, but if we did that we would quickly find ourself swamped with terms, many of which are repeats! Indeed, one can see that, for instance:
ùúï ùëì
sf =2(2Q0v+x4y+2)-2w4x-y-2)(Wwertyte? ‚Äî(w+x-y-2z) >) 2(2(wtx-y-z)+2(w+xt+y+z)) ((v+x-y‚Äî2)? + (wx4y42))) x ((ortxy eo? = Orex-y- a) + (Wex-y-o%+ Wax ty en) (A.16)
ùúï ùëì
If we then also wanted to compute ùúïùë•, we would end up with a similar equation again with many repeated terms, and many shared repeated terms between the two derivatives. This represents a massive quantity of wasted work, and if we needed to compute derivatives this way, the whole deep learning revolution would have stalled out before it began! Let‚Äôs break up the problem. We will start by trying to understand how ùëì changes when we
change ùëé, essentially assuming that ùë§,ùë•, ùë¶, and ùëß all do not exist. We will reason as we did back when we worked with the gradient for the first time. Let‚Äôs take ùëé and add a small amount ùúñ to it. ùëì ‚Äûùë¢‚Äûùëé ‚Äö ùúñ, ùëè‚Äù,ùë£‚Äûùëé ‚Äö ùúñ, ùëè‚Äù‚Äù
xf |u(a, b)rertCa, b), v(a, y+ eat ‚Äú(a, b) xf (u(a, b), v(a, b)) +‚Ç¨ Fuca, b),v(a, 0) (a ,b)+ 2 ua, b),v(a by) oe = (a, b)}. ‚Äú(a.7)
The first line follows from the definition of partial derivative, and the second follows from the definition of gradient. It is notationally burdensome to track exactly where we evaluate ùúï ùëì ùúïùë¢ ‚Äûùë¢‚Äûùëé, ùëè‚Äù,ùë£‚Äûùëé, ùëè‚Äù‚Äù, so we often abbreviate this to every derivative, as in the expression the much more memorable
ùúï ùëì
ùúïùëé = ùúïùë¢ ùúïùëé ‚Äö ùúïùë£ ùúïùëé . (A.18)
It is useful to think about the meaning of the process. We are trying to understand how a function of the form f(u(a,b),v(a,b)) changes its value with a change in a. There are two pathways this can occur: there is the pathway where a > u ‚Äî f and where a‚Äî v‚Äî f. We can compute both of these contributions via the chain rule: oe ou and a a) Fe x tespectively, and added up. Imagine we have a different network of functions where the functions on the right depend on those that are connected to on the left as is shown in Fig. A.2.bubuOOO o<o_G20
tFig. A.2
Another more subtle example of the chain rule. ùúï ùëì
ùúïùë¢
ùúï ùëì
ùúïùë£
Multivariable Calculus
941

ùúï ùëì
To compute something like ùúïùë¶, we need to sum over all (in this case 3) paths from ùë¶ to ùëì giving
ùúï ùëì
ùúï ùëì
ùúïùëé
ùúïùë¢
ùúïùë¶ = ùúïùëé ùúïùë¢ ùúïùë¶ ‚Äö ùúïùë¢ ùúïùë¶ ‚Äö ùúïùëè ùúïùë£ ùúïùë¶ . (A.19)
Understanding the chain rule in this way will pay great dividends when trying to understand how gradients flow through networks, and why various architectural choices like those in LSTMs (Section 10.1) or residual layers (Section 8.6) can help shape the learning process by controlling gradient flow. A.4.5 The Backpropagation Algorithm
Let‚Äôs return to the example of (A.14) the previous section where
f(u,v) = (ut v)? u(a,b) =(a+b)‚Äô, v(a,b) = (a‚Äî b)?, (A.20) a(w,x,y,z) =(w+xtyt 2), b(w,x,y,2) =(wtx-y- 2). ùúï ùëì
If we want to compute say ùúïùë§ we may apply the multi-variate chain rule to see:
ùúï ùëì
ùúïùë§ = ùúïùë¢ ùúïùë§ ‚Äö ùúïùë£ ùúïùë§ , ùúïùë¢ ùúïùë§ = ùúïùë¢ ùúïùëé ùúïùëé ùúïùë§ ‚Äö ùúïùë¢ ùúïùëè ùúïùëè ùúïùë§ , (A.21) ùúïùë£ ùúïùë§ = ùúïùë£ ùúïùëé ùúïùëé ùúïùë§ ‚Äö ùúïùë£ ùúïùëè ùúïùëè ùúïùë§ . Let‚Äôs try using this decomposition to compute ùúïùë§. Notice that all we need here are the various single step partials:
Of _ OF _ Fy 7 2 ty) ay =2(u+v), ou _ (a+b), a =2(a+b), by ' (A.22) 5, =a), Se =-2(a-b), 28 _awaxtyty, ¬Æ _owex-y-2). Ow Ow
If we write this out into code this becomes a fairly manageable expression. # Compute the value of the function from inputs to outputs w, x, y, z = -1, 0, -2, 1 a, b = (w + x + y + z)**2, (w + x - y - z)**2 u, v = (a + b)**2, (a - b)**2 f = (u + v)**2 print(f' f at {w}, {x}, {y}, {z} is {f}') # Compute the single step partials df_du, df_dv = 2*(u + v), 2*(u + v)
ùúï ùëì
ùúïùë¢
ùúï ùëì
ùúïùëè
ùúïùë£
ùúï ùëì
ùúïùë¢
ùúï ùëì
ùúïùë£
ùúï ùëì
(continues on next page)
Mathematics for Deep Learning
942

du_da, du_db, dv_da, dv_db = 2*(a + b), 2*(a + b), 2*(a - b), -2*(a - b) da_dw, db_dw = 2*(w + x + y + z), 2*(w + x - y - z)
# Compute the final result from inputs to outputs
du_dw, dv_dw = du_da*da_dw + du_db*db_dw, dv_da*da_dw + dv_db*db_dw df_dw = df_du*du_dw + df_dv*dv_dw print(f'df/dw at {w}, {x}, {y}, {z} is {df_dw}')
f at -1, 0, -2, 1 is 1024 df/dw at -1, 0, -2, 1 is -4096
However, note that this still does not make it easy to compute something like ùúïùë•. The reason for that is the way we chose to apply the chain rule.bubuIf we look at what we did above, we always kept ùúïùë§ in the denominator when we could. In this way, we chose to apply the chain rule seeing how ùë§ changed every other variable. If that is what we wanted, this would be a good idea. However, think back to our motivation from deep learning: we want to see how every parameter changes the loss. In essence, we want to apply the chain rule keeping ùúï ùëì in the numerator whenever we can! To be more explicit, note that we can write
ùúï ùëì ùúïùë§ = ùúï ùëì ùúïùëé ùúïùëé ùúïùë§ ‚Äö ùúï ùëì ùúïùëè ùúïùëè ùúïùë§ , ùúï ùëì ùúïùëé = ùúï ùëì ùúïùë¢ ùúïùë¢ ùúïùëé ‚Äö ùúï ùëì ùúïùë£ ùúïùë£ ùúïùëé , (A.23) ùúï ùëì ùúïùëè = ùúï ùëì ùúïùë¢ ùúïùë¢ ùúïùëè ‚Äö ùúï ùëì ùúïùë£ ùúïùë£ ùúïùëè . Notethatthisapplicationofthechainrulehasusexplicitlycompute ùúïùë§. Nothing stops us from also including the equations:
ùúï ùëì
ùúïùë• = ùúïùëé ùúïùë• ‚Äö ùúïùëè ùúïùë• , ùúï ùëì ùúïùë¶ = ùúï ùëì ùúïùëé ùúïùëé ùúïùë¶ ‚Äö ùúï ùëì ùúïùëè ùúïùëè ùúïùë¶ , (A.24) ùúï ùëì ùúïùëß = ùúï ùëì ùúïùëé ùúïùëé ùúïùëß ‚Äö ùúï ùëì ùúïùëè ùúïùëè ùúïùëß . and then keeping track of how ùëì changes when we change any node in the entire network. Let‚Äôs implement it. # Compute the value of the function from inputs to outputs w, x, y, z = -1, 0, -2, 1 a, b = (w + x + y + z)**2, (w + x - y - z)**2 u, v = (a + b)**2, (a - b)**2 f = (u + v)**2 print(f'f at {w}, {x}, {y}, {z} is {f}') # Compute the derivative using the decomposition above
(continued from previous page)
ùúï ùëì
ùúï ùëì
ùúïùë¢, ùúï ùëì
ùúïùë£ , ùúï ùëì
ùúïùëé, ùúï ùëì
ùúï ùëì
ùúïùëè, and
ùúï ùëì
ùúïùëé
ùúï ùëì
ùúïùëè
(continues on next page)
Multivariable Calculus
943

# First compute the single step partials df_du, df_dv = 2*(u + v), 2*(u + v) du_da, du_db, dv_da, dv_db = 2*(a + b), 2*(a + b), 2*(a - b), -2*(a - b) da_dw, db_dw = 2*(w + x + y + z), 2*(w + x - y - z) da_dx, db_dx = 2*(w + x + y + z), 2*(w + x - y - z) da_dy, db_dy = 2*(w + x + y + z), -2*(w + x - y - z) da_dz, db_dz = 2*(w + x + y + z), -2*(w + x - y - z) # Now compute how f changes when we change any value from output to input
# Now compute how f changes when we change any value from output to input df_da, df_db = df_du*du_da + df_dv*dv_da, df_du*du_db + df_dv*dv_db df_dw, df_dx = df_da*da_dw + df_db*db_dw, df_da*da_dx + df_db*db_dx df_dy, df_dz = df_da*da_dy + df_db*db_dy, df_da*da_dz + df_db*db_dz
print(f'df/dw at {w}, {x}, {y}, {z} is {df_dw}') print(f'df/dx at {w}, {x}, {y}, {z} is {df_dx}') print(f'df/dy at {w}, {x}, {y}, {z} is {df_dy}') print(f'df/dz at {w}, {x}, {y}, {z} is {df_dz}')
f at -1, 0, -2, 1 is 1024 df/dw at -1, 0, -2, 1 is -4096 df/dx at -1, 0, -2, 1 is -4096 df/dy at -1, 0, -2, 1 is -4096 df/dz at -1, 0, -2, 1 is -4096
The fact that we compute derivatives from ùëì back towards the inputs rather than from the
inputs forward to the outputs (as we did in the first code snippet above) is what gives this algorithm its name: backpropagation. Note that there are two steps: 1.bubuCompute the value of the function, and the single step partials from front to back. While not done above, this can be combined into a single forward pass. 2. Compute the gradient of ùëì from back to front. We call this the backwards pass. This is precisely what every deep learning algorithm implements to allow the computation of the gradient of the loss with respect to every weight in the network at one pass. It is an astonishing fact that we have such a decomposition. To see how to encapsulated this, let‚Äôs take a quick look at this example. # Initialize as ndarrays, then attach gradients w = torch.tensor([-1.], requires_grad=True) x = torch.tensor([0.], requires_grad=True) y = torch.tensor([-2.], requires_grad=True) z = torch.tensor([1.], requires_grad=True) # Do the computation like usual, tracking gradients a, b = (w + x + y + z)**2, (w + x - y - z)**2 u, v = (a + b)**2, (a - b)**2 f = (u + v)**2 # Execute backward pass f.backward() print(f'df/dw at {w.data.item()}, {x.data.item()}, {y.data.item()}, '
(continued from previous page)
(continues on next page)
Mathematics for Deep Learning
944

f'{z.data.item()} is {w.grad.data.item()}') print(f'df/dx at {w.data.item()}, {x.data.item()}, {y.data.item()}, ' f'{z.data.item()} is {x.grad.data.item()}') print(f'df/dy at {w.data.item()}, {x.data.item()}, {y.data.item()}, ' f'{z.data.item()} is {y.grad.data.item()}') print(f'df/dz at {w.data.item()}, {x.data.item()}, {y.data.item()}, ' f'{z.data.item()} is {z.grad.data.item()}')
df/dw at -1.0, 0.0, -2.0, 1.0 is -4096.0 df/dx at -1.0, 0.0, -2.0, 1.0 is -4096.0 df/dy at -1.0, 0.0, -2.0, 1.0 is -4096.0 df/dz at -1.0, 0.0, -2.0, 1.0 is -4096.0
All of what we did above can be done automatically by calling f.backwards(). A.4.6 Hessians
As with single variable calculus, it is useful to consider higher-order derivatives in order to get a handle on how we can obtain a better approximation to a function than using the gradient alone.bubuThere is one immediate problem one encounters when working with higher order deriva- tives of functions of several variables, and that is there are a large number of them. If we have a function ùëì ‚Äûùë•1, . . .,ùë•ùëõ‚Äù of ùëõ variables, then we can take ùëõ2 many second derivatives, namely for any choice of ùëñ and ùëó:
ùëë2 ùëì
ùëëùë•ùëñùëëùë• ùëó = ùëëùë•ùëñ ùëëùë• ùëó ùëì . (A.25)
This is traditionally assembled into a matrix called the Hessian:
af Caml dxidxi """ ‚Äî dxidxp Hp=| 2: |. (A.26) af Caml dxndx, ¬∞¬∞" AxndXxn
Not every entry of this matrix is independent. Indeed, we can show that as long as both mixed partials (partial derivatives with respect to more than one variable) exist and are continuous, we can say that for any ùëñ, and ùëó,
ùëë2 ùëì ùëëùë•ùëñùëëùë• ùëó = ùëë2 ùëì ùëëùë• ùëóùëëùë•ùëñ . (A.27)
This follows by considering first perturbing a function in the direction of ùë•ùëñ, and then per- turbing it in ùë• ùëó and then comparing the result of that with what happens if we perturb first ùë• ùëó and then ùë•ùëñ, with the knowledge that both of these orders lead to the same final change in the output of ùëì. As with single variables, we can use these derivatives to get a far better idea of how the
(continued from previous page)
ùëë
ùëë
Multivariable Calculus
945

function behaves near a point. In particular, we can use it to find the best fitting quadratic near a point x0, as we saw in a single variable. Let‚Äôs see an example. Suppose that ùëì ‚Äûùë•1,ùë•2‚Äù = ùëé ‚Äö ùëè1ùë•1 ‚Äö ùëè2ùë•2 ‚Äö ùëê11ùë•2 1 ‚Äö ùëê12ùë•1ùë•2 ‚Äö ùëê22ùë•2 2. This is the general form for a quadratic in two variables. If we look at the value of the function, its gradient, and its Hessian (A.26), all at the point zero:
f(0,0) =a, v(0,0) = |7! fOO=1 A> (A.28)
Hùëì ‚Äû0,0‚Äù = 2ùëê11 ùëê12 ùëê12 2ùëê22 ,
we can get our original polynomial back by saying
1 F(x) = f(0) + VF(0) -x+ 3x Hf (Ox. (A.29)
In general, if we computed this expansion any point x0, we see that
/(00) = FC%0) +¬• fp) - (X= Xo) + 5K ‚Äî Xo)" H/CO)(K‚ÄîXo).‚Äî_(A.30)
This works for any dimensional input, and provides the best approximating quadratic to any function at a point. To give an example, let‚Äôs plot the function
f(x,y) = xe, (A.31)
One can compute that the gradient and Hessian are
2_y2 [1 - 2x? 22 {43-6x 4x?y - 2y =er-y =e -y yay vy(ssy) =e" (TLE) and Hyer yy =e (AES PD). (A.32)
And thus, with a little algebra, see that the approximating quadratic at [-1,0]7 is
f(x,y) xe! (-1- +I) + (x41?bubu+9‚Äô). (A.33)
# Construct grid and compute function
x, y = torch.meshgrid(torch.linspace(-2, 2, 101),
torch.linspace(-2, 2, 101))
z = x*torch.exp(- x**2 - y**2)
# Compute approximating quadratic with gradient and Hessian at (1, 0) w = torch.exp(torch.tensor([-1.]))*(-1 - (x + 1) + 2 * (x + 1)**2 + 2 * y**2)
# Plot function
ax = d2l.plt.figure().add_subplot(111, projection='3d')
ax.plot_wireframe(x.numpy(), y.numpy(), z.numpy(),
**{'rstride': 10, 'cstride': 10})
ax.plot_wireframe(x.numpy(), y.numpy(), w.numpy(),
**{'rstride': 10, 'cstride': 10}, color='purple')
(A.32)
(continues on next page)
Mathematics for Deep Learning
946

d2l.plt.xlabel('x') d2l.plt.ylabel('y') d2l.set_figsize() ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(-1, 1) ax.dist = 12

This forms the basis for Newton‚Äôs Algorithm discussed in Section 12.3, where we perform numerical optimization iteratively finding the best fitting quadratic, and then exactly mini- mizing that quadratic. A.4.7 A Little Matrix Calculus
Derivatives of functions involving matrices turn out to be particularly nice. This section can become notationally heavy, so may be skipped in a first reading, but it is useful to know how derivatives of functions involving common matrix operations are often much cleaner than one might initially anticipate, particularly given how central matrix operations are to deep learning applications. Let‚Äôs begin with an example. Suppose that we have some fixed column vector ùú∑, and we
want to take the product function ùëì ‚Äûx‚Äù = ùú∑>x, and understandhow the dot product changes when we change x. A bit of notation that will be useful when working with matrix derivatives in ML is called the denominator layout matrix derivative where we assemble our partial derivatives into the shape of whatever vector, matrix, or tensor is in the denominator of the differential. In this case, we will write
ùëëùëì ùëëx = 6 6 6 6 6 6 4 ùëëùë•1...bubuùëë ùëì ùëëùë•ùëõ 7 7 7 7 7 7 5 , (A.34)
where we matched the shape of the column vector x. If we write out our function into components this is
¬£09 =D) Baxi = Bit +--+ + Ban. (A.35) i=l
(continued from previous page)
3
2
ùëë ùëì
Multivariable Calculus
947

If we now take the partial derivative with respect to say ùõΩ1, note that everything is zero but
the first term, which is just ùë•1 multiplied by ùõΩ1, so we obtain that
or more generally that
We can now reassemble this into a matrix to see
ùëëùëì ùëëx = 6 6 6 6 6 6 4 ùëëùë•1... ùëë ùëì ùëëùë•ùëõ 7 7 7 7 7 7 5 = 6 6 6 6 6 4 ùõΩ1 ...bubuùõΩùëõ 7 7 7 7 7 5 = ùú∑. (A.38)
This illustrates a few factors about matrix calculus that we will often counter throughout this section:
e First, The computations will get rather involved. e Second, The final results are much cleaner than the intermediate process, and will al-
ways look similar to the single variable case. In this case, note that ùëë ùëë ‚Äûùú∑>x‚Äù = ùú∑ are both similar. ùëëùë• ‚Äûùëèùë•‚Äù = ùëè and
ùëëx
e Third, transposes can often appear seemingly from nowhere. The core reason for this is
the convention that we match the shape of the denominator, thus when we multiply matrices, we will need to take transposes to match back to the shape of the original term. To keep building intuition, let‚Äôs try a computation that is a little harder. Suppose that we have a column vector x, and a square matrix ùê¥ and we want to compute
To drive towards easier to manipulate notation, let‚Äôs consider this problem using Einstein notation. In this case we can write the function as
x>ùê¥x = ùë•ùëñùëéùëñùëóùë• ùëó. (A.40)
To compute our derivative, we need to understand for every ùëò, what is the value of
ùëë
ùëëùë•ùëò ‚Äûx>ùê¥x‚Äù = ùëëùë•ùëò ùë•ùëñùëéùëñùëóùë• ùëó. (A.41)
By the product rule, this is
ùëë ùëëùë•ùëò ùë•ùëñùëéùëñùëóùë• ùëó = ùëëùë•ùëñ ùëëùë•ùëò ùëéùëñùëóùë• ùëó ‚Äö ùë•ùëñùëéùëñùëó ùëëùë•ùëò . (A.42)
ùëëùë•ùëñ
ùëëùë•ùëò , it is not hard to see that this is one when ùëñ = ùëò and zero otherwise. For a term like This means that every term where ùëñ and ùëò are different vanish from this sum, so the only
ùëëùëì
ùëëùë•1 = ùõΩ1, (A.36)
ùëëùëì
ùëëùë•ùëñ = ùõΩùëñ. (A.37)
2
3
ùëë ùëì
2
3
ùëë
ùëëx ‚Äûx>ùê¥x‚Äù. (A.39)
ùëë
ùëëùë• ùëó
Mathematics for Deep Learning
948

terms that remain in that first sum are the ones where ùëñ = ùëò. The same reasoning holds for
the second term where we need ùëó = ùëò. This gives
ùëë
ùëëùë•ùëò ùë•ùëñùëéùëñùëóùë• ùëó = ùëéùëò ùëóùë• ùëó ‚Äö ùë•ùëñùëéùëñùëò. (A.43)
Now, the names of the indices in Einstein notation are arbitrary‚Äîthe fact that ùëñ and ùëó are
different is immaterial to this computation at this point, so we can re-index so that they both use ùëñ to see that
ùëë
ùëëùë•ùëò ùë•ùëñùëéùëñùëóùë• ùëó = ùëéùëòùëñùë•ùëñ ‚Äö ùë•ùëñùëéùëñùëò = ‚Äûùëéùëòùëñ ‚Äö ùëéùëñùëò‚Äùùë•ùëñ. (A.44)
Now, here is where we start to need some practice to go further. Let‚Äôs try and identify this outcome in terms of matrix operations. ùëéùëòùëñ ‚Äö ùëéùëñùëò is the ùëò,ùëñ-th component of A‚ÄöA>. This gives
ùëë
ùëëùë•ùëò ùë•ùëñùëéùëñùëóùë• ùëó = ¬ªA ‚Äö A>‚Ä¶ùëòùëñùë•ùëñ. (A.45)
Similarly, this term is now the product of the matrix A ‚Äö A> by the vector x, so we see
that
ùëë ùëëx ‚Äûx>ùê¥x‚Äù ùëò = ùëë ùëëùë•ùëò ùë•ùëñùëéùëñùëóùë• ùëó = ¬ª‚ÄûA ‚Äö A>‚Äùx‚Ä¶ùëò. (A.46)
Thus, we see that the ùëò-th entry of the desired derivative from (A.39) is just the ùëò-th entry
of the vector on the right, and thus the two are the same. Thus yields
ùëë
ùëëx ‚Äûx>ùê¥x‚Äù = ‚ÄûA ‚Äö A>‚Äùx. (A.47)
This required significantly more work than our last one, but the final result is small. More thanthat,considerthefollowingcomputationfortraditionalsinglevariablederivatives:
ùëë
ùëëùë• ‚Äûùë•ùëéùë•‚Äù = ùëëùë• ùëéùë• ‚Äö ùë•ùëé ùëëùë• = ‚Äûùëé ‚Äö ùëé‚Äùùë•. (A.48)
Equivalently ùëë
ùëëùë• ‚Äûùëéùë•2‚Äù = 2ùëéùë• = ‚Äûùëé ‚Äö ùëé‚Äùùë•. Again, we get a result that looks rather like the single variable result but with a transpose tossed in. At this point, the pattern should be looking rather suspicious, so let‚Äôs try to figure out why. When we take matrix derivatives like this, let‚Äôs first assume that the expression we get will be another matrix expression: an expression we can write it in terms of products and sums of matrices and their transposes. If such an expression exists, it will need to be true for all matrices. In particular, it will need to be true of 1 x 1 matrices, in which case the matrix product is just the product of the numbers, the matrix sum is just the sum, and the transpose does nothing at all! In other words, whatever expression we get must match the single variable expression. This means that, with some practice, one can often guess matrix derivatives just by knowing what the associated single variable expression must look like! Let‚Äôs try this out. Suppose that X is an x m matrix, U is ann xr and V is anr x m. Let‚Äôs
try to compute
ùëë
d F'lx -UV\|3 =? (A.49)
ùëëùë•
ùëëùë•
Multivariable Calculus
949

This computation is important in an area called matrix factorization. For us, however, it is just a derivative to compute. Let‚Äôs try to imagine what this would be for 1 x 1 matrices. In that case, we get the expression
ùëë
d ‚Äî(x = uy)? =-2(x-uv)u, (A.50) dv
where, the derivative is rather standard. If we try to convert this back into a matrix expres- sion we get
ùëë
d qv iix- UV | = -2(X - UV)U. (A.51)
However, if we look at this it does not quite work. Recall that X is n x m, as is UV, so the
However, if we look at this it does not quite work. Recall that X is n x m, as is UV, so the matrix 2(X ‚Äî UV) isnxm. On the other hand U is n xr, and we cannot multiply an xm and an X r matrix since the dimensions do not match! We want to get ùëë
We want to get a. which is the same shape as V, which is r x m. So somehow we need to take a nm X m matrix and an X r matrix, multiply them together (perhaps with some transposes) to get ar x m. We can do this by multiplying U' by (X - UV). Thus, we can guess the solution to (A.49) is
ùëë
d qy!lX - UV IE =-2U'(X- UV). (A.52)
To show that this works, we would be remiss to not provide a detailed computation. If we already believe that this rule-of-thumb works, feel free to skip past this derivation. To compute
ùëë
d 2 IX UVI3, (A.53)
we must find for every ùëé, and ùëè
2 a |X -UVI3 = ‚Äúy xij ‚Äî )wiRv Rj (A.54) dvab 2 dvay VN Aa
Recalling that all entries of X and U are constants as far as ùëëùë£ùëéùëè is concerned, we may push the derivative inside the sum, and apply the chain rule to the square to get
d 2 dvxj X-UvVI2 = YS 2[x- ove ll‚Äî . J). 55 Tan l| lls ) [s ) nun] | > ik (A.55) ij k
ùëëùë£ùëéùëè is only non-zero if the ùëò = ùëé and As in the previous derivation, we may note that ùëó = ùëè. If either of those conditions do not hold, the term in the sum is zero, and we may freely discard it. We see that
d |X - UV} =-2)¬∞ [¬ª -¬ª) va] Uia- (A.56) i dv ab z
An important subtlety here is that the requirement that ùëò = ùëé does not occur inside the
! ùëë
!bubu!bubuùëëùë£ùëò ùëó
! Mathematics for Deep Learning
950

inner sum since that ùëò is a dummy variable which we are summing over inside the inner
term. For a notationally cleaner example, consider why
ùëë ùëëùë•1 ùëñ ùë•ùëñ = 2 ùëñ ùë•ùëñ . (A.57)
From this point, we may start identifying components of the sum. First,
ùë¢ùëñùëòùë£ùëòùëè = ¬ªUV‚Ä¶ùëñùëè. ùëò (A.58)
So the entire expression in the inside of the sum is
Xib ‚Äî ¬ª UikVkb = [X- UV]in. (A.59) k
This means we may now write our derivative as
ùëë
d Vab [X - UV} = -2 EX - UV]inuia- (A.60)
We want this to look like the ùëé, ùëè element of a matrix so we can use the technique as in the
previous example to arrive at a matrix expression, which means that we need to exchange the order of the indices on ùë¢ùëñùëé. If we notice that ùë¢ùëñùëé = ¬ªU>‚Ä¶ùëéùëñ, we can then write
ùëë
d dab IX ‚Äî UVI} = -2 DTU" JailX - UV]iv. (A.61)
This is a matrix product, and thus we can conclude that
ùëë
d Vab |X - UV]; = -2[U"(X - UV) Jap. (A.62)
and thus we may write the solution to (A.49)
ùëë
Aix Uv =-2U'(X- UV). (A.63)
This matches the solution we guessed above! It is reasonable to ask at this point, ‚ÄúWhy can I not just write down matrix versions of all the calculus rules I have learned? It is clear this is still mechanical. Why do we not just get it over with!‚Äù And indeed there are such rules and (Petersen and Pedersen, 2008) provides an excellent summary. However, due to the plethora of ways matrix operations can be combined compared to single values, there are many more matrix derivative rules than single variable ones. It is often the case that it is best to work with the indices, or leave it up to automatic differentiation when appropriate. A.4.8 Summary
e In higher dimensions, we can define gradients which serve the same purpose as deriva-
tives in one dimension. These allow us to see how a multi-variable function changes when we make an arbitrary small change to the inputs.bubu!bubu! 2
Integral Calculus
951

The backpropagation algorithm can be seen to be a method of organizing the multi-
variable chain rule to allow for the efficient computation of many partial derivatives. Matrix calculus allows us to write the derivatives of matrix expressions in concise ways. A.4.9 Exercises
1. Givenacolumnvector ùú∑, computethederivativesofboth ùëì ‚Äûx‚Äù = ùú∑>xandùëî‚Äûx‚Äù = x>ùú∑. Why do you get the same answer? 2. Let v be an ùëõ dimension vector. What is ùúï
3. Let ùêø‚Äûùë•, ùë¶‚Äù = log‚Äûùëíùë• ‚Äö ùëíùë¶‚Äù. Compute the gradient. What is the sum of the components
of the gradient? 4.bubuLet ùëì ‚Äûùë•, ùë¶‚Äù = ùë•2ùë¶ ‚Äö ùë•ùë¶2. Show that the only critical point is ‚Äû0,0‚Äù. By considering
ùëì ‚Äûùë•,ùë•‚Äù, determine if ‚Äû0,0‚Äù is a maximum, minimum, or neither. 5. Suppose that we are minimizing a function ùëì ‚Äûx‚Äù = ùëî‚Äûx‚Äù ‚Äö ‚Ñé‚Äûx‚Äù. How can we geomet-
rically interpret the condition of rùëì = 0 in terms of ùëî and ‚Ñé? Discussions283.bubu283
A.5 Integral Calculus
|
Differentiation only makes up half of the content of a traditional calculus education. The other pillar, integration, starts out seeming a rather disjoint question, ‚ÄúWhat is the area underneath this curve?‚Äù While seemingly unrelated, integration is tightly intertwined with the differentiation via what is known as the fundamental theorem of calculus. Atthelevelofmachinelearningwediscussinthisbook, wewillnotneedadeepunderstand- ing of integration. However, we will provide a brief introduction to lay the groundwork for any further applications we will encounter later on. A.5.1 Geometric Interpretation
Supposethatwehaveafunction ùëì ‚Äûùë•‚Äù. Forsimplicity, let‚Äôsassumethat ùëì ‚Äûùë•‚Äù isnon-negative
(never takes a value less than zero). What we want to try and understand is: what is the area contained between ùëì ‚Äûùë•‚Äù and the ùë•-axis? %matplotlib inline import torch from IPython import display from mpl_toolkits import mplot3d from d2l import torch as d2l
kvk2? ¬£llvllo? ùúïv
(continues on next page)
Mathematics for Deep Learning
952

x = torch.arange(-2, 2, 0.01) f = torch.exp(-x**2) d2l.set_figsize() d2l.plt.plot(x, f, color='black') d2l.plt.fill_between(x.tolist(), f.tolist()) d2l.plt.show()
1.0 0.8 0.6 0.4 0.2 0.0
In most cases, this area will be infinite or undefined (consider the area under ùëì ‚Äûùë•‚Äù = ùë•2),
so people will often talk about the area between a pair of ends, say ùëé and ùëè. x = torch.arange(-2, 2, 0.01) f = torch.exp(-x**2) d2l.set_figsize() d2l.plt.plot(x, f, color='black') d2l.plt.fill_between(x.tolist()[50:250], f.tolist()[50:250]) d2l.plt.show()
1.0 0.8 0.6 0.4 0.2 0.0
We will denote this area by the integral symbol below:
Area‚ÄûA‚Äù = ùëì ‚Äûùë•‚Äù ùëëùë•. (A.1) ùëé
The inner variable is a dummy variable, much like the index of a sum in a , and so this can be equivalently written with any inner value we like:
‚Äû ùëè
ùëì ‚Äûùë•‚Äù ùëëùë• = ùëì ‚Äûùëß‚Äù ùëëùëß. (A.2) ùëé ùëé
(continued from previous page)
‚Äû ùëè
Àù
‚Äû ùëè
Integral Calculus
953

There is a traditional way to try and understand how we might try to approximate such integrals: we can imagine taking the region in-between ùëé and ùëè and chopping it into ùëÅ vertical slices. If ùëÅ is large, we can approximate the area of each slice by a rectangle, and then add up the areas to get the total area under the curve. Let‚Äôs take a look at an example doing this in code.bubuWe will see how to get the true value in a later section. epsilon = 0.05 a = 0 b = 2 x = torch.arange(a, b, epsilon) f = x / (1 + x**2) approx = torch.sum(epsilon*f) true = torch.log(torch.tensor([5.])) / 2 d2l.set_figsize() d2l.plt.bar(x, f, width=epsilon, align='edge') d2l.plt.plot(x, f, color='black') d2l.plt.ylim([0, 1]) d2l.plt.show()
f'approximation: {approx}, truth: {true}'
1.0 0.8 0.6 0.4 0.2 0.0- 0.0 0.5 1.0 15 2.0
'approximation: 0.7944855690002441, truth: tensor([0.8047])'
The issue is that while it can be done numerically, we can do this approach analytically for only the simplest functions like
Anything somewhat more complex like our example from the code above
‚Äû ùëè
ùëé 1 ‚Äö ùë•2 ùëëùë•. (A.4)
is beyond what we can solve with such a direct method.bubuWe will instead take a different approach. We will work intuitively with the notion of the area, and learn the main computational tool used to find integrals: the fundamental theorem of calculus. This will be the basis for our study of integration. ‚Äû ùëè
ùë• ùëëùë•. ùëé (A.3)
ùë•
Mathematics for Deep Learning
954

A.5.2 The Fundamental Theorem of Calculus
To dive deeper into the theory of integration, let‚Äôs introduce a function
ùêπ‚Äûùë•‚Äù = ùëì ‚Äûùë¶‚Äùùëëùë¶. 0 (A.5)
This function measures the area between 0 and ùë• depending on how we change ùë•. Notice
that this is everything we need since
‚Äû ùëè
b f(x) dx = F(b) - F(a). (A) a
This is a mathematical encoding of the fact that we can measure the area out to the far end- point and then subtract off the area to the near end point as indicated in Fig. A.1. tFig. A.1
Visualizing why we may reduce the problem of computing the area under a curve between two points to computing the area to the left of a point. Thus, we can figure out what the integral over any interval is by figuring out what ùêπ‚Äûùë•‚Äù
is. To do so, let‚Äôs consider an experiment. As we often do in calculus, let‚Äôs imagine what hap- pens when we shift the value by a tiny bit. From the comment above, we know that
X+E F(x+6) - F(x) = [ f(y) dy. (A.7) x
This tells us that the function changes by the area under a tiny sliver of a function. This is the point at which we make an approximation. If we look at a tiny sliver of area like this, it looks like this area is close to the rectangular area with height the value of ùëì ‚Äûùë•‚Äù and the base width ùúñ. Indeed, one can show that as ùúñ !bubu0 this approximation becomes better and better. Thus we can conclude:
F(x+e)‚Äî F(x) ef (x). (A.8)
However, we can now notice: this is exactly the pattern we expect if we were computing the derivative of ùêπ! Thus we see the following rather surprising fact:
ùëëùêπ
ùëëùë• ‚Äûùë•‚Äù = ùëì ‚Äûùë•‚Äù. (A.9)
This is the fundamental theorem of calculus. We may write it in expanded form as
‚Äû ùë•
ùëë ùëì ‚Äûùë¶‚Äù ùëëùë¶ = ùëì ‚Äûùë•‚Äù. ùëëùë• 0 (A.10)
It takes the concept of finding areas (a priori rather hard), and reduces it to a statement derivatives (something much more completely understood). One last comment that we
‚Äû ùë•
‚Äû ùë•‚Äöùúñ
Integral Calculus
955

must make is that this does not tell us exactly what ùêπ‚Äûùë•‚Äù is. Indeed ùêπ‚Äûùë•‚Äù ‚Äöùê∂ for any ùê∂ has
the same derivative. This is a fact-of-life in the theory of integration. Thankfully, notice that when working with definite integrals, the constants drop out, and thus are irrelevant to the outcome. ‚Äû ùëè
b f(x) dx = (F(b) + C) - (F(a) + C) = F(b) - F(a). (A.11) a
This may seem like abstract non-sense, but let‚Äôs take a moment to appreciate that it has given us a whole new perspective on computing integrals. Our goal is no-longer to do some sort of chop-and-sum process to try and recover the area, rather we need only find a function whose derivative is the function we have! This is incredible since we can now list many rather difficult integrals by just reversing the table from Section A.3.2. For instance, we know that the derivative of x‚Äù is nx"~!. Thus, we can say using the fundamental theorem (A.10) that
‚Äû ùë•
x [ ny"! dy =x" ‚Äî-Q" =x". (A.12) 0
Similarly, we know that the derivative of ùëíùë• is itself, so that means
‚Äû ùë•
x [ e* dx =e*‚Äîe¬∞ =e*- 1, (A.13) 0
Inthisway, wecandeveloptheentiretheoryofintegrationleveragingideasfromdifferential calculus freely. Every integration rule derives from this one fact. A.5.3 Change of Variables
Just as with differentiation, there are a number of rules which make the computation of integrals more tractable. In fact, every rule of differential calculus (like the product rule, sumrule, andchainrule)hasacorrespondingruleforintegralcalculus(integrationbyparts, linearity of integration, and the change of variables formula respectively). In this section, we will dive into what is arguably the most important from the list: the change of variables formula. First, suppose that we have a function which is itself an integral:
ùêπ‚Äûùë•‚Äù = ùëì ‚Äûùë¶‚Äù ùëëùë¶. 0 (A.14)
Let‚Äôs suppose that we want to know how this function looks when we compose it with another to obtain ùêπ‚Äûùë¢‚Äûùë•‚Äù‚Äù. By the chain rule, we know
ùëë
d dF du . af UO) = Gi U@) (A.15)
We can turn this into a statement about integration by using the fundamental theorem (A.10) as above. This gives
*d d Flu(s))~ FO) = f¬∞ Flats) F dy. (A.16)
‚Äû ùë•
ùëëùêπ
ùëëùë¢
‚Äû ùë•
Mathematics for Deep Learning
956

Recalling that ùêπ is itself an integral gives that the left hand side may be rewritten to
be
‚Äû ùë¢‚Äûùë•‚Äù
ue) * dF du J, Le [Guo Fa (A.17)
Similarly, recalling that ùêπ is an integral allows us to recognize that ùëëùêπ
fundamental theorem (A.10), and thus we may conclude
‚Äû ùë¢‚Äûùë•‚Äù
u(x) * du ) = y))¬ª ‚Äî dy. A. I, f(y) dy I f(uQy)) dy dy (A.18)
This is the change of variables formula. For a more intuitive derivation, consider what happens when we take an integral of ùëì ‚Äûùë¢‚Äûùë•‚Äù‚Äù
For a more intuitive derivation, consider what happens when we take an integral of f(u(x)) between x and x + ‚Ç¨. For a small e, this integral is approximately ef (u(x)), the area of the associated rectangle. Now, let‚Äôs compare this with the integral of f(y) from u(x) to u(x + ‚Ç¨). We know that u(x + ‚Ç¨) ¬ª u(x) + 44 (x), so the area of this rectangle is approx- imately 44 (x) f(u(x)). Thus, to make the area of these two rectangles to agree, we need to multiply the first one by du (x) as is illustrated in Fig. A.2. flued) So), Reparametrize = > = x Xe ua) uorte)
tFig. A.2
Visualizing the transformation of a single thin rectangle under the change of variables. This tells us that
‚Äû ùë•‚Äöùúñ
ùë• ùëì ‚Äûùë¢‚Äûùë¶‚Äù‚Äù ùëëùë¢ ùëëùë¶ ‚Äûùë¶‚Äù ùëëùë¶ = ùë¢‚Äûùë•‚Äù ùëì ‚Äûùë¶‚Äù ùëëùë¶. (A.19)
This is the change of variables formula expressed for a single small rectangle. If ùë¢‚Äûùë•‚Äù and ùëì ‚Äûùë•‚Äù are properly chosen, this can allow for the computation of incredibly
If u(x) and f(x) are properly chosen, this can allow for the computation of incredibly complex integrals. For instance, if we even chose f(y) = 1 and u(x) = ew (which means d(x) = -2xe7*‚Äô), this can show for instance that
e
e 1 et-1 -[ ldy= 2 | ye-‚Ñ¢ dy, (A.20) eo 0
and thus by rearranging that
‚Äû
! 2 1-e7! [ ye dy= e : (A.21) 0 2
A.5.4 A Comment on Sign Conventions
‚Äû ùë•
ùëëùë• = ùëì using the
‚Äû ùë•
‚Äû ùë¢‚Äûùë•‚Äöùúñ ‚Äù
‚Äû
Integral Calculus
957

Keen-eyed readers will observe something strange about the computations above. Namely, computations like
e
e [ ldy=e!-1<0, (A.22) e0
can produce negative numbers. When thinking about areas, it can be strange to see a neg- ative value, and so it is worth digging into what the convention is. Mathematicians take the notion of signed areas. This manifests itself in two ways. First, if we consider a function ùëì ‚Äûùë•‚Äù which is sometimes less than zero, then the area will also be negative. So for instance
‚Äû
fo dx =-1. (A.23) 0
Similarly, integrals which progress from right to left, rather than left to right are also taken to be negative areas
1
-1 [ ldx =-l. (A.24) 0
The standard area (from left to right of a positive function) is always positive. Anything obtained by flipping it (say flipping over the ùë•-axis to get the integral of a negative number, or flipping over the ùë¶-axis to get an integral in the wrong order) will produce a negative area. And indeed, flipping twice will give a pair of negative signs that cancel out to have positive area
fo dx = 1. (A.25) 0
0
If this discussion sounds familiar, it is! In Section A.1 we discussed how the determinant represented the signed area in much the same way. A.5.5 Multiple Integrals
In some cases, we will need to work in higher dimensions. For instance, suppose that we have a function of two variables, like ùëì ‚Äûùë•, ùë¶‚Äù and we want to know the volume under ùëì when ùë• ranges over ¬ªùëé, ùëè‚Ä¶ and ùë¶ ranges over ¬ªùëê, ùëë‚Ä¶. # Construct grid and compute function x, y = torch.meshgrid(torch.linspace(-2, 2, 101), torch.linspace(-2, 2, 101)) z = torch.exp(- x**2 - y**2) # Plot function ax = d2l.plt.figure().add_subplot(111, projection='3d') ax.plot_wireframe(x, y, z) d2l.plt.xlabel('x') d2l.plt.ylabel('y') d2l.plt.xticks([-2, -1, 0, 1, 2]) d2l.plt.yticks([-2, -1, 0, 1, 2]) d2l.set_figsize()
1
(continues on next page)
Mathematics for Deep Learning
958

ax.set_xlim(-2, 2) ax.set_ylim(-2, 2) ax.set_zlim(0, 1) ax.dist = 12

We write this as
‚Äû
f f(x,y) dx dy. (A.26) [a,b] x[c,d]
Suppose that we wish to compute this integral. My claim is that wecan do this byiteratively computing first the integral in ùë• and then shifting to the integral in ùë¶, that is to say
‚Äû
dy pb / flay) de dy= [ Flx.y) ax) dy. (A.27) [a,b]x[c,d] c a
Let‚Äôs see why this is. Consider the figure above where we have split the function into ‚Ç¨ x ‚Ç¨ squares which we will
index with integer coordinates ùëñ, ùëó. In this case, our integral is approximately
ùëñ, ùëó ùúñ2 ùëì ‚Äûùúñùëñ,ùúñ ùëó‚Äù. (A.28)
Once we discretize the problem, we may add up the values on these squares in whatever order we like, and not worry about changing the values. This is illustrated in Fig.bubuA.3. In particular, we can say that
ùúñ ùúñ ùëì ‚Äûùúñùëñ,ùúñ ùëó‚Äù .bubu(A.29) ùëó ùëñ
HH - BEI Hee =| HVE EH 2
tFig. A.3
Illustrating how to decompose a sum over many squares as a sum over Ô¨Årst the columns (1), then adding the column sums together (2). (continued from previous page)
pb
‚Äû ùëë
! Integral Calculus
959

The sum on the inside is precisely the discretization of the integral
‚Äû ùëè
ùê∫‚Äûùúñ ùëó‚Äù = ùëì ‚Äûùë•,ùúñ ùëó‚Äù ùëëùë•. (A.30) ùëé
Finally, notice that if we combine these two expressions we get
‚Äû ùëë
‚Äû
d Yeen~ [ao ay= [ flxy) de dy. (A31) 7 c [a,b]x[c,d]
Thus putting it all together, we have that
‚Äû
‚Äû ùëë
d b / flay) de dy= [ Flx.y) ax) dy. (A.32) [a,b]x[c,d] c a
Notice that, once discretized, all we did was rearrange the order in which we added a list of numbers. This may make it seem like it is nothing, however this result (called Fubini‚Äôs Theorem) is not always true! For the type of mathematics encountered when doing ma- chine learning (continuous functions), there is no concern, however it is possible to create examples where it fails (for example the function f(x, y) = xy(x? ‚Äî y?)/(x?bubu+ y?)3 over the rectangle [0,2] x [0, 1]). Note that the choice to do the integral in ùë• first, and then the integral in ùë¶ was arbitrary. We
could have equally well chosen to do ùë¶ first and then ùë• to see
‚Äû ùëè
‚Äû
b d x,y) dx dy = .y) dy) dx. A.33 Tosca tl y) dx dy [ (/ f(x,y) ¬ª} (A.33)
Often times, we will condense down to vector notation, and say that for U = [a, b] x [c, d]
this is
‚Äû
ùëì ‚Äûx‚Äù ùëëx. (A.34) ùëà
A.5.6 Change of Variables in Multiple Integrals
As with single variables in (A.18), the ability to change variables inside a higher dimen- sional integral is a key tool. Let‚Äôs summarize the result without derivation. We need a function that reparametrizes our domain of integration. We can take this to be ùúô : Rùëõ ! Rùëõ, that is any function which takes in ùëõ real variables and returns another ùëõ. To keep the expressions clean, we will assume that ùúô is injective which is to say it never folds over itself (ùúô‚Äûx‚Äù = ùúô‚Äûy‚Äù =) x = y). In this case, we can say that
‚Äû
‚Äû
ùúô‚Äûùëà‚Äù ùëì ‚Äûx‚Äù ùëëx = ùëà ùëì ‚Äûùúô‚Äûx‚Äù‚Äù jdet‚Äûùê∑ùúô‚Äûx‚Äù‚Äùj ùëëx. (A.35)
where ùê∑ùúô istheJacobianof ùúô,whichisthematrixofpartialderivativesof ùùì = ‚Äûùúô1‚Äûùë•1, . .bubu.,ùë•ùëõ‚Äù, . . ., ùúôùëõ‚Äûùë•1, .bubu. .,ùë•ùëõ‚Äù‚Äù,
2
ùúïùúô1
Ob |, OH ox Oxn De=| 2 7¬∞ 2].bubu(A.36) Don Obn Ox. Oy
b
d
3
ùúïùúô1
Mathematics for Deep Learning
960

Looking closely, we see that this is similar to the single variable chain rule (A.18), except we have replaced the term ùëëùë¢ ùëëùë• ‚Äûùë•‚Äù with jdet‚Äûùê∑ùúô‚Äûx‚Äù‚Äùj. Let‚Äôs see how we can to interpret this term. Recall that the ùëëùë¢ ùëëùë• ‚Äûùë•‚Äù term existed to say how much we stretched our ùë•-axis by applying ùë¢. The same process in higher dimensions is to determine how much we stretch the area (or volume, or hyper-volume) of a little square (or little hyper-cube) by applying ùùì. If ùùì was the multiplication by a matrix, then we know how the determinant already gives the answer. With some work, one can show that the Jacobian provides the best approximation to a multivariable function ùùì at a point by a matrix in the same way we could approximate by lines or planes with derivatives and gradients. Thus the determinant of the Jacobian exactly mirrors the scaling factor we identified in one dimension. It takes some work to fill in the details to this, so do not worry if they are not clear now. Let‚Äôs see at least one example we will make use of later on. Consider the integral
‚Äû 1
‚Äû 1
[ [ ey‚Äù dx dy. (A.37)
Playing with this integral directly will get us no-where, but if we change variables, we can make significant progress. If we let ùùì‚Äûùëü, ùúÉ‚Äù = ‚Äûùëü cos‚ÄûùúÉ‚Äù,ùëü sin‚ÄûùúÉ‚Äù‚Äù (which is to say that ùë• = ùëü cos‚ÄûùúÉ‚Äù, ùë¶ = ùëü sin‚ÄûùúÉ‚Äù), then we can apply the change of variable formula to see that this is the same thing as
‚Äû 1
‚Äû
00 Qn 2 [ [ e-" |det(DCE(x))| d√© dr, (A.38) 0 0
where
cos(@) ‚Äîrsin(@) |det(DG8(x))| = es ae r cos(@) | = r(cos?(@) + sin?(6)) =r. (A.39)
Thus, the integral is
‚Äû 1
‚Äû
2ùúã
ro) Qn os) [ [ re" d0 dr = an f re" dr=n, (A.40) 0 0 0
where the final equality follows by the same computation that we used in section Section A.5.3. We will meet this integral again when we study continuous random variables in Section A.6. A.5.7 Summary
e The theory of integration allows us to answer questions about areas or volumes. e The fundamental theorem of calculus allows us to leverage knowledge about derivatives
to compute areas via the observation that the derivative of the area up to some point is given by the value of the function being integrated. e Integrals in higher dimensions can be computed by iterating single variable integrals. ‚Äû 1
Random Variables
961

A.5.8 Exercises
Ô¨Ç
1.bubuWhat is 2 1 ùë• ùëëùë•? 1
2. Use the change of variables formula to integrate
Ô¨Ç
3. What is ¬ª0,1‚Ä¶2 ùë•ùë¶ ùëëùë• ùëëùë¶? 4. Use the change of variables formula to compute fk f xy(x? ‚Äî y?)/(x? + y*)> dy dx and f fk f(x,y) = xy(x? ‚Äî y?)/(x? + y?)3 dx dy to see they are different. Discussions?*4,
Discussions284. 284
284
A.6 Random Variables
|
In Section 2.6 we saw the basics of how to work with discrete random variables, which in our case refer to those random variables which take either a finite set of possible values, or the integers. In this section, we develop the theory of continuous random variables, which are random variables which can take on any real value. A.6.1 Continuous Random Variables
Continuous random variables are a significantly more subtle topic than discrete random variables. A fair analogy to make is that the technical jump is comparable to the jump between adding lists of numbers and integrating functions. As such, we will need to take some time to develop the theory. From Discrete to Continuous
To understand the additional technical challenges encountered when working with contin- uous random variables, let‚Äôs perform a thought experiment. Suppose that we are throwing a dart at the dart board, and we want to know the probability that it hits exactly 2cm from the center of the board. To start with, we imagine measuring a single digit of accuracy, that is to say with bins for 0cm, 1cm, 2cm, and so on. We throw say 100 darts at the dart board, and if 20 of them fall into the bin for 2cm we conclude that 20% of the darts we throw hit the board 2cm away from the center. However, when we look closer, this does not match our question! We wanted exact equality, whereas these bins hold all that fell between say 1.5cm and 2.5cm. Undeterred, we continue further. We measure even more precisely, say 1.9cm, 2.0cm,
2.1cm, and now see that perhaps 3 of the 100 darts hit the board in the 2.0cm bucket. Thus we conclude the probability is 3%. Ô¨Ç p
ùúã
ùë• sin‚Äûùë•2‚Äù ùëëùë•. 0
Ô¨Ç
Ô¨Ç
2
1
Mathematics for Deep Learning
962

However, thisdoesnotsolveanything! Wehavejustpushedtheissuedownonedigitfurther. Let‚Äôs abstract a bit. Imagine we know the probability that the first ùëò digits match with 2.00000. . . and we want to know the probability it matches for the first ùëò ‚Äö 1 digits. It is fairly reasonable to assume that the ùëò ‚Äö 1th digit is essentially a random choice from the set f0,1,2, . .bubu.,9g. At least, we cannot conceive of a physically meaningful process which would force the number of micrometers away form the center to prefer to end in a 7 vs a 3. What this means is that in essence each additional digit of accuracy we require should decrease probability of matching by a factor of 10. Or put another way, we would expect that
P(distance is 2.00..., to k digits) = p - 107*. (A.1)
The value p essentially encodes what happens with the first few digits, and the 10-* handles
the rest. Notice that if we know the position accurate to ùëò = 4 digits after the decimal, that means
Notice that if we know the position accurate to k = 4 digits after the decimal, that means we know the value falls within the interval say [1.99995, 2.00005] which is an interval of length 2.00005 ‚Äî 1.99995 = 10-4. Thus, if we call the length of this interval ‚Ç¨, we can say
P(distance is in an ‚Ç¨-sized interval around 2) ~ ‚Ç¨: p. (A.2)
Let‚Äôs take this one final step further. We have been thinking about the point 2 the entire time, but never thinking about other points. Nothing is different there fundamentally, but it is the case that the value ùëù will likely be different. We would at least hope that a dart thrower was more likely to hit a point near the center, like 2cm rather than 20cm. Thus, the value ùëù is not fixed, but rather should depend on the point ùë•. This tells us that we should expect
P(distance is in an e-sized interval around x) ~ ‚Ç¨- p(x). (A.3)
Indeed, (A.3) precisely defines the probability density function. It is a function ùëù‚Äûùë•‚Äù which encodes the relative probability of hitting near one point vs. another.bubuLet‚Äôs visualize what such a function might look like. %matplotlib inline import torch from IPython import display from d2l import torch as d2l torch.pi = torch.acos(torch.zeros(1)).item() * 2 # Define pi in torch # Plot the probability density function for some random variable x = torch.arange(-5, 5, 0.01) p = 0.2*torch.exp(-(x - 3)**2 / 2)/torch.sqrt(2 * torch.tensor(torch.pi)) + \ 0.8*torch.exp(-(x + 1)**2 / 2)/torch.sqrt(2 * torch.tensor(torch.pi)) d2l.plot(x, p, 'x', 'Density')
Random Variables
963

0.0
The locations where the function value is large indicates regions where we are more likely to find the random value. The low portions are areas where we are unlikely to find the random value. Probability Density Functions
Let‚Äôs now investigate this further. We have already seen what a probability density function is intuitively for a random variable ùëã, namely the density function is a function ùëù‚Äûùë•‚Äù so that
P(X is in an e-sized interval around x) ~ ‚Ç¨ - p(x). (A.4)
But what does this imply for the properties of ùëù‚Äûùë•‚Äù? First, probabilities are never negative, thus we should expect that p(x) > 0 as well. Second, let‚Äôs imagine that we slice up the R into an infinite number of slices which are ùúñ
Second, let‚Äôs imagine that we slice up the R into an infinite number of slices which are ‚Ç¨ wide, say with slices (‚Ç¨-i, ‚Ç¨- (i+ 1)]. For each of these, we know from (A.4) the probability is approximately
P(X is in an e-sized interval around x) ~ ‚Ç¨- p(e- i),
(A.5)
so summed over all of them it should be
P(X ER) )e- ple-i). (A.6) i
This is nothing more than the approximation of an integral discussed in Section A.5, thus we can say that
¬© P(X ER)= [ P(x) dx. (A.7)
We know that ùëÉ‚Äûùëã 2 R‚Äù = 1, since the random variable must take on some number, we
can conclude that for any density
‚Äû 1
[ve dx =1. (A.8) co
Indeed, digging into this further shows that for any ùëé, and ùëè, we see that
ùëÉ‚Äûùëã 2 ‚Äûùëé, ùëè‚Ä¶‚Äù = ùëù‚Äûùë•‚Äù ùëëùë•. ùëé (A.9)
‚Äû 1
‚Äû ùëè
Mathematics for Deep Learning
964

We may approximate this in code by using the same discrete approximation methods as before. In this case we can approximate the probability of falling in the blue region. # Approximate probability using numerical integration epsilon = 0.01 x = torch.arange(-5, 5, 0.01) p = 0.2*torch.exp(-(x - 3)**2 / 2) / torch.sqrt(2 * torch.tensor(torch.pi)) +\ 0.8*torch.exp(-(x + 1)**2 / 2) / torch.sqrt(2 * torch.tensor(torch.pi)) d2l.set_figsize() d2l.plt.plot(x, p, color='black') d2l.plt.fill_between(x.tolist()[300:800], p.tolist()[300:800]) d2l.plt.show()
f'approximate Probability: {torch.sum(epsilon*p[300:800])}'
0.3 0.2 0.1 0.0
'approximate Probability: 0.773617148399353'
It turns out that these two properties describe exactly the space of possible probability density functions (or p.d.f.‚Äôs for the commonly encountered abbreviation). They are non- negative functions p(x) > 0 such that
‚Äû 1
[ve dx =1. (A.10)
We interpret this function by using integration to obtain the probability our random variable is in a specific interval:
ùëÉ‚Äûùëã 2 ‚Äûùëé, ùëè‚Ä¶‚Äù = ùëù‚Äûùë•‚Äù ùëëùë•. ùëé (A.11)
In Section A.8 we will see a number of common distributions, but let‚Äôs continue working in the abstract. Cumulative Distribution Functions
In the previous section, we saw the notion of the p.d.f. In practice, this is a commonly en- countered method to discuss continuous random variables, but it has one significant pitfall: that the values of the p.d.f. are not themselves probabilities, but rather a function that we must integrate to yield probabilities. There is nothing wrong with a density being larger
‚Äû ùëè
Random Variables
965

than 10, as long as it is not larger than 10 for more than an interval of length 1/10. This
can be counter-intuitive, so people often also think in terms of the cumulative distribution function, or c.d.f., which is a probability. In particular, by using (A.11), we define the c.d.f. for a random variable ùëã with density
ùëù‚Äûùë•‚Äù by
‚Äû ùë•
F(x) = f p(x) dx = P(X <x). (A.12)
Let‚Äôs observe a few properties. e F(x) > Oasx > -~,
e F(x) > lasx > ¬©. e F(x) is non-decreasing (y > x => F(y) > F(x)). e F(x) is continuous (has no jumps) if X is a continuous random variable. With the fourth bullet point, note that this would not be true if ùëã were discrete, say taking
With the fourth bullet point, note that this would not be true if X were discrete, say taking the values 0 and 1| both with probability 1/2. In that case
0 x<0, FQx=)5 x<1, (A.13) 1 x21. In this example, we see one of the benefits of working with the c.d.f., the ability to deal with continuous or discrete random variables in the same framework, or indeed mixtures of the two (flip a coin: if heads return the roll of a die, if tails return the distance of a dart throw from the center of a dart board). Suppose that we are dealing with a random variables ùëã. The distribution itself can be hard
to interpret. It is often useful to be able to summarize the behavior of a random variable concisely. Numbers that help us capture the behavior of a random variable are called sum- mary statistics. The most commonly encountered ones are the mean, the variance, and the standard deviation. The mean encodes the average value of a random variable. If we have a discrete random variable ùëã, which takes the values ùë•ùëñ with probabilities ùëùùëñ, then the mean is given by the weighted average: sum the values times the probability that the random variable takes on that value:
ùúáùëã = ùê∏¬ªùëã‚Ä¶ = ùë•ùëñùëùùëñ. ùëñ (A.14)
The way we should interpret the mean (albeit with caution) is that it tells us essentially where the random variable tends to be located. As a minimalistic example that we will examine throughout this section, let‚Äôs take ùëã to be
8>>><
ùë• < 0,
Means
Mathematics for Deep Learning
966

the random variable which takes the value a ‚Äî 2 with probability p, a+2 with probability p
the random variable which takes the value a ‚Äî 2 with probability p, a+2 with probability p and a with probability 1 - 2p. We can compute using (A.14) that, for any possible choice of a and p, the mean is
ux = E[X] = } xpi = (a 2)p + a(1 ~ 2p) + (a+ 2)p =a. (A.15) i
Thus we see that the mean is ùëé. This matches the intuition since ùëé is the location around
which we centered our random variable. Because they are helpful, let‚Äôs summarize a few properties. e For any random variable X and numbers a and b, we have that wax+p = aux + b. e If we have two random variables X and Y, we have x+y = Lx + My. Means are useful for understanding the average behavior of a random variable, however the mean is not sufficient to even have a full intuitive understanding. Making a profit of $10+$1 per sale is very different from making $10 + $15 per sale despite having the same average value. The second one has a much larger degree of fluctuation, and thus represents a much larger risk. Thus, to understand the behavior of a random variable, we will need at minimum one more measure: some measure of how widely a random variable fluctuates. This leads us to consider the variance of a random variable. This is a quantitative measure of how far a random variable deviates from the mean. Consider the expression X ‚Äî jrx. This is the deviation of the random variable from its mean. This value can be positive or negative, so we need to do something to make it positive so that we are measuring the magnitude of the deviation. A reasonable thing to try is to look at |X ‚Äî jzx|, and indeed this leads to a useful quan-
tity called the mean absolute deviation, however due to connections with other areas of mathematics and statistics, people often use a different solution. In particular, they look at (X ‚Äî jzx)?. If we look at the typical size of this quantity by taking the mean, we arrive at the variance
oy = Var(X) = E [(X - ux)?| = E[X?] - ny. (A.16)
Thelastequalityin(A.16)holdsbyexpandingoutthedefinitioninthemiddle, andapplying the properties of expectation. Let‚Äôs look at our example where X is the random variable which takes the value a ‚Äî 2 with
Let‚Äôs look at our example where X is the random variable which takes the value a ‚Äî 2 with probability p, a + 2 with probability p and a with probability 1 ‚Äî 2p. In this case zx =a, so all we need to compute is E [x?]. This can readily be done:
E [x?] =(a-2)¬∞*p+a?(1-2p) + (a+2)*p =a 4+ 8p. (A.17)
Thus, we see that by (A.16) our variance is
ox = Var(X) = E[X?] ‚Äî py =a? + 8p- a? = 8p. (A.18)
Variances
Random Variables
967

This result again makes sense. The largest p can be is 1/2 which corresponds to picking
This result again makes sense. The largest p can be is 1/2 which corresponds to picking a-2ora+2 witha coin flip. The variance of this being 4 corresponds to the fact that both a ‚Äî 2 and a +2 are 2 units away from the mean, and 27 = 4. On the other end of the spectrum, if p = 0, this random variable always takes the value 0 and so it has no variance at all. We will list a few properties of variance below:
e For any random variable X, Var(X) > 0, with Var(X) = 0 if and only if X is a constant. For any random variable X and numbers a and b, we have that Var(aX +b) = a?Var(X). e If we have two independent random variables X and Y, we have Var(X + Y) = Var(X) +
Var‚Äûùëå‚Äù. When interpreting these values, there can be a bit of a hiccup. In particular, let‚Äôs try imag- ining what happens if we keep track of units through this computation. Suppose that we are working with the star rating assigned to a product on the web page. Then a, a‚Äî 2, and a+2 are all measured in units of stars. Similarly, the mean zy is then also measured in stars (being a weighted average). However, if we get to the variance, we immediately encounter an issue, which is we want to look at (X ‚Äî 1x)‚Äù, which is in units of squared stars. This means that the variance itself is not comparable to the original measurements. To make it interpretable, we will need to return to our original units. Standard Deviations
This summary statistics can always be deduced from the variance by taking the square root! Thus we define the standard deviation to be
ùúéùëã =
(A.19)
In our example, this means we now have the standard deviation is ùúéùëã = 2
dealing with units of stars for our review example, ùúéùëã is again in units of stars. The properties we had for the variance can be restated for the standard deviation. e For any random variable X, ax > 0. e For any random variable X and numbers a and b, we have that cax+5 = |alox
e If we have two independent random variables X and Y, we have ox+4y =
It is natural at this moment to ask, ‚ÄúIf the standard deviation is in the units of our original random variable, does it represent something we can draw with regards to that random variable?‚Äù The answer is a resounding yes! Indeed much like the mean told us the typical location of our random variable, the standard deviation gives the typical range of variation of that random variable. We can make this rigorous with what is known as Chebyshev‚Äôs inequality:
1 P(X ¬¢ [mx ‚Äî ax, Ux + @ox]) < a (A.20)
p
Var‚Äûùëã‚Äù. p
2ùëù.bubuIf we are
q
lox.bubuùëã ‚Äö ùúé2
ùëå. Mathematics for Deep Learning
968

Or to state it verbally in the case of ùõº = 10, 99% of the samples from any random variable fall within 10 standard deviations of the mean. This gives an immediate interpretation to our standard summary statistics. To see how this statement is rather subtle, let‚Äôs take a look at our running example again where X is the random variable which takes the value a ‚Äî 2 with probability p, a+ 2 with probability p and a with probability | - 2p. We saw that the mean was a and the standard deviation was 2y2p. This means, if we take Chebyshev‚Äôs inequality (A.20) with a = 2, we see that the expression is
P(X ¬¢ [a‚Äî4y2p,a+4y2pl) < 4. (A.21)
This means that 75% of the time, this random variable will fall within this interval for any value of p. Now, notice that as p ‚Äî 0, this interval also converges to the single point a. But we know that our random variable takes the values a‚Äî2, a, and a+2 only so eventually we can be certain a ‚Äî 2 and a + 2 will fall outside the interval! The question is, at what p does that happen. So we want to solve: for what p does a + 4y2p = a+2, which is solved when p = 1/8, which is exactly the first p where it could possibly happen without violating our claim that no more than 1/4 of samples from the distribution would fall outside the interval (1/8 to the left, and 1/8 to the right). Let‚Äôs visualize this. We will show the probability of getting the three values as three vertical bars with height proportional to the probability. The interval will be drawn as a horizontal line in the middle. The first plot shows what happens for p > 1/8 where the interval safely contains all points. # Define a helper to plot these figures def plot_chebyshev(a, p): d2l.set_figsize() d2l.plt.stem([a-2, a, a+2], [p, 1-2*p, p], use_line_collection=True) d2l.plt.xlim([-4, 4]) d2l.plt.xlabel('x') d2l.plt.ylabel('p.m.f.') d2l.plt.hlines(0.5, a - 4 * torch.sqrt(2 * p), a + 4 * torch.sqrt(2 * p), 'black', lw=4) d2l.plt.vlines(a - 4 * torch.sqrt(2 * p), 0.53, 0.47, 'black', lw=1) d2l.plt.vlines(a + 4 * torch.sqrt(2 * p), 0.53, 0.47, 'black', lw=1) d2l.plt.title(f'p = {p:.3f}') d2l.plt.show() # Plot interval when p > 1/8 plot_chebyshev(0.0, torch.tensor(0.2))
The second shows that at p = 1/8, the interval exactly touches the two points. This shows
that the inequality is sharp, since no smaller interval could be taken while keeping the inequality true. p
p
Random Variables
969

p = 0.200 0.6 0.4 E a 0.2 0.0 -4 -2 0 2 4
# Plot interval when p = 1/8 plot_chebyshev(0.0, torch.tensor(0.125))
p = 0.125 0.6 0.4 a 0.2 0.0 -4 -2 0 2 4
The third shows that for p < 1/8 the interval only contains the center. This does not invali-
The third shows that for p < 1/8 the interval only contains the center. This does not invali- date the inequality since we only needed to ensure that no more than 1/4 of the probability falls outside the interval, which means that once p < 1/8, the two points at a ‚Äî 2 anda +2 can be discarded. # Plot interval when p < 1/8
plot_chebyshev(0.0, torch.tensor(0.05))
p = 0.050 0.8 0.6 p.m f, 0.2 0.0 -4 -2 i} 2 4
p = 0.125
Mathematics for Deep Learning
970

Means and Variances in the Continuum
This has all been in terms of discrete random variables, but the case of continuous random variables is similar. To intuitively understand how this works, imagine that we split the real number line into intervals of length ùúñ given by ‚Äûùúñùëñ,ùúñ‚Äûùëñ ‚Äö 1‚Äù‚Ä¶. Once we do this, our continuous random variable has been made discrete and we can use (A.14) say that
yx DaPx ‚Ç¨ (ei, e(i + 1)]) A.22 x Medpxteie, ( )
where ùëùùëã is the density of ùëã. This is an approximation to the integral of ùë•ùëùùëã‚Äûùë•‚Äù, so we
can conclude that
Lx -[ xpx(x) dx. (A.23) co
Similarly, using (A.16) the variance can be written as
‚Äû 1
¬© ¬© 2 of = EDP] == [ px) dv ‚Äî( [px ax) _ (A.24) ¬©o ¬©
Everything stated above about the mean, the variance, and the standard deviation still ap- plies in this case. For instance, if we consider the random variable with density
ùëù‚Äûùë•‚Äù = 1 0 ùë• 2 ¬ª0,1‚Ä¶, otherwise. (A.25)
we can compute
‚Äû 1
¬© 1 Ux = [ xp(x) dx = x dx = : (A.26) - 0
and
‚Äû 1
¬∞ i? 1 1 1
As a warning, let‚Äôs examine one more example, known as the Cauchy distribution. This is the distribution with p.d.f. given by
ùëù‚Äûùë•‚Äù = 1 1 ‚Äö ùë•2 . (A.28)
# Plot the Cauchy distribution p.d.f. x = torch.arange(-5, 5, 0.01) p = 1 / (1 + x**2) d2l.plot(x, p, 'x', 'p.d.f.')
This function looks innocent, and indeed consulting a table of integrals will show it has area one under it, and thus it defines a continuous random variable. ‚Äû 1
¬©
2
(
‚Äû
Random Variables
971


To see what goes astray, let‚Äôs try to compute the variance of this. This would involve using (A.16) computing
‚Äû 1
co 2 ‚Äî dx. A.29 [.bubu14x? ( )
The function on the inside looks like this:
# Plot the integrand needed to compute the variance x = torch.arange(-20, 20, 0.01) p = x**2 / (1 + x**2) d2l.plot(x, p, 'x', 'integrand')
10 08 06 04 integrand 0.2 0.0
This function clearly has infinite area under it since it is essentially the constant one with a small dip near zero, and indeed we could show that
‚Äû 1
co x2 [ ‚Äúdx =o. (A.30) oo 1 +x? This means it does not have a well-defined finite variance. However, looking deeper shows an even more disturbing result. Let‚Äôs try to compute the mean using (A.14). Using the change of variables formula, we see
‚Äû 1
‚Äúx 1f¬∞1 = ‚Äî‚Äî dx == ‚Äî du. A.31 Hx [= * 3 u u (4.31)
The integral inside is the definition of the logarithm, so this is in essence log‚Äû1‚Äù = 1, so
there is no well-defined average value either! ‚Äû 1
Mathematics for Deep Learning
972

Machine learning scientists define their models so that we most often do not need to deal with these issues, and will in the vast majority of cases deal with random variables with well-defined means and variances. However, every so often random variables with heavy tails (that is those random variables where the probabilities of getting large values are large enoughtomakethingslikethemeanorvarianceundefined)arehelpfulinmodelingphysical systems, thus it is worth knowing that they exist. Joint Density Functions
The above work all assumes we are working with a single real valued random variable. But what if we are dealing with two or more potentially highly correlated random variables? This circumstance is the norm in machine learning: imagine random variables like ùëÖùëñ, ùëó which encode the red value of the pixel at the ‚Äûùëñ, ùëó‚Äù coordinate in an image, or ùëÉùë° which is a random variable given by a stock price at time ùë°. Nearby pixels tend to have similar color, and nearby times tend to have similar prices. We cannot treat them as separate random variables, and expect to create a successful model (we will see in Section A.9 a model that under-performsduetosuchanassumption). Weneedtodevelopthemathematicallanguage to handle these correlated continuous random variables. Thankfully, with the multiple integrals in Section A.5 we can develop such a language. Suppose that we have, for simplicity, two random variables ùëã,ùëå which can be correlated. Then, similar to the case of a single variable, we can ask the question:
ùëÉ‚Äûùëã is in an ùúñ-sized interval around ùë• and ùëå is in an ùúñ-sized interval around ùë¶‚Äù. (A.32)
Similarreasoningtothesinglevariablecaseshowsthatthisshouldbeapproximately
P(X is in an e-sized interval around x and Y is in an e-sized interval around y) ~ px, y),
(A.33)
for some function ùëù‚Äûùë•, ùë¶‚Äù. This is referred to as the joint density of ùëã and ùëå. Similar
properties are true for this as we saw in the single variable case. Namely:
¬© p(x,y) 2 0;
Ô¨Ç
¬© fos D(x, y) dx dy = 1;
Ô¨Ç
e P((X,Y)ED)= Io p(x, y) dx dy. In this way, we can deal with multiple, potentially correlated random variables. If we wish to work with more than two random variables, we can extend the multivariate density to as many coordinates as desired by considering ùëù‚Äûx‚Äù = ùëù‚Äûùë•1, . .bubu.,ùë•ùëõ‚Äù.bubuThe same properties of being non-negative, and having total integral of one still hold. Marginal Distributions
When dealing with multiple variables, we oftentimes want to be able to ignore the rela- tionships and ask, ‚Äúhow is this one variable distributed?‚Äù Such a distribution is called a marginal distribution. Random Variables
973

To be concrete, let‚Äôs suppose that we have two random variables ùëã,ùëå with joint density
given by ùëùùëã,ùëå‚Äûùë•, ùë¶‚Äù. We will be using the subscript to indicate what random variables the density is for. The question of finding the marginal distribution is taking this function, and using it to find ùëùùëã‚Äûùë•‚Äù. As with most things, it is best to return to the intuitive picture to figure out what should be true. Recall that the density is the function ùëùùëã so that
P(X ‚Ç¨ [x,x+‚Ç¨]) % ‚Ç¨- px(x). (A.34)
There is no mention of ùëå, but if all we are given is ùëùùëã,ùëå, we need to include ùëå somehow. We can first observe that this is the same as
P(X ‚Ç¨ [x,x +], and Y ‚Ç¨ R) ye: px(x). (A.35)
Our density does not directly tell us about what happens in this case, we need to split into small intervals in ùë¶ as well, so we can write this as
‚Ç¨- px(x) ¬• es ‚Ç¨ [x,x +e], andY ‚Ç¨ [e-i,e- (i+ 1)]) 4, (A.36) x ¬ª ‚Ç¨px,y (x, ‚Ç¨ +i). 7
Ha ‚Äî HBA BESCEaS ¬´=| BUI SESE Dooooole. Joint Probability Marginal Probability
tFig. A.1
By summing along the columns of our array of probabilities, we are able to obtain the marginal distribution for just the random variable represented along the x-axis. This tells us to add up the value of the density along a series of squares in a line as is shown in Fig. A.1. Indeed, after canceling one factor of epsilon from both sides, and recognizing the sum on the right is the integral over ùë¶, we can conclude that
px(x) * Dy epxy (sei) i -[ Pxy(x, y) dy. ¬© (A.37)
Thus we see
px(x) = / pxv(x,y) dy. (A.38) co
This tells us that to get a marginal distribution, we integrate over the variables we do not
‚Äû 1
Mathematics for Deep Learning
974

care about. This process is often referred to as integrating out or marginalized out the unneeded variables. Covariance
When dealing with multiple random variables, there is one additional summary statistic which is helpful to know: the covariance. This measures the degree that two random vari- able fluctuate together. Suppose that we have two random variables ùëã and ùëå, to begin with, let‚Äôs suppose they
are discrete, taking on values ‚Äûùë•ùëñ, ùë¶ ùëó‚Äù with probability ùëùùëñùëó. In this case, the covariance is defined as
oxy = Cov(X.¬•) = D*(ai ~ wx)(9 ‚Äî Hy )Piy- = ELXY]- EXEL]. (4.39) ij
To think about this intuitively: consider the following pair of random variables. Suppose that X takes the values 1 and 3, and Y takes the values ‚Äî1 and 3. Suppose that we have the following probabilities
P(X = Landy =~1)=¬£, 1- P(X =1andy =3)=‚Äî‚Äù, 2 (A.40) P(X =3 and Y= ~1) = ‚Äî*, P(X =3and ¬• =3) = &,
where p is a parameter in [0, 1] we get to pick. Notice that if p = 1 then they are both always their minimum or maximum values simultaneously, and if p = 0 they are guaranteed to take their flipped values simultaneously (one is large when the other is small and vice versa). If p = 1/2, then the four possibilities are all equally likely, and neither should be related. Let‚Äôs compute the covariance. First, note zx = 2 and wy = 1, so we may compute using (A.39):
Cov‚Äûùëã,ùëå‚Äù =
= Sei ‚Äî EX)Vy ~ Hy) Pi ij 1- =(1-2)(-1-)¬£+(1- 2-1) 7 l-p 2 +(3-2)(-1-1) +3-2G-D¬£ =4p-2. (A.41)
When ùëù = 1 (the case where they are both maximally positive or negative at the same time)
When p = | (the case where they are both maximally positive or negative at the same time) has a covariance of 2. When p = 0 (the case where they are flipped) the covariance is ‚Äî2. Finally, when p = 1/2 (the case where they are unrelated), the covariance is 0. Thus we see that the covariance measures how these two random variables are related. A quick note on the covariance is that it only measures these linear relationships. More complex relationships like X = Y? where Y is randomly chosen from {‚Äî2, ‚Äî1,0, 1, 2} with
ùëù
(A.41)
Random Variables
975

equal probability can be missed. Indeed a quick computation shows that these random vari- ables have covariance zero, despite one being a deterministic function of the other. For continuous random variables, much the same story holds. At this point, we are pretty comfortable with doing the transition between discrete and continuous, so we will provide the continuous analogue of (A.39) without any derivation. ‚Äû
oxy = [ (= Wx) = Hy) poy) de dy. (A.42)
For visualization, let‚Äôs take a look at a collection of random variables with tunable covari- ance. # Plot a few random variables adjustable covariance covs = [-0.9, 0.0, 1.2] d2l.plt.figure(figsize=(12, 3)) for i in range(3): X = torch.randn(500) Y = covs[i]*X + torch.randn(500) d2l.plt.subplot(1, 4, i+1) d2l.plt.scatter(X.numpy(), Y.numpy()) d2l.plt.xlabel('X') d2l.plt.ylabel('Y') d2l.plt.title(f'cov = {covs[i]}') d2l.plt.show()

Let‚Äôs see some properties of covariances:
e For any random variable X, Cov(X, X) = Var(X). e For any random variables X, Y and numbers a and b, Cov(aX+b, Y) = Cov(X,aY+b) =
ùëéCov‚Äûùëã,ùëå‚Äù. e If X and Y are independent then Cov(X, Y) = 0. In addition, we can use the covariance to expand a relationship we saw before. Recall that is ùëã and ùëå are two independent random variables then
Var‚Äûùëã ‚Äöùëå‚Äù = Var‚Äûùëã‚Äù ‚Äö Var‚Äûùëå‚Äù. (A.43)
Mathematics for Deep Learning
976

With knowledge of covariances, we can expand this relationship. Indeed, some algebra can show that in general,
Var‚Äûùëã ‚Äöùëå‚Äù = Var‚Äûùëã‚Äù ‚Äö Var‚Äûùëå‚Äù ‚Äö 2Cov‚Äûùëã,ùëå‚Äù. Var(X + Y) = Var(X) + Var(¬•) + 2Cov(X, Y). (A.44)
Thisallowsustogeneralizethevariancesummationruleforcorrelatedrandomvariables. As we did in the case of means and variances, let‚Äôs now consider units. If ùëã is measured in
As we did in the case of means and variances, let‚Äôs now consider units. If X is measured in one unit (say inches), and Y is measured in another (say dollars), the covariance is measured in the product of these two units inches x dollars. These units can be hard to interpret. What we will often want in this case is a unit-less measurement of relatedness. Indeed, often we do not care about exact quantitative correlation, but rather ask if the correlation is in the same direction, and how strong the relationship is. To see what makes sense, let‚Äôs perform a thought experiment. Suppose that we convert our random variables in inches and dollars to be in inches and cents. In this case the ran- dom variable ùëå is multiplied by 100. If we work through the definition, this means that Cov‚Äûùëã,ùëå‚Äù will be multiplied by 100. Thus we see that in this case a change of units change the covariance by a factor of 100. Thus, to find our unit-invariant measure of correlation, we will need to divide by something else that also gets scaled by 100. Indeed we have a clear candidate, the standard deviation! Indeed if we define the correlation coeÔ¨Äicient to be
ùúå‚Äûùëã,ùëå‚Äù = ùúéùëãùúéùëå , (A.45)
we see that this is a unit-less value. A little mathematics can show that this number is between ‚Äî1 and 1 with 1 meaning maximally positively correlated, whereas ‚Äî1 means maximally negatively correlated. Returning to our explicit discrete example above, we can see that ùúéùëã = 1 and ùúéùëå = 2,
so we can compute the correlation between the two random variables using (A.45) to see that
4p-2 1-2 p(X,Y) = =2p-1. (A.46)
This now ranges between ‚Äî1 and | with the expected behavior of 1 meaning most correlated,
This now ranges between ‚Äî1 and | with the expected behavior of 1 meaning most correlated, and ‚Äî1 meaning minimally correlated. As another example, consider ùëã as any random variable, and ùëå = ùëéùëã ‚Äö ùëè as any linear
deterministic function of ùëã. Then, one can compute that
ùúéùëå = ùúéùëéùëã‚Äöùëè = jùëéjùúéùëã, (A.47)
Cov‚Äûùëã,ùëå‚Äù = Cov‚Äûùëã, ùëéùëã ‚Äö ùëè‚Äù = ùëéCov‚Äûùëã, ùëã‚Äù = ùëéVar‚Äûùëã‚Äù, (A.48)
and thus by (A.45) that
ùëéVar‚Äûùëã‚Äù
ùúå‚Äûùëã,ùëå‚Äù = jùëéjùúé2 ùëã = jùëéj = sign‚Äûùëé‚Äù. (A.49)
(A.44)
Correlation
Cov‚Äûùëã,ùëå‚Äù
ùëé
Random Variables
977

Thus we see that the correlation is +1 for any a > 0, and ‚Äî1 for any a < 0 illustrating that
correlation measures the degree and directionality the two random variables are related, not the scale that the variation takes. Let‚Äôs again plot a collection of random variables with tunable correlation. # Plot a few random variables adjustable correlations cors = [-0.9, 0.0, 1.0] d2l.plt.figure(figsize=(12, 3)) for i in range(3): X = torch.randn(500) Y = cors[i] * X + torch.sqrt(torch.tensor(1) - cors[i]**2) * torch.randn(500) d2l.plt.subplot(1, 4, i + 1) d2l.plt.scatter(X.numpy(), Y.numpy()) d2l.plt.xlabel('X') d2l.plt.ylabel('Y') d2l.plt.title(f'cor = {cors[i]}') d2l.plt.show()
cor = 1.0
Let‚Äôs list a few properties of the correlation below. e For any random variable X, p(X, X) = 1.bubue For any random variables X,Y and numbers a and b, p(aX + b,Y) = p(X,aY +b) =
ùúå‚Äûùëã,ùëå‚Äù. e If X and Y are independent with non-zero variance then p(X, Y) = 0. As a final note, you may feel like some of these formulae are familiar.bubuIndeed, if we expand everything out assuming that ùúáùëã = ùúáùëå = 0, we see that this is
ùúå‚Äûùëã,ùëå‚Äù = qÀù qÀù ùëñ, ùëó ùë•2 ùëñ ùëùùëñùëó ùëñ, ùëó ùë¶2 ùëóùëùùëñùëó . (A.50)
This looks like a sum of a product of terms divided by the square root of sums of terms. This is exactly the formula for the cosine of the angle between two vectors v,w with the
Àù
ùëñ, ùëó ùë•ùëñùë¶ùëñùëùùëñùëó
Mathematics for Deep Learning
978

different coordinates weighted by ùëùùëñùëó:
vw
cos‚ÄûùúÉ‚Äù = kvkkwk = qÀù qÀù ùëñ ùë£2 ùëñ ùëñ ùë§2 ùëñ . (A.51)
Indeed if we think of norms as being related to standard deviations, and correlations as being cosines of angles, much of the intuition we have from geometry can be applied to thinking about random variables. A.6.2 Summary
e Continuous random variables are random variables that can take on a continuum of val-
ues. They have some technical difficulties that make them more challenging to work with compared to discrete random variables. e The probability density function allows us to work with continuous random variables by
giving a function where the area under the curve on some interval gives the probability of finding a sample point in that interval. e The cumulative distribution function is the probability of observing the random variable
to be less than a given threshold. It can provide a useful alternate viewpoint which unifies discrete and continuous variables. e The mean is the average value of a random variable. e The variance is the expected square of the difference between the random variable and
its mean. e The standard deviation is the square root of the variance. It can be thought of as mea-
suring the range of values the random variable may take. e Chebyshev‚Äôs inequality allows us to make this intuition rigorous by giving an explicit
interval that contains the random variable most of the time. e Joint densities allow us to work with correlated random variables. We may marginalize
joint densities by integrating over unwanted random variables to get the distribution of the desired random variable. e The covariance and correlation coefficient provide a way to measure any linear relation-
ship between two correlated random variables. A.6.3 Exercises
1.bubuSuppose that we have the random variable with density given by ùëù‚Äûùë•‚Äù = 1
and ùëù‚Äûùë•‚Äù = 0 otherwise. What is ùëÉ‚Äûùëã > 2‚Äù? 2. The Laplace distribution is a random variable whose density is given by ùëù‚Äûùë• = 1
2. The Laplace distribution is a random variable whose density is given by p(x = se Pl, What is the mean and the standard deviation of this function? As a hint, th xe* dx =1 and f,¬∞ x?e-* dx = 2. 0
Àù
ùëñ ùë£ùëñùë§ùëñ
+5 for x > 1 x2 ‚Äî
Pl,
Maximum Likelihood
979

3. I walk up to you on the street and say ‚ÄúI have a random variable with mean 1, standard deviation 2, and I observed 25% of my samples taking a value larger than 9.‚Äù Do you believe me? Why or why not?bubu4. Supposethatyouhavetworandomvariables ùëã,ùëå,withjointdensitygivenby ùëùùëãùëå‚Äûùë•, ùë¶‚Äù = 4ùë•ùë¶ for ùë•, ùë¶ 2 ¬ª0,1‚Ä¶ and ùëùùëãùëå‚Äûùë•, ùë¶‚Äù = 0 otherwise. What is the covariance of ùëã and ùëå?bubuDiscussions285. 285
A.7 Maximum Likelihood
eC
One of the most commonly encountered way of thinking in machine learning is the maxi- mum likelihood point of view. This is the concept that when working with a probabilistic model with unknown parameters, the parameters which make the data have the highest probability are the most likely ones. A.7.1 The Maximum Likelihood Principle
This has a Bayesian interpretation which can be helpful to think about. Suppose that we have a model with parameters ùúΩ and a collection of data examples ùëã. For concreteness, we can imagine that ùúΩ is a single value representing the probability that a coin comes up heads when flipped, and ùëã is a sequence of independent coin flips. We will look at this example in depth later. If we want to find the most likely value for the parameters of our model, that means we want to find
argmax ùëÉ‚ÄûùúΩ j ùëã‚Äù. (A.1)
By Bayes‚Äô rule, this is the same thing as
argmax ùëÉ‚Äûùëã‚Äù . (A.2)
The expression ùëÉ‚Äûùëã‚Äù, a parameter agnostic probability of generating the data, does not
depend on ùúΩ at all, and so can be dropped without changing the best choice of ùúΩ. Similarly, we may now posit that we have no prior assumption on which set of parameters are better than any others, so we may declare that ùëÉ‚ÄûùúΩ‚Äù does not depend on theta either! This, for instance, makes sense in our coin flipping example where the probability it comes up heads could be any value in ¬ª0,1‚Ä¶ without any prior belief it is fair or not (often referred to as an uninformative prior). Thus we see that our application of Bayes‚Äô rule shows that our best choice of ùúΩ is the maximum likelihood estimate for ùúΩ:
ÀÜùúΩ = argmax ùëÉ‚Äûùëã j ùúΩ‚Äù. ùúΩ (A.3)
Asamatterofcommonterminology, theprobabilityofthedatagiventheparameters(ùëÉ‚Äûùëã j
ùúΩ‚Äù) is referred to as the likelihood. ùëÉ‚Äûùëã j ùúΩ‚ÄùùëÉ‚ÄûùúΩ‚Äù
Mathematics for Deep Learning
980

A Concrete Example
Let‚Äôs see how this works in a concrete example. Suppose that we have a single parameter ùúÉ
Let‚Äôs see how this works in a concrete example. Suppose that we have a single parameter 6 representing the probability that a coin flip is heads. Then the probability of getting a tails is | ‚Äî 6, and so if our observed data X is a sequence with ny heads and nz tails, we can use the fact that independent probabilities multiply to see that
P(X | 0) =0""(1-6)"". (A.4)
If we flip 13 coins and get the sequence ‚ÄúHHHTHTTHHHHHT‚Äù, which has ùëõùêª = 9 and
ùëõùëá = 4, we see that this is
P(X | 6) =@(1-0)*. (A.5)
One nice thing about this example will be that we know the answer going in. Indeed, if we said verbally, ‚ÄúI flipped 13 coins, and 9 came up heads, what is our best guess for the probability that the coin comes us heads?,‚Äù everyone would correctly guess 9/13. What this maximum likelihood method will give us is a way to get that number from first principals in a way that will generalize to vastly more complex situations. For our example, the plot of ùëÉ‚Äûùëã j ùúÉ‚Äù is as follows:
%matplotlib inline import torch from d2l import torch as d2l theta = torch.arange(0, 1, 0.001) p = theta**9 * (1 - theta)**4. d2l.plot(theta, p, 'theta', 'likelihood')
0.0003 0.0002 likelihood 0.0001 0.0000 0.0 0.2 0.4 0.6 0.8 1.0 theta
This has its maximum value somewhere near our expected 9/13 ~ 0.7.... To see if it
is exactly there, we can turn to calculus. Notice that at the maximum, the gradient of the function is flat. Thus, we could find the maximum likelihood estimate (A.1) by finding the values of ùúÉ where the derivative is zero, and finding the one that gives the highest
Maximum Likelihood
981

probability. We compute:
ùëë
d 0=‚ÄîP(X|@ P(X | 8) _ d 9 4 = 70¬∞ (1-@) (A.6) = 90¬∞(1- @)* - 46¬∞(1 - 6)? = 0(1 ‚Äî 6)3(9 ‚Äî 136).bubuThis has three solutions: 0, 1 and 9/13. The first two are clearly minima, not maxima as
This has three solutions: 0, 1 and 9/13. The first two are clearly minima, not maxima as they assign probability 0 to our sequence. The final value does not assign zero probability to our sequence, and thus must be the maximum likelihood estimate 6 = 9/13. A.7.2 Numerical Optimization and the Negative Log-Likelihood
The previous example is nice, but what if we have billions of parameters and data exam- ples? First, notice that if we make the assumption that all the data examples are independent, we can no longer practically consider the likelihood itself as it is a product of many probabili- ties. Indeed, each probability is in [0, 1], say typically of value about 1/2, and the product of (1/2) 1000000000 is far below machine precision. We cannot work with that directly. However, recall that the logarithm turns products to sums, in which case
log( (1/2) 100000000) ‚Äî 1900000000 - log(1/2) + ‚Äî301029995.6... (A.7)
This number fits perfectly within even a single precision 32-bit float. Thus, we should consider the log-likelihood, which is
log‚ÄûùëÉ‚Äûùëã j ùúΩ‚Äù‚Äù. (A.8)
Since the function ùë• 7! log‚Äûùë•‚Äù is increasing, maximizing the likelihood is the same thing
as maximizing the log-likelihood. Indeed in Section A.9 we will see this reasoning applied when working with the specific example of the naive Bayes classifier. We often work with loss functions, where we wish to minimize the loss. We may turn maximum likelihood into the minimization of a loss by taking ‚Äîlog(P(X | @)), which is the negative log-likelihood. To illustrate this, consider the coin flipping problem from before, and pretend that we do not know the closed form solution. We may compute that
‚Äîlog(P(X | @)) = -log(@‚Äù"" (1 - @)"") = -(ny log(6) + nz log(1 ‚Äî 6)). (A.9)
This can be written into code, and freely optimized even for billions of coin flips. # Set up our data n_H = 8675309 n_T = 256245
(continues on next page)
Mathematics for Deep Learning
982

# Initialize our paramteres theta = torch.tensor(0.5, requires_grad=True) # Perform gradient descent lr = 1e-9 for iter in range(100): loss = -(n_H * torch.log(theta) + n_T * torch.log(1 - theta)) loss.backward() with torch.no_grad(): theta -= lr * theta.grad theta.grad.zero_() # Check output theta, n_H / (n_H + n_T)
(tensor(0.9713, requires_grad=True), 0.9713101437890875)
Numericalconvenienceisnottheonlyreasonwhypeopleliketousenegativelog-likelihoods. There are several other reasons why it is preferable.bubuThe second reason we consider the log-likelihood is the simplified application of calcu- lus rules. As discussed above, due to independence assumptions, most probabilities we encounter in machine learning are products of individual probabilities. P(X | 8) = p(x1 | 0) - p(x2 | @)--+ pn | 8). (A.10)
This means that if we directly apply the product rule to compute a derivative we get
sR 18) = (5 PCr 18)) Pla 18) Pls | 8) + P(x | 8)- (Fre | 0) Pos | 4) aan ll
# Pos 1) Poon 1): ( FPG | 0). This requires n(n ‚Äî 1) multiplications, along with (n ‚Äî 1) additions, so it is proportional
to quadratic time in the inputs! Sufficient cleverness in grouping terms will reduce this to linear time, but it requires some thought. For the negative log-likelihood we have in- stead
‚Äî log (P(X | @)) = ‚Äî log( P(x | 8)) ‚Äî log(P(x2 | @)) +++ - log(P(xn | 8),
(A.12)
which then gives
(a) 1 0 1 (2) 99 los (P(X | 8) = mo (ae |) oot oo [Fp P le |0)). (A.13)
(continued from previous page)
(A.11)
... Maximum Likelihood
983

This requires only n divides and n ‚Äî 1 sums, and thus is linear time in the inputs. The third and final reason to consider the negative log-likelihood is the relationship to information theory, which we will discuss in detail in Section A.11. This is a rigorous mathematicaltheorywhichgivesawaytomeasurethedegreeofinformationorrandomness in a random variable. The key object of study in that field is the entropy which is
H(p) =~) pilogs(pi); (A.14)
which measures the randomness of a source. Notice that this is nothing more than the av- erage ‚Äî log probability, and thus if we take our negative log-likelihood and divide by the number of data examples, we get a relative of entropy known as cross-entropy. This theoret- ical interpretation alone would be sufficiently compelling to motivate reporting the average negative log-likelihood over the dataset as a way of measuring model performance. A.7.3 Maximum Likelihood for Continuous Variables
Everything that we have done so far assumes we are working with discrete random vari- ables, but what if we want to work with continuous ones? The short summary is that nothing at all changes, except we replace all the instances of the probability with the probability density. Recalling that we write densities with lower case ùëù, this means that for example we now say
‚Äî log (p(X | )) = ‚Äî log(p(ax1 | 8)) ‚Äî log(p(x2 | 8))--- ‚Äî log(p@n | 8) = ‚Äî Dilos(r% | 4)). * (A.15)
The question becomes, ‚ÄúWhy is this OK?‚Äù After all, the reason we introduced densities was because probabilities of getting specific outcomes themselves was zero, and thus is not the probability of generating our data for any set of parameters zero? Indeed, this is the case, and understanding why we can shift to densities is an exercise in tracing what happens to the epsilons. Let‚Äôs first re-define our goal. Suppose that for continuous random variables we no longer want to compute the probability of getting exactly the right value, but instead matching to withinsomerangeùúñ. Forsimplicity,weassumeourdataisrepeatedobservationsùë•1, . . .,ùë•ùëÅ of identically distributed random variables ùëã1, . .bubu., ùëãùëÅ. As we have seen previously, this can be written as
P(X, ‚Ç¨ [x1,x1 + ‚Ç¨], X2 ‚Ç¨ [x2,x2 + ‚Ç¨],..., Xn ‚Ç¨ [xn xn + ‚Ç¨] | A) . =e pla |8)- plar | 8) Pls | 8). (Ar8)
Thus, if we take negative logarithms of this we obtain
‚Äîlog( P(X) ‚Ç¨ [x1, x1 + ‚Ç¨], X2 ‚Ç¨ [x2,x2 + ‚Ç¨],...,Xn ‚Ç¨ [xn, xn + ‚Ç¨] | 9)) (A.17) ~ ‚Äî Nlog(e) - ¬ª log(p(xi | 8). If we examine this expression, the only place that the ùúñ occurs is in the additive constant
(A.15)
Mathematics for Deep Learning
984

‚ÄîN log(e). This does not depend on the parameters 6 at all, so the optimal choice of 6 does
not depend on our choice of ùúñ! If we demand four digits or four-hundred, the best choice of ùúΩ remains the same, thus we may freely drop the epsilon to see that what we want to optimize is
- Di log(pG; | 6)). (A.18)
Thus, we see that the maximum likelihood point of view can operate with continuous ran- dom variables as easily as with discrete ones by replacing the probabilities with probability densities. A.7.4 Summary
e The maximum likelihood principle tells us that the best fit model for a given dataset is
the one that generates the data with the highest probability. e Often people work with the negative log-likelihood instead for a variety of reasons: nu-
merical stability, conversion of products to sums (and the resulting simplification of gradient computations), and theoretical ties to information theory. e While simplest to motivate in the discrete setting, it may be freely generalized to the
continuous setting as well by maximizing the probability density assigned to the dat- apoints. A.7.5 Exercises
1. Suppose that you know that a non-negative random variable has density ~we~ ¬∞* for some
value ùõº > 0. You obtain a single observation from the random variable which is the number 3. What is the maximum likelihood estimate for ùõº? 2. Supposethatyouhaveadatasetofsamples fùë•ùëñgùëÅ
ùëñ=1 drawnfromaGaussianwithunknown mean, but variance 1. What is the maximum likelihood estimate for the mean? 286
Discussions286. A.8 Distributions

Now that we have learned how to work with probability in both the discrete and the contin- uous setting, let‚Äôs get to know some of the common distributions encountered. Depending on the area of machine learning, we may need to be familiar with vastly more of these, or for some areas of deep learning potentially none at all. This is, however, a good basic list to be familiar with.bubuLet‚Äôs first import some common libraries. 985

%matplotlib inline from math import erf, factorial import torch from IPython import display from d2l import torch as d2l
torch.pi = torch.acos(torch.zeros(1)) * 2 # Define pi in torch
A.8.1 Bernoulli
This is the simplest random variable usually encountered. This random variable encodes a coin flip which comes up 1 with probability p and 0 with probability 1 ‚Äî p. If we have a random variable X with this distribution, we will write
X ~ Bernoulli(p). (A.1)
The cumulative distribution function is
0 x <0, FQ) =41-p 0<x<1, (A.2) 1 x>=l1. The probability mass function is plotted below. p = 0.3
d2l.set_figsize() d2l.plt.stem([0, 1], [1 - p, p], use_line_collection=True) d2l.plt.xlabel('x') d2l.plt.ylabel('p.m.f.') d2l.plt.show()
06 p.m. 0.2 0.0 0.0 0.2 0.4 0.6 0.8 1.0
Now, let‚Äôs plot the cumulative distribution function (A.2). x = torch.arange(-1, 2, 0.01)
def F(x):
return 0 if x < 0 else 1 if x > 1 else 1 - p
Distributions
8>>><
(continues on next page)
Mathematics for Deep Learning
986

d2l.plot(x, torch.tensor([F(y) for y in x]), 'x', 'c.d.f.')
1.0 0.8 0.6 c.d.f. 0.2 0.0
If X ~ Bernoulli(p), then:
¬© Ux =P,
2_ ¬© oy =p(l‚Äîp). WecansampleanarrayofarbitraryshapefromaBernoullirandomvariableasfollows. 1*(torch.rand(10, 10) < p)
tensor([[0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 0, 1, 0, 0]])
A.8.2 Discrete Uniform
The next commonly encountered random variable is a discrete uniform. For our discussion here, we will assume that it is supported on the integers f1,2, .bubu.bubu.,ùëõg, however any other set of values can be freely chosen. The meaning of the word uniform in this context is that every possible value is equally likely. The probability for each value ùëñ 2 f1,2,3, . . .,ùëõg is ùëùùëñ = 1 ùëõ. We will denote a random variable ùëã with this distribution as
(continued from previous page)
X ~ U(n). (A.3)
987

The cumulative distribution function is
8>>><
ùë• < 1,
0 x<i, FQx)=)k kex<k+ 1withl<k<n, (A.4) 1 x>=n. Let‚Äôs first plot the probability mass function. n = 5
d2l.plt.stem([i+1 for i in range(n)], n*[1 / n], use_line_collection=True) d2l.plt.xlabel('x') d2l.plt.ylabel('p.m.f.') d2l.plt.show()
N x w i wu
Now, let‚Äôs plot the cumulative distribution function (A.4). x = torch.arange(-1, 6, 0.01)
def F(x):
return 0 if x < 1 else 1 if x > n else torch.floor(x) / n
d2l.plot(x, torch.tensor([F(y) for y in x]), 'x', 'c.d.f.')
10 08 06 cdf. 0.2 0.0
If X ~ U(n), then:
eux =i,
2 ,
2 _ wel RD
2 e OX
12 . Distributions
Mathematics for Deep Learning
988

We can sample an array of arbitrary shape from a discrete uniform random variable as follows. torch.randint(1, n, size=(10, 10))
tensor([[1, 4, 3, 2, 1, 1, 3, 1, 1, 4], [4, 1, 1, 4, 4, 1, 4, 3, 2, 4], [2, 4, 4, 1, 4, 2, 4, 3, 2, 1], [1, 2, 3, 1, 1, 4, 2, 4, 1, 3], [1, 2, 4, 1, 4, 3, 3, 2, 2, 1], [1, 2, 2, 4, 1, 3, 2, 4, 2, 3], [1, 2, 3, 4, 1, 3, 4, 1, 4, 3], [3, 1, 1, 4, 4, 1, 3, 1, 1, 2], [2, 2, 4, 3, 4, 2, 3, 4, 2, 4], [1, 4, 3, 3, 2, 3, 3, 4, 1, 3]])
A.8.3 Continuous Uniform
Next, let‚Äôs discuss the continuous uniform distribution. The idea behind this random vari- able is that if we increase the ùëõ in the discrete uniform distribution, and then scale it to fit within the interval ¬ªùëé, ùëè‚Ä¶, we will approach a continuous random variable that just picks an arbitrary value in ¬ªùëé, ùëè‚Ä¶ all with equal probability. We will denote this distribution as
(A.5)
The probability density function is
a ,b], p(x = fea XE lwo (AS) 0 x ¬¢ [a,b]. The cumulative distribution function is
0 x <a, F(x) =) 54 xe [a,b], (A.7) 1 x>=b. Let‚Äôs first plot the probability density function (A.6). a, b = 1, 3 x = torch.arange(0, 4, 0.01) p = (x > a).type(torch.float32)*(x < b).type(torch.float32)/(b-a) d2l.plot(x, p, 'x', 'p.d.f.')
Now, let‚Äôs plot the cumulative distribution function (A.7). X ~ U(a,b). (
8>>><
ùë• < ùëé,
989

05 04 ¬´03 p.di 0.2 O21 0.0 ¬∞ ¬ª xN w Ss
def F(x):
return 0 if x < a else 1 if x > b else (x - a) / (b - a)
d2l.plot(x, torch.tensor([F(y) for y in x]), 'x', 'c.d.f.')
1.0 0.8 0.6 c.d.f. 0.2 0.0 ¬∞ An xN w rs
If X ~ U(a, b), then:
b eux= 5,
2 ,
(b-a)* TT
2 ¬∞
ùëã =
. 12
We can sample an array of arbitrary shape from a uniform random variable as follows. Note that it by default samples from a ùëà‚Äû0,1‚Äù, so if we want a different range we need to scale it. (b - a) * torch.rand(10, 10) + a
tensor([[2.4857, 2.2461, 1.6809, 2.7434, 2.7072, 2.6190, 1.4883, 1.2517, 1. ‚Ü©!3454, 2.4754], [1.0974, 1.5680, 1.8788, 2.8231, 2.1695, 2.6461, 1.4914, 1.4887, 1. ‚Ü©!3860, 1.9090], [1.3746, 1.7773, 1.2412, 1.1950, 2.7281, 2.8356, 1.2266, 2.4724, 2. ‚Ü©!4641, 2.8991], [2.4018, 2.6727, 1.0308, 1.1951, 1.9390, 1.6486, 2.8314, 1.1025, 1. Distributions
(continues on next page)
Mathematics for Deep Learning
990

‚Ü©!3354, 1.0130], [1.1281, 1.8000, 2.3788, 2.6580, 1.6750, 2.2081, 1.2705, 1.0757, 2. ‚Ü©!3311, 2.6557], [2.9912, 1.2263, 1.8115, 1.5940, 1.9321, 1.6469, 2.2990, 2.1473, 1. ‚Ü©!8165, 1.2806], [1.1672, 1.1536, 1.9649, 2.1655, 1.7170, 1.0284, 1.3305, 2.1904, 1. ‚Ü©!4036, 2.1958], [2.5891, 2.5840, 2.2679, 2.0687, 2.9249, 1.6741, 1.2238, 2.4463, 2. ‚Ü©!2235, 2.7038], [1.8697, 2.4965, 1.5785, 2.7890, 2.3319, 2.1434, 2.3333, 1.0286, 1. ‚Ü©!9245, 1.7640], [1.2504, 1.7558, 1.4322, 1.5226, 1.3380, 1.1388, 1.8707, 2.2330, 2. ‚Ü©!3818, 2.2087]])
A.8.4 Binomial
Let‚Äôs make things a little more complex and examine the binomial random variable. This randomvariableoriginatesfromperformingasequenceofùëõ independentexperiments, each of which has probability ùëù of succeeding, and asking how many successes we expect to see. Let‚Äôs express this mathematically. Each experiment is an independent random variable ùëãùëñ
Let‚Äôs express this mathematically. Each experiment is an independent random variable X; where we will use 1 to encode success, and 0 to encode failure. Since each is an independent coin flip which is successful with probability p, we can say that X; ~ Bernoulli(p). Then, the binomial random variable is
In this case, we will write
X ~ Binomial(n, p). (A.9)
To get the cumulative distribution function, we need to notice that getting exactly ùëò suc-
To get the cumulative distribution function, we need to notice that getting exactly k suc- cesses can occur in (7) = CEST ways each of which has a probability of p*(1 ‚Äî p)"~* of occurring. Thus the cumulative distribution function is
8>>><
0 x <0, F(x) =) Linck (pn )P‚Ñ¢U = pyr" ks x<k+ 1 withO<k <n, (A.10) 1 X>=n. Let‚Äôs first plot the probability mass function. (continued from previous page)
n
ùëã = ùëãùëñ. (A.8) ùëñ=1
991

n, p = 10, 0.2 # Compute binomial coefficient def binom(n, k): comb = 1 for i in range(min(k, n - k)): comb = comb * (n - i) // (i + 1) return comb pmf = torch.tensor([p**i * (1-p)**(n - i) * binom(n, i) for i in range(n + 1)]) d2l.plt.stem([i for i in range(n + 1)], pmf, use_line_collection=True) d2l.plt.xlabel('x') d2l.plt.ylabel('p.m.f.') d2l.plt.show()
0.3 0.2 p.m 01 0.0 ¬∞ N iS o ¬© 6
Now, let‚Äôs plot the cumulative distribution function (A.10). x = torch.arange(-1, 11, 0.01) cmf = torch.cumsum(pmf, dim=0) def F(x): return 0 if x < 0 else 1 if x > n else cmf[int(x)]
d2l.plot(x, torch.tensor([F(y) for y in x.tolist()]), 'x', 'c.d.f.')
1.0 08 06 c.d.f. 0.2 0.0
If X ~ Binomial(n, p), then:
¬© Mx =np,
Distributions
Mathematics for Deep Learning
992

¬∞ 02 =np(1-p). This follows from the linearity of expected value over the sum of ùëõ Bernoulli random vari-
ables, and the fact that the variance of the sum of independent random variables is the sum of the variances. This can be sampled as follows. m = torch.distributions.binomial.Binomial(n, p) m.sample(sample_shape=(10, 10))
tensor([[6., 3., 4., 3., 3., 1., 3., 3., 3., 3.], [3., 1., 2., 2., 3., 2., 1., 3., 1., 4.], [6., 1., 0., 3., 0., 3., 1., 0., 1., 1.], [1., 2., 3., 1., 2., 2., 2., 2., 3., 2.], [2., 2., 5., 4., 1., 3., 4., 3., 2., 0.], [2., 0., 2., 2., 3., 1., 1., 4., 3., 1.], [1., 1., 3., 2., 4., 2., 2., 2., 1., 0.], [0., 3., 2., 1., 1., 3., 2., 1., 1., 3.], [2., 3., 2., 3., 4., 3., 1., 2., 1., 2.], [1., 2., 1., 1., 3., 2., 4., 3., 3., 2.]])
A.8.5 Poisson
Let‚Äôs now perform a thought experiment. We are standing at a bus stop and we want to know how many buses will arrive in the next minute. Let‚Äôs start by considering X() ~ Bernoulli(p) which is simply the probability that a bus arrives in the one minute window. For bus stops far from an urban center, this might be a pretty good approximation. We may never see more than one bus in a minute. However, if we are in a busy area, it is possible or even likely that two buses will arrive. We can model this by splitting our random variable into two parts for the first 30 seconds, or the second 30 seconds. In this case we can write
XOXO 4 XO), (A.11)
where X(?) is the total sum, and x) ~ Bernoulli(p/2). The total distribution is then X) ~ Binomial(2, p/2). Why stop here? Let‚Äôs continue to split that minute into ùëõ parts. By the same reasoning as
above, we see that
X ~ Binomial(n, p/n). (A.12)
Consider these random variables. By the previous section, we know that (A.12) has mean Hyin) = n(p/n) = p, and variance Tm = n(p/n)(1 - (p/n)) = p( - p/n). If we take n ‚Äî oo, we can see that these numbers stabilize to p2y() = p, and variance O60) = p. This indicates that there could be some random variable we can define in this infinite subdivision limit. This should not come as too much of a surprise, since in the real world we can just count
993

the number of bus arrivals, however it is nice to see that our mathematical model is well defined. This discussion can be made formal as the law of rare events. Following through this reasoning carefully, we can arrive at the following model. We will say that X ~ Poisson(A) if it is a random variable which takes the values {0, 1,2, ...} with probability
ake~4 Pk= (A.13)
The value ùúÜ > 0 is known as the rate (or the shape parameter), and denotes the average
number of arrivals we expect in one unit of time. Wemaysumthisprobabilitymassfunctiontogetthecumulativedistributionfunction.bubu(
x <0, 0 F(x) = {. yh at (A.14) ot ksx<k+lwithO<k. Let‚Äôs first plot the probability mass function (A.13). lam = 5.0 xs = [i for i in range(20)] pmf = torch.tensor([torch.exp(torch.tensor(-lam)) * lam**k / factorial(k) for k in xs]) d2l.plt.stem(xs, pmf, use_line_collection=True) d2l.plt.xlabel('x') d2l.plt.ylabel('p.m.f.') d2l.plt.show()
0.15 e ‚Äú0.10 E a 0.05 0.00 i} 5 10 15 x
Now, let‚Äôs plot the cumulative distribution function (A.14). x = torch.arange(-1, 21, 0.01) cmf = torch.cumsum(pmf, dim=0) def F(x): return 0 if x < 0 else 1 if x > n else cmf[int(x)] d2l.plot(x, torch.tensor([F(y) for y in x.tolist()]), 'x', 'c.d.f.')
As we saw above, the means and variances are particularly concise. If X ~ Poisson(A),
then:
Distributions
Mathematics for Deep Learning
994

1.0 08 06 cdf. 0.2 0.0
eux =A,
eo,aa
ùëã = ùúÜ. This can be sampled as follows. m = torch.distributions.poisson.Poisson(lam) m.sample((10, 10))
tensor([[ 1., 4., 6., 8., 4., 4., 4., 7., 6., 4.], [ 3., 6., 7., 7., 5., 7., 7., 3., 5., 4.], [ 4., 1., 3., 3., 10., 5., 5., 3., 7., 5.], [ 4., 3., 4., 10., 8., 6., 4., 6., 5., 5.], [ 5., 11., 1., 5., 7., 5., 2., 4., 3., 5.], [ 6., 6., 4., 4., 3., 1., 5., 8., 4., 5.], [ 2., 9., 7., 2., 6., 5., 2., 8., 6., 10.], [ 1., 4., 3., 7., 3., 1., 7., 5., 3., 6.], [ 5., 4., 6., 4., 9., 8., 3., 3., 1., 8.], [ 3., 12., 9., 13., 2., 14., 3., 2., 0., 3.]])
A.8.6 Gaussian
Now Let‚Äôs try a different, but related experiment. Let‚Äôs say we again are performing n independent Bernoulli(p) measurements X;. The distribution of the sum of these is X‚Äú) ~ Binomial(n, p). Rather than taking a limit as n increases and p decreases, Let‚Äôs fix p, and then send n ‚Äî ov, In this case Lyin) = np ‚Äî co and oy no reason to think this limit should be well defined. ="2p(1‚Äî p) > %, so there is
However, not all hope is lost! Let‚Äôs just make the mean and variance be well behaved by defining
X = pyin yo = ‚Äî (A.15) x(n
This can be seen to have mean zero and variance one, and so it is plausible to believe that it will converge to some limiting distribution. If we plot what these distributions look like, we will become even more convinced that it will work. 995

p = 0.2 ns = [1, 10, 100, 1000] d2l.plt.figure(figsize=(10, 3)) for i in range(4): n = ns[i] pmf = torch.tensor([p**i * (1-p)**(n-i) * binom(n, i) for i in range(n + 1)]) d2l.plt.subplot(1, 4, i + 1) d2l.plt.stem([(i - n*p)/torch.sqrt(torch.tensor(n*p*(1 - p))) for i in range(n + 1)], pmf, use_line_collection=True) d2l.plt.xlim([-4, 4]) d2l.plt.xlabel('x') d2l.plt.ylabel('p.m.f.') d2l.plt.title("n = {}".format(n)) d2l.plt.show()
n=1 n=10 n= 100 n= 1000 0.8 .30 .25 0.6 .20 ¬£04 ¬£ q.15 a a 10 0.2 .05 0.0 .00 -4 -2 0 2 4 -4 -2 0 x x x x
One thing to note: compared to the Poisson case, we are now dividing by the standard de- viation which means that we are squeezing the possible outcomes into smaller and smaller areas. This is an indication that our limit will no longer be discrete, but rather continu- ous. A derivation of what occurs is beyond the scope of this document, but the central limit theorem states that as ùëõ ! 1, this will yield the Gaussian Distribution (or sometimes normal distribution). More explicitly, for any ùëé, ùëè:
lim ùëõ!1 ùëÉ‚Äûùëå ‚Äûùëõ‚Äù 2 ¬ªùëé, ùëè‚Ä¶‚Äù = ùëÉ‚ÄûN‚Äû0,1‚Äù 2 ¬ªùëé, ùëè‚Ä¶‚Äù, (A.16)
where we say a random variable is normally distributed with given mean ùúá and variance
where we say a random variable is normally distributed with given mean jy and variance o?, written X ~ N(j1,07) if X has density
_ e-w)? eo (A.17) Px(x) =
Let‚Äôs first plot the probability density function (A.17). mu, sigma = 0, 1
Distributions
(continues on next page)
Mathematics for Deep Learning
996

x = torch.arange(-3, 3, 0.01) p = 1 / torch.sqrt(2 * torch.pi * sigma**2) * torch.exp( -(x - mu)**2 / (2 * sigma**2)) d2l.plot(x, p, 'x', 'p.d.f.')
0.4 0.3 30.2 a 0.1 0.0
Now, let‚Äôs plot the cumulative distribution function. It is beyond the scope of this ap- pendix, but the Gaussian c.d.f. does not have a closed-form formula in terms of more elementary functions. We will use erf which provides a way to compute this integral nu- merically. def phi(x): return (1.0 + erf((x - mu) / (sigma * torch.sqrt(torch.tensor(2.))))) / 2.0 d2l.plot(x, torch.tensor([phi(y) for y in x.tolist()]), 'x', 'c.d.f.')
def phi(x):
1.0 08 0.6 c.d.f. 0.2 0.0
Keen-eyedreaderswillrecognizesomeoftheseterms.bubuIndeed, weencounteredthisintegral in Section A.5. Indeed we need exactly that computation to see that this ùëùùëã‚Äûùë•‚Äù has total area one and is thus a valid density. Our choice of working with coin flips made computations shorter, but nothing about that choice was fundamental. Indeed, if we take any collection of independent identically dis- tributed random variables ùëãùëñ, and form
ùëã ‚ÄûùëÅ‚Äù = ùëãùëñ. (A.18) ùëñ=1
(continued from previous page)
N
997

Then
ùúéùëã‚ÄûùëÅ‚Äù (A.19)
will be approximately Gaussian. There are additional requirements needed to make it work, most commonly ùê∏¬ªùëã4‚Ä¶ < 1, but the philosophy is clear. The central limit theorem is the reason why the Gaussian is fundamental to probability, statistics, and machine learning. Whenever we can say that something we measured is a sumofmanysmallindependentcontributions, wecanassumethatthethingbeingmeasured will be close to Gaussian. There are many more fascinating properties of Gaussians, and we would like to discuss one more here. The Gaussian is what is known as a maximum entropy distribution. We will get into entropy more deeply in Section A.11, however all we need to know at this point is that it is a measure of randomness. In a rigorous mathematical sense, we can think of the Gaussian as the most random choice of random variable with fixed mean and variance. Thus, if we know that our random variable has some mean and variance, the Gaussian is in a sense the most conservative choice of distribution we can make. To close the section, let‚Äôs recall that if X ~ N(y, o), then:
¬∞ Ux =H,
e ox = 0". ùëã = ùúé2. WecansamplefromtheGaussian(orstandardnormal)distributionasshownbelow. torch.normal(mu, sigma, size=(10, 10))
tensor([[ 1.3588, 0.0473, -1.5805, -0.0108, 0.4253, 0.7924, -0.6547, 0. ‚Ü©!7313, -0.3038, 1.1935], [ 0.0089, 0.8951, 1.0055, 0.0956, -1.1109, -0.6342, 1.6772, 1. ‚Ü©!0314, 0.3819, -1.7822], [-0.0604, -1.0318, 0.9113, 1.3118, -1.8370, -0.9023, 1.0365, 0. ‚Ü©!9052, -0.6411, -0.8949], [-0.1713, -0.2347, 0.0767, -0.6375, -0.4612, -1.6875, -0.1570, 1. ‚Ü©!0591, 0.8377, 0.5097], [ 0.2762, -0.6213, -0.3422, 0.9449, -0.7544, -0.2150, 1.0240, 1. ‚Ü©!0253, -0.9182, 1.1536], [ 0.0614, 0.2758, -0.3610, -1.0577, -0.5513, -0.9158, 0.7539, 0. ‚Ü©!9204, -0.5908, 0.9113], [ 1.6190, -0.9213, -0.7944, -2.2621, 0.5826, -1.8287, 1.4097, -0. ‚Ü©!5744, -0.0668, 1.2074], [-0.0624, 0.1928, 1.3002, 0.6756, 1.1590, 1.0144, 1.1840, -0. Distributions
(N) _ XUN) Hen,
(continues on next page)
Mathematics for Deep Learning
998

‚Ü©!5010, 0.6026, -0.7722], [-2.0148, 0.6958, 0.9940, 0.8477, 1.0957, -0.5253, 0.2353, -0. ‚Ü©!2663, 1.2275, 0.5993], [ 0.4651, -0.8218, -0.5441, -2.0338, -0.6930, -0.0674, -0.4448, -0. ‚Ü©!8397, 0.0360, -0.7089]])
A.8.7 Exponential Family
One shared property for all the distributions listed above is that they all belong to which is known as the exponential family. The exponential family is a set of distributions whose density can be expressed in the following form:
p(x | 9) = h(x) - exp (9 - T(x) - A()) (A.20)
As this definition can be a little subtle, let‚Äôs examine it closely. First, ‚Ñé‚Äûx‚Äù is known as the underlying measure or the base measure. This can be viewed
as an original choice of measure we are modifying with our exponential weight. Second, we have the vector ¬ª = (7,72,....m) ‚Ç¨ R! called the natural parameters or canonical parameters. These define how the base measure will be modified. The natural parameters enter into the new measure by taking the dot product of these parameters against some function T(-) of x = (x1, X2,...,X,) ‚Ç¨ R‚Äù and exponentiated. The vector T(x) = (T, (x), To(x), ..., Tj (x)) is called the sufficient statistics for n. This name is used since the information represented by T(x) is sufficient to calculate the probability density and no other information from the sample x‚Äôs are required. Third, we have ùê¥‚Äûùúº‚Äù, which is referred to as the cumulant function, which ensures that the
above distribution (A.20) integrates to one, i.e.,
A(n) = log [/ h(x) - exp (7 - T(x)) ar . (A.21)
To be concrete, let‚Äôs consider the Gaussian. Assuming that x is an univariate variable, we saw that it had a density of
2 ~(x ‚Äî exp (¬´= #) 20? 1 Lu 1 1 = Te exp {5 - a - (so? + tog()}} : P(x | 4.0) = TO (A.22)
This matches the definition of the exponential family with:
e underlying measure: h(x) =
ee |
2ùúã,
ùúÇ1
4 o I
e natural parameters: n =
ùúÇ2
2ùúé2
(continued from previous page)
,
999

¬© sufficient statistics: T(x) = 9}, and -x 2 e cumulant function: A(n) = sae + log(a) = a - 3 log(2n2). Itisworthnotingthattheexactchoiceofeachofabovetermsissomewhatarbitrary. Indeed, theimportantfeatureisthatthedistributioncanbeexpressedinthisform, nottheexactform itself. As we allude to in Section 4.1.2, a widely used technique is to assume that the final output y follows an exponential family distribution. The exponential family is a common and powerful family of distributions encountered frequently in machine learning. A.8.8 Summary
e Bernoulli random variables can be used to model events with a yes/no outcome. e Discrete uniform distributions model selects from a finite set of possibilities. e Continuous uniform distributions select from an interval. e Binomial distributions model a series of Bernoulli random variables, and count the num-
ber of successes. e Poisson random variables model the arrival of rare events. e Gaussian random variables model the result of adding a large number of independent
random variables together. e All the above distributions belong to exponential family.bubuA.8.9 Exercises
1. What is the standard deviation of a random variable that is the difference X ‚Äî Y of two
1. What is the standard deviation of a random variable that is the difference X ‚Äî Y of two independent binomial random variables X,Y ~ Binomial(16, 1/2). 2.bubuIf we take a Poisson random variable X ~ Poisson(A) and consider (X ‚Äî A)/VA
ùúÜ ! 1, we can show that this becomes approximately Gaussian. Why does this make sense?bubu3. Whatistheprobabilitymassfunctionforasumoftwodiscreteuniformrandomvariables on ùëõ elements? Discussions287. 287
287
A.9 Naive Bayes
a
Throughout the previous sections, we learned about the theory of probability and random variables. To put this theory to work, let‚Äôs introduce the naive Bayes classifier. This
Naive Bayes
p
ùúÜ as
Mathematics for Deep Learning
1000

uses nothing but probabilistic fundamentals to allow us to perform classification of dig- its. Learningisallaboutmakingassumptions. Ifwewanttoclassifyanewdataexamplethatwe have never seen before we have to make some assumptions about which data examples are similar to each other. The naive Bayes classifier, a popular and remarkably clear algorithm, assumes all features are independent from each other to simplify the computation. In this section, we will apply this model to recognize characters in images. %matplotlib inline import math import torch import torchvision from d2l import torch as d2l
d2l.use_svg_display()
A.9.1 Optical Character Recognition
MNIST (LeCun et al., 1998) is one of widely used datasets. It contains 60,000 images for training and 10,000 images for validation. Each image contains a handwritten digit from 0 to 9. The task is classifying each image into the corresponding digit. Gluon provides a MNIST class in the data.vision module to automatically retrieve the dataset from the Internet. Subsequently, Gluon will use the already-downloaded local copy. We specify whether we are requesting the training set or the test set by setting the value of the parameter train to True or False, respectively. Each image is a grayscale image with both width and height of 28 with shape (28,28,1). We use a customized transformation to remove the last channel dimension. In addition, the dataset represents each pixel by an un- signed 8-bit integer. We quantize them into binary features to simplify the problem. data_transform = torchvision.transforms.Compose([ torchvision.transforms.ToTensor(), lambda x: torch.floor(x * 255 / 128).squeeze(dim=0) ]) mnist_train = torchvision.datasets.MNIST( root='./temp', train=True, transform=data_transform, download=True) mnist_test = torchvision.datasets.MNIST( root='./temp', train=False, transform=data_transform, download=True)
Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz to ./ ‚Ü©!temp/MNIST/raw/train-images-idx3-ubyte.gz 100%|| 9912422/9912422 [00:00<00:00, 115752065.81it/s] Extracting ./temp/MNIST/raw/train-images-idx3-ubyte.gz to ./temp/MNIST/raw
Downloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz Downloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz to ./
(continues on next page)
1001

‚Ü©!temp/MNIST/raw/train-labels-idx1-ubyte.gz 100%|| 28881/28881 [00:00<00:00, 5234904.66it/s] Extracting ./temp/MNIST/raw/train-labels-idx1-ubyte.gz to ./temp/MNIST/raw
Downloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz Downloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz to ./ ‚Ü©!temp/MNIST/raw/t10k-images-idx3-ubyte.gz 100%|| 1648877/1648877 [00:00<00:00, 43715298.68it/s]Extracting ./ ‚Ü©!temp/MNIST/raw/t10k-images-idx3-ubyte.gz to ./temp/MNIST/raw
Downloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz Downloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz to ./ ‚Ü©!temp/MNIST/raw/t10k-labels-idx1-ubyte.gz 100%|| 4542/4542 [00:00<00:00, 21501725.47it/s] Extracting ./temp/MNIST/raw/t10k-labels-idx1-ubyte.gz to ./temp/MNIST/raw
We can access a particular example, which contains the image and the corresponding la- bel. image, label = mnist_train[2] image.shape, label
(torch.Size([28, 28]), 4)
Our example, stored here in the variable image, corresponds to an image with a height and width of 28 pixels. image.shape, image.dtype
(torch.Size([28, 28]), torch.float32)
Our code stores the label of each image as a scalar. Its type is a 32-bit integer. label, type(label)
(4, int)
We can also access multiple examples at the same time. images = torch.stack([mnist_train[i][0] for i in range(10, 38)], dim=0) labels = torch.tensor([mnist_train[i][1] for i in range(10, 38)]) images.shape, labels.shape
Naive Bayes
(continued from previous page)
Mathematics for Deep Learning
1002

(torch.Size([28, 28, 28]), torch.Size([28]))
Let‚Äôs visualize these examples. d2l.show_images(images, 2, 9);








A.9.2 The Probabilistic Model for Classification
In a classification task, we map an example into a category. Here an example is a grayscale 28 x 28 image, and a category is a digit. (Refer to Section 4.1 for a more detailed expla- nation.) One natural way to express the classification task is via the probabilistic question: what is the most likely label given the features (i.e., image pixels)? Denote by x ‚Ç¨ R@ the features of the example and y ‚Ç¨ R the label. Here features are image pixels, where we can reshape a 2-dimensional image to a vector so that d = 28* = 784, and labels are digits. The probability of the label given the features is p(y | x). If we are able to compute these probabilities, which are p(y | x) for y = 0,...,9 in our example, then the classifier will output the prediction f given by the expression:
ÀÜùë¶ = argmax ùëù‚Äûùë¶ j x‚Äù. (A.1)
Unfortunately, this requires that we estimate ùëù‚Äûùë¶ j x‚Äù for every value of x = ùë•1, ...,ùë•ùëë. Imagine that each feature could take one of 2 values. For example, the feature ùë•1 = 1 might signify that the word apple appears in a given document and ùë•1 = 0 would signify that it does not. If we had 30 such binary features, that would mean that we need to be prepared to classify any of 230 (over 1 billion!) possible values of the input vector x. Moreover, where is the learning? If we need to see every single possible example in order to predictthecorrespondinglabelthenwearenotreallylearningapatternbutjustmemorizing the dataset. A.9.3 The Naive Bayes Classifier
Fortunately, by making some assumptions about conditional independence, we can intro- duce some inductive bias and build a model capable of generalizing from a comparatively modest selection of training examples. To begin, let‚Äôs use Bayes theorem, to express the classifier as
ÀÜùë¶ = argmaxùë¶ ùëù‚Äûùë¶ j x‚Äù = argmaxùë¶ ùëù‚Äûx‚Äù . (A.2)










ùëù‚Äûx j ùë¶‚Äùùëù‚Äûùë¶‚Äù
1003

Notethat the denominator is the normalizing term ùëù‚Äûx‚Äù whichdoes not depend on the value
of the label ùë¶. As a result, we only need to worry about comparing the numerator across different values of ùë¶. Even if calculating the denominator turned out to be intractable, we could get away with ignoring it, so long as we could evaluate the numerator. Fortunately, even if we wanted to recover the normalizing constant, we could. We can always recover Àù ùë¶ ùëù‚Äûùë¶ j x‚Äù = 1. the normalization term since
Now, let‚Äôs focus on ùëù‚Äûx j ùë¶‚Äù. Using the chain rule of probability, we can express the term
ùëù‚Äûx j ùë¶‚Äù as
P(x | y) + pQv2 | ats y) + Pa | 1, Xa-1,Y)- (A.3)
By itself, this expression does not get us any further. We still must estimate roughly 2ùëë
parameters. However, if we assume that the features are conditionally independent of each other, given the label, then suddenly we are in much better shape, as this term simplifies to Àõ ùëñ ùëù‚Äûùë•ùëñ j ùë¶‚Äù, giving us the predictor
ÀÜùë¶ = argmaxùë¶ ùëù‚Äûùë•ùëñ j ùë¶‚Äùùëù‚Äûùë¶‚Äù. ùëñ=1 (A.4)
If we can estimate ùëù‚Äûùë•ùëñ = 1 j ùë¶‚Äù for every ùëñ and ùë¶, and save its value in ùëÉùë•ùë¶¬ªùëñ, ùë¶‚Ä¶, here ùëÉùë•ùë¶
If we can estimate p(x; = 1 | y) for every i and y, and save its value in Py, [i, y], here Py is ad Xn matrix with n being the number of classes and y ‚Ç¨ {1,...,m}, then we can also use this to estimate p(x; = 0 | y), ie.,
Pxyli,y] for t; = 1; (A.5) 1- Px y[i,y] fort; = 0. P(xi=tily)= |
In addition, we estimate ùëù‚Äûùë¶‚Äù for every ùë¶ and save it in ùëÉùë¶¬ªùë¶‚Ä¶, with ùëÉùë¶ a ùëõ-length vector. Then, for any new example t = ‚Äûùë°1,ùë°2, . . .,ùë°ùëë‚Äù, we could compute
d
d ¬ß =argmax, p(y) | [ pr = 1 y) i=l d =argmax, Pyly] | | Pxyliyl" (1- Payli.yl) i=l (A.6) 1-1
for any ùë¶. So our assumption of conditional independence has taken the complexity of
our model from an exponential dependence on the number of features O‚Äû2ùëëùëõ‚Äù to a linear dependence, which is O‚Äûùëëùëõ‚Äù. A.9.4 Training
The problem now is that we do not know ùëÉùë•ùë¶ and ùëÉùë¶. So we need to estimate their values
given some training data first. This is training the model. Estimating ùëÉùë¶ is not too hard. Since we are only dealing with 10 classes, we may count the number of occurrences ùëõùë¶ for each of the digits and divide it by the total amount of data ùëõ. For instance, if digit 8 occurs ùëõ8 = 5,800 times and we have a total of ùëõ = 60,000 images, the probability estimate is ùëù‚Äûùë¶ = 8‚Äù = 0.0967. Naive Bayes
d
(
Mathematics for Deep Learning
1004

X = torch.stack([mnist_train[i][0] for i in range(len(mnist_train))], dim=0) Y = torch.tensor([mnist_train[i][1] for i in range(len(mnist_train))]) n_y = torch.zeros(10) for y in range(10): n_y[y] = (Y == y).sum() P_y = n_y / n_y.sum() P_y
tensor([0.0987, 0.1124, 0.0993, 0.1022, 0.0974, 0.0904, 0.0986, 0.1044, 0.0975, 0.0992])
Now on to slightly more difficult things ùëÉùë•ùë¶. Since we picked black and white images,
ùëù‚Äûùë•ùëñ j ùë¶‚Äù denotes the probability that pixel ùëñ is switched on for class ùë¶. Just like before we can go and count the number of times ùëõùëñùë¶ such that an event occurs and divide it by the total number of occurrences of ùë¶, i.e., ùëõùë¶. But there is something slightly troubling: certain pixels may never be black (e.g., for well cropped images the corner pixels might always be white). A convenient way for statisticians to deal with this problem is to add pseudo counts to all occurrences. Hence, rather than ùëõùëñùë¶ we use ùëõùëñùë¶ ‚Äö 1 and instead of ùëõùë¶ we use ùëõùë¶ ‚Äö 2 (since there are two possible values pixel ùëñ can take - it can either be black or white). This is also called Laplace Smoothing. It may seem ad-hoc, however it can be motivated from a Bayesian point-of-view by a Beta-binomial model. n_x = torch.zeros((10, 28, 28)) for y in range(10): n_x[y] = torch.tensor(X.numpy()[Y.numpy() == y].sum(axis=0)) P_xy = (n_x + 1) / (n_y + 2).reshape(10, 1, 1) d2l.show_images(P_xy, 2, 5);
d2l.show_images(P_xy, 2, 5);




By visualizing these 10 x 28 x 28 probabilities (for each pixel for each class) we could get
some mean looking digits. Now we can use (A.6) to predict a new image. Given x, the following functions computes ùëù‚Äûx j ùë¶‚Äùùëù‚Äûùë¶‚Äù for every ùë¶. 1005

def bayes_pred(x): x = x.unsqueeze(0) # (28, 28) -> (1, 28, 28) p_xy = P_xy * x + (1 - P_xy)*(1 - x) p_xy = p_xy.reshape(10, -1).prod(dim=1) # p(x|y) return p_xy * P_y image, label = mnist_test[0] bayes_pred(image)
tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
This went horribly wrong! To find out why, let‚Äôs look at the per pixel probabilities.bubuThey are typically numbers between 0.001 and 1. We are multiplying 784 of them. At this point it is worth mentioning that we are calculating these numbers on a computer, hence with a fixed range for the exponent. What happens is that we experience numerical underflow, i.e., multiplying all the small numbers leads to something even smaller until it is rounded down to zero. We discussed this as a theoretical issue in Section A.7, but we see the phenomena clearly here in practice. As discussed in that section, we fix this by use the fact that logùëéùëè = logùëé ‚Äö log ùëè, i.e.,
we switch to summing logarithms. Even if both ùëé and ùëè are small numbers, the logarithm values should be in a proper range. a = 0.1 print('underflow:', a**784) print('logarithm is normal:', 784*math.log(a))
underflow: 0.0 logarithm is normal: -1805.2267129073316
Since the logarithm is an increasing function, we can rewrite (A.6) as
h
d
d ¬ß =argmax, log Pyly] + )) |r log PyyLai,y] + (1-4) log = PayLei.y))]- (AZ) i=l
We can implement the following stable version:
log_P_xy = torch.log(P_xy) log_P_xy_neg = torch.log(1 - P_xy) log_P_y = torch.log(P_y) def bayes_pred_stable(x): x = x.unsqueeze(0) # (28, 28) -> (1, 28, 28) p_xy = log_P_xy * x + log_P_xy_neg * (1 - x) p_xy = p_xy.reshape(10, -1).sum(axis=1) # p(x|y) return p_xy + log_P_y py = bayes_pred_stable(image) py
Naive Bayes
i
Mathematics for Deep Learning
1006

tensor([-268.9725, -301.7044, -245.1951, -218.8738, -193.4570, -206.0909, -292.5226, -114.6257, -220.3313, -163.1784])
We may now check if the prediction is correct. py.argmax(dim=0) == label
tensor(True)
If we now predict a few validation examples, we can see the Bayes classifier works pretty well. def predict(X): return [bayes_pred_stable(x).argmax(dim=0).type(torch.int32).item() for x in X] X = torch.stack([mnist_test[i][0] for i in range(18)], dim=0) y = torch.tensor([mnist_test[i][1] for i in range(18)]) preds = predict(X) d2l.show_images(X, 2, 9, titles=[str(d) for d in preds]);
7
2
1
0




9
0
6
9




Finally, let‚Äôs compute the overall accuracy of the classifier. X = torch.stack([mnist_test[i][0] for i in range(len(mnist_test))], dim=0) y = torch.tensor([mnist_test[i][1] for i in range(len(mnist_test))]) preds = torch.tensor(predict(X), dtype=torch.int32) float((preds == y).sum()) / len(y) # Validation accuracy
0.8427
Modern deep networks achieve error rates of less than 0.01. The relatively poor perfor-
mance is due to the incorrect statistical assumptions that we made in our model: we as- sumed that each and every pixel are independently generated, depending only on the label. This is clearly not how humans write digits, and this wrong assumption led to the downfall of our overly naive (Bayes) classifier. A.9.5 Summary
4
1
4
9
4





i}
1
3
9
7





1007

Using Bayes‚Äô rule, a classifier can be made by assuming all observed features are inde-
pendent. This classifier can be trained on a dataset by counting the number of occurrences of
combinations of labels and pixel values. This classifier was the gold standard for decades for tasks such as spam detection. A.9.6 Exercises
1. Consider the dataset ¬ª¬ª0,0‚Ä¶, ¬ª0,1‚Ä¶, ¬ª1,0‚Ä¶, ¬ª1,1‚Ä¶‚Ä¶ with labels given by the XOR of the two elements ¬ª0,1,1,0‚Ä¶. What are the probabilities for a Naive Bayes classifier built on this dataset. Does it successfully classify our points?bubuIf not, what assumptions are violated?bubu2. Suppose that we did not use Laplace smoothing when estimating probabilities and a data example arrived at testing time which contained a value never observed in training. What would the model output?bubu3. The naive Bayes classifier is a specific example of a Bayesian network, where the de- pendence of random variables are encoded with a graph structure. While the full theory is beyond the scope of this section (see Koller and Friedman (2009) for full details), explain why allowing explicit dependence between the two input variables in the XOR model allows for the creation of a successful classifier. 288 Discussions288.bubuA.10 Statistics
ae
Undoubtedly, to be a top deep learning practitioner, the ability to train the state-of-the-art and high accurate models is crucial. However, it is often unclear when improvements are significant, or only the result of random fluctuations in the training process. To be able to discuss uncertainty in estimated values, we must learn some statistics. The earliest reference of statistics can be traced back to an Arab scholar Al-Kindi in the 9th- century, who gave a detailed description of how to use statistics and frequency analysis to decipher encrypted messages. After 800 years, the modern statistics arose from Germany in 1700s, when the researchers focused on the demographic and economic data collection andanalysis. Today, statisticsisthesciencesubjectthatconcernsthecollection, processing, analysis, interpretation and visualization of data. What is more, the core theory of statistics has been widely used in the research within academia, industry, and government. More specifically, statistics can be divided to descriptive statistics and statistical inference. The former focus on summarizing and illustrating the features of a collection of observed data, which is referred to as a sample. The sample is drawn from a population, denotes
Statistics
Mathematics for Deep Learning
1008

the total set of similar individuals, items, or events of our experiment interests. Contrary to descriptive statistics, statistical inference further deduces the characteristics of a population from the given samples, based on the assumptions that the sample distribution can replicate the population distribution at some degree. You may wonder: ‚ÄúWhat is the essential difference between machine learning and statis- tics?‚Äù Fundamentally speaking, statistics focuses on the inference problem. This type of problems includes modeling the relationship between the variables, such as causal infer- ence, and testing the statistically significance of model parameters, such as A/B testing. In contrast, machine learning emphasizes on making accurate predictions, without explicitly programming and understanding each parameter‚Äôs functionality. In this section, we will introduce three types of statistics inference methods: evaluating and comparing estimators, conducting hypothesis tests, and constructing confidence intervals. These methods can help us infer the characteristics of a given population, i.e., the true parameter ùúÉ. For brevity, we assume that the true parameter ùúÉ of a given population is a scalar value. It is straightforward to extend to the case where ùúÉ is a vector or a tensor, thus we omit it in our discussion. A.10.1 Evaluating and Comparing Estimators
In statistics, an estimator is a function of given samples used to estimate the true parameter ùúÉ. We will write ÀÜùúÉùëõ = ÀÜùëì ‚Äûùë•1, .bubu. .,ùë•ùëõ‚Äù for the estimate of ùúÉ after observing the samples {ùë•1,ùë•2, . .bubu.,ùë•ùëõ}.bubuWe have seen simple examples of estimators before in section Section A.7. If you have a number of samples from a Bernoulli random variable, then the maximum likelihood esti- mate for the probability the random variable is one can be obtained by counting the number of ones observed and dividing by the total number of samples. Similarly, an exercise asked you to show that the maximum likelihood estimate of the mean of a Gaussian given a num- ber of samples is given by the average value of all the samples. These estimators will almost never give the true value of the parameter, but ideally for a large number of samples the estimate will be close. As an example, we show below the true density of a Gaussian random variable with mean zero and variance one, along with a collection samples from that Gaussian. We constructed the ùë¶ coordinate so every point is visible and the relationship to the original density is clearer. import torch from d2l import torch as d2l
torch.pi = torch.acos(torch.zeros(1)) * 2 #define pi in torch
# Sample datapoints and create y coordinate epsilon = 0.1 torch.manual_seed(8675309) xs = torch.randn(size=(300,))
(continues on next page)
1009

ys = torch.tensor( [torch.sum(torch.exp(-(xs[:i] - xs[i])**2 / (2 * epsilon**2))\ / torch.sqrt(2*torch.pi*epsilon**2)) / len(xs)\ for i in range(len(xs))]) # Compute true density xd = torch.arange(torch.min(xs), torch.max(xs), 0.01) yd = torch.exp(-xd**2/2) / torch.sqrt(2 * torch.pi) # Plot the results d2l.plot(xd, yd, 'x', 'density') d2l.plt.scatter(xs, ys) d2l.plt.axvline(x=0) d2l.plt.axvline(x=torch.mean(xs), linestyle='--', color='purple') d2l.plt.title(f'sample mean: {float(torch.mean(xs).item()):.2f}') d2l.plt.show()
sample mean: 0.00
There can be many ways to compute an estimator of a parameter ÀÜùúÉùëõ. In this section, we
introduce three common methods to evaluate and compare estimators: the mean squared error, the standard deviation, and statistical bias.bubuMean Squared Error
Perhaps the simplest metric used to evaluate estimators is the mean squared error (MSE) (or ùëô2 loss) estimator which can be defined as
MSE(4,, 8) = E[(On ‚Äî 9)7]. (A)
This allows us to quantify the average squared deviation from the true value. MSE is always non-negative. IfyouhavereadSection3.1, youwillrecognizeitasthemostcommonlyused regression loss function. As a measure to evaluate an estimator, the closer its value to zero, the closer the estimator is close to the true parameter ùúÉ. Statistical Bias
The MSE provides a natural metric, but we can easily imagine multiple different phenom- ena that might make it large. Two fundamentally important are fluctuation in the estimator
Statistics
(continued from previous page)
Mathematics for Deep Learning
1010

due to randomness in the dataset, and systematic error in the estimator due to the estimation procedure. First, let‚Äôs measure the systematic error. For an estimator ÀÜùúÉùëõ, the mathematical illustration
of statistical bias can be defined as
bias(6,) = E(O, ‚Äî 0) = E(6,) - 0. (A.2)
Note that when bias‚Äû ÀÜùúÉùëõ‚Äù = 0, the expectation of the estimator ÀÜùúÉùëõ is equal to the true value
of parameter. In this case, we say ÀÜùúÉùëõ is an unbiased estimator. In general, an unbiased estimator is better than a biased estimator since its expectation is the same as the true pa- rameter. It is worth being aware, however, that biased estimators are frequently used in practice. There are cases where unbiased estimators do not exist without further assumptions, or are intractable to compute. This may seem like a significant flaw in an estimator, however the majority of estimators encountered in practice are at least asymptotically unbiased in the sense that the bias tends to zero as the number of available samples tends to infinity: limùëõ!1 bias‚Äû ÀÜùúÉùëõ‚Äù = 0. Variance and Standard Deviation
Second, let‚Äôs measure the randomness in the estimator. Recall from Section A.6, the stan- dard deviation (or standard error) is defined as the squared root of the variance. We may measure the degree of fluctuation of an estimator by measuring the standard deviation or variance of that estimator. q
or, = WVarlOn) = VEUGn ‚Äî EOn)1- (A.3)
It is important to compare (A.3) to (A.1). In this equation we do not compare to the true population value ùúÉ, but instead to ùê∏‚Äû ÀÜùúÉùëõ‚Äù, the expected sample mean. Thus we are not measuring how far the estimator tends to be from the true value, but instead we measuring the fluctuation of the estimator itself. The Bias-Variance Trade-off
It is intuitively clear that these two main components contribute to the mean squared error. What is somewhat shocking is that we can show that this is actually a decomposition of the mean squared error into these two contributions plus a third one. That is to say that we can write the mean squared error as the sum of the square of the bias, the variance and the
q
1011

irreducible error. MSE(4),, 0) = E[(On - 8)"] = E[(6n)?] + E[07] ‚Äî 2E[6,6] = Var[6,,] + E[6,]? + Var[6] + E[6]? - 2E[4,, ]E[6] = (E[6,] ‚Äî E[6])? + Var[6,] + Var[6] = (E[4, ‚Äî 6])? + Var[,,] + Var[6] = (bias[4,])? + Var(6,,) + Var[6]. (AA)
We refer the above formula as bias-variance trade-off. The mean squared error can be di- vided into three sources of error: the error from high bias, the error from high variance and the irreducible error. The bias error is commonly seen in a simple model (such as a linear regression model), which cannot extract high dimensional relations between the features and the outputs. If a model suffers from high bias error, we often say it is underfitting or lack of flexibilty as introduced in (Section 3.6). The high variance usually results from a too complex model, which overfits the training data. As a result, an overfitting model is sensitive to small fluctuations in the data. If a model suffers from high variance, we often sayitis overfitting andlackof generalizationasintroduced in(Section3.6). Theirreducible error is the result from noise in the ùúÉ itself. Evaluating Estimators in Code
Since the standard deviation of an estimator has been implementing by simply calling a. std() for a tensor a, we will skip it but implement the statistical bias and the mean squared error. # Statistical bias def stat_bias(true_theta, est_theta): return(torch.mean(est_theta) - true_theta) # Mean squared error def mse(data, true_theta): return(torch.mean(torch.square(data - true_theta)))
To illustrate the equation of the bias-variance trade-off, let‚Äôs simulate of normal distribution N‚ÄûùúÉ, ùúé2‚Äù with 10,000 samples. Here, we use a ùúÉ = 1 and ùúé = 4. As the estimator is a function of the given samples, here we use the mean of the samples as an estimator for true ùúÉ in this normal distribution N‚ÄûùúÉ, ùúé2‚Äù . theta_true = 1 sigma = 4 sample_len = 10000 samples = torch.normal(theta_true, sigma, size=(sample_len, 1)) theta_est = torch.mean(samples) theta_est
Statistics
Mathematics for Deep Learning
1012

tensor(1.0170)
Let‚Äôs validate the trade-off equation by calculating the summation of the squared bias and the variance of our estimator. First, calculate the MSE of our estimator. mse(samples, theta_true)
tensor(16.0298)
Next, we calculate Var‚Äû ÀÜùúÉùëõ‚Äù ‚Äö ¬ªbias‚Äû ÀÜùúÉùëõ‚Äù‚Ä¶2 as below. As you can see, the two values agree to numerical precision. bias = stat_bias(theta_true, theta_est) torch.square(samples.std(unbiased=False)) + torch.square(bias)
tensor(16.0298)
A.10.2 Conducting Hypothesis Tests
The most commonly encountered topic in statistical inference is hypothesis testing. While hypothesis testing was popularized in the early 20th century, the first use can be traced back to John Arbuthnot in the 1700s. John tracked 80-year birth records in London and concluded that more men were born than women each year. Following that, the modern significance testing is the intelligence heritage by Karl Pearson who invented ùëù-value and Pearson‚Äôs chi-squared test, William Gosset who is the father of Student‚Äôs t-distribution, and Ronald Fisher who initialed the null hypothesis and the significance test. A hypothesis test is a way of evaluating some evidence against the default statement about a population. We refer the default statement as the null hypothesis ùêª0, which we try to reject using the observed data. Here, we use ùêª0 as a starting point for the statistical significance testing. The alternative hypothesis ùêªùê¥ (or ùêª1) is a statement that is contrary to the null hypothesis. A null hypothesis is often stated in a declarative form which posits a relation- ship between variables. It should reflect the brief as explicit as possible, and be testable by statistics theory. Imagine you are a chemist. After spending thousands of hours in the lab, you develop a new medicine which can dramatically improve one‚Äôs ability to understand math. To show its magic power, you need to test it. Naturally, you may need some volunteers to take the medicine and see whether it can help them learn mathematics better. How do you get started? First, you will need carefully random selected two groups of volunteers, so that there is no difference between their mathematical understanding ability measured by some metrics. The two groups are commonly referred to as the test group and the control group. The test group (or treatment group) is a group of individuals who will experience the medicine,
1013

while the control group represents the group of users who are set aside as a benchmark, i.e., identical environment setups except taking this medicine. In this way, the influence of all the variables are minimized, except the impact of the independent variable in the treatment. Second, after a period of taking the medicine, you will need to measure the two groups‚Äô mathematical understanding by the same metrics, such as letting the volunteers do the same tests after learning a new mathematical formula. Then, you can collect their performance and compare the results. In this case, our null hypothesis will be that there is no difference between the two groups, and our alternate will be that there is. This is still not fully formal.bubuThere are many details you have to think of carefully. For example, what is the suitable metrics to test their mathematical understanding ability? How many volunteers for your test so you can be confident to claim the effectiveness of your medicine? How long should you run the test? How do you decide if there is a difference between the two groups? Do you care about the average performance only, or also the range of variation of the scores?bubuAnd so on. In this way, hypothesis testing provides a framework for experimental design and reasoning about certainty in observed results. If we can now show that the null hypothesis is very unlikely to be true, we may reject it with confidence. To complete the story of how to work with hypothesis testing, we need to now introduce some additional terminology and make some of our concepts above formal. Statistical Significance
The statistical significance measures the probability of erroneously rejecting the null hy- pothesis, ùêª0, when it should not be rejected, i.e.,
statistical significance = 1 ‚Äî a = | ‚Äî P(reject Ho | Hp is true). (A.5)
It is also referred to as the type I error or false positive. The ùõº, is called as the significance
It is also referred to as the type J error or false positive. The a, is called as the significance level and its commonly used value is 5%, i.e., 1 ‚Äî @ = 95%. The significance level can be explained as the level of risk that we are willing to take, when we reject a true null hypothesis. Fig. A.1 shows the observations‚Äô values and probability of a given normal distribution in a two-sample hypothesis test. If the observation data example is located outsides the 95% threshold, it will be a very unlikely observation under the null hypothesis assump- tion. Hence, there might be something wrong with the null hypothesis and we will reject it. Statistical Power
The statistical power (or sensitivity) measures the probability of reject the null hypothesis, ùêª0, when it should be rejected, i.e.,
statistical power = 1 ‚Äî B = 1 ‚Äî P( fail to reject Ho | Ho is false). (A.6)
Statistics
Mathematics for Deep Learning
1014

97.5% significance threshold (1-2) 1 Very unusual bservations Very unusual * observations | ‚Äî__ 95% Confidence interval > Value of observations: An outlier (p-value < 5%)
Probability of observations
tFig. A.1
Statistical signiÔ¨Åcance. Recall that a type I error is error caused by rejecting the null hypothesis when it is true, whereas a type II error is resulted from failing to reject the null hypothesis when it is false. A type II error is usually denoted as 8, and hence the corresponding statistical power is 1-8. Intuitively, statistical power can be interpreted as how likely our test will detect a real dis- crepancy of some minimum magnitude at a desired statistical significance level. 80% is a commonly used statistical power threshold. The higher the statistical power, the more likely we are to detect true differences. One of the most common uses of statistical power is in determining the number of samples needed. Theprobabilityyourejectthenullhypothesiswhenitisfalsedependsonthedegree to which it is false (known as the effect size) and the number of samples you have. As you might expect, small effect sizes will require a very large number of samples to be detectable with high probability. While beyond the scope of this brief appendix to derive in detail, as an example, want to be able to reject a null hypothesis that our sample came from a mean zero variance one Gaussian, and we believe that our sample‚Äôs mean is actually close to one, we can do so with acceptable error rates with a sample size of only 8. However, if we think our sample population true mean is close to 0.01, then we‚Äôd need a sample size of nearly 80000 to detect the difference. We can imagine the power as a water filter. In this analogy, a high power hypothesis test is like a high quality water filtration system that will reduce harmful substances in the water as much as possible. On the other hand, a smaller discrepancy is like a low quality water filter, where some relative small substances may easily escape from the gaps. Similarly, if the statistical power is not of enough high power, then the test may not catch the smaller discrepancy. Test Statistic
A test statistic ùëá‚Äûùë•‚Äù is a scalar which summarizes some characteristic of the sample data. Thegoalofdefiningsuchastatisticisthatitshouldallowustodistinguishbetweendifferent distributions and conduct our hypothesis test. Thinking back to our chemist example, if we wish to show that one population performs better than the other, it could be reasonable to
1015

take the mean as the test statistic. Different choices of test statistic can lead to statistical test with drastically different statistical power. Often, ùëá‚Äûùëã‚Äù (the distribution of the test statistic under our null hypothesis) will follow, at
least approximately, a common probability distribution such as a normal distribution when considered under the null hypothesis. If we can derive explicitly such a distribution, and then measure our test statistic on our dataset, we can safely reject the null hypothesis if our statistic is far outside the range that we would expect. Making this quantitative leads us to the notion of ùëù-values. The ùëù-value (or the probability value) is the probability that ùëá‚Äûùëã‚Äù is at least as extreme as
the observed test statistic ùëá‚Äûùë•‚Äù assuming that the null hypothesis is true, i.e.,
ùëù-value = ùëÉùêª0
(A.7)
If the ùëù-value is smaller than or equal to a predefined and fixed statistical significance level
ùõº, we may reject the null hypothesis. Otherwise, we will conclude that we are lack of evidence to reject the null hypothesis. For a given population distribution, the region of rejection will be the interval contained of all the points which has a ùëù-value smaller than the statistical significance level ùõº. One-side Test and Two-sided Test
Normally there are two kinds of significance test: the one-sided test and the two-sided test. The one-sided test (or one-tailed test) is applicable when the null hypothesis and the alternative hypothesis only have one direction. For example, the null hypothesis may state that the true parameter ùúÉ is less than or equal to a value ùëê. The alternative hypothesis would be that ùúÉ is greater than ùëê. That is, the region of rejection is on only one side of the sampling distribution. Contrary to the one-sided test, the two-sided test (or two-tailed test) is applicable when the region of rejection is on both sides of the sampling distribution. An example in this case may have a null hypothesis state that the true parameter ùúÉ is equal to a value ùëê. The alternative hypothesis would be that ùúÉ is not equal to ùëê. General Steps of Hypothesis Testing
After getting familiar with the above concepts, let‚Äôs go through the general steps of hypoth- esis testing. 1. State the question and establish a null hypotheses ùêª0. 2. Set the statistical significance level a and a statistical power (1 ‚Äî ¬£). 3. Obtain samples through experiments. The number of samples needed will depend on the statistical power, and the expected effect size. 4. Calculate the test statistic and the ùëù-value. Statistics
ùëù-value
> T(x)). Mathematics for Deep Learning
1016

5. Make the decision to keep or reject the null hypothesis based on the ùëù-value and the
statistical significance level ùõº. To conduct a hypothesis test, we start by defining a null hypothesis and a level of risk that we are willing to take. Then we calculate the test statistic of the sample, taking an extreme value of the test statistic as evidence against the null hypothesis. If the test statistic falls within the reject region, we may reject the null hypothesis in favor of the alternative. Hypothesis testing is applicable in a variety of scenarios such as the clinical trails and A/B testing. A.10.3 Constructing Confidence Intervals
When estimating the value of a parameter ùúÉ, point estimators like ÀÜùúÉ are of limited utility
since they contain no notion of uncertainty. Rather, it would be far better if we could produce an interval that would contain the true parameter ùúÉ with high probability. If you were interested in such ideas a century ago, then you would have been excited to read ‚ÄúOutlineofaTheoryofStatisticalEstimationBasedontheClassicalTheoryofProbability‚Äù by Jerzy Neyman (Neyman, 1937), who first introduced the concept of confidence interval in 1937. To be useful, a confidence interval should be as small as possible for a given degree of certainty. Let‚Äôs see how to derive it. Mathematically, a confidence interval for the true parameter ùúÉ is an interval ùê∂ùëõ that com-
puted from the sample data such that
Po(Cy > 0) = 1-a,VO. (A.8)
Here a ‚Ç¨ (0, 1), and | ‚Äîa@ is called the confidence level or coverage of the interval. This is
the same ùõº as the significance level as we discussed about above. Note that (A.8) is about variable ùê∂ùëõ, not about the fixed ùúÉ. To emphasize this, we write
ùëÉùúÉ‚Äûùê∂ùëõ 3 ùúÉ‚Äù rather than ùëÉùúÉ‚ÄûùúÉ 2 ùê∂ùëõ‚Äù. Interpretation
It is very tempting to interpret a 95% confidence interval as an interval where you can be 95% sure the true parameter lies, however this is sadly not true. The true parameter is fixed, and it is the interval that is random. Thus a better interpretation would be to say that if you generated a large number of confidence intervals by this procedure, 95% of the generated intervals would contain the true parameter. Thismayseempedantic, butitcanhaverealimplicationsfortheinterpretationoftheresults. In particular, we may satisfy (A.8) by constructing intervals that we are almost certain do not contain the true value, as long as we only do so rarely enough. We close this section by
Definition
1017

providing three tempting but false statements. An in-depth discussion of these points can be found in Morey et al. (2016).bubue Fallacy 1. Narrow confidence intervals mean we can estimate the parameter precisely. e Fallacy 2. The values inside the confidence interval are more likely to be the true value
than those outside the interval. e Fallacy 3. The probability that a particular observed 95% confidence interval contains
the true value is 95%. Sufficed to say, confidence intervals are subtle objects. However, if you keep the interpre- tation clear, they can be powerful tools. A Gaussian Example
Let‚Äôs discuss the most classical example, the confidence interval for the mean of a Gaussian of unknown mean and variance. Suppose we collect ùëõ samples fùë•ùëñgùëõ N‚Äûùúá, ùúé2‚Äù. We can compute estimators for the mean and variance by taking ùëñ=1 from our Gaussian
fin= 7 DX and & = ‚Äî‚Äî Dye a (A.9) i= i=
If we now consider the random variable
fin = T= > A.10 Gu] (A210)
we obtain a random variable following a well-known distribution called the Student‚Äôs t- distribution on n ‚Äî | degrees of freedom. This distribution is very well studied, and it is known, for instance, that as ùëõ ! 1, it is
This distribution is very well studied, and it is known, for instance, that as n ‚Äî on, it is approximately a standard Gaussian, and thus by looking up values of the Gaussian c.d.f. in a table, we may conclude that the value of T is in the interval [‚Äî1.96, 1.96] at least 95% of the time. For finite values of n, the interval needs to be somewhat larger, but are well known and precomputed in tables. Thus, we may conclude that for large ùëõ,
fin = H p(fene ‚Ç¨ [-1.96, 1.961} > 0.95. (A.11)
Rearranging this by multiplying both sides by &,,/-Vn
Rearranging this by multiplying both sides by &,,/-Vn and then adding fi, we obtain
Gn on Pipe | fin ‚Äî 1.96‚Äî, fin + 1.96 ‚Äî (¬´ |e¬ª van Vi > 0.95. (A.12)
Thus we know that we have found our 95% confidence interval:
on on fin ‚Äî 1.96, fin + 1.96] . A.13 E Valin ‚Äú| (A.18)
It is safe to say that (A.13) is one of the most used formula in statistics. Let‚Äôs close our
Statistics
fin =
p
ùëõ and then adding ÀÜùúáùëõ, we obtain
Mathematics for Deep Learning
1018

discussion of statistics by implementing it. For simplicity, we assume we are in the asymp- totic regime. Small values of ùëÅ should include the correct value of t_star obtained either programmatically or from a ùë°-table. # PyTorch uses Bessel's correction by default, which means the use of ddof=1 # instead of default ddof=0 in numpy. We can use unbiased=False to imitate # ddof=0. # Number of samples N = 1000 # Sample dataset samples = torch.normal(0, 1, size=(N,)) # Lookup Students's t-distribution c.d.f. t_star = 1.96 # Construct interval mu_hat = torch.mean(samples) sigma_hat = samples.std(unbiased=True) (mu_hat - t_star*sigma_hat/torch.sqrt(torch.tensor(N, dtype=torch.float32)),\ mu_hat + t_star*sigma_hat/torch.sqrt(torch.tensor(N, dtype=torch.float32)))
(tensor(-0.0568), tensor(0.0704))
A.10.4 Summary
Statistics focuses on inference problems, whereas deep learning emphasizes on making
accurate predictions without explicitly programming and understanding. There are three common statistics inference methods: evaluating and comparing estima-
tors, conducting hypothesis tests, and constructing confidence intervals.bubuThere are three most common estimators: statistical bias, standard deviation, and mean
square error. A confidence interval is an estimated range of a true population parameter that we can
construct by given the samples. e Hypothesis testing is a way of evaluating some evidence against the default statement
about a population. A.10.5 Exercises
‚Äú!bubuUnif(O, 6), where ‚Äúiid‚Äù stands for independent and identically
1. Let ùëã1, ùëã2, .bubu. ., ùëãùëõ
distributed. Consider the following estimators of ùúÉ:
ÀÜùúÉ = maxfùëã1, ùëã2, . . ., ùëãùëõg; (A.14)
ÀúùúÉ = 2 ¬Øùëãùëõ = 2 ùëõ ùëñ=1 ùëãùëñ. (A.15)
Information Theory
1019

e Find the statistical bias, standard deviation, and mean square error of 6. e Find the statistical bias, standard deviation, and mean square error of 6. e Which estimator is better?bubu2. For our chemist example in introduction, can you derive the 5 steps to conduct a two- sided hypothesis testing? Given the statistical significance level a = 0.05 and the sta- tistical power 1 ‚Äî B = 0.8.bubu3. Run the confidence interval code with ùëÅ = 2 and ùõº = 0.5 for 100 independently gener-
ated dataset, and plot the resulting intervals (in this case t_star = 1.0). You will see several very short intervals which are very far from containing the true mean 0. Does this contradict the interpretation of the confidence interval? Do you feel comfortable using short intervals to indicate high precision estimates? Discussions289. 289

A.11 Information Theory
a
The universe is overflowing with information. Information provides a common language acrossdisciplinaryrifts: fromShakespeare‚ÄôsSonnettoresearchers‚ÄôpaperonCornellArXiv, from Van Gogh‚Äôs printing Starry Night to Beethoven‚Äôs music Symphony No. 5, from the first programming language Plankalk√ºl to the state-of-the-art machine learning algorithms. Everything must follow the rules of information theory, no matter the format. With infor- mation theory, we can measure and compare how much information is present in different signals. In this section, we will investigate the fundamental concepts of information theory and applications of information theory in machine learning. Before we get started, let‚Äôs outline the relationship between machine learning and informa- tiontheory. Machinelearningaimstoextractinterestingsignalsfromdataandmakecritical predictions. On the other hand, information theory studies encoding, decoding, transmit- ting, and manipulating information. As a result, information theory provides fundamental language for discussing the information processing in machine learned systems. For exam- ple, many machine learning applications use the cross-entropy loss as described in Section 4.1. This loss can be directly derived from information theoretic considerations. A.11.1 Information
Let‚Äôs start with the ‚Äúsoul‚Äù of information theory: information. Information can be encoded in anything with a particular sequence of one or more encoding formats. Suppose that we task ourselves with trying to define a notion of information. What could be our starting point? Consider the following thought experiment. We have a friend with a deck of cards. They
Mathematics for Deep Learning
1020

will shuffle the deck, flip over some cards, and tell us statements about the cards. We will try to assess the information content of each statement. First, they flip over a card and tell us, ‚ÄúI see a card.‚Äù This provides us with no information at all. We were already certain that this was the case so we hope the information should be zero. Next, they flip over a card and say, ‚ÄúI see a heart.‚Äù This provides us some information, but in reality there are only 4 different suits that were possible, each equally likely, so we are not surprised by this outcome. We hope that whatever the measure of information, this event should have low information content. Next, they flip over a card and say, ‚ÄúThis is the 3 of spades.‚Äù This is more information. Indeed there were 52 equally likely possible outcomes, and our friend told us which one it was. This should be a medium amount of information. Let‚Äôs take this to the logical extreme. Suppose that finally they flip over every card from the deck and read off the entire sequence of the shuffled deck. There are 52! different orders to the deck, again all equally likely, so we need a lot of information to know which one it is. Any notion of information we develop must conform to this intuition. Indeed, in the next sections we will learn how to compute that these events have 0 bits, 2 bits, 5.7 bits, and 225.6 bits of information respectively. If we read through these thought experiments, we see a natural idea. As a starting point, rather than caring about the knowledge, we may build off the idea that information repre- sents the degree of surprise or the abstract possibility of the event. For example, if we want to describe an unusual event, we need a lot information. For a common event, we may not need much information. In 1948, Claude E. Shannon published A Mathematical Theory of Communication (Shan- non, 1948) establishing the theory of information. In his article, Shannon introduced the concept of information entropy for the first time. We will begin our journey here. Self-information
Since information embodies the abstract possibility of an event, how do we map the pos- sibility to the number of bits? Shannon introduced the terminology bit as the unit of in- formation, which was originally created by John Tukey. So what is a ‚Äúbit‚Äù and why do we use it to measure information? Historically, an antique transmitter can only send or receive two types of code: 0 and 1. Indeed, binary encoding is still in common use on all modern digital computers. In this way, any information is encoded by a series of 0 and 1. And hence, a series of binary digits of length ùëõ contains ùëõ bits of information. Now, suppose that for any series of codes, each 0 or 1 occurs with a probability of 1
Hence, an event ùëã with a series of codes of length ùëõ, occurs with a probability of 1 the same time, as we mentioned before, this series contains ùëõ bits of information. So, can 2. 2ùëõ. At
Information Theory
1021

we generalize to a mathematical function which can transfer the probability ùëù to the number
of bits? Shannon gave the answer by defining self-information
1(X) = ‚Äîlog,(p),
(A.1)
as the bits of information we have received for this event ùëã. Note that we will always use
base-2 logarithms in this section. For the sake of simplicity, the rest of this section will omit the subscript 2 in the logarithm notation, i.e., log‚Äû.‚Äù always refers to log2 ‚Äû.‚Äù. For example, the code ‚Äú0010‚Äù has a self-information
1(¬∞0010‚Äù) = ‚Äî log(p(0010‚Äù)) = ‚Äî log (;:) = 4 bits. (A.2)
We can calculate self information as shown below. Before that, let‚Äôs first import all the necessary packages in this section. import torch from torch.nn import NLLLoss def nansum(x): # Define nansum, as pytorch does not offer it inbuilt. return x[~torch.isnan(x)].sum() def self_information(p): return -torch.log2(torch.tensor(p)).item() self_information(1 / 64)
6.0
A.11.2 Entropy
As self-information only measures the information of a single discrete event, we need a more generalized measure for any random variable of either discrete or continuous distri- bution. Motivating Entropy
Let‚Äôs try to get specific about what we want. This will be an informal statement of what are known as the axioms of Shannon entropy. It will turn out that the following collection of common-sense statements force us to a unique definition of information. A formal version of these axioms, along with several others may be found in Csisz√°r (2008). 1. The information we gain by observing a random variable does not depend on what we call the elements, or the presence of additional elements which have probability zero. 2. The information we gain by observing two random variables is no more than the sum of the information we gain by observing them separately. If they are independent, then it is exactly the sum. ‚Äûùëù‚Äù,
Mathematics for Deep Learning
1022

3. The information gained when observing (nearly) certain events is (nearly) zero. While proving this fact is beyond the scope of our text, it is important to know that this uniquely determines the form that entropy must take. The only ambiguity that these allow is in the choice of fundamental units, which is most often normalized by making the choice we saw before that the information provided by a single fair coin flip is one bit. For any random variable ùëã that follows a probability distribution ùëÉ with a probability den-
sity function (p.d.f.) or a probability mass function (p.m.f.) ùëù‚Äûùë•‚Äù, we measure the expected amount of information through entropy (or Shannon entropy)
H(X) =-Ex.pllog p(x). (A)
To be specific, if ùëã is discrete,
H(X) =-) pi log p;, where p; = P(X;). (A.4) 7
Otherwise, if ùëã is continuous, we also refer entropy as differential entropy
H(X) = - [ pe) log p(x) dx. (A.5) x
We can define entropy as below. def entropy(p): entropy = - p * torch.log2(p) # Operator `nansum` will sum up the non-nan number out = nansum(entropy) return out
entropy(torch.tensor([0.1, 0.5, 0.1, 0.3]))
tensor(1.6855)
Interpretations
You may be curious: in the entropy definition (A.3), why do we use an expectation of a negative logarithm? Here are some intuitions. First, why do we use a logarithm function log? Suppose that ùëù‚Äûùë•‚Äù = ùëì1‚Äûùë•‚Äù ùëì2‚Äûùë•‚Äù .bubu. ., ùëìùëõ‚Äûùë•‚Äù,
where each component function ùëìùëñ‚Äûùë•‚Äù is independent from each other. This means that each ùëìùëñ‚Äûùë•‚Äù contributes independently to the total information obtained from ùëù‚Äûùë•‚Äù. As discussed above, we want the entropy formula to be additive over independent random variables. Luckily, log can naturally turn a product of probability distributions to a summation of the individual terms. Next, why do we use a negative log? Intuitively, more frequent events should contain less
Definition
‚Äû
Information Theory
1023

information than less common events, since we often gain more information from an un- usual case than from an ordinary one. However, log is monotonically increasing with the probabilities, and indeed negative for all values in ¬ª0,1‚Ä¶. We need to construct a monoton- ically decreasing relationship between the probability of events and their entropy, which will ideally be always positive (for nothing we observe should force us to forget what we have known). Hence, we add a negative sign in front of log function. Last, where does the expectation function come from? Consider a random variable ùëã. We
Last, where does the expectation function come from? Consider a random variable X. We can interpret the self-information (‚Äî log(p)) as the amount of surprise we have at seeing a particular outcome. Indeed, as the probability approaches zero, the surprise becomes infinite. Similarly, we can interpret the entropy as the average amount of surprise from observing X. For example, imagine that a slot machine system emits statistical indepen- dently symbols s;,...,5, with probabilities p;,..., px% respectively. Then the entropy of this system equals to the average self-information from observing each output, i.e.,
H(S) = >" pi: Msi) = ‚Äî D1 pi tog pi- (A.6) 7 7
Properties of Entropy
By the above examples and interpretations, we can derive the following properties of en- tropy (A.3). Here, we refer to ùëã as an event and ùëÉ as the probability distribution of ùëã. e H(X) = 0 for all discrete X (entropy can be negative for continuous X). e If X ~ Pwithap.df.bubuorap.m.f. p(x), and we try to estimate P by a new probability
distribution ùëÑ with a p.d.f. or a p.m.f. ùëû‚Äûùë•‚Äù, then
H(X) =-E,~p[log p(x)] < ‚ÄîEx~p[log q(x)], with equality if and only if P = Q. (A.7)
Alternatively, ùêª‚Äûùëã‚Äù gives a lower bound of the average number of bits needed to
encode symbols drawn from ùëÉ. e If X ~ P, then x conveys the maximum amount of information if it spreads evenly among
all possible outcomes. Specifically, if the probability distribution ùëÉ is discrete with ùëò-class fùëù1, . . ., ùëùùëòg, then
H(X) < log(k), with equality if and only if p; = Yi (A.8)
If ùëÉ is a continuous random variable, then the story becomes much more complicated. However, if we additionally impose that ùëÉ is supported on a finite interval (with all values between 0 and 1), then ùëÉ has the highest entropy if it is the uniform distribution on that interval. A.11.3 Mutual Information
Previously we defined entropy of a single random variable ùëã, how about the entropy of a
pair random variables ‚Äûùëã,ùëå‚Äù? We can think of these techniques as trying to answer the
1
Mathematics for Deep Learning
1024

following type of question, ‚ÄúWhat information is contained in ùëã and ùëå together compared
to each separately? Is there redundant information, or is it all unique?‚Äù
Forthefollowingdiscussion, wealwaysuse ‚Äûùëã,ùëå‚Äù asapairofrandomvariablesthatfollows
a joint probability distribution ùëÉ with a p.d.f. or a p.m.f. ùëùùëã,ùëå‚Äûùë•, ùë¶‚Äù, while ùëã andùëå follow probability distribution ùëùùëã‚Äûùë•‚Äù and ùëùùëå‚Äûùë¶‚Äù, respectively. Joint Entropy
Similar to entropy of a single random variable (A.3), we define the joint entropy ùêª‚Äûùëã,ùëå‚Äù
of a pair random variables ‚Äûùëã,ùëå‚Äù as
(X,Y) = ‚ÄîE(x,y)~p [log px,y(x, y)]. (A.9)
Precisely, on the one hand, if ‚Äûùëã,ùëå‚Äù is a pair of discrete random variables, then
A(X,Y) = - >) Yi px y) log px,y (x, y). (A.10) x y
On the other hand, if ‚Äûùëã,ùëå‚Äù is a pair of continuous random variables, then we define the
differential joint entropy as
‚Äû
H(X,Y) =‚Äî [ px. y) log py.y(a.y) de dy. (A.11) x,y
We can think of (A.9) as telling us the total randomness in the pair of random variables. As a pair of extremes, if ùëã = ùëå are two identical random variables, then the information in the pair is exactly the information in one and we have ùêª‚Äûùëã,ùëå‚Äù = ùêª‚Äûùëã‚Äù = ùêª‚Äûùëå‚Äù. On the other extreme, if ùëã and ùëå are independent then ùêª‚Äûùëã,ùëå‚Äù = ùêª‚Äûùëã‚Äù ‚Äö ùêª‚Äûùëå‚Äù. Indeed we will always have that the information contained in a pair of random variables is no smaller than the entropy of either random variable and no more than the sum of both. H(X), H(Y) < H(X,Y) < H(X)+H(Y). (A.12)
Let‚Äôs implement joint entropy from scratch. def joint_entropy(p_xy): joint_ent = -p_xy * torch.log2(p_xy) # Operator `nansum` will sum up the non-nan number out = nansum(joint_ent) return out joint_entropy(torch.tensor([[0.1, 0.5], [0.1, 0.3]]))
tensor(1.6855)
Notice that this is the same code as before, but now we interpret it differently as working on the joint distribution of the two random variables. Information Theory
1025

Conditional Entropy
The joint entropy defined above the amount of information contained in a pair of random variables. This is useful, but oftentimes it is not what we care about.bubuConsider the setting of machine learning. Let‚Äôs take ùëã to be the random variable (or vector of random variables) that describes the pixel values of an image, and ùëå to be the random variable which is the class label. ùëã should contain substantial information‚Äîa natural image is a complex thing. However, the information contained in ùëå once the image has been show should be low. Indeed, the image of a digit should already contain the information about what digit it is unless the digit is illegible. Thus, to continue to extend our vocabulary of information theory, we need to be able to reason about the information content in a random variable conditional on another. In the probability theory, we saw the definition of the conditional probability to measure the relationship between variables. We now want to analogously define the conditional entropy ùêª‚Äûùëå j ùëã‚Äù. We can write this as
AY | X) = -E(x,y)~p [log p(y | x), (A.13)
ùëùùëã,ùëå ‚Äûùë•,ùë¶‚Äù
where ùëù‚Äûùë¶ j ùë•‚Äù = ùëùùëã‚Äûùë•‚Äù is the conditional probability. Specifically, if ‚Äûùëã,ùëå‚Äù is a pair of discrete random variables, then
A(Y |X) =- )" )* p(x, y) log pO | x). (A) x oy
If ‚Äûùëã,ùëå‚Äù is a pair of continuous random variables, then the differential conditional entropy
is similarly defined as
‚Äû
ny |x) == ff pony) loge |) de ay. (A.15) y
It is now natural to ask, how does the conditional entropy ùêª‚Äûùëå j ùëã‚Äù relate to the entropy
ùêª‚Äûùëã‚Äù and the joint entropy ùêª‚Äûùëã,ùëå‚Äù? Using the definitions above, we can express this cleanly:
H(Y | X) = H(X,Y) - H(X). (A.16)
This has an intuitive interpretation: the information in ùëå given ùëã (ùêª‚Äûùëå j ùëã‚Äù) is the same
as the information in both ùëã and ùëå together (ùêª‚Äûùëã,ùëå‚Äù) minus the information already con- tained in ùëã. This gives us the information in ùëå which is not also represented in ùëã. Now, let‚Äôs implement conditional entropy (A.13) from scratch. def conditional_entropy(p_xy, p_x): p_y_given_x = p_xy/p_x cond_ent = -p_xy * torch.log2(p_y_given_x) # Operator `nansum` will sum up the non-nan number out = nansum(cond_ent) return out
conditional_entropy(torch.tensor([[0.1, 0.5], [0.2, 0.3]]), torch.tensor([0.2, 0.8]))
‚Äû
Mathematics for Deep Learning
1026

tensor(0.8635)
Mutual Information
Given the previous setting of random variables ‚Äûùëã,ùëå‚Äù, you may wonder: ‚ÄúNow that we
know how much information is contained inùëå but not in ùëã, can we similarly ask how much information is shared between ùëã and ùëå?‚Äù The answer will be the mutual information of ‚Äûùëã,ùëå‚Äù, which we will write as ùêº‚Äûùëã,ùëå‚Äù. Rather than diving straight into the formal definition, let‚Äôs practice our intuition by first trying to derive an expression for the mutual information entirely based on terms we have constructed before. We wish to find the information shared between two random variables. One way we could try to do this is to start with all the information contained in both ùëã and ùëå together, and then we take off the parts that are not shared. The information contained in both ùëã andùëå together is written as ùêª‚Äûùëã,ùëå‚Äù. We want to subtract from this the information contained in ùëã but not inùëå, and the information contained inùëå but not in ùëã. As we saw in the previous section, this is given by ùêª‚Äûùëã j ùëå‚Äù and ùêª‚Äûùëå j ùëã‚Äù respectively. Thus, we have that the mutual information should be
1(X,Y) = H(X,Y)- H(Y | X)- H(X|Y). (A.17)
Indeed, this is a valid definition for the mutual information. If we expand out the definitions of these terms and combine them, a little algebra shows that this is the same as
ùëùùëã,ùëå‚Äûùë•, ùë¶‚Äù ùêº‚Äûùëã,ùëå‚Äù = ùê∏ùë•ùê∏ùë¶ ùëùùëã,ùëå‚Äûùë•, ùë¶‚Äù log . ùëùùëã‚Äûùë•‚Äùùëùùëå‚Äûùë¶‚Äù (A.18)
We can summarize all of these relationships in image Fig. A.1. It is an excellent test of intuition to see why the following statements are all also equivalent to ùêº‚Äûùëã,ùëå‚Äù. e H(X)- H(X |Y)
e H(Y)-H(Y|X)
e H(X)+H(Y) - (X,Y)
Eaopy yp 2) Conditional Entropy HYIX) Joint Entropy H(X, ¬•)
tFig. A.1
Mutual information‚Äôs relationship with joint entropy and conditional entropy. In many ways we can think of the mutual information (A.18) as principled extension of correlation coefficient we saw in Section A.6. This allows us to ask not only for linear
Information Theory
1027

relationships between variables, but for the maximum information shared between the two random variables of any kind. Now, let‚Äôs implement mutual information from scratch. def mutual_information(p_xy, p_x, p_y): p = p_xy / (p_x * p_y) mutual = p_xy * torch.log2(p) # Operator `nansum` will sum up the non-nan number out = nansum(mutual) return out mutual_information(torch.tensor([[0.1, 0.5], [0.1, 0.3]]), torch.tensor([0.2, 0.8]), torch.tensor([[0.75, 0.25]]))
tensor(0.7195)
Properties of Mutual Information
Rather than memorizing the definition of mutual information (A.18), you only need to keep in mind its notable properties:
e Mutual information is symmetric, i.e., /(X,Y) = 1(Y, X). e Mutual information is non-negative, i.e., /(X,Y) >= 0. e 1(X,Y) = Oif and only if X and Y are independent. For example, if X and Y are in-
dependent, then knowing ùëå does not give any information about ùëã and vice versa, so their mutual information is zero. e Alternatively, if X is an invertible function of Y, then Y and X share all information and
ùêº‚Äûùëã,ùëå‚Äù = ùêª‚Äûùëå‚Äù = ùêª‚Äûùëã‚Äù. (A.19)
Pointwise Mutual Information
When we worked with entropy at the beginning of this chapter, we were able to provide an interpretation of ‚Äî log(px(x)) as how surprised we were with the particular outcome. We may give a similar interpretation to the logarithmic term in the mutual information, which is often referred to as the pointwise mutual information:
pmi‚Äûùë•, ùë¶‚Äù = log ùëùùëã‚Äûùë•‚Äùùëùùëå‚Äûùë¶‚Äù . (A.20)
We can think of (A.20) as measuring how much more or less likely the specific combina- tion of outcomes ùë• and ùë¶ are compared to what we would expect for independent random outcomes. If it is large and positive, then these two specific outcomes occur much more fre- quentlythantheywouldcomparedtorandomchance(note: thedenominatoris ùëùùëã‚Äûùë•‚Äùùëùùëå‚Äûùë¶‚Äù which is the probability of the two outcomes were independent), whereas if it is large and
ùëùùëã,ùëå‚Äûùë•, ùë¶‚Äù
Mathematics for Deep Learning
1028

negative it represents the two outcomes happening far less than we would expect by random chance. This allows us to interpret the mutual information (A.18) as the average amount that we were surprised to see two outcomes occurring together compared to what we would expect if they were independent. Applications of Mutual Information
Mutual information may be a little abstract in it pure definition, so how does it related to machine learning? In natural language processing, one of the most difficult problems is the ambiguity resolution, or the issue of the meaning of a word being unclear from context. For example, recently a headline in the news reported that ‚ÄúAmazon is on fire‚Äù. You may wonder whether the company Amazon has a building on fire, or the Amazon rain forest is on fire. In this case, mutual information can help us resolve this ambiguity. We first find the group of words that each has a relatively large mutual information with the company Amazon, such as e-commerce, technology, and online. Second, we find another group of words that each has a relatively large mutual information with the Amazon rain forest, such as rain, forest, and tropical. When we need to disambiguate ‚ÄúAmazon‚Äù, we can compare which group has more occurrence in the context of the word Amazon. In this case the article would go on to describe the forest, and make the context clear. A.11.4 Kullback‚ÄìLeibler Divergence
As what we have discussed in Section 2.3, we can use norms to measure distance between two points in space of any dimensionality. We would like to be able to do a similar task withprobabilitydistributions. Therearemanywaystogoaboutthis, butinformationtheory provides one of the nicest. We now explore the Kullback‚ÄìLeibler (KL) divergence, which provides a way to measure if two distributions are close together or not. Given a random variable ùëã that follows the probability distribution ùëÉ with a p.d.f.bubuor a
p.m.f. ùëù‚Äûùë•‚Äù, and we estimate ùëÉ by another probability distribution ùëÑ with a p.d.f. or a p.m.f.bubuùëû‚Äûùë•‚Äù. Then the Kullback‚ÄìLeibler (KL) divergence (or relative entropy) between ùëÉ and ùëÑ is
Dx (PIIQ) = Exp [ee faa ; (A.21) q(x)
As with the pointwise mutual information (A.20), we can again provide an interpretation of the logarithmic term: ‚Äî log aM = ‚Äîlog(q(x)) ‚Äî (‚Äîlog(p(x))) will be large and positive if we see x far more often under P than we would expect for Q, and large and negative if we see the outcome far less than expected. In this way, we can interpret it as our relative surprise at observing the outcome compared to how surprised we would be observing it from our reference distribution. Definition
Information Theory
1029

Let‚Äôs implement the KL divergence from Scratch. def kl_divergence(p, q): kl = p * torch.log2(p / q) out = nansum(kl) return out.abs().item()
KL Divergence Properties
Let‚Äôs take a look at some properties of the KL divergence (A.21). KL divergence is non-symmetric, i.e., there are P, Q such that
ùê∑KL‚ÄûùëÉkùëÑ‚Äù ‚â† ùê∑KL‚ÄûùëÑkùëÉ‚Äù. (A.22)
KL divergence is non-negative, i.e.,
Note that the equality holds only when ùëÉ = ùëÑ. If there exists an x such that p(x) > 0 and g(x) = 0, then Dx, (P||Q) = o0. There is a close relationship between KL divergence and mutual information. Besides
the relationship shown in Fig. A.1, ùêº‚Äûùëã,ùëå‚Äù is also numerically equivalent with the following terms:
1. ùê∑KL‚ÄûùëÉ‚Äûùëã,ùëå‚Äù k ùëÉ‚Äûùëã‚ÄùùëÉ‚Äûùëå‚Äù‚Äù;
2. ùê∏ùëåfùê∑KL‚ÄûùëÉ‚Äûùëã j ùëå‚Äù k ùëÉ‚Äûùëã‚Äù‚Äùg;
3.bubuùê∏ùëãfùê∑KL‚ÄûùëÉ‚Äûùëå j ùëã‚Äù k ùëÉ‚Äûùëå‚Äù‚Äùg. For the first term, we interpret mutual information as the KL divergence between ùëÉ‚Äûùëã,ùëå‚Äù and the product of ùëÉ‚Äûùëã‚Äù and ùëÉ‚Äûùëå‚Äù, and thus is a measure of how differ- ent the joint distribution is from the distribution if they were independent. For the second term, mutual information tells us the average reduction in uncertainty aboutùëå that results from learning the value of the ùëã‚Äôs distribution. Similarly to the third term.bubuLet‚Äôs go through a toy example to see the non-symmetry explicitly. First, let‚Äôs generate and sort three tensors of length 10,000: an objective tensor ùëù which
First, let‚Äôs generate and sort three tensors of length 10,000: an objective tensor p which follows a normal distribution N(0, 1), and two candidate tensors q; and q2 which follow normal distributions N(‚Äî1, 1) and N(1, 1) respectively. Dy (PIlQ) = 0. (A.23)
Example
Mathematics for Deep Learning
1030

torch.manual_seed(1) tensor_len = 10000 p = torch.normal(0, 1, (tensor_len, )) q1 = torch.normal(-1, 1, (tensor_len, )) q2 = torch.normal(1, 1, (tensor_len, )) p = torch.sort(p)[0] q1 = torch.sort(q1)[0] q2 = torch.sort(q2)[0]
Since ùëû1 and ùëû2 are symmetric with respect to the y-axis (i.e., ùë• = 0), we expect a similar
value of KL divergence between ùê∑KL‚Äûùëùkùëû1‚Äù and ùê∑KL‚Äûùëùkùëû2‚Äù. As you can see below, there is only a less than 3% off between ùê∑KL‚Äûùëùkùëû1‚Äù and ùê∑KL‚Äûùëùkùëû2‚Äù. kl_pq1 = kl_divergence(p, q1) kl_pq2 = kl_divergence(p, q2) similar_percentage = abs(kl_pq1 - kl_pq2) / ((kl_pq1 + kl_pq2) / 2) * 100 kl_pq1, kl_pq2, similar_percentage
kl_pq1, kl_pq2, similar_percentage
(8582.0341796875, 8828.3095703125, 2.8290698237936858)
In contrast, you may find that ùê∑KL‚Äûùëû2kùëù‚Äù and ùê∑KL‚Äûùëùkùëû2‚Äù are off a lot, with around 40%
off as shown below. kl_q2p = kl_divergence(q2, p) differ_percentage = abs(kl_q2p - kl_pq2) / ((kl_q2p + kl_pq2) / 2) * 100 kl_q2p, differ_percentage
(14130.125, 46.18621024399691)
A.11.5 Cross-Entropy
If you are curious about applications of information theory in deep learning, here is a quick example. We define the true distribution ùëÉ with probability distribution ùëù‚Äûùë•‚Äù, and the estimated distribution ùëÑ with probability distribution ùëû‚Äûùë•‚Äù, and we will use them in the rest of this section. Say we need to solve a binary classification problem based on given ùëõ data examples
{ùë•1, . .bubu.,ùë•ùëõ}. Assume that we encode 1 and 0 as the positive and negative class label ùë¶ùëñ respectively, and our neural network is parametrized by ùúÉ. If we aim to find a best ùúÉ so that ÀÜùë¶ùëñ = ùëùùúÉ‚Äûùë¶ùëñ j ùë•ùëñ‚Äù, it is natural to apply the maximum log-likelihood approach as was seen in Section A.7. To be specific, for true labels ùë¶ùëñ and predictions ÀÜùë¶ùëñ = ùëùùúÉ‚Äûùë¶ùëñ j ùë•ùëñ‚Äù, the probability to be classified as positive is ùúãùëñ = ùëùùúÉ‚Äûùë¶ùëñ = 1 j ùë•ùëñ‚Äù. Hence, the log-likelihood
Information Theory
1031

function would be
ùëô‚ÄûùúÉ‚Äù = log ùêø‚ÄûùúÉ‚Äù
= lo! iC] ‚Äî n,)!-¬• [|x (hom) (A.24) =) yilog(a;) + (1 = yy) log(1 - 73). i=l
Maximizing the log-likelihood function /(@) is identical to minimizing ‚Äî/(@), and hence
Maximizing the log-likelihood function /(@) is identical to minimizing ‚Äî/(@), and hence we can find the best @ from here. To generalize the above loss to any distributions, we also called ‚Äî/(@) the cross-entropy loss CE(y, $), where y follows the true distribution P and follows the estimated distribution Q. This was all derived by working from the maximum likelihood point of view. However, if we look closely we can see that terms like log‚Äûùúãùëñ‚Äù have entered into our computation which is a solid indication that we can understand the expression from an information theoretic point of view. Formal Definition
Like KL divergence, for a random variable ùëã, we can also measure the divergence between
the estimating distribution ùëÑ and the true distribution ùëÉ via cross-entropy,
CE(P, Q) = -Ex-p[log(q(x))]- (A.25)
By using properties of entropy discussed above, we can also interpret it as the summation of the entropy ùêª‚ÄûùëÉ‚Äù and the KL divergence between ùëÉ and ùëÑ, i.e.,
CE‚ÄûùëÉ,ùëÑ‚Äù = ùêª‚ÄûùëÉ‚Äù ‚Äö ùê∑KL‚ÄûùëÉkùëÑ‚Äù. (A.26)
We can implement the cross-entropy loss as below. def cross_entropy(y_hat, y): ce = -torch.log(y_hat[range(len(y_hat)), y]) return ce.mean()
Now define two tensors for the labels and predictions, and calculate the cross-entropy loss of them. labels = torch.tensor([0, 2]) preds = torch.tensor([[0.3, 0.6, 0.1], [0.2, 0.3, 0.5]]) cross_entropy(preds, labels)
tensor(0.9486)
Mathematics for Deep Learning
1032

Asalludedinthebeginningofthissection, cross-entropy(A.25)canbeusedtodefinealoss function in the optimization problem. It turns out that the following are equivalent:
1.bubuMaximizing predictive probability of Q for distribution P, (i.e., Ex~p [log(q(x))]);
2. Minimizing cross-entropy CE‚ÄûùëÉ,ùëÑ‚Äù;
3. Minimizing the KL divergence ùê∑KL‚ÄûùëÉkùëÑ‚Äù. The definition of cross-entropy indirectly proves the equivalent relationship between ob- jective 2 and objective 3, as long as the entropy of true data ùêª‚ÄûùëÉ‚Äù is constant. Cross-Entropy as An Objective Function of Multi-class Classification
If we dive deep into the classification objective function with cross-entropy loss CE, we will find minimizing CE is equivalent to maximizing the log-likelihood function ùêø. To begin with, suppose that we are given a dataset with ùëõ examples, and it can be classified
into ùëò-classes.bubuFor each data example ùëñ, we represent any ùëò-class label yùëñ = ‚Äûùë¶ùëñ1, . . ., ùë¶ùëñùëò‚Äù by one-hot encoding. To be specific, if the example ùëñ belongs to class ùëó, then we set the ùëó-th entry to 1, and all other components to 0, i.e.,
ùë¶ùëñùëó = 1 0 ùëó 2 ùêΩ; otherwise. (A.27)
For instance, if a multi-class classification problem contains three classes ùê¥, ùêµ, and ùê∂, then
the labels yùëñ can be encoded in {ùê¥ : ‚Äû1,0,0‚Äù; ùêµ : ‚Äû0,1,0‚Äù;ùê∂ : ‚Äû0,0,1‚Äù}. Assume that our neural network is parametrized by ùúÉ. For true label vectors yùëñ and predic- tions
ÀÜyùëñ = ùëùùúÉ‚Äûyùëñ j xùëñ‚Äù = ùë¶ùëñùëóùëùùúÉ‚Äûùë¶ùëñùëó j xùëñ‚Äù. ùëó=1 (A.28)
Hence, the cross-entropy loss would be
n nek CE(y, $) = - )" yilog yi =- >") viz log palviy | xi). (A.29) i=l i=l j=l
On the other side, we can also approach the problem through maximum likelihood es- timation. To begin with, let‚Äôs quickly introduce a ùëò-class multinoulli distribution. It is an extension of the Bernoulli distribution from binary class to multi-class. If a random variable z = ‚Äûùëß1, . . ., ùëßùëò‚Äù follows a ùëò-class multinoulli distribution with probabilities p = (ùëù1, . .bubu., ùëùùëò), i.e.,
ùëù‚Äûz‚Äù = ùëù‚Äûùëß1, . . ., ùëßùëò‚Äù = Multi‚Äûùëù1, .bubu. ., ùëùùëò‚Äù, where ùëùùëñ = 1, ùëñ=1 (A.30)
Properties
(
k
k
Information Theory
1033

then the joint probability mass function(p.m.f.) of z is
pz = ùëùùëßùëó ùëó . (A.31) ùëó=1
It can be seen that the label of each data example, yùëñ, is following a ùëò-class multinoulli
distribution with probabilities ùùÖ = (ùúã1, . .bubu., ùúãùëò). Therefore, the joint p.m.f. of each data Àõùëò ùúãùë¶ùëñùëó . Hence, the log-likelihood function would be example yùëñ is √üyùëñ = ùëó
ùëó=1
n
ùëô‚ÄûùúÉ‚Äù = log ùêø‚ÄûùúÉ‚Äù = log ùùÖyùëñ = log ùúãùë¶ùëñùëó ùëó = ùë¶ùëñùëó log ùúãùëó. (A.32) ùëñ=1 ùëñ=1 ùëó=1 ùëñ=1 ùëó=1
Since in maximum likelihood estimation, we maximizing the objective function ùëô‚ÄûùúÉ‚Äù by
having ùúãùëó = ùëùùúÉ‚Äûùë¶ùëñùëó j xùëñ‚Äù. Therefore, for any multi-class classification, maximizing the abovelog-likelihoodfunctionùëô‚ÄûùúÉ‚Äù isequivalenttominimizingtheCElossCE‚Äûùë¶, ÀÜùë¶‚Äù. To test the above proof, let‚Äôs apply the built-in measure NegativeLogLikelihood. Using the same labels and preds as in the earlier example, we will get the same numerical loss as the previous example up to the 5 decimal place. # Implementation of cross-entropy loss in PyTorch combines `nn.LogSoftmax()` # and `nn.NLLLoss()` nll_loss = NLLLoss() loss = nll_loss(torch.log(preds), labels) loss
tensor(0.9486)
A.11.6 Summary
e Information theory is a field of study about encoding, decoding, transmitting, and ma-
nipulating information. e Entropy is the unit to measure how much information is presented in different signals. e KL divergence can also measure the divergence between two distributions. e Cross-entropy can be viewed as an objective function of multi-class classification. Min-
imizing cross-entropy loss is equivalent to maximizing the log-likelihood function. A.11.7 Exercises
1.bubuVerify that the card examples from the first section indeed have the claimed entropy. 2. Show that the KL divergence ùê∑‚Äûùëùkùëû‚Äù is nonnegative for all distributions ùëù and ùëû. Hint:
2. Show that the KL divergence D(p||q) is nonnegative for all distributions p and q. Hint: use Jensen‚Äôs inequality, i.e., use the fact that ‚Äî log x is a convex function. 3. Let‚Äôs compute the entropy from a few data sources:
k
La
z
Mathematics for Deep Learning
1034

e Assume that you are watching the output generated by a monkey at a typewriter. The
monkey presses any of the 44 keys of the typewriter at random (you can assume that it has not discovered any special keys or the shift key yet). How many bits of randomness per character do you observe? e Being unhappy with the monkey, you replaced it by a drunk typesetter. It is able
to generate words, albeit not coherently. Instead, it picks a random word out of a vocabulary of 2,000 words. Let‚Äôs assume that the average length of a word is 4.5 letters in English. How many bits of randomness per character do you observe now? e Still being unhappy with the result, you replace the typesetter by a high quality lan-
e Still being unhappy with the result, you replace the typesetter by a high quality lan- guage model. The language model can currently obtain a perplexity as low as 15 points per word. The character perplexity of a language model is defined as the inverse of the geometric mean of a set of probabilities, each probability is corre- sponding to a character in the word. To be specific, if the length of a given word is 1, then PPL(word) = [J]; p(character;)]~7 = exp [-+ >, log p(character;) | . As- sume that the test word has 4.5 letters, how many bits of randomness per character do you observe now? 4.bubuExplain intuitively why 1(X,Y) = H(X) - H(X | Y). Then, show this is true by
expressing both sides as an expectation with respect to the joint distribution. 5. What is the KL Divergence between the two Gaussian distributions N‚Äûùúá1, ùúé2
N‚Äûùúá2, ùúé2 ‚Äù? 1
2
Discussions290.bubu290
‚Äù and
B  Tools for Deep Learning 
To get the most out of Dive into Deep Learning, we will talk you through different tools in thisappendix,suchasforrunningandcontributingtothisinteractiveopen-sourcebook. B.1 Using Jupyter Notebooks
ee
This section describes how to edit and run the code in each section of this book using the Jupyter Notebook. Make sure you have installed Jupyter and downloaded the code as described in Installation (page xxxiv). If you want to know more about Jupyter see the excellent tutorial in their documentation291. 291 
B.1.1 Editing and Running the Code Locally
Suppose that the local path of the book‚Äôs code is xx/yy/d2l-en/. Use the shell to change the directory to this path (cd xx/yy/d2l-en) and run the command jupyter notebook. If your browser does not do this automatically, open http://localhost:8888 and you will see the interface of Jupyter and all the folders containing the code of the book, as shown in Fig. B.1. ~~ jupyter Quit Logout Files Running Clusters Nbextensions Select items to perform actions on them. Upload Newry @ Do - w&/ Name Last Modified __File size O ¬© build seconds ago OD chapter_appendix-mathematics-for-deep-learning 6 days ago ¬© ¬© chapter_attention-mechanisms an hour ago
tFig. B.1
The folders containing the code of this book. You can access the notebook files by clicking on the folder displayed on the webpage. They usually have the suffix ‚Äú.ipynb‚Äù. For the sake of brevity, we create a temporary ‚Äútest.ipynb‚Äù file. The content displayed after you click it is shown in Fig.bubuB.2. This notebook includes a
1035
Tools for Deep Learning
1036

markdown cell and a code cell. The content in the markdown cell includes ‚ÄúThis Is a Title‚Äù and ‚ÄúThis is text.‚Äù. The code cell contains two lines of Python code. S JUpyter test weaved changes Py Logout File Edit View Insert Cell Kernel Widgets Help Trusted Python3 O B + *& @ BH & % hRun MC WD Markdown v Biv This Is a Title This is text. In [ ]: import numpy as np np.ones((3, 4))
tFig. B.2
Markdown and code cells in the ‚Äútext.ipynb‚Äù Ô¨Åle. Double click on the markdown cell to enter edit mode. Add a new text string ‚ÄúHello world.‚Äù at the end of the cell, as shown in Fig. B.3. S Jupyter test creaves nares PP) Legout File Edit View Insert Cell Kernel Widgets Help Trusted # | Python 3 fe} + ¬´ @ BR *¬Æ & PRU MC OD Makdown v @ | # This Is a Title This is text. Hello world.| In [ ]: import numpy as np np.ones((3, 4))
tFig. B.3
Edit the markdown cell. As demonstrated in Fig. B.4, click ‚ÄúCell‚Äù ! ‚ÄúRun Cells‚Äù in the menu bar to run the edited
cell. After running, the markdown cell is shown in Fig. B.5. Next, click on the code cell. Multiply the elements by 2 after the last line of code, as shown in Fig. B.6. You can also run the cell with a shortcut (‚ÄúCtrl + Enter‚Äù by default) and obtain the output result from Fig. B.7. When a notebook contains more cells, we can click ‚ÄúKernel‚Äù ! ‚ÄúRestart & Run All‚Äù in the
menu bar to run all the cells in the entire notebook. By clicking ‚ÄúHelp‚Äù !bubu‚ÄúEdit Keyboard Shortcuts‚Äùinthemenubar, youcanedittheshortcutsaccordingtoyourpreferences. B.1 Using Jupyter Notebooks
1037

CS JUpyter test dnsaedcrangss File Edit View Insert Cell Kernel Widgets Help + & @ BH ¬Æ % RunCells Run Cells and Select Below Trusted | Python 3 ¬© Run Cells and Insert Below | C2 # This Is puna Run All Above This is text Run All Below In [ ]: import numpy np.ones((3, | Cll Type , Current Outputs mt
tFig. B.4
Run the cell. JUpyter test neared cranges File Edit View insert += Cell_~=s Kernel ~=s Widgets_~‚ÄîSs Help Trusted | Python 3 O + x @ BH & % PRU mC WP Markdown vo @ |'¬• This Is a Title This is text. Hello world. In [ ]: import numpy as np np.ones((3, 4))
tFig. B.5
The markdown cell after running. S Jupyter test inmedenengen Popout File Edit View Insert Cell = Kernel += Widgets_~‚ÄîsHelp Trusted g | Python3 O 8 + x @ &H *¬Æ % PRU mM C PW Code vy @el|v This Is a Title This is text. Hello world. In [ }: import numpy as np np.ones((3, 4)) * 2|
tFig. B.6
Edit the code cell. Tools for Deep Learning
1038

S jupyter test insavedcharees Logout File Edit View Insert Cell Kernel Widgets Help Trusted | Python 3 ¬© + x ¬© KR & % PRU HM CS DP Code , ely This Is a Title This is text. Hello world. In [1]: import numpy as np np.ones((3, 4)) * 2 Out[1}: array([[2-, 2., 2-, 2-l, [2., 2., 2., 2.], [2., 26, 26, 2.)1)
tFig. B.7
Run the code cell to obtain the output. B.1.2 Advanced Options
Beyondlocaleditingtwothingsarequiteimportant: editingthenotebooksinthemarkdown format and running Jupyter remotely. The latter matters when we want to run the code on a faster server. The former matters since Jupyter‚Äôs native ipynb format stores a lot of auxiliary data that is irrelevant to the content, mostly related to how and where the code is run. This is confusing for Git, making reviewing contributions very difficult. Fortunately there is an alternative‚Äînative editing in the markdown format. Markdown Files in Jupyter
If you wish to contribute to the content of this book, you need to modify the source file (md file, not ipynb file) on GitHub. Using the notedown plugin we can modify notebooks in the md format directly in Jupyter. First, install the notedown plugin, run the Jupyter Notebook, and load the plugin:
pip install d2l-notedown # You may need to uninstall the original notedown. jupyter notebook --NotebookApp.contents_manager_class='notedown. ‚Ü©!NotedownContentsManager'
You may also turn on the notedown plugin by default whenever you run the Jupyter Note- book. First, generate a Jupyter Notebook configuration file (if it has already been generated, you can skip this step). jupyter notebook --generate-config
Then, add the following line to the end of the Jupyter Notebook configuration file (for Linux or macOS, usually in the path ~/.jupyter/jupyter_notebook_config.py):
Using Jupyter Notebooks
1039

c.NotebookApp.contents_manager_class = 'notedown.NotedownContentsManager'
After that, you only need to run the jupyter notebook command to turn on the notedown plugin by default. Running Jupyter Notebooks on a Remote Server
Sometimes, youmaywanttorunJupyternotebooksonaremoteserverandaccessitthrough a browser on your local computer. If Linux or macOS is installed on your local machine (Windows can also support this function through third-party software such as PuTTY), you can use port forwarding:
ssh myserver -L 8888:localhost:8888
The above string myserver is the address of the remote server. Then we can use http: //localhost:8888 to access the remote server myserver that runs Jupyter notebooks. We will detail on how to run Jupyter notebooks on AWS instances later in this appendix. We can use the ExecuteTime plugin to time the execution of each code cell in Jupyter notebooks. Use the following commands to install the plugin:
pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user jupyter nbextension enable execute_time/ExecuteTime
B.1.3 Summary
e Using the Jupyter Notebook tool, we can edit, run, and contribute to each section of the
book. e We can run Jupyter notebooks on remote servers using port forwarding.bubuB.1.4 Exercises
1.bubuEdit and run the code in this book with the Jupyter Notebook on your local machine. 2. Edit and run the code in this book with the Jupyter Notebook remotely via port forward- ing. 3. Compare the running time of the operations A>B and AB for two square matrices in
3. Compare the running time of the operations A'B and AB for two square matrices in R1024x1024| Which one is faster? 292
Discussions292. Timing
Tools for Deep Learning
1040

B.2 Using Amazon SageMaker
es
Deep learning applications may demand so much computational resource that easily goes beyond what your local machine can offer. Cloud computing services allow you to run GPU-intensive code of this book more easily using more powerful computers. This section will introduce how to use Amazon SageMaker to run the code of this book. B.2.1 Signing Up
First, we need to sign up an account at https://aws.amazon.com/. For additional security, usingtwo-factorauthenticationisencouraged. Itisalsoagoodideatosetupdetailedbilling and spending alerts to avoid any surprise, e.g., when forgetting to stop running instances. After logging into your AWS account, go to your console 293 and search for ‚ÄúAmazon SageMaker‚Äù (see Fig. B.1), then click it to open the SageMaker panel. 293
AWS services Find Services You can enter names, keywords or acronyms. Q sage Amazon SageMaker Build, Train, and Deploy Machine Learning Models
tFig. B.1
Search for and open the SageMaker panel. B.2.2 Creating a SageMaker Instance
Next, let‚Äôs create a notebook instance as described in Fig. B.2. Amazon SageMaker =X ‚ÄòAmazon SageMaker > Notebook instances Amazon SageMaker Studio i Dashboard Q Search notebook instances 1 @ Search y Ground Truth Name ¬• Instance Creation time ¬• Status ¬• Actions Labeling jobs ‚ÄòThere are currently no resources. Labeling datasets Labeling workforces < Notebook Notebook instances Lifecycle configurations Git repositories
tFig. B.2
Create a SageMaker instance. Using Amazon SageMaker
1041

SageMaker provides multiple instance types 294 with varying computational power and prices. When creating a notebook instance, we can specify its name and type. In Fig. B.3, we choose ml.p3.2xlarge: with one Tesla V100 GPU and an 8-core CPU, this instance is powerful enough for most of the book. 294 
Notebook instance settings Notebook instance name D2L Maximum of 63 alphanumeric characters. Can include hyphens (-), but not spaces. Must be unique within your accou Notebook instance type mLp3.2xlarge v
tFig.bubuB.3
Choose the instance type. The entire book in the ipynb format for running with SageMaker is available at https:// github.com/d2l-ai/d2l-pytorch-sagemaker. We can specify this GitHub repository URL (Fig. B.4) to allow SageMaker to clone it when creating the instance. v Git repositories - optional v Default repository Repository Jupyter will start in this repository. Repositories are added to your home directory. Clone a public Git repository to this notebook instance only v Git repository URL Clonea _ to use for this notebook instance ~
tFig. B.4
Specify the GitHub repository. B.2.3 Running and Stopping an Instance
Creating an instance may take a few minutes. When it is ready, click on the ‚ÄúOpen Jupyter‚Äù link next to it (Fig. B.5) so you can edit and run all the Jupyter notebooks of this book on this instance (similar to steps in Section B.1). Name ¬• _ Instance Creation time v Status v Actions pat mlp3.2xlarge Dec 18, 2019 19:16 UTC OinService Open Jupyter J Open JupyterLab
Name ¬• _ Instance Creation time v Status v Actions pat mlp3.2xlarge Dec 18, 2019 19:16 UTC OinService Open Jupyter J Open JupyterLab
tFig. B.5
Open Jupyter on the created SageMaker instance. After finishing your work, do not forget to stop the instance to avoid being charged further (Fig. B.6). Tools for Deep Learning
1042

Notebook instances Actions ¬• Create notebook Open Jupyter Q Search notebook instances 1 Open JupyterLab Name ¬• Instance itatus Vv ¬∞ D2L mL.p3.2xlarge Add/Edit tags Dinservice
tFig. B.6
Stop a SageMaker instance. B.2.4 Updating Notebooks
Notebooks of this open-source book will be regularly updated in the d2l-ai/d2l-pytorch- sagemaker 295 repository on GitHub. To update to the latest version, you may open a terminal on the SageMaker instance (Fig. B.7). 295
t) Upload | New ~ Other: Text File Folder
tFig. B.7
Open a terminal on the SageMaker instance. You may wish to commit your local changes before pulling updates from the remote repos- itory. Otherwise, simply discard all your local changes with the following commands in the terminal:
cd SageMaker/d2l-pytorch-sagemaker/ git reset --hard git pull
B.2.5 Summary
e We can create a notebook instance using Amazon SageMaker to run GPU-intensive code
of this book. e We can update notebooks via the terminal on the Amazon SageMaker instance. B.2.6 Exercises
1. Edit and run any section that requires a GPU using Amazon SageMaker. Using AWS EC2 Instances
1043

2. Open a terminal to access the local directory that hosts all the notebooks of this book. Discussions296. 296
B.3 Using AWS EC2 Instances

In this section, we will show you how to install all libraries on a raw Linux machine. Recall thatinSectionB.2wediscussedhowtouseAmazonSageMaker, whilebuildinganinstance by yourself costs less on AWS. The walkthrough includes three steps:
1. Request for a GPU Linux instance from AWS EC2. 2. Install CUDA (or use an Amazon Machine Image with preinstalled CUDA). 3. Install the deep learning framework and other libraries for running the code of the book. This process applies to other instances (and other clouds), too, albeit with some minor modifications.bubuBefore going forward, you need to create an AWS account, see Section B.2 for more details. B.3.1 Creating and Running an EC2 Instance
AfterloggingintoyourAWSaccount, click‚ÄúEC2‚Äù(Fig.B.1)togototheEC2panel. aws Recently visited Compute Favorites All services AWS App Runner Build and run production web apy 3 Analytics | Application Integration = ARBVR ¬© AWS Cost Management slockchain fh. Business Applications ‚Äò Elastic Beanstalk
tFig. B.1
Open the EC2 console. Fig.bubuB.2 shows the EC2 panel. Presetting Location
Select a nearby data center to reduce latency, e.g., ‚ÄúOregon‚Äù (marked by the red box in the top-right of Fig. B.2). If you are located in China, you can select a nearby Asia Pacific
Tools for Deep Learning
1044

Oregon ¬• ¬© New ec2 Experience yy Tell us ha you think Launch instance Service health Explore EC2 Dashboard virtual server in the cloud. Cc AWS Health Dashboard [3 EC2 Global View ‚ÄòAmazon Gi GuardDuty Events Region detection i US West (Oregon) workloads. Status save upt ‚Äîe‚Äîr‚Äî‚Äî‚Äî‚Äîevroveoee ave up to ¬© This service is operating normally Pp ¬• Instances Note: Your instances wil taunch in the US West (Oregon) Optimize Region ‚Äò Instances New purchase 0 Zanes more [3
tFig. B.2
The EC2 panel.buburegion, such as Seoul or Tokyo. Please note that some data centers may not have GPU instances. Increasing Limits
Before choosing an instance, check if there are quantity restrictions by clicking the ‚ÄúLim- its‚Äù label in the bar on the left as shown in Fig. B.2.bubuFig. B.3 shows an example of such a limitation. The account currently cannot open ‚Äúp2.xlarge‚Äù instances according to the re- gion. If you need to open one or more instances, click on the ‚ÄúRequest limit increase‚Äù link to apply for a higher instance quota. Generally, it takes one business day to process an application. Resource Groupe funnng OmDerand m√©detal ances ¬∞ ques intnrase Funnng Orbea m√©dage stances 2 Request intnrase Funnng OmDerand o@6klage instances ¬∞ Request itnrease Funnng Or oerand 2.aye stances ¬∞ Request ntnrease : runng On-Demand 2 tage nance ¬∞ esevedinsirces funnng On oeranc argent ¬∞ eves intnrease Dealeated Hosts Running On-Demand p3.8xlarge instances o Request limit increase Schedule nstarces
tFig. B.3
Instance quantity restrictions.bubuLaunching an Instance
Next, click the ‚ÄúLaunch Instance‚Äù button marked by the red box in Fig. B.2 to launch your instance. We begin by selecting a suitable Amazon MachineImage (AMI). Select an Ubuntu instance (Fig. B.4). EC2 provides many different instance configurations to choose from. This can sometimes feel overwhelming to a beginner. tab_ec2 lists different suitable machines. :Different EC2 instance types
p
Using AWS EC2 Instances
1045

v Application and OS Images (Amazon Machine Image) info An AMI is a template that contains the software configuration (operating system, application server, and applications) required to launch your instance. Search or Browse for AMIs if you don‚Äôt see what you are looking for below Q Search our full catalog including 1000s of application and OS images Recents My AMIs Quick Start Amazon macOS Ubuntu Windows Red Hat s Q Linux > Browse more AMIs aws o |) = Including AMIs fi ubuntu Microsoft RedHat including AMIs from ‚Äî Mac a e AWS, Marketplace and the Community Amazon Machine Image (AMI) Ubuntu Server 22.04 LTS (HVM), SSD Volume Type Free tier eligible v ami-017fecd1353bcc96e (64-bit (x86)) / ami-Odb84aebfa8d17e23 (64-bit (Arm)) Virtualization: hvm ENA enabled: true Root device type: ebs
tFig. B.4
Choose an AMI. Table B.1: label:tab_ec2
Name GPU Notes g2 Grid K520 ancient p2 Kepler K80 old but often cheap as spot g3 Maxwell M60 good trade-off p3 Volta V100 high performance for FP16 p4 Ampere A100 high performance for large-scale training g4 Turing T4 inference optimized FP16/INT8
All these servers come in multiple flavors indicating the number of GPUs used. For exam- ple, a p2.xlarge has 1 GPU and a p2.16xlarge has 16 GPUs and more memory. For more details, see the AWS EC2 documentation297 or a summary page298. For the purpose of illustration, a p2.xlarge will suffice (marked in the red box of Fig.bubuB.5). 297
Bate
v Instance type info Instance type p2.xlarge Family:p2 4vCPU 61 GiB Memory Compare instance types On-Demand Linux pricing: 0.9 USD per Hour On-Demand Windows pricing: 1.084 USD per Hour
298
tFig. B.5
Choose an instance. Tools for Deep Learning
1046

Note that you should use a GPU-enabled instance with suitable drivers and a GPU-enabled deep learning framework. Otherwise you will not see any benefit from using GPUs. We go on to select the key pair used to access the instance. If you do not have a key pair, click ‚ÄúCreate new key pair‚Äù in Fig. B.6 to generate a key pair. Subsequently, you can select the previously generated key pair. Make sure that you download the key pair and store it in a safe location if you generated a new one. This is your only way to SSH into the server. v Key pair (login) info You can use a key pair to securely connect to your instance. Ensure that you have access to the selected key pair before you launch the instance. Key pair name - required [oon
tFig. B.6
Select a key pair. In this example, we will keep the default configurations for ‚ÄúNetwork settings‚Äù (click the ‚ÄúEdit‚Äù button to configure items such as the subnet and security groups). We just increase the default hard disk size to 64 GB (Fig.bubuB.7). Note that CUDA by itself already takes up 4 GB. v Configure storage info Advanced 1x 64 GiB gp2 v_ Root volume (Not encrypted) ¬© Free tier eligible customers can get up to 30 GB of EBS General Purpose (SSD) or Magnetic x storage | Add new volume
tFig. B.7
Modify the hard disk size.bubuClick ‚ÄúLaunch Instance‚Äù to launch the created instance. Click the instance ID shown in Fig. B.8 to view the status of this instance. Connecting to the Instance
As shown in Fig. B.9, after the instance state turns green, right-click the instance and select Connect to view the instance access method. If this is a new key, it must not be publicly viewable for SSH to work. Go to the folder where
Using AWS EC2 Instances
1047

EC2 > Instances > Launch an instance ¬© Success Successfully initiated launch of instan dd) > Launch log
tFig. B.8
Click the instance ID. Name v | Instance ID | Instance state 97 Instance type - Launch instances dd ¬©Running QQ p2.xlarge Launch instance from template Migrate a server Connect
tFig. B.9
View the instance access method. you store D2L_key.pem and execute the following command to make the key not publicly viewable:
chmod 400 D2L_key.pem
Connect to instance info Connect to your instance i-07d488d640e6358dd using any of these options EC2 Instance Connect Session Manager | SSHclient | C2 serial console Instance ID Gi-o7 dd 1. Open an SSH client.bubu2. Locate your private key file. The key used to launch this instance is D2L_key.pem 3. Run this command, if necessary, to ensure your key is not publicly viewable. chmod 400 D2L_key.pem 4, Connect to your instance using its Public DNS: GB ec2- .compute.amazonaws.com D2L_key.pem‚Äù ubuntu@ec? ‚Äòompute.amazonaws.com ¬© Note: In most cases, the guessed user name is correct. However, read your AMI usage instructions to check if ‚Äòthe AMI owner has changed the default AMI user name. tFig.bubuB.10
View instance access and startup method. Now, copy the SSH command in the lower red box of Fig. B.10 and paste onto the command line:
Tools for Deep Learning
1048

ssh -i "D2L_key.pem" ubuntu@ec2-xx-xxx-xxx-xxx.y.compute.amazonaws.com
When the command line prompts ‚ÄúAre you sure you want to continue connecting (yes/no)‚Äù, enter ‚Äúyes‚Äù and press Enter to log into the instance. Your server is ready now. B.3.2 Installing CUDA
Before installing CUDA, be sure to update the instance with the latest drivers. sudo apt-get update && sudo apt-get install -y build-essential git libgfortran3
Here we download CUDA 12.1. Visit NVIDIA‚Äôs official repository299 to find the download
link as shown in Fig. B.11. 299

Home Select Target Platform Click on the green buttons that describe your target platform. Only supported platforms will be shown. 8y downloading end using the software, you agree to fully comply with the terms and conditiens of the CUDA EULA. Operating System ne wecom Architecture ) ee) Distribution ene jose Ff con Fn ff cme ce c= co el Version 908 ot | e Installer Type ==) i EEE ler for Linux Ubuntu 22.04 x86_64 ‚ÄòThe base installer is available for download below. tFig. B.11
Find the CUDA 12.1 download address. Copy the instructions and paste them onto the terminal to install CUDA 12.1. # The link and file name are subject to changes wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_ ‚Ü©!64/cuda-ubuntu2204.pin sudo mv cuda-ubuntu2204.pin /etc/apt/preferences.d/cuda-repository-pin-600 wget https://developer.download.nvidia.com/compute/cuda/12.1.0/local_ ‚Ü©!installers/cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb sudo dpkg -i cuda-repo-ubuntu2204-12-1-local_12.1.0-530.30.02-1_amd64.deb
(continues on next page)
Using AWS EC2 Instances
1049

sudo cp /var/cuda-repo-ubuntu2204-12-1-local/cuda-*-keyring.gpg /usr/share/ ‚Ü©!keyrings/ sudo apt-get update sudo apt-get -y install cuda
After installing the program, run the following command to view the GPUs:
nvidia-smi
Finally, add CUDA to the library path to help other libraries find it, such as appending the following lines to the end of ~/.bashrc. export PATH="/usr/local/cuda-12.1/bin:$PATH" export LD_LIBRARY_PATH=${LD_LIBRARY_PATH}:/usr/local/cuda-12.1/lib64
B.3.3 Installing Libraries for Running the Code
To run the code of this book, just followsteps in Installation (page xxxiv) for Linux users on the EC2 instance and use the following tips for working on a remote Linux server:
e To download the bash script on the Miniconda installation page, right click the download
link and select ‚ÄúCopy Link Address‚Äù, then execute wget [copied link address]. e After running ~/miniconda3/bin/conda init, you may execute source ~/.bashrc
instead of closing and reopening your current shell. B.3.4 Running the Jupyter Notebook remotely
To run the Jupyter Notebook remotely you need to use SSH port forwarding. After all, the server in the cloud does not have a monitor or keyboard. For this, log into your server from your desktop (or laptop) as follows:
# This command must be run in the local command line ssh -i "/path/to/key.pem" ubuntu@ec2-xx-xxx-xxx-xxx.y.compute.amazonaws.com -L‚ê£ ‚Ü©!8889:localhost:8888
Next, go to the location of the downloaded code of this book on the EC2 instance, then run:
conda activate d2l jupyter notebook
Fig. B.12 shows the possible output after you run the Jupyter Notebook.bubuThe last row is the URL for port 8888. Since you used port forwarding to port 8889, copy the last row in the red box of Fig. B.12, replace ‚Äú8888‚Äù with ‚Äú8889‚Äù in the URL, and open it in your local browser. (continued from previous page)
Tools for Deep Learning
1050


tFig. B.12
Output after running the Jupyter Notebook. The last row is the URL for port 8888. B.3.5 Closing Unused Instances
As cloud services are billed by the time of use, you should close instances that are not being used. Note that there are alternatives:
e ‚ÄúStopping‚Äù an instance means that you will be able to start it again. This is akin to
switching off the power for your regular server. However, stopped instances will still be billed a small amount for the hard disk space retained. e ‚ÄúTerminating‚Äù an instance will delete all data associated with it. This includes the disk,
hence you cannot start it again. Only do this if you know that you will not need it in the future. If you want to use the instance as a template for many more instances, right-click on the exampleinFig.B.9andselect‚ÄúImage‚Äù!‚ÄúCreate‚Äùtocreateanimageoftheinstance. Once this is complete, select ‚ÄúInstance State‚Äù ! ‚ÄúTerminate‚Äù to terminate the instance. The next time you want to use this instance, you can follow the steps in this section to create an instance based on the saved image. The only difference is that, in ‚Äú1. Choose AMI‚Äù shown in Fig. B.4, you must use the ‚ÄúMy AMIs‚Äù option on the left to select your saved image. The created instance will retain the information stored on the image hard disk. For example, you will not have to reinstall CUDA and other runtime environments. B.3.6 Summary
We can launch and stop instances on demand without having to buy and build our own
computer. We need to install CUDA before using the GPU-enabled deep learning framework. e We can use port forwarding to run the Jupyter Notebook on a remote server. B.3.7 Exercises
300
1.bubuThe cloud offers convenience, but it does not come cheap. Find out how to launch spot instances300 to see how to reduce costs. Using Google Colab
1051

2. Experiment with different GPU servers. How fast are they? 3. Experiment with multi-GPU servers. How well can you scale things up?bubuDiscussions301. 301
B.4 Using Google Colab

We introduced how to run this book on AWS in Section B.2 and Section B.3. Another option is running this book on Google Colab302 if you have a Google account. 302
To run the code of a section on Colab, simply click the Colab button as shown in Fig. B.1.bubu2.1. Data Manipulation Q 2.1. Data Manipulation
tFig. B.1
Run the code of a section on Colab
If it is your first time to run a code cell, you will receive a warning message as shown in Fig. B.2.bubuJust click ‚ÄúRUN ANYWAY‚Äù to ignore it. Warning: This notebook was not authored ... This notebook is being loaded from GitHub. It may request access to your data stored with Google, or read data and credentials from other sessions. Please review the source code before executing this notebook.bubuCANCEL | RUN ANYWAY
tFig. B.2
Ignore the warning message by clicking ‚ÄúRUN ANYWAY‚Äù. Next, Colab will connect you to an instance to run the code of this section. Specifically, if a GPU is needed, Colab will be automatically requested for connecting to a GPU in- stance. B.4.1 Summary
e You can use Google Colab to run each section‚Äôs code in this book. e Colab will be requested to connect to a GPU instance if a GPU is needed in any section
of this book. Tools for Deep Learning
1052

B.4.2 Exercises
1. Open any section of this book using Google Colab.bubu2. Edit and run any section that requires a GPU using Google Colab. Discussions303. 303
B.5 Selecting Servers and GPUs
es
Deep learning training generally requires large amounts of computation. At present GPUs are the most cost-effective hardware accelerators for deep learning. In particular, compared with CPUs, GPUs are cheaper and offer higher performance, often by over an order of magnitude. Furthermore, a single server can support multiple GPUs, up to 8 for high end servers. More typical numbers are up to 4 GPUs for an engineering workstation, since heat, cooling, and power requirements escalate quickly beyond what an office building can support. For larger deployments, cloud computing (e.g., Amazon‚Äôs P3 304 and G4 305 instances) is a much more practical solution. 304
B.5.1 Selecting Servers
305
There is typically no need to purchase high-end CPUs with many threads since much of the computation occurs on the GPUs. That said, due to the global interpreter lock (GIL) in Python single-thread performance of a CPU can matter in situations where we have 4‚Äì8 GPUs. All things equal this suggests that CPUs with a smaller number of cores but a higher clock frequency might be a more economical choice. For example, when choosing between a 6-core 4 GHz and an 8-core 3.5 GHz CPU, the former is much preferable, even though its aggregate speed is less. An important consideration is that GPUs use lots of power and thus dissipate lots of heat. This requires very good cooling and a large enough chassis to use the GPUs. Follow the guidelines below if possible:
1. Power Supply. GPUs use significant amounts of power. Budget with up to 350W per device(checkforthepeakdemand ofthegraphicscardratherthantypicaldemand, since efficient code can use lots of energy). If your power supply is not up to the demand you will find that your system becomes unstable. 2.bubuChassisSize. GPUsarelargeandtheauxiliarypowerconnectorsoftenneedextraspace. Also, large chassis are easier to cool. 3. GPU Cooling. If you have a large number of GPUs you might want to invest in water cooling. Also, aim for reference designs even if they have fewer fans, since they are thin enough to allow for air intake between the devices. If you buy a multi-fan GPU it might be too thick to get enough air when installing multiple GPUs and you will run into thermal throttling. Selecting Servers and GPUs
1053

4. PCle Slots. Moving data to and from the GPU (and exchanging it between GPUs) requires lots of bandwidth. We recommend PCle 3.0 slots with 16 lanes. If you mount multiple GPUs, be sure to carefully read the motherboard description to ensure that 16x bandwidth is still available when multiple GPUs are used at the same time and that you are getting PCle 3.0 as opposed to PCle 2.0 for the additional slots. Some motherboards downgrade to 8x or even 4x bandwidth with multiple GPUs installed. This is partly due to the number of PCle lanes that the CPU offers. In short, here are some recommendations for building a deep learning server:
e Beginner. Buy a low end GPU with low power consumption (cheap gaming GPUs suit-
ablefordeeplearninguse150‚Äì200W).Ifyouareluckyyourcurrentcomputersupports it. e 1 GPU. A low-end CPU with 4 cores will be sufficient and most motherboards suffice. Aim for at least 32 GB DRAM and invest into an SSD for local data access. A power supply with 600W should be sufficient. Buy a GPU with lots of fans. e 2 GPUs. A low-end CPU with 4-6 cores will suffice. Aim for 64 GB DRAM and invest into an SSD. You will need in the order of 1000W for two high-end GPUs. In terms of mainboards, make sure that they have two PCle 3.0 x16 slots. If you can, get a mainboard that has two free spaces (60mm spacing) between the PCle 3.0 x16 slots for extra air. In this case, buy two GPUs with lots of fans. e 4GPUs. Make sure that you buy a CPU with relatively fast single-thread speed (i.e., high clock frequency). You will probably need a CPU with a larger number of PCle lanes, such as an AMD Threadripper. You will likely need relatively expensive mainboards to get 4 PCle 3.0 x16 slots since they probably need a PLX to multiplex the PCle lanes. Buy GPUs with reference design that are narrow and let air in between the GPUs. You need a 1600‚Äî2000W power supply and the outlet in your office might not support that. This server will probably run loud and hot. You do not want it under your desk. 128 GB of DRAM is recommended. Get an SSD (1-2 TB NVMe) for local storage and a bunch of hard disks in RAID configuration to store your data. e 8GPUs. You need to buy a dedicated multi-GPU server chassis with multiple redundant power supplies (e.g., 2+1 for 1600W per power supply). This will require dual socket server CPUs, 256 GB ECC DRAM, a fast network card (10 GBE recommended), and you will need to check whether the servers support the physical form factor of the GPUs. Airflow and wiring placement differ significantly between consumer and server GPUs (e.g., RTX 2080 vs. Tesla V100). This means that you might not be able to install the consumer GPU in a server due to insufficient clearance for the power cable or lack of a suitable wiring harness (as one of the coauthors painfully discovered). B.5.2 Selecting GPUs
Atpresent,AMDandNVIDIAarethetwomainmanufacturersofdedicatedGPUs. NVIDIA was the first to enter the deep learning field and provides better support for deep learning frameworks via CUDA. Therefore, most buyers choose NVIDIA GPUs. Tools for Deep Learning
1054

NVIDIA provides two types of GPUs, targeting individual users (e.g., via the GTX and RTX series) and enterprise users (via its Tesla series). The two types of GPUs provide comparable compute power. However, the enterprise user GPUs generally use (passive) forced cooling, more memory, and ECC (error correcting) memory. These GPUs are more suitable for data centers and usually cost ten times more than consumer GPUs. If you are a large company with 100+ servers you should consider the NVIDIA Tesla series or alternatively use GPU servers in the cloud. For a lab or a small to medium company with 10+ servers the NVIDIA RTX series is likely most cost effective. You can buy preconfig- ured servers with Supermicro or Asus chassis that hold 4‚Äì8 GPUs efficiently. GPU vendors typically release a new generation every one to two years, such as the GTX 1000 (Pascal) series released in 2017 and the RTX 2000 (Turing) series released in 2019. Each series offers several different models that provide different performance levels.bubuGPU performance is primarily a combination of the following three parameters:
1. Compute Power. Generally we look for 32-bit floating-point compute power. 16-bit floating point training (FP16) is also entering the mainstream. If you are only interested in prediction, you can also use 8-bit integer. The latest generation of Turing GPUs offers 4-bit acceleration. Unfortunately at the time of writing the algorithms for training low- precision networks are not yet widespread. 2.bubuMemory Size. As your models become larger or the batches used during training grow bigger, you will need more GPU memory. Check for HBM2 (High Bandwidth Memory) vs. GDDR6 (Graphics DDR) memory. HBM2 is faster but much more expensive. 3.bubuMemory Bandwidth. You can only get the most out of your compute power when you have sufficient memory bandwidth. Look for wide memory buses if using GDDR6. For most users, it is enough to look at compute power. Note that many GPUs offer different types of acceleration. For example, NVIDIA‚Äôs TensorCores accelerate a subset of opera- tors by 5x. Ensure that your libraries support this. The GPU memory should be no less than 4 GB (8 GB is much better). Try to avoid using the GPU also for displaying a GUI (use the built-in graphics instead). If you cannot avoid it, add an extra 2 GB of RAM for safety.bubuFig. B.1 compares the 32-bit floating-point compute power and price of the various GTX 900, GTX 1000 and RTX 2000 series models. The prices suggested are those found on Wikipedia at the time of writing.bubuWe can see a number of things:
1. Within each series, price and performance are roughly proportional. Titan models com- mand a significant premium for the benefit of larger amounts of GPU memory. How- ever, the newer models offer better cost effectiveness, as can be seen by comparing the 980Tiand1080Ti. ThepricedoesnotappeartoimprovemuchfortheRTX2000series. However, this is due to the fact that they offer far superior low precision performance (FP16, INT8, and INT4). Selecting Servers and GPUs
1055

@ = GTX9XX @ = GTX10XX @ = RTX20XX @ Titan X; 12500 qoRO TT A208 : a p ¬£ Titan X Pascal 10000 Titan Z e ¬´7500 500095011 970 4 ¬∞ * 105060 2500 1950p ¬∞ 0 500 1000 1500 2000 2500 Price ($)
a 2 it oO
tFig. B.1
Floating-point compute power and price comparison. 2. The performance-to-cost ratio of the GTX 1000 series is about two times greater than the 900 series. 3. For the RTX 2000 series the performance (in GFLOPs) is an aÔ¨Äine function of the price. @ ‚ÄîGTX9XX @ ‚ÄîGTX10XX @ ~ RTX20XX @ 12500 wee ‚Äî Titan xsPascal $ 10000 Titan e 7500 ax itan 1070 Titan ‚Äò@ 2060 s 500%) 1060 [380 f 50 Ti - e 970 ¬∞ ¬∞ 2 1050 960 2500 | 950 ‚Äî e 0 100 150 200 250 300 Watt
¬ª Q 8 5 ¬∞
tFig. B.2
Floating-point compute power and energy consumption.bubuFig. B.2 shows how energy consumption scales mostly linearly with the amount of com-
Z
Tools for Deep Learning
1056

putation. Second, later generations are more efficient. This seems to be contradicted by the graph corresponding to the RTX 2000 series. However, this is a consequence of the TensorCores that draw disproportionately much energy. B.5.3 Summary
Watch out for power, PCle bus lanes, CPU single thread speed, and cooling when build-
ing a server. You should purchase the latest GPU generation if possible. Use the cloud for large deployments. High density servers may not be compatible with all GPUs. Check the mechanical and
cooling specifications before you buy. e Use FP16 or lower precision for high efficiency. 306
Discussions306.bubuB.6 Contributing to This Book
es
307
Contributions by readers307 help us improve this book. If you find a typo, an outdated link, something where you think we missed a citation, where the code does not look elegant or where an explanation is unclear, please contribute back and help us help our readers. While in regular books the delay between print runs (and thus between typo corrections) can be measured in years, it typically takes hours to days to incorporate an improvement in this book. This is all possible due to version control and continuous integration (CI) testing. To do so you need to submit a pull request308 to the GitHub repository. When your pull request is merged into the code repository by the authors, you will become a contributor. 308
B.6.1 Submitting Minor Changes
309
The most common contributions are editing one sentence or fixing typos. We recommend that you find the source file in the GitHub repository 309 and edit the file directly. For example, you can search the file through the Find file 310 button (Fig. B.1) to locate the source file (a markdown file). Then you click the ‚ÄúEdit this file‚Äù button on the upper-right corner to make your changes in the markdown file. 310
After you are done, fill in your change descriptions in the ‚ÄúPropose file change‚Äù panel on the page bottom and then click the ‚ÄúPropose file change‚Äù button. It will redirect you to a new page to review your changes (Fig. B.7). If everything is good, you can submit a pull request by clicking the ‚ÄúCreate pull request‚Äù button. Contributing to This Book
1057

j.md Find file | Copy path cc78f74 on Jan14 Edit this file Raw Blame History [] cp
tFig. B.1
Edit the Ô¨Åle on Github. B.6.2 Proposing Major Changes
If you plan to update a large portion of text or code, then you need to know a little bit more about the format this book is using. The source file is based on the markdown format311 with a set of extensions through the D2L-Book312 package such as referring to equations, images, chapters, and citations. You can use any markdown editors to open these files and make your changes. 311
312 If you would like to change the code, we recommend that you use the Jupyter Notebook to open these markdown files as described in Section B.1, so that you can run and test your changes. Please remember to clear all outputs before submitting your changes since our CI system will execute the sections you updated to generate outputs. Some sections may support multiple framework implementations.bubuIf you add a new code block, please use %%tab to mark this block on the beginning line. For example, %%tab pytorch for a PyTorch code block, %%tab tensorflow for a TensorFlow code block, or %%tab all a shared code block for all implementations. You may refer to the d2lbook package for more information. B.6.3 Submitting Major Changes
We suggest you to use the standard Git process to submit a major change. In a nutshell the process works as described in Fig.bubuB.2. merge pull push request GitHub fork ‚Äî¬ª| GitHub clone | Pal Copy |e co nit d2l-ai/d2l-en user/d2l-en d2l-en
tFig. B.2
Contributing to the book. We will walk you through the steps in detail. If you are already familiar with Git you can skip this section. For concreteness we assume that the contributor‚Äôs user name is ‚Äúas- tonzhang‚Äù. Tools for Deep Learning
1058

Installing Git
The Git open-source book describes how to install Git 313 . This typically works via apt install git on Ubuntu Linux, by installing the Xcode developer tools on macOS, or by using GitHub‚Äôs desktop client314. If you do not have a GitHub account, you need to sign up for one. 313
BE
il
Sea
314
me 7
Logging in to GitHub
Enter the address 315 of the book‚Äôs code repository in your browser. Click on the Fork
button in the red box at the upper-right of Fig. B.3, to make a copy of the repository of this book. This is now your copy and you can change it any way you want. 315
ost
Fao
@ d2l-ai/d2l-en Public Edit Pins + @Unwateh 352 ~ ~ te Starred 15.5k 9 y <> Code ¬© Issues 58 T) Pullrequests 17¬∞ ¬©) Discussions ¬© Actions [Fj Projects ¬© Security |~ Insights
tFig. B.3
The code repository page. Now, the code repository of this book will be forked (i.e., copied) to your username, such as astonzhang/d2l-en shown at the upper-left of Fig. B.4. ¬• astonzhang/d2I-en Public <Q Pin @Wwatch o + || Y Fork ak + vy Star o ~ forked from d2l-as2l-en <> Code {] Pullrequests ¬© Actions [F Projects ¬© Security [~ Insights & Settings
tFig. B.4
The forked code repository. Cloning the Repository
To clone the repository (i.e., to make a local copy) we need to get its repository address. The green button in Fig.bubuB.5 displays this. Make sure that your local copy is up to date with the main repository if you decide to keep this fork around for longer. For now simply follow the instructions in Installation (page xxxiv) to get started. The main difference is that you are now downloading your own fork of the repository. ¬• master~ # 1branch ¬© Otags Gotofile Add file ~ Local Codespaces This branch is up to date with d2l-ai/d2I-en:master. ¬© Clone ¬Æ ¬©) astonzhang Update README.md HTTPS SSH GitHub CLI ¬Æ& github Update PULL_REQUEST_T
tFig. B.5
Cloning the repository. Contributing to This Book
1059

# Replace your_github_username with your GitHub username git clone https://github.com/your_github_username/d2l-en.git
Editing and Pushing
Now it is time to edit the book. It is best to edit it in the Jupyter Notebook following instruc- tions in Section B.1. Make the changes and check that they are OK. Assume that we have modified a typo in the file ~/d2l-en/chapter_appendix-tools-for-deep-learning/ contributing.md. You can then check which files you have changed. At this point Git will prompt that the chapter_appendix-tools-for-deep-learning/ contributing.md file has been modified. mylaptop:d2l-en me$ git status On branch master Your branch is up-to-date with 'origin/master'. Changes not staged for commit: (use "git add <file>..." to update what will be committed) (use "git checkout -- <file>..." to discard changes in working directory) modified: chapter_appendix-tools-for-deep-learning/contributing.md
After confirming that this is what you want, execute the following command:
git add chapter_appendix-tools-for-deep-learning/contributing.md
git commit -m 'Fix a typo in git documentation'
git push
The changed code will then be in your personal fork of the repository. To request the addition of your change, you have to create a pull request for the official repository of the book. Submitting Pull Requests
As shown in Fig. B.6, go to your fork of the repository on GitHub and select ‚ÄúNew pull request‚Äù. This will open up a screen that shows you the changes between your edits and what is current in the main repository of the book. ¬• astonzhang/d2I-en Public & Pin @ Watch O ~ Fork 3.4k - vy Star o + forked from d2I-ai/d2l-en <> Code {} Pullrequests ¬©) Actions ] Projects ¬© Security | Insights 3 Settings Filters ~ Q_ is:pris:open Q Labels 9 ¬© Milestones 0
tFig. B.6
New pull request. Tools for Deep Learning
1060

Finally, submit a pull request by clicking the button as shown in Fig. B.7.bubuMake sure to describe the changes you have made in the pull request. This will make it easier for the authors to review it and to merge it with the book. Depending on the changes, this might get accepted right away, rejected, or more likely, you will getsome feedbackon the changes. Once you have incorporated them, you are good to go. Comparing changes Choose two branches to see what's changed or to start a new pull request. If you need to, you can also compare across forks. 2 base repository: d2i-ai/d2l-en+ base: mastery ¬© head repository: astonzhang/d2I-en + compare: master ~ v Able to merge. These branches can be automatically merged. sees arena STENIEGC HUT EGOTTES SENSIS SoM ET
tFig. B.7
Create pull request. B.6.4 Summary
e You can use GitHub to contribute to this book. e You can edit the file on GitHub directly for minor changes. e For a major change, please fork the repository, edit things locally, and only contribute
back once you are ready. e Pull requests are how contributions are being bundled up. Try not to submit huge pull
requests since this makes them hard to understand and incorporate. Better send several smaller ones. B.6.5 Exercises
1. Star and fork the d2l-ai/d2l-en repository. 2. If you spot anything that needs improvement (e.g., missing a reference), submit a pull request. 3. It is usually a better practice to create a pull request using a new branch. Learn how to do it with Git branching316.bubu316

Discussions317. B.7 Utility Functions and Classes
317
|
This section contains the implementations of utility functions and classes used in this book. Utility Functions and Classes
1061

import collections import inspect from IPython import display from torch import nn from d2l import torch as d2l
Hyperparameters. @d2l.add_to_class(d2l.HyperParameters) #@save def save_hyperparameters(self, ignore=[]): """Save function arguments into class attributes.""" frame = inspect.currentframe().f_back _, _, _, local_vars = inspect.getargvalues(frame) self.hparams = {k:v for k, v in local_vars.items() if k not in set(ignore+['self']) and not k.startswith('_')} for k, v in self.hparams.items(): setattr(self, k, v)
Progress bar. @d2l.add_to_class(d2l.ProgressBoard) #@save def draw(self, x, y, label, every_n=1): Point = collections.namedtuple('Point', ['x', 'y']) if not hasattr(self, 'raw_points'): self.raw_points = collections.OrderedDict() self.data = collections.OrderedDict() if label not in self.raw_points: self.raw_points[label] = [] self.data[label] = [] points = self.raw_points[label] line = self.data[label] points.append(Point(x, y)) if len(points) != every_n: return mean = lambda x: sum(x) / len(x) line.append(Point(mean([p.x for p in points]), mean([p.y for p in points]))) points.clear() if not self.display: return d2l.use_svg_display() if self.fig is None: self.fig = d2l.plt.figure(figsize=self.figsize) plt_lines, labels = [], [] for (k, v), ls, color in zip(self.data.items(), self.ls, self.colors): plt_lines.append(d2l.plt.plot([p.x for p in v], [p.y for p in v], linestyle=ls, color=color)[0]) labels.append(k) axes = self.axes if self.axes else d2l.plt.gca() if self.xlim: axes.set_xlim(self.xlim) if self.ylim: axes.set_ylim(self.ylim) if not self.xlabel: self.xlabel = self.x axes.set_xlabel(self.xlabel) axes.set_ylabel(self.ylabel)
(continues on next page)
Tools for Deep Learning
1062

axes.set_xscale(self.xscale) axes.set_yscale(self.yscale) axes.legend(plt_lines, labels) display.display(self.fig) display.clear_output(wait=True)
Add FrozenLake enviroment
def frozen_lake(seed): #@save # See https://www.gymlibrary.dev/environments/toy_text/frozen_lake/ to‚ê£ ‚Ü©!learn more about this env # How to process env.P.items is adpated from https://sites.google.com/view/ ‚Ü©!deep-rl-bootcamp/labs import gym env = gym.make('FrozenLake-v1', is_slippery=False) env.seed(seed) env.action_space.np_random.seed(seed) env.action_space.seed(seed) env_info = {} env_info['desc'] = env.desc # 2D array specifying what each grid item‚ê£ ‚Ü©!means env_info['num_states'] = env.nS # Number of observations/states or obs/ ‚Ü©!state dim env_info['num_actions'] = env.nA # Number of actions or action dim # Define indices for (transition probability, nextstate, reward, done)‚ê£ ‚Ü©!tuple env_info['trans_prob_idx'] = 0 # Index of transition probability entry env_info['nextstate_idx'] = 1 # Index of next state entry env_info['reward_idx'] = 2 # Index of reward entry env_info['done_idx'] = 3 # Index of done entry env_info['mdp'] = {} env_info['env'] = env for (s, others) in env.P.items(): # others(s) = {a0: [ (p(s'|s,a0), s', reward, done),...], a1:[...], ... ‚Ü©!} for (a, pxrds) in others.items(): # pxrds is [(p1,next1,r1,d1),(p2,next2,r2,d2),..].bubu# e.g. [(0.3, 0, 0, False), (0.3, 0, 0, False), (0.3, 4, 1, False)] env_info['mdp'][(s,a)] = pxrds return env_info
Create enviroment
def make_env(name ='', seed=0): #@save # Input parameters: # name: specifies a gym environment. # For Value iteration, only FrozenLake-v1 is supported. if name == 'FrozenLake-v1': return frozen_lake(seed)
(continued from previous page)
(continues on next page)
Utility Functions and Classes
1063

else:
raise ValueError("%s env is not supported in this Notebook")
Show value function
def show_value_function_progress(env_desc, V, pi): #@save
# This function visualizes how value and policy changes over time. # V: [num_iters, num_states] # pi: [num_iters, num_states] # How to visualize value function is adapted (but changed) from: https:// ‚Ü©!sites.google.com/view/deep-rl-bootcamp/labs num_iters = V.shape[0] fig, ax = plt.subplots(figsize=(15, 15)) for k in range(V.shape[0]): plt.subplot(4, 4, k + 1) plt.imshow(V[k].reshape(4,4), cmap="bone") ax = plt.gca() ax.set_xticks(np.arange(0, 5)-.5, minor=True) ax.set_yticks(np.arange(0, 5)-.5, minor=True) ax.grid(which="minor", color="w", linestyle='-', linewidth=3) ax.tick_params(which="minor", bottom=False, left=False) ax.set_xticks([]) ax.set_yticks([]) # LEFT action: 0, DOWN action: 1 # RIGHT action: 2, UP action: 3 action2dxdy = {0:(-.25, 0),1: (0, .25), 2:(0.25, 0),3: (-.25, 0)} for y in range(4): for x in range(4): action = pi[k].reshape(4,4)[y, x] dx, dy = action2dxdy[action] if env_desc[y,x].decode() == 'H': ax.text(x, y, str(env_desc[y,x].decode()), ha="center", va="center", color="y", size=20, fontweight='bold') elif env_desc[y,x].decode() == 'G': ax.text(x, y, str(env_desc[y,x].decode()), ha="center", va="center", color="w", size=20, fontweight='bold') else: ax.text(x, y, str(env_desc[y,x].decode()), ha="center", va="center", color="g", size=15, fontweight='bold') # No arrow for cells with G and H labels
if env_desc[y,x].decode() != 'G' and env_desc[y,x].decode() !=
(continued from previous page)
(continues on next page)
Tools for Deep Learning
1064

‚Ü©!'H': ax.arrow(x, y, dx, dy, color='r', head_width=0.2, head_ ‚Ü©!length=0.15) ax.set_title("Step = " + str(k + 1), fontsize=20) fig.tight_layout() plt.show()
Show Q function
def show_Q_function_progress(env_desc, V_all, pi_all): #@save # This function visualizes how value and policy changes over time. # V: [num_iters, num_states] # pi: [num_iters, num_states] # We want to only shows few values num_iters_all = V_all.shape[0] num_iters = num_iters_all // 10 vis_indx = np.arange(0, num_iters_all, num_iters).tolist() vis_indx.append(num_iters_all - 1) V = np.zeros((len(vis_indx), V_all.shape[1])) pi = np.zeros((len(vis_indx), V_all.shape[1])) for c, i in enumerate(vis_indx): V[c] = V_all[i] pi[c] = pi_all[i] num_iters = V.shape[0] fig, ax = plt.subplots(figsize=(15, 15)) for k in range(V.shape[0]): plt.subplot(4, 4, k + 1) plt.imshow(V[k].reshape(4,4), cmap="bone") ax = plt.gca() ax.set_xticks(np.arange(0, 5)-.5, minor=True) ax.set_yticks(np.arange(0, 5)-.5, minor=True) ax.grid(which="minor", color="w", linestyle='-', linewidth=3) ax.tick_params(which="minor", bottom=False, left=False) ax.set_xticks([]) ax.set_yticks([]) # LEFT action: 0, DOWN action: 1 # RIGHT action: 2, UP action: 3 action2dxdy = {0:(-.25, 0),1:(0, .25), 2:(0.25, 0),3:(-.25, 0)} for y in range(4): for x in range(4): action = pi[k].reshape(4,4)[y, x] dx, dy = action2dxdy[action] if env_desc[y,x].decode() == 'H':
(continued from previous page)
(continues on next page)
Utility Functions and Classes
1065

ax.text(x, y, str(env_desc[y,x].decode()), ha="center", va="center", color="y", size=20, fontweight='bold') elif env_desc[y,x].decode() == 'G': ax.text(x, y, str(env_desc[y,x].decode()), ha="center", va="center", color="w", size=20, fontweight='bold') else: ax.text(x, y, str(env_desc[y,x].decode()), ha="center", va="center", color="g", size=15, fontweight='bold') # No arrow for cells with G and H labels if env_desc[y,x].decode() != 'G' and env_desc[y,x].decode() != ‚Ü©!'H': ax.arrow(x, y, dx, dy, color='r', head_width=0.2, head_ ‚Ü©!length=0.15) ax.set_title("Step = " + str(vis_indx[k] + 1), fontsize=20) fig.tight_layout() plt.show()
Trainer
A bunch of functions that will be deprecated:
def load_array(data_arrays, batch_size, is_train=True): #@save """Construct a PyTorch data iterator.""" dataset = torch.utils.data.TensorDataset(*data_arrays) return torch.utils.data.DataLoader(dataset, batch_size, shuffle=is_train) def synthetic_data(w, b, num_examples): #@save """Generate y = Xw + b + noise.""" X = torch.normal(0, 1, (num_examples, len(w))) y = torch.matmul(X, w) + b y += torch.normal(0, 0.01, y.shape) return X, y.reshape((-1, 1)) def sgd(params, lr, batch_size): #@save """Minibatch stochastic gradient descent.""" with torch.no_grad(): for param in params: param -= lr * param.grad / batch_size param.grad.zero_() def get_dataloader_workers(): #@save """Use 4 processes to read the data.""" return 4 def load_data_fashion_mnist(batch_size, resize=None): #@save """Download the Fashion-MNIST dataset and then load it into memory."""
(continued from previous page)
(continues on next page)
Tools for Deep Learning
1066

(continued from previous page) trans = [transforms.ToTensor()] if resize: trans.insert(0, transforms.Resize(resize)) trans = transforms.Compose(trans) mnist_train = torchvision.datasets.FashionMNIST( root="../data", train=True, transform=trans, download=True) mnist_test = torchvision.datasets.FashionMNIST( root="../data", train=False, transform=trans, download=True) return (torch.utils.data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers()), torch.utils.data.DataLoader(mnist_test, batch_size, shuffle=False, num_workers=get_dataloader_workers())) def evaluate_accuracy_gpu(net, data_iter, device=None): #@save """Compute the accuracy for a model on a dataset using a GPU.""" if isinstance(net, nn.Module): net.eval() # Set the model to evaluation mode if not device: device = next(iter(net.parameters())).device # No. of correct predictions, no.bubuof predictions metric = d2l.Accumulator(2) with torch.no_grad(): for X, y in data_iter: if isinstance(X, list): # Required for BERT Fine-tuning (to be covered later) X = [x.to(device) for x in X] else: X = X.to(device) y = y.to(device) metric.add(d2l.accuracy(net(X), y), y.numel()) return metric[0] / metric[1] #@save def train_ch6(net, train_iter, test_iter, num_epochs, lr, device): """Train a model with a GPU (defined in Chapter 6).""" def init_weights(m): if type(m) == nn.Linear or type(m) == nn.Conv2d: nn.init.xavier_uniform_(m.weight) net.apply(init_weights) print('training on', device) net.to(device) optimizer = torch.optim.SGD(net.parameters(), lr=lr) loss = nn.CrossEntropyLoss() animator = d2l.Animator(xlabel='epoch', xlim=[1, num_epochs], legend=['train loss', 'train acc', 'test acc']) timer, num_batches = d2l.Timer(), len(train_iter) for epoch in range(num_epochs): # Sum of training loss, sum of training accuracy, no. of examples metric = d2l.Accumulator(3) net.train() for i, (X, y) in enumerate(train_iter): timer.start() optimizer.zero_grad()
(continues on next page)
Utility Functions and Classes
1067

X, y = X.to(device), y.to(device) y_hat = net(X) l = loss(y_hat, y) l.backward() optimizer.step() with torch.no_grad(): metric.add(l * X.shape[0], d2l.accuracy(y_hat, y), X.shape[0]) timer.stop() train_l = metric[0] / metric[2] train_acc = metric[1] / metric[2] if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (train_l, train_acc, None)) test_acc = evaluate_accuracy_gpu(net, test_iter) animator.add(epoch + 1, (None, None, test_acc)) print(f'loss {train_l:.3f}, train acc {train_acc:.3f}, ' f'test acc {test_acc:.3f}') print(f'{metric[2] * num_epochs / timer.sum():.1f} examples/sec ' f'on {str(device)}')
f'on {str(device)}') def show_images(imgs, num_rows, num_cols, titles=None, scale=1.5): #@save """Plot a list of images.""" figsize = (num_cols * scale, num_rows * scale) _, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize) axes = axes.flatten() for i, (ax, img) in enumerate(zip(axes, imgs)): try: img = img.detach().numpy() except: pass ax.imshow(img) ax.axes.get_xaxis().set_visible(False) ax.axes.get_yaxis().set_visible(False) if titles: ax.set_title(titles[i]) return axes
def linreg(X, w, b): #@save """The linear regression model.""" return torch.matmul(X, w) + b def squared_loss(y_hat, y): #@save """Squared loss.""" return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2 def get_fashion_mnist_labels(labels): #@save """Return text labels for the Fashion-MNIST dataset.""" text_labels = ['t-shirt', 'trouser', 'pullover', 'dress', 'coat', 'sandal', 'shirt', 'sneaker', 'bag', 'ankle boot'] return [text_labels[int(i)] for i in labels] class Animator: #@save """For plotting data in animation."""
class Animator: #@save """For plotting data in animation."""
(continued from previous page)
(continues on next page)
Tools for Deep Learning
1068

def __init__(self, xlabel=None, ylabel=None, legend=None, xlim=None, ylim=None, xscale='linear', yscale='linear', fmts=('-', 'm--', 'g-.', 'r:'), nrows=1, ncols=1, figsize=(3.5, 2.5)): # Incrementally plot multiple lines if legend is None: legend = [] d2l.use_svg_display() self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize) if nrows * ncols == 1: self.axes = [self.axes, ] # Use a lambda function to capture arguments self.config_axes = lambda: d2l.set_axes( self.axes[0], xlabel, ylabel, xlim, ylim, xscale, yscale, legend) self.X, self.Y, self.fmts = None, None, fmts def add(self, x, y): # Add multiple data points into the figure if not hasattr(y, "__len__"): y = [y] n = len(y) if not hasattr(x, "__len__"): x = [x] * n if not self.X: self.X = [[] for _ in range(n)] if not self.Y: self.Y = [[] for _ in range(n)] for i, (a, b) in enumerate(zip(x, y)): if a is not None and b is not None: self.X[i].append(a) self.Y[i].append(b) self.axes[0].cla() for x, y, fmt in zip(self.X, self.Y, self.fmts): self.axes[0].plot(x, y, fmt) self.config_axes() display.display(self.fig) display.clear_output(wait=True) class Accumulator: #@save """For accumulating sums over `n` variables.""" def __init__(self, n): self.data = [0.0] * n def add(self, *args): self.data = [a + float(b) for a, b in zip(self.data, args)] def reset(self): self.data = [0.0] * len(self.data) def __getitem__(self, idx): return self.data[idx] def accuracy(y_hat, y): #@save """Compute the number of correct predictions."""
(continued from previous page)
(continues on next page)
Utility Functions and Classes
1069

if len(y_hat.shape) > 1 and y_hat.shape[1] > 1: y_hat = y_hat.argmax(axis=1) cmp = y_hat.type(y.dtype) == y return float(cmp.type(y.dtype).sum())
import hashlib
import os
import tarfile import zipfile import requests def download(url, folder='../data', sha1_hash=None): #@save """Download a file to folder and return the local filepath.""" if not url.startswith('http'): # For back compatability url, sha1_hash = DATA_HUB[url] os.makedirs(folder, exist_ok=True) fname = os.path.join(folder, url.split('/')[-1]) # Check if hit cache if os.path.exists(fname) and sha1_hash: sha1 = hashlib.sha1() with open(fname, 'rb') as f: while True: data = f.read(1048576) if not data: break sha1.update(data) if sha1.hexdigest() == sha1_hash: return fname # Download print(f'Downloading {fname} from {url}...') r = requests.get(url, stream=True, verify=True) with open(fname, 'wb') as f: f.write(r.content) return fname def extract(filename, folder=None): #@save """Extract a zip/tar file into folder.""" base_dir = os.path.dirname(filename) _, ext = os.path.splitext(filename) assert ext in ('.zip', '.tar', '.gz'), 'Only support zip/tar files.' if ext == '.zip': fp = zipfile.ZipFile(filename, 'r') else: fp = tarfile.open(filename, 'r') if folder is None: folder = base_dir fp.extractall(folder)
def download_extract(name, folder=None): #@save """Download and extract a zip/tar file.""" fname = download(name)
(continued from previous page)
(continues on next page)
Tools for Deep Learning
1070

base_dir = os.path.dirname(fname)
data_dir, ext = os.path.splitext(fname)
if ext == '.zip':
fp = zipfile.ZipFile(fname, 'r')
elif ext in ('.tar', '.gz'):
fp = tarfile.open(fname, 'r')
else:
assert False, 'Only zip/tar files can be extracted.'
fp.extractall(base_dir)
return os.path.join(base_dir, folder) if folder else data_dir
def tokenize(lines, token='word'): #@save """Split text lines into word or character tokens.""" assert token in ('word', 'char'), 'Unknown token type: ' + token return [line.split() if token == 'word' else list(line) for line in lines]
def evaluate_loss(net, data_iter, loss): #@save """Evaluate the loss of a model on the given dataset.""" metric = d2l.Accumulator(2) # Sum of losses, no. of examples for X, y in data_iter: out = net(X) y = y.reshape(out.shape) l = loss(out, y) metric.add(l.sum(), l.numel()) return metric[0] / metric[1]
def grad_clipping(net, theta): #@save """Clip the gradient.""" if isinstance(net, nn.Module): params = [p for p in net.parameters() if p.requires_grad] else: params = net.params norm = torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params)) if norm > theta: for param in params: param.grad[:] *= theta / norm
More for the attention chapter. #@save d2l.DATA_HUB['fra-eng'] = (d2l.DATA_URL + 'fra-eng.zip', '94646ad1522d915e7b0f9296181140edcf86a4f5') #@save def read_data_nmt(): """Load the English-French dataset.""" data_dir = d2l.download_extract('fra-eng') with open(os.path.join(data_dir, 'fra.txt'), 'r', encoding='utf-8') as f: return f.read() #@save
(continued from previous page)
(continues on next page)
Utility Functions and Classes
1071

def preprocess_nmt(text): """Preprocess the English-French dataset.""" def no_space(char, prev_char): return char in set(',.!?') and prev_char != ' ' # Replace non-breaking space with space, and convert uppercase letters to # lowercase ones text = text.replace('\u202f', ' ').replace('\xa0', ' ').lower() # Insert space between words and punctuation marks out = [' ' + char if i > 0 and no_space(char, text[i - 1]) else char for i, char in enumerate(text)] return ''.join(out) #@save def tokenize_nmt(text, num_examples=None): """Tokenize the English-French dataset.""" source, target = [], [] for i, line in enumerate(text.split('\n')): if num_examples and i > num_examples: break parts = line.split('\t') if len(parts) == 2: source.append(parts[0].split(' ')) target.append(parts[1].split(' ')) return source, target #@save def truncate_pad(line, num_steps, padding_token): """Truncate or pad sequences.""" if len(line) > num_steps: return line[:num_steps] # Truncate return line + [padding_token] * (num_steps - len(line)) # Pad #@save def build_array_nmt(lines, vocab, num_steps): """Transform text sequences of machine translation into minibatches.""" lines = [vocab[l] for l in lines] lines = [l + [vocab['<eos>']] for l in lines] array = torch.tensor([truncate_pad( l, num_steps, vocab['<pad>']) for l in lines]) valid_len = (array != vocab['<pad>']).type(torch.int32).sum(1) return array, valid_len #@save def load_data_nmt(batch_size, num_steps, num_examples=600): """Return the iterator and the vocabularies of the translation dataset.""" text = preprocess_nmt(read_data_nmt()) source, target = tokenize_nmt(text, num_examples) src_vocab = d2l.Vocab(source, min_freq=2, reserved_tokens=['<pad>', '<bos>', '<eos>']) tgt_vocab = d2l.Vocab(target, min_freq=2, reserved_tokens=['<pad>', '<bos>', '<eos>'])
(continued from previous page)
(continues on next page)
Tools for Deep Learning
1072

src_array, src_valid_len = build_array_nmt(source, src_vocab, num_steps) tgt_array, tgt_valid_len = build_array_nmt(target, tgt_vocab, num_steps) data_arrays = (src_array, src_valid_len, tgt_array, tgt_valid_len) data_iter = d2l.load_array(data_arrays, batch_size) return data_iter, src_vocab, tgt_vocab
return data_iter, src_vocab, tgt_vocab #@save def sequence_mask(X, valid_len, value=0): """Mask irrelevant entries in sequences.""" maxlen = X.size(1) mask = torch.arange((maxlen), dtype=torch.float32, device=X.device)[None, :] < valid_len[:, None] X[~mask] = value return X #@save class MaskedSoftmaxCELoss(nn.CrossEntropyLoss): """The softmax cross-entropy loss with masks.""" # `pred` shape: (`batch_size`, `num_steps`, `vocab_size`) # `label` shape: (`batch_size`, `num_steps`) # `valid_len` shape: (`batch_size`,) def forward(self, pred, label, valid_len): weights = torch.ones_like(label) weights = sequence_mask(weights, valid_len) self.reduction='none' unweighted_loss = super(MaskedSoftmaxCELoss, self).forward( pred.permute(0, 2, 1), label) weighted_loss = (unweighted_loss * weights).mean(dim=1) return weighted_loss #@save def train_seq2seq(net, data_iter, lr, num_epochs, tgt_vocab, device): """Train a model for sequence to sequence.""" def xavier_init_weights(m): if type(m) == nn.Linear: nn.init.xavier_uniform_(m.weight) if type(m) == nn.GRU: for param in m._flat_weights_names: if "weight" in param: nn.init.xavier_uniform_(m._parameters[param]) net.apply(xavier_init_weights) net.to(device) optimizer = torch.optim.Adam(net.parameters(), lr=lr) loss = MaskedSoftmaxCELoss() net.train() animator = d2l.Animator(xlabel='epoch', ylabel='loss', xlim=[10, num_epochs]) for epoch in range(num_epochs): timer = d2l.Timer() metric = d2l.Accumulator(2) # Sum of training loss, no. of tokens for batch in data_iter: optimizer.zero_grad() X, X_valid_len, Y, Y_valid_len = [x.to(device) for x in batch]
(continued from previous page)
(continues on next page)
Utility Functions and Classes
1073

bos = torch.tensor([tgt_vocab['<bos>']] * Y.shape[0], device=device).reshape(-1, 1) dec_input = torch.cat([bos, Y[:, :-1]], 1) # Teacher forcing Y_hat, _ = net(X, dec_input, X_valid_len) l = loss(Y_hat, Y, Y_valid_len) l.sum().backward() # Make the loss scalar for `backward` d2l.grad_clipping(net, 1) num_tokens = Y_valid_len.sum() optimizer.step() with torch.no_grad(): metric.add(l.sum(), num_tokens) if (epoch + 1) % 10 == 0: animator.add(epoch + 1, (metric[0] / metric[1],)) print(f'loss {metric[0] / metric[1]:.3f}, {metric[1] / timer.stop():.1f} ' f'tokens/sec on {str(device)}') #@save def predict_seq2seq(net, src_sentence, src_vocab, tgt_vocab, num_steps, device, save_attention_weights=False): """Predict for sequence to sequence.""" # Set `net` to eval mode for inference net.eval() src_tokens = src_vocab[src_sentence.lower().split(' ')] + [ src_vocab['<eos>']] enc_valid_len = torch.tensor([len(src_tokens)], device=device) src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab['<pad>']) # Add the batch axis enc_X = torch.unsqueeze( torch.tensor(src_tokens, dtype=torch.long, device=device), dim=0) enc_outputs = net.encoder(enc_X, enc_valid_len) dec_state = net.decoder.init_state(enc_outputs, enc_valid_len) # Add the batch axis dec_X = torch.unsqueeze(torch.tensor( [tgt_vocab['<bos>']], dtype=torch.long, device=device), dim=0) output_seq, attention_weight_seq = [], [] for _ in range(num_steps): Y, dec_state = net.decoder(dec_X, dec_state) # We use the token with the highest prediction likelihood as input # of the decoder at the next time step dec_X = Y.argmax(dim=2) pred = dec_X.squeeze(dim=0).type(torch.int32).item() # Save attention weights (to be covered later) if save_attention_weights: attention_weight_seq.append(net.decoder.attention_weights) # Once the end-of-sequence token is predicted, the generation of the # output sequence is complete if pred == tgt_vocab['<eos>']: break output_seq.append(pred) return ' '.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq
(continued from previous page)
Tools for Deep Learning
1074

B.8 The d2l API Document
|
This section displays classes and functions (sorted alphabetically) in the d2l package, showing where they are defined in the book so you can find more detailed implementa- tions and explanations.bubuSee also the source code on the GitHub repository318.bubu318
B.8.1 Classes
class d2l.torch.AdditiveAttention(num_hiddens, dropout, **kwargs)
Bases: Module
Additive attention. Defined in Section 11.3.2
forward(queries, keys, values, valid_lens)
Defines the computation performed at every call. Should be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.AddNorm(norm_shape, dropout)
Bases: Module
The residual connection followed by layer normalization. Defined in Section 11.7.2
forward(X, Y)
Defines the computation performed at every call.bubuShould be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.AttentionDecoder
Bases: Decoder (page 1075)
The base attention-based decoder interface. The d2l API Document
1075
Defined in Section 11.4 property attention_weights class d2l.torch.Classifier(plot_train_per_epoch=2, plot_valid_per_epoch=1) Bases: Module (page 1078) The base class of classification models. Defined in Section 4.3 accuracy(Y_hat, Y, averaged=True) Compute the number of correct predictions. Defined in Section 4.3 layer_summary(X_shape) Defined in Section 7.6 loss(Y_hat, Y, averaged=True) Defined in Section 4.5 validation_step(batch) class d2l.torch.DataModule(root=‚Äô../data‚Äô, num_workers=4) Bases: HyperParameters (page 1077) The base class of data. Defined in Section 3.2.2 get_dataloader(train) get_tensorloader(tensors, train, indices=slice(0, None, None)) Defined in Section 3.3 train_dataloader() val_dataloader()

class d2l.torch.Decoder
Bases: Module
The base decoder interface for the encoder‚Äìdecoder architecture. Defined in Section 10.6
forward(X, state)
Defines the computation performed at every call.bubuShould be overridden by all subclasses. Tools for Deep Learning
1076

Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. init_state(enc_all_outputs, *args)
class d2l.torch.DotProductAttention(dropout)
Bases: Module
Scaled dot product attention. Defined in Section 11.3.2
forward(queries, keys, values, valid_lens=None)
Defines the computation performed at every call.bubuShould be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.Encoder
Bases: Module
The base encoder interface for the encoder‚Äìdecoder architecture. Defined in Section 10.6
forward(X, *args)
Defines the computation performed at every call.bubuShould be overridden by all subclasses.bubuNote: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.EncoderDecoder(encoder, decoder)
Bases: Classifier (page 1075)
The base class for the encoder‚Äìdecoder architecture. Defined in Section 10.6
The d2l API Document
1077

forward(enc_X, dec_X, *args)
Defines the computation performed at every call. Should be overridden by all subclasses.bubuNote: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. predict_step(batch, device, num_steps, save_attention_weights=False)
Defined in Section 10.7.6
class d2l.torch.FashionMNIST(batch_size=64, resize=(28, 28))
Bases: DataModule (page 1075)
The Fashion-MNIST dataset. Defined in Section 4.2
get_dataloader(train)
Defined in Section 4.2
text_labels(indices)
Return text labels. Defined in Section 4.2
visualize(batch, nrows=1, ncols=8, labels=[])
Defined in Section 4.2
class d2l.torch.GRU(num_inputs, num_hiddens, num_layers, dropout=0)
Bases: RNN (page 1081)
The multilayer GRU model. Defined in Section 10.3
class d2l.torch.HyperParameters
Bases: object
The base class of hyperparameters. save_hyperparameters(ignore=[])
Save function arguments into class attributes. Defined in Section B.7
Tools for Deep Learning
1078

class d2l.torch.LeNet(lr=0.1, num_classes=10) Bases: Classifier (page 1075) The LeNet-5 model. Defined in Section 7.6 class d2l.torch.LinearRegression(lr) Bases: Module (page 1078) The linear regression model implemented with high-level APIs. Defined in Section 3.5 configure_optimizers() Defined in Section 3.5 forward(X) Defined in Section 3.5 get_w_b() Defined in Section 3.5 loss(y_hat, y) Defined in Section 3.5 class d2l.torch.LinearRegressionScratch(num_inputs, lr, sigma=0.01) Bases: Module (page 1078) The linear regression model implemented from scratch. Defined in Section 3.4 configure_optimizers() Defined in Section 3.4 forward(X) Defined in Section 3.4 loss(y_hat, y) Defined in Section 3.4
class d2l.torch.Module(plot_train_per_epoch=2, plot_valid_per_epoch=1)
Bases: Module, HyperParameters (page 1077)
The base class of models. Defined in Section 3.2
apply_init(inputs, init=None)
Defined in Section 6.4
The d2l API Document
1079

configure_optimizers()
Defined in Section 4.3
forward(X)
Defines the computation performed at every call. Should be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. loss(y_hat, y) plot(key, value, train) Plot a point in animation. training_step(batch) validation_step(batch) class d2l.torch.MTFraEng(batch_size, num_steps=9, num_train=512, num_val=128) Bases: DataModule (page 1075) The English-French dataset. Defined in Section 10.5 build(src_sentences, tgt_sentences) Defined in Section 10.5.3 get_dataloader(train) Defined in Section 10.5.3 class d2l.torch.MultiHeadAttention(num_hiddens, num_heads, dropout, bias=False, **kwargs) Bases: Module (page 1078) Multi-head attention. Defined in Section 11.5 forward(queries, keys, values, valid_lens) Defines the computation performed at every call. Should be overridden by all subclasses. Tools for Deep Learning
1080

Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. transpose_output(X)
Reverse the operation of transpose_qkv. Defined in Section 11.5
transpose_qkv(X)
Transposition for parallel computation of multiple attention heads. Defined in Section 11.5
class d2l.torch.PositionalEncoding(num_hiddens, dropout, max_len=1000)
Bases: Module
Positional encoding. Defined in Section 11.6
forward(X)
Defines the computation performed at every call.bubuShould be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.PositionWiseFFN(ffn_num_hiddens, ffn_num_outputs)
Bases: Module
The positionwise feed-forward network. Defined in Section 11.7
forward(X)
Defines the computation performed at every call.bubuShould be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. The d2l API Document
1081

class d2l.torch.ProgressBoard(xlabel=None, ylabel=None, xlim=None,
ylim=None, xscale=‚Äôlinear‚Äô, yscale=‚Äôlinear‚Äô,
ls=[‚Äô-‚Äô, ‚Äô--‚Äô, ‚Äô-.‚Äô, ‚Äô:‚Äô], colors=[‚ÄôC0‚Äô, ‚ÄôC1‚Äô, ‚ÄôC2‚Äô,
‚ÄôC3‚Äô], fig=None, axes=None, figsize=(3.5, 2.5),
display=True)
Bases: HyperParameters (page 1077)
The board that plots data points in animation. Defined in Section 3.2
draw(x, y, label, every_n=1)
Defined in Section B.7
class d2l.torch.Residual(num_channels, use_1x1conv=False, strides=1)
Bases: Module
The Residual block of ResNet models. Defined in Section 8.6
forward(X)
Defines the computation performed at every call. Should be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.ResNeXtBlock(num_channels, groups, bot_mul,
use_1x1conv=False, strides=1)
Bases: Module
The ResNeXt block. Defined in Section 8.6.2
forward(X)
Defines the computation performed at every call. Should be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. Tools for Deep Learning
1082

class d2l.torch.RNN(num_inputs, num_hiddens)
Bases: Module (page 1078)
The RNN model implemented with high-level APIs. Defined in Section 9.6
forward(inputs, H=None)
Defines the computation performed at every call.bubuShould be overridden by all subclasses.bubuNote: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.RNNLM(rnn, vocab_size, lr=0.01)
Bases: RNNLMScratch (page 1082)
The RNN-based language model implemented with high-level APIs. Defined in Section 9.6
init_params()
output_layer(hiddens)
Defined in Section 9.5
class d2l.torch.RNNLMScratch(rnn, vocab_size, lr=0.01)
Bases: Classifier (page 1075)
The RNN-based language model implemented from scratch. Defined in Section 9.5
forward(X, state=None)
Defined in Section 9.5
init_params()
one_hot(X)
Defined in Section 9.5
output_layer(rnn_outputs)
Defined in Section 9.5
predict(prefix, num_preds, vocab, device=None)
Defined in Section 9.5
The d2l API Document
1083

training_step(batch)
validation_step(batch)
class d2l.torch.RNNScratch(num_inputs, num_hiddens, sigma=0.01)
Bases: Module (page 1078)
The RNN model implemented from scratch. Defined in Section 9.5
forward(inputs, state=None)
Defined in Section 9.5
class d2l.torch.Seq2Seq(encoder, decoder, tgt_pad, lr)
Bases: EncoderDecoder (page 1076)
The RNN encoder‚Äìdecoder for sequence to sequence learning. Defined in Section 10.7.3
configure_optimizers()
Defined in Section 4.3
validation_step(batch)
class d2l.torch.Seq2SeqEncoder(vocab_size, embed_size, num_hiddens,
Bases: Encoder (page 1076)
The RNN encoder for sequence-to-sequence learning. Defined in Section 10.7
forward(X, *args)
Defines the computation performed at every call.bubuShould be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.SGD(params, lr)
Bases: HyperParameters (page 1077)
Minibatch stochastic gradient descent. Defined in Section 3.4
num_layers, dropout=0)
Tools for Deep Learning
1084

step()
zero_grad()
class d2l.torch.SoftmaxRegression(num_outputs, lr)
Bases: Classifier (page 1075)
The softmax regression model. Defined in Section 4.5
forward(X)
Defines the computation performed at every call. Should be overridden by all subclasses. Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.SyntheticRegressionData(w, b, noise=0.01, num_train=1000, num_val=1000, batch_size=32)
Bases: DataModule (page 1075) Synthetic data for linear regression. Defined in Section 3.3 get_dataloader(train) Defined in Section 3.3 class d2l.torch.TimeMachine(batch_size, num_steps, num_train=10000, num_val=5000) Bases: DataModule (page 1075) The Time Machine dataset. Defined in Section 9.2 build(raw_text, vocab=None) Defined in Section 9.2 get_dataloader(train) Defined in Section 9.3.3 class d2l.torch.Trainer(max_epochs, num_gpus=0, gradient_clip_val=0) Bases: HyperParameters (page 1077) The base class for training models with data. The d2l API Document
1085

Defined in Section 3.2.2 clip_gradients(grad_clip_val, model) Defined in Section 9.5 fit(model, data) fit_epoch() Defined in Section 3.4 prepare_batch(batch) Defined in Section 6.7 prepare_data(data) prepare_model(model) Defined in Section 6.7 class d2l.torch.TransformerEncoder(vocab_size, num_hiddens, ffn_num_hiddens, num_heads, num_blks, dropout, use_bias=False) Bases: Encoder (page 1076) The Transformer encoder. Defined in Section 11.7.4 forward(X, valid_lens) Defines the computation performed at every call.bubuShould be overridden by all subclasses.bubuNote: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.TransformerEncoderBlock(num_hiddens, ffn_num_hiddens, num_heads, dropout, use_bias=False)
Bases: Module
The Transformer encoder block. Defined in Section 11.7.2
forward(X, valid_lens)
Defines the computation performed at every call. Should be overridden by all subclasses. Tools for Deep Learning
1086

Note: Although the recipe for forward pass needs to be defined within this function, one should call the Module (page 1078) instance afterwards instead of this since the formertakescareofrunningtheregisteredhookswhilethelattersilentlyignoresthem. class d2l.torch.Vocab(tokens=[], min_freq=0, reserved_tokens=[])
Bases: object
Vocabulary for text. to_tokens(indices)
property unk
B.8.2 Functions
d2l.torch.add_to_class(Class)
Register functions as methods in created class. Defined in Section 3.2
d2l.torch.bleu(pred_seq, label_seq, k)
Compute the BLEU. Defined in Section 10.7.6
d2l.torch.check_len(a, n)
Check the length of a list. Defined in Section 9.5
d2l.torch.check_shape(a, shape)
Check the shape of a tensor. Defined in Section 9.5
d2l.torch.corr2d(X, K)
Compute 2D cross-correlation. Defined in Section 7.2
d2l.torch.cpu()
Get the CPU device. Defined in Section 6.7
d2l.torch.gpu(i=0)
Get a GPU device. Defined in Section 6.7
The d2l API Document
1087

d2l.torch.init_cnn(module)
Initialize weights for CNNs. Defined in Section 7.6
d2l.torch.init_seq2seq(module)
Initialize weights for sequence-to-sequence learning. Defined in Section 10.7
d2l.torch.masked_softmax(X, valid_lens)
Perform softmax operation by masking elements on the last axis. Defined in Section 11.3
d2l.torch.num_gpus()
Get the number of available GPUs. Defined in Section 6.7
d2l.torch.plot(X, Y=None, xlabel=None, ylabel=None, legend=[], xlim=None, ylim=None, xscale=‚Äôlinear‚Äô, yscale=‚Äôlinear‚Äô, fmts=(‚Äô-‚Äô, ‚Äôm--‚Äô, ‚Äôg-.‚Äô, ‚Äôr:‚Äô), figsize=(3.5, 2.5), axes=None)
Plot data points. Defined in Section 2.4
d2l.torch.set_axes(axes, xlabel, ylabel, xlim, ylim, xscale, yscale, legend)
Set the axes for matplotlib. Defined in Section 2.4
d2l.torch.set_figsize(figsize=(3.5, 2.5))
Set the figure size for matplotlib. Defined in Section 2.4
d2l.torch.show_heatmaps(matrices, xlabel, ylabel, titles=None, figsize=(2.5, 2.5), cmap=‚ÄôReds‚Äô)
Show heatmaps of matrices. Defined in Section 11.1
d2l.torch.show_list_len_pair_hist(legend, xlabel, ylabel, xlist, ylist)
Plot the histogram for list length pairs. Defined in Section 10.5
d2l.torch.try_all_gpus()
Return all available GPUs, or [cpu(),] if no GPU exists. Defined in Section 6.7
1088

d2l.torch.try_gpu(i=0)
Return gpu(i) if exists, otherwise return cpu(). Defined in Section 6.7
d2l.torch.use_svg_display()
Use the svg format to display a plot in Jupyter. Defined in Section 2.4
Tools for Deep Learning
References
Abadi, M., Barham, P., Chen, J., Chen, Z., Davis, A., Dean, J., ‚Ä¶ et al.bubu(2016). Tensor- Flow: a system for large-scale machine learning. 12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16) (pp.bubu265‚Äì283). Abdel-Hamid, O., Mohamed, A.-R., Jiang, H., Deng, L., Penn, G., & Yu, D.bubu(2014). Con- volutional neural networks for speech recognition. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 22(10), 1533‚Äì1545. Ahmed, A., Aly, M., Gonzalez, J., Narayanamurthy, S., & Smola, A. J.bubu(2012). Scalable inference in latent variable models. Proceedings of the Fifth ACM International Confer- ence on Web Search and Data Mining (pp. 123‚Äì132).bubuAkiba, T., Sano, S., Yanase, T., Ohta, T., & Koyama, M.bubu(2019). Optuna: a next-generation hyperparameter optimization framework. Proceedings of the 25th ACM SIGKDD Inter- national Conference on Knowledge Discovery & Data Mining. Alayrac, J.-B., Donahue, J., Luc, P., Miech, A., Barr, I., Hasson, Y., ‚Ä¶ et al.bubu(2022). Flamingo: a visual language model for few-shot learning. ArXiv:2204.14198.bubuAlsallakh, B., Kokhlikyan, N., Miglani, V., Yuan, J., & Reblitz-Richardson, O.bubu(2020). Mind the PAD ‚Äì CNNs can develop blind spots. ArXiv:2010.02178.bubuAnil, R., Dai, A. M., Firat, O., Johnson, M., Lepikhin, D., Passos, A., ‚Ä¶ et al. (2023). PaLM 2 Technical Report. ArXiv:2305.10403. Anil, R., Gupta, V., Koren, T., Regan, K., & Singer, Y. (2020). Scalable second-order optimization for deep learning. ArXiv:2002.09018.bubuAronszajn, N. (1950). Theory of reproducing kernels. Transactions of the American Math- ematical Society, 68(3), 337‚Äì404. Ba, J.bubuL., Kiros, J. R., & Hinton, G. E.bubu(2016). Layer normalization. ArXiv:1607.06450. Baevski, A., & Auli, M.bubu(2018). Adaptive input representations for neural language mod- eling. International Conference on Learning Representations. Bahdanau, D., Cho, K., &Bengio, Y.(2014).Neuralmachinetranslationbyjointlylearning to align and translate. ArXiv:1409.0473.bubuBai, Y., Kadavath, S., Kundu, S., Askell, A., Kernion, J., Jones, A., ‚Ä¶ et al.bubu(2022). Con- stitutional AI: harmlessness from AI feedback. ArXiv:2212.08073.bubuBaptista, R., & Poloczek, M. (2018). Bayesian optimization of combinatorial structures. Proceedings of the 35th International Conference on Machine Learning. Bardenet, R., Brendel, M., K√©gl, B., & Sebag, M. (2013). Collaborative hyperparam- eter tuning. Proceedings of the 30th International Conference on Machine Learning (ICML‚Äô13). Bay, H., Tuytelaars, T., & Van Gool, L. (2006). SURF: Speeded up robust features. Euro- pean Conference on Computer Vision (pp. 404‚Äì417).bubu1089
REFERENCES
1090

Bellman, R. (1966). Dynamic programming. Science, 153, 34‚Äì37. Bellman, R.bubu(1952). On the theory of dynamic programming. Proceedings of the National Academy of Sciences, 38(8), 716‚Äì719. Bellman, R. (1957). A Markovian decision process. Journal of Mathematics and Mechan- ics, 6(5), 679‚Äì684. URL: http://www.jstor.org/stable/24900506
Bellman, R. (1957). Dynamic Programming. Dover Publications.bubuBeltagy, I., Peters, M. E., & Cohan, A.bubu(2020). Longformer: the long-document trans- former. ArXiv:2004.05150. Bengio, Y., Ducharme, R., Vincent, P., &Jauvin, C.(2003).Aneuralprobabilisticlanguage model. Journal of Machine Learning Research, 3(Feb), 1137‚Äì1155. Bengio, Y., Simard, P., & Frasconi, P. (1994). Learning long-term dependencies with gra- dient descent is difficult. IEEE Transactions on Neural Networks, 5(2), 157‚Äì166. Bergstra, J., Bardenet, R., Bengio, Y., & K√©gl, B. (2011). Algorithms for hyper-parameter optimization. Advances in Neural Information Processing Systems, 24. Bergstra, J., Breuleux, O., Bastien, F., Lamblin, P., Pascanu, R., Desjardins, G., ‚Ä¶ Ben- gio, Y.bubu(2010). Theano: a CPU and GPU math compiler in Python. Proc. 9th Python in Science Conference (pp. 3‚Äì10).bubuBeutel, A., Murray, K., Faloutsos, C., & Smola, A. J.bubu(2014). CoBaFi: collaborative Bayesianfiltering. Proceedings of the23rdInternational Conferenceon WorldWideWeb (pp.bubu97‚Äì108).bubuBishop, C. M.bubu(1995). Training with noise is equivalent to Tikhonov regularization. Neural Computation, 7(1), 108‚Äì116. Bishop, C.bubuM.bubu(2006). Pattern Recognition and Machine Learning. Springer.bubuBlack, F., & Scholes, M. (1973). The pricing of options and corporate liabilities. Journal of Political Economy, 81, 637‚Äì654. Bodla, N., Singh, B., Chellappa, R., & Davis, L. S.bubu(2017). Soft-NMS-improving object detection with one line of code. Proceedings of the IEEE International Conference on Computer Vision (pp. 5561‚Äì5569).bubuBojanowski, P., Grave, E., Joulin, A., & Mikolov, T.bubu(2017). Enriching word vectors with subword information. Transactions of the Association for Computational Linguistics, 5, 135‚Äì146. Bollob√°s, B. (1999). Linear Analysis. Cambridge University Press. Bommasani, R., Hudson, D. A., Adeli, E., Altman, R., Arora, S., von Arx, S., ‚Ä¶ et al. (2021). On the opportunities and risks of foundation models. ArXiv:2108.07258. Bottou, L. (2010). Large-scale machine learning with stochastic gradient descent. Proceed- ings of COMPSTAT‚Äô2010 (pp.bubu177‚Äì186). Springer. Bottou, L., & Le Cun, Y.bubu(1988). SN: a simulator for connectionist models. Proceedings of NeuroNimes 88 (pp. 371‚Äì382).bubuNimes, France. URL: http://leon.bottou.org/papers/ bottou-lecun-88
Boucheron, S., Bousquet, O., & Lugosi, G. (2005). Theory of classification: a survey of some recent advances. ESAIM: Probability and Statistics, 9, 323‚Äì375. Bowman, S.bubuR., Angeli, G., Potts, C., & Manning, C. D.bubu(2015). A large annotated corpus for learning natural language inference. ArXiv:1508.05326.bubuBoyd, S., & Vandenberghe, L. (2004). Convex Optimization. Cambridge, England: Cambridge University Press. REFERENCES
1091

Bradley, R. A., & Terry, M.bubuE.bubu(1952). Rank analysis of incomplete block designs: I. The method of paired comparisons. Biometrika, 39(3/4), 324‚Äì345. Brown, N., & Sandholm, T.bubu(2017). Libratus: the superhuman AI for no-limit poker. IJCAI (pp.bubu5226‚Äì5228). Brown, P. F., Cocke, J., Della Pietra, S. A., Della Pietra, V. J., Jelinek, F., Lafferty, J., ‚Ä¶ Roossin, P. S.bubu(1990). A statistical approach to machine translation. Computational Linguistics, 16(2), 79‚Äì85. Brown, P.bubuF., Cocke, J., Della Pietra, S. A., Della Pietra, V. J., Jelinek, F., Mercer, R. L., & Roossin, P.bubu(1988). A statistical approach to language translation. COLING Budapest 1988 Volume 1: International Conference on Computational Linguistics. Brown, T., Mann, B., Ryder, N., Subbiah, M., Kaplan, J.bubuD., Dhariwal, P., ‚Ä¶ et al.bubu(2020). Language models are few-shot learners. Advances in Neural Information Processing Sys- tems, 33, 1877‚Äì1901. Buslaev, A., Iglovikov, V. I., Khvedchenya, E., Parinov, A., Druzhinin, M., & Kalinin, A. A.bubu(2020). Albumentations: Fast and flexible image augmentations. Information, 11(2), 125.bubuCampbell, M., Hoane Jr, A. J., & Hsu, F.-h. (2002). Deep blue. Artificial Intelligence, 134(1-2), 57‚Äì83. Canny, J.bubu(1987). A computational approach to edge detection. Readings in Computer Vi- sion (pp. 184‚Äì203).bubuElsevier. Cer, D., Diab, M., Agirre, E., Lopez-Gazpio, I., & Specia, L.bubu(2017). SemEval-2017 Task 1: semantictextualsimilarity multilingual and crosslingual focusedevaluation. Proceed- ings of the 11th International Workshop on Semantic Evaluation (SemEval-2017) (pp. 1‚Äì 14).bubuChan, W., Jaitly, N., Le, Q. V., & Vinyals, O. (2015). Listen, attend and spell. ArXiv:1508.01211. Chen, L., Lu, K., Rajeswaran, A., Lee, K., Grover, A., Laskin, M., ‚Ä¶ Mordatch, I.bubu(2021). Decision transformer: reinforcement learning via sequence modeling. Advances in Neu- ral Information Processing Systems, 34, 15084‚Äì15097. Chen, T., Li, M., Li, Y., Lin, M., Wang, N., Wang, M., ‚Ä¶ Zhang, Z.bubu(2015). MXNET: a flexible and efficient machine learning library for heterogeneous distributed systems. ArXiv:1512.01274.bubuCheng, J., Dong, L., & Lapata, M.bubu(2016). Long short-term memory-networks for machine reading.Proceedingsofthe2016ConferenceonEmpiricalMethodsinNaturalLanguage Processing (pp. 551‚Äì561).bubuChetlur, S., Woolley, C., Vandermersch, P., Cohen, J., Tran, J., Catanzaro, B., &Shelhamer, E.bubu(2014). CuDNN: Efficient primitives for deep learning. ArXiv:1410.0759.bubuCho, K., Van Merri√´nboer, B., Bahdanau, D., & Bengio, Y.bubu(2014). On the properties of neural machine translation: Encoder‚Äìdecoder approaches. ArXiv:1409.1259.bubuCho, K., Van Merri√´nboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., & Bengio, Y.bubu(2014). Learning phrase representations using RNN encoder‚Äìdecoder for statistical machine translation. ArXiv:1406.1078.bubuChowdhery, A., Narang, S., Devlin, J., Bosma, M., Mishra, G., Roberts, A., ‚Ä¶etal.(2022). PaLM: scaling language modeling with pathways. ArXiv:2204.02311.bubuREFERENCES
1092

Chung, J., Gulcehre, C., Cho, K., & Bengio, Y.bubu(2014). Empirical evaluation of gated re- current neural networks on sequence modeling. ArXiv:1412.3555.bubuClark, K., Luong, M.-T., Le, Q. V., & Manning, C.bubuD.bubu(2020). ELECTRA: pre-training text encoders as discriminators rather than generators. International Conference on Learning Representations. Collobert, R., Weston, J., Bottou, L., Karlen, M., Kavukcuoglu, K., & Kuksa, P. (2011). Natural language processing (almost) from scratch. Journal of Machine Learning Re- search, 12, 2493‚Äì2537. Cordonnier, J.-B., Loukas, A., & Jaggi, M. (2020). On the relationship between self- attention and convolutional layers. International Conference on Learning Representa- tions. Cover, T., & Thomas, J. (1999). Elements of Information Theory. John Wiley & Sons. Csisz√°r, I.bubu(2008). Axiomatic characterizations of information measures. Entropy, 10(3), 261‚Äì273. Cybenko, G.bubu(1989). Approximation by superpositions of a sigmoidal function. Mathemat- ics of Control, Signals and Systems, 2(4), 303‚Äì314. Dalal, N., & Triggs, B.bubu(2005). Histograms of oriented gradients for human detection. 2005 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR‚Äô05) (pp. 886‚Äì893).bubuDe Cock, D.bubu(2011). Ames, Iowa: alternative to the Boston housing data as an end of semester regression project. Journal of Statistics Education, 19(3).bubuDean, J., Corrado, G. S., Monga, R., Chen, K., Devin, M., Le, Q. V., ‚Ä¶ et al.bubu(2012). Large scale distributed deep networks. Proceedings of the 25th International Conference on Neural Information Processing Systems, Volume 1 (pp. 1223‚Äì1231).bubuDeCandia, G., Hastorun, D., Jampani, M., Kakulapati, G., Lakshman, A., Pilchin, A., ‚Ä¶ Vogels, W.bubu(2007). Dynamo: Amazon‚Äôs highly available key-value store. ACM SIGOPS Operating Systems Review (pp. 205‚Äì220). Deng, J., Dong, W., Socher, R., Li, L.-J., Li, K., & Fei-Fei, L.bubu(2009). Imagenet: a large- scale hierarchical image database. 2009 IEEE Conference on Computer Vision and Pat- tern Recognition (pp. 248‚Äì255).bubuDer Kiureghian, A., & Ditlevsen, O. (2009). Aleatory or epistemic? does it matter? Struc- tural Safety, 31(2), 105‚Äì112. Devlin, J., Chang, M.-W., Lee, K., & Toutanova, K.bubu(2018). BERT: Pre-training of deep bidirectional transformers for language understanding. ArXiv:1810.04805.bubuDinh, L., Krueger, D., & Bengio, Y.bubu(2014). NICE: non-linear independent components estimation. ArXiv:1410.8516.bubuDinh, L., Sohl-Dickstein, J., & Bengio, S.bubu(2017). Density estimation using real NVP. In- ternational Conference on Learning Representations. Doersch, C., Gupta, A., & Efros, A. A.bubu(2015). Unsupervised visual representation learning by context prediction. Proceedings of the IEEE International Conference on Computer Vision (pp. 1422‚Äì1430).bubuDosovitskiy, A., Beyer, L., Kolesnikov, A., Weissenborn, D., Zhai, X., Unterthiner, T., ‚Ä¶ et al.bubu(2021). An image is worth 16 x 16 words: transformers for image recognition at scale. International Conference on Learning Representations.bubuREFERENCES
1093

Duchi, J., Hazan, E., &Singer, Y.(2011). Adaptivesubgradient methodsforonlinelearning and stochastic optimization. Journal of Machine Learning Research, 12, 2121‚Äì2159. Dumoulin, V., & Visin, F. (2016). A guide to convolution arithmetic for deep learning. ArXiv:1603.07285.bubuDwivedi, V. P., & Bresson, X.bubu(2020). A generalization of transformer networks to graphs. ArXiv:2012.09699.bubuDwork, C., Feldman, V., Hardt, M., Pitassi, T., Reingold, O., & Roth, A. L.bubu(2015). Pre- serving statistical validity in adaptive data analysis. Proceedings of the 47th Annual ACM Symposium on Theory of Computing (pp. 117‚Äì126).bubuElman, J. L.bubu(1990). Finding structure in time. Cognitive Science, 14(2), 179‚Äì211. Elsken, T., Metzen, J. H., & Hutter, F.bubu(2018). Neural architecture search: a ssurvey. ArXiv:1808.05377 [stat.ML].bubuFechner, G. T. (1860). Elemente der Psychophysik. Vol. 2. Breitkopf u. H√§rtel. Fedus, W., Zoph, B., & Shazeer, N.bubu(2022). Switch transformers: scaling to trillion param- eter models with simple and efficient sparsity. Journal of Machine Learning Research, 23(120), 1‚Äì39. Fernando, R.(2004).GPUGems: ProgrammingTechniques,Tips,andTricksforReal-Time Graphics. Addison-Wesley.bubuFeurer, M., & Hutter, F.bubu(2018). Hyperparameter ptimization. Automatic Machine Learn- ing: Methods, Systems, Challenges. Springer.bubuFeurer, M., Letham, B., Hutter, F., & Bakshy, E.bubu(2022). Practical transfer learning for Bayesian optimization. ArXiv:1802.02219 [stat.ML].bubuField, D. J.bubu(1987). Relations between the statistics of natural images and the response properties of cortical cells. JOSA A, 4(12), 2379‚Äì2394.bubuFisher, R. A. (1925). Statistical Methods for Research Workers. Oliver & Boyd. Flammarion, N., & Bach, F.bubu(2015). From averaging to acceleration, there is only a step- size. Conference on Learning Theory (pp.bubu658‚Äì695).bubuForrester, A. I., S√≥bester, A., & Keane, A. J.bubu(2007). Multi-fidelity optimization via surro- gate modelling. Proceedings of the Royal Society A: Mathematical, Physical and Engi- neering Sciences, 463(2088), 3251‚Äì3269. Franceschi, L., Donini, M., Frasconi, P., &Pontil, M.(2017).Forwardandreversegradient- based hyperparameter optimization. Proceedings of the 34th International Conference on Machine Learning (ICML‚Äô17). Frankle, J., & Carbin, M. (2018). The lottery ticket hypothesis: finding sparse, trainable neural networks. ArXiv:1803.03635.bubuFrazier, P. I.bubu(2018). A tutorial on Bayesian optimization. ArXiv:1807.02811. Freund, Y., & Schapire, R. E.bubu(1996). Experiments with a new boosting algorithm. Pro- ceedings of the International Conference on Machine Learning (pp. 148‚Äì156).bubuFriedman, J. H.bubu(1987). Exploratory projection pursuit. Journal of the American Statistical Association, 82(397), 249‚Äì266. Frostig, R., Johnson, M. J., & Leary, C.bubu(2018). Compiling machine learning programs via high-level tracing. Proceedings of Systems for Machine Learning. Fukushima, K. (1982). Neocognitron: a self-organizing neural network model for a mechanism of visual pattern recognition. Competition and Cooperation in Neural Nets (pp. 267‚Äì285).bubuSpringer. REFERENCES
1094

Gardner, J., Pleiss, G., Weinberger, K. Q., Bindel, D., & Wilson, A. G.bubu(2018). GPyTorch: blackbox matrix‚Äìmatrix Gaussian process inference with GPU acceleration. Advances in Neural Information Processing Systems. Garg, S., Balakrishnan, S., Kolter, Z., & Lipton, Z. (2021). RATT: leveraging unla- beled data to guarantee generalization. International Conference on Machine Learning (pp. 3598‚Äì3609).bubuGatys, L. A., Ecker, A. S., & Bethge, M.bubu(2016). Image style transfer using convolutional neural networks. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 2414‚Äì2423).bubuGauss, C. F.bubu(1809). Theoria motus corporum coelestum. Werke. K√∂niglich Preussische Akademie der Wissenschaften. Gibbs, J. W.bubu(1902). Elementary Principles of Statistical Mhanics. Scribner‚Äôs. Ginibre, J.bubu(1965). Statistical ensembles of complex, quaternion, and real matrices. Journal of Mathematical Physics, 6(3), 440‚Äì449. Girshick, R.bubu(2015). Fast R-CNN. Proceedings of the IEEE International Conference on Computer Vision (pp. 1440‚Äì1448).bubuGirshick, R., Donahue, J., Darrell, T., & Malik, J.bubu(2014). Rich feature hierarchies for ac- curate object detection and semantic segmentation. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 580‚Äì587).bubuGlorot, X., & Bengio, Y.bubu(2010). Understanding the difficulty of training deep feedforward neural networks. Proceedings of the 13th International Conference on Artificial Intelli- gence and Statistics (pp. 249‚Äì256).bubuGoh, G.bubu(2017). Why momentum really works. Distill. URL: http://distill.pub/2017/ momentum
Goldberg, D., Nichols, D., Oki, B. M., & Terry, D.bubu(1992). Using collaborative filtering to weave an information tapestry. Communications of the ACM, 35(12), 61‚Äì71.bubuGolub, G. H., & Van Loan, C. F.bubu(1996). Matrix Computations. Johns Hopkins University Press. Goodfellow, I., Bengio, Y., &Courville, A.(2016).DeepLearning.MITPress.http://www. deeplearningbook.org. Goodfellow, I., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., ‚Ä¶ Ben- gio, Y. (2014). Generative adversarial nets. Advances in Neural Information Processing Systems (pp. 2672‚Äì2680).bubuGotmare, A., Keskar, N. S., Xiong, C., & Socher, R.bubu(2018). A closer look at deep learning heuristics: learning rate restarts, warmup and distillation. ArXiv:1810.13243.bubuGoyal, A., Bochkovskiy, A., Deng, J., & Koltun, V. (2021). Non-deep networks. ArXiv:2110.07641. Graham, B.bubu(2014). Fractional max-pooling. ArXiv:1412.6071. Graves, A.(2013).Generatingsequenceswithrecurrentneuralnetworks.ArXiv:1308.0850. Graves, A., Liwicki, M., Fern√°ndez, S., Bertolami, R., Bunke, H., & Schmidhuber, J. (2008). A novel connectionist system for unconstrained handwriting recognition. IEEE
Transactions on Pattern Analysis and Machine Intelligence, 31(5), 855‚Äì868. Graves,A.,&Schmidhuber,J.(2005).Framewisephonemeclassificationwithbidirectional LSTM and other neural network architectures. Neural Networks, 18(5-6), 602‚Äì610. REFERENCES
1095

Griewank, A. (1989). On automatic differentiation. Mathematical Programming: Recent Developments and Applications (pp. 83‚Äì107).bubuKluwer. Gulati, A., Qin, J., Chiu, C.-C., Parmar, N., Zhang, Y., Yu, J., ‚Ä¶ et al.bubu(2020). Con- former: convolution-augmented transformer for speech recognition. Proc.bubuInterspeech 2020, pp. 5036‚Äì5040. Guyon, I., Gunn, S., Nikravesh, M., & Zadeh, L. A.bubu(2008). Feature Extraction: Founda- tions and Applications. Springer.bubuHadjis, S., Zhang, C., Mitliagkas, I., Iter, D., & R√©, C.bubu(2016). Omnivore: an optimizer for multi-device deep learning on CPUs and GPUs. ArXiv:1606.04487.bubuHartley, R., & Zisserman, A. (2000). Multiple View Geometry in Computer Vision. Cambridge University Press.bubuHartley, R. I., & Kahl, F.bubu(2009). Global optimization through rotation space search. Inter- national Journal of Computer Vision, 82(1), 64‚Äì79. He, K., Chen, X., Xie, S., Li, Y., Doll√°r, P., &Girshick, R.(2022).Maskedautoencodersare scalable vision learners. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 16000‚Äì16009).bubuHe, K., Gkioxari, G., Doll√°r, P., & Girshick, R.bubu(2017). Mask R-CNN. Proceedings of the IEEE International Conference on Computer Vision (pp. 2961‚Äì2969).bubuHe, K., Zhang, X., Ren, S., & Sun, J.bubu(2015). Delving deep into rectifiers: surpassing human-level performance on ImageNet classification. Proceedings of the IEEE Interna- tional Conference on Computer Vision (pp. 1026‚Äì1034).bubuHe, K., Zhang, X., Ren, S., & Sun, J.bubu(2016). Deep residual learning for image recogni- tion. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 770‚Äì778).bubuHe, K., Zhang, X., Ren, S., & Sun, J.bubu(2016). Identity mappings in deep residual networks. European Conference on Computer Vision (pp. 630‚Äì645).bubuHebb, D. O.bubu(1949). The Organization of Behavior. Wiley. Hendrycks, D., & Gimpel, K.bubu(2016). Gaussian error linear units (GELUs). ArXiv:1606.08415.bubuHennessy, J. L., & Patterson, D. A.bubu(2011). Computer Architecture: A Quantitative Ap- proach. Elsevier.bubuHo, J., Jain, A., & Abbeel, P.bubu(2020). Denoising diffusion probabilistic models. Advances in Neural Information Processing Systems, 33, 6840‚Äì6851. Hochreiter, S., Bengio, Y., Frasconi, P., & Schmidhuber, J. (2001). Gradient flow in recur- rent nets: the difficulty of learning long-term dependencies. A Field Guide to Dynamical Recurrent Neural Networks. IEEE Press.bubuHochreiter, S., & Schmidhuber, J. (1997). Long short-term memory. Neural Computation, 9(8), 1735‚Äì1780. Hoffmann, J., Borgeaud, S., Mensch, A., Buchatskaya, E., Cai, T., Rutherford, E., ‚Ä¶ et al. (2022). Training compute-optimal large language models. ArXiv:2203.15556.bubuHoward, A., Sandler, M., Chu, G., Chen, L.-C., Chen, B., Tan, M., ‚Ä¶ Adam, H. (2019). Searching for MobileNetV3. Proceedings of the IEEE/CVF International Conference on Computer Vision (pp. 1314‚Äì1324).bubuREFERENCES
1096

Hoyer, P. O., Janzing, D., Mooij, J. M., Peters, J., & Sch√∂lkopf, B.bubu(2009). Nonlinear causal discovery with additive noise models. Advances in Neural Information Processing Sys- tems (pp. 689‚Äì696).bubuHu, J., Shen, L., & Sun, G.bubu(2018). Squeeze-and-excitation networks. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 7132‚Äì7141). Hu, Y., Koren, Y., & Volinsky, C.bubu(2008). Collaborative filtering for implicit feedback datasets. 2008 8th IEEE International Conference on Data Mining (pp. 263‚Äì272). Hu, Z., Lee, R. K.-W., Aggarwal, C. C., & Zhang, A.bubu(2022). Text style transfer: a review and experimental evaluation. SIGKDD Explor.bubuNewsl., 24(1). URL: https://doi.org/10. 1145/3544903.3544906
Huang, C.-Z. A., Vaswani, A., Uszkoreit, J., Simon, I., Hawthorne, C., Shazeer, N., ‚Ä¶ Eck, D.bubu(2018). Music transformer: generating music with long-term structure. International Conference on Learning Representations. Huang, G., Liu, Z., Van Der Maaten, L., & Weinberger, K. Q.bubu(2017). Densely connected convolutional networks. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 4700‚Äì4708).bubuHuang, Z., Xu, W., & Yu, K.bubu(2015). Bidirectional LSTM‚ÄìCRF models for sequence tag- ging. ArXiv:1508.01991.bubuHubel, D. H., & Wiesel, T. N.bubu(1959). Receptive fields of single neurones in the cat‚Äôs striate cortex. Journal of Physiology, 148(3), 574‚Äì591.bubuHubel, D. H., & Wiesel, T. N.bubu(1962). Receptive fields, binocular interaction and functional architecture in the cat‚Äôs visual cortex. Journal of Physiology, 160(1), 106‚Äì154.bubuHubel, D. H., & Wiesel, T. N.bubu(1968). Receptive fields and functional architecture of mon- key striate cortex. Journal of Physiology, 195(1), 215‚Äì243. Hutter, F., Hoos, H., & Leyton-Brown, K.bubu(2011). Sequential model-based optimization for general algorithm configuration. Proceedings of the Fifth International Conference on Learning and Intelligent Optimization (LION‚Äô11). Hutter, F., Kotthoff, L., & Vanschoren, J. (Eds.) (2019). Automated Machine Learning: Methods, Systems, Challenges. Springer.bubuIoffe, S.bubu(2017). Batch renormalization: towards reducing minibatch dependence in batch- normalized models. Advances in Neural Information Processing Systems (pp. 1945‚Äì 1953).bubuIoffe, S., & Szegedy, C.bubu(2015). Batch normalization: accelerating deep network training by reducing internal covariate shift. ArXiv:1502.03167.bubuIzmailov, P., Podoprikhin, D., Garipov, T., Vetrov, D., & Wilson, A. G.bubu(2018). Averaging weights leads to wider optima and better generalization. ArXiv:1803.05407.bubuJacot, A., Gabriel, F., & Hongler, C.bubu(2018). Neural tangent kernel: convergence and gen- eralization in neural networks. Advances in Neural Information Processing Systems. Jaeger, H. (2002). Tutorial on training recurrent neural networks, covering BPPT, RTRL, EKF and the ‚Äúecho state network‚Äù approach. GMD-Forschungszentrum Information- stechnik Bonn.bubuJamieson, K., & Talwalkar, A.bubu(2016). Non-stochastic best arm identification and hyper- parameter optimization. Proceedings of the 17th International Conference on Artificial Intelligence and Statistics. REFERENCES
1097

Jenatton, R., Archambeau, C., Gonz√°lez, J., & Seeger, M. (2017). Bayesian optimization with tree-structured dependencies. Proceedings of the 34th International Conference on Machine Learning (ICML‚Äô17). Jia, X., Song, S., He, W., Wang, Y., Rong, H., Zhou, F., ‚Ä¶ et al.bubu(2018). Highly scalable deep learning training system with mixed-precision: training ImageNet in four minutes. ArXiv:1807.11205.bubuJia, Y., Shelhamer, E., Donahue, J., Karayev, S., Long, J., Girshick, R., ‚Ä¶ Darrell, T.bubu(2014). Caffe: convolutional architecture for fast feature embedding. Proceedings of the 22nd ACM International Conference on Multimedia (pp.bubu675‚Äì678).bubuJoshi, M., Chen, D., Liu, Y., Weld, D. S., Zettlemoyer, L., & Levy, O.bubu(2020). SpanBERT: improving pre-training by representing and predicting spans. Transactions of the Asso- ciation for Computational Linguistics, 8, 64‚Äì77. Jouppi, N. P., Young, C., Patil, N., Patterson, D., Agrawal, G., Bajwa, R., ‚Ä¶ et al.bubu(2017). In-datacenter performance analysis of a tensor processing unit. 2017 ACM/IEEE 44th Annual International Symposium on Computer Architecture (ISCA) (pp. 1‚Äì12). Kalchbrenner, N., Grefenstette, E., & Blunsom, P.bubu(2014). A convolutional neural network for modelling sentences. ArXiv:1404.2188.bubuKalman, B. L., & Kwasny, S. C.bubu(1992). Why tanh: choosing a sigmoidal function. Pro- ceedings of the International Joint Conference on Neural Networks (IJCNN) (pp. 578‚Äì 581).bubuKaplan, J., McCandlish, S., Henighan, T., Brown, T. B., Chess, B., Child, R., ‚Ä¶ Amodei, D.bubu(2020). Scaling laws for neural language models. ArXiv:2001.08361. Karnin, Z., Koren, T., & Somekh, O.bubu(2013). Almost optimal exploration in multi- armed bandits. Proceedings of the 30th International Conference on Machine Learning (ICML‚Äô13). Karras, T., Aila, T., Laine, S., & Lehtinen, J. (2017). Progressive growing of GANs for improved quality, stability, and variation. ArXiv:1710.10196.bubuKim, J., El-Khamy, M., & Lee, J.bubu(2017). Residual LSTM: design of a deep recurrent architecture for distant speech recognition. ArXiv:1701.03360.bubuKim, Y.bubu(2014). Convolutional neural networks for sentence classification. ArXiv:1408.5882.bubuKimeldorf, G. S., & Wahba, G.bubu(1971). Some results on Tchebycheffian spline functions. J.bubuMath. Anal. Appl., 33, 82‚Äì95. Kingma, D. P., & Ba, J.bubu(2014). Adam: a method for stochastic optimization. ArXiv:1412.6980.bubuKingma, D. P., & Welling, M.bubu(2014). Auto-encoding variational Bayes. International Con- ference on Learning Representations (ICLR). Kipf, T.bubuN., & Welling, M.bubu(2016). Semi-supervised classification with graph convolutional networks. ArXiv:1609.02907.bubuKojima, T., Gu, S. S., Reid, M., Matsuo, Y., & Iwasawa, Y.bubu(2022). Large language models are zero-shot reasoners. arxiv.org/abs/2205.11916.bubuKoller, D., & Friedman, N. (2009). Probabilistic Graphical Models: Principles and Tech- niques. MIT Press.bubuKolmogorov, A. (1933). Sulla determinazione empirica di una legge di distribuzione. Inst.bubuItal. Attuari, Giorn., 4, 83‚Äì91. REFERENCES
1098

Kolter, Z. (2008). Linear algebra review and reference. Available http://cs229.stanford.edu/section/cs229-linalg.pdf. online:
Krizhevsky, A., Sutskever, I., & Hinton, G.bubuE.bubu(2012). ImageNet classification with deep convolutional neural networks. Advances in Neural Information Processing Systems (pp. 1097‚Äì1105).bubuKung, S. Y.bubu(1988). VLSI Array Processors. Prentice Hall.bubuKuzovkin, I., Vicente, R., Petton, M., Lachaux, J.-P., Baciu, M., Kahane, P., ‚Ä¶ Aru, J.bubu(2018). Activations of deep convolutional neural networks are aligned with gamma band activity of human visual cortex. Communications Biology, 1(1), 1‚Äì12.bubuLan, Z., Chen, M., Goodman, S., Gimpel, K., Sharma, P., & Soricut, R.bubu(2019). ALBERT: a lite BERT for self-supervised learning of language representations. ArXiv:1909.11942.bubuLavin, A., & Gray, S.bubu(2016). Fast algorithms for convolutional neural networks. Proceed- ings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 4013‚Äì 4021).bubuLe, Q.bubuV.bubu(2013). Building high-level features using large scale unsupervised learning. Pro- ceedingsoftheIEEEInternationalConferenceonAcoustics, SpeechandSignalProcess- ing (pp. 8595‚Äì8598).bubuLeCun, Y., Bengio, Y., & et al.bubu(1995). Convolutional networks for images, speech, and time series. The Handbook of Brain Theory and Neural Networks (p. 3361).bubuMIT Press. LeCun, Y., Boser, B., Denker, J.bubuS., Henderson, D., Howard, R. E., Hubbard, W., & Jackel, L.D.(1989).Backpropagationappliedtohandwrittenzipcoderecognition.NeuralCom- putation, 1(4), 541‚Äì551. LeCun, Y., Bottou, L., Orr, G., & Muller, K.-R. (1998). Efficient backprop. Neural Net- works: Tricks of the Trade. Springer.bubuLeCun, Y., Bottou, L., Bengio, Y., & Haffner, P.bubu(1998). Gradient-based learning applied to document recognition. Proceedings of the IEEE, 86(11), 2278‚Äì2324.bubuLeCun, Y., Jackel, L., Bottou, L., Brunot, A., Cortes, C., Denker, J., ‚Ä¶ et al.bubu(1995). Com- parison of learning algorithms for handwritten digit recognition. International Confer- ence on Artificial Neural Networks (pp. 53‚Äì60).bubuLegendre, A. M.bubu(1805). M√©moire sur les Op√©rations Trigonom√©triques: dont les R√©sultats D√©pendent de la Figure de la Terre. F.bubuDidot. Lewis, M., Liu, Y., Goyal, N., Ghazvininejad, M., Mohamed, A., Levy, O., ‚Ä¶ Zettlemoyer, L.bubu(2019). BART: denoising sequence-to-sequence pre-training for natural language gen- eration, translation, and comprehension. ArXiv:1910.13461.bubuLewkowycz, A., Andreassen, A., Dohan, D., Dyer, E., Michalewski, H., Ramasesh, V., ‚Ä¶ et al.bubu(2022). Solving quantitative reasoning problems with language models. ArXiv:2206.14858.bubuLi, L., Jamieson, K., Rostamizadeh, A., Gonina, K., Hardt, M., Recht, B., & Talwalkar, A. (2018). Massively parallel hyperparameter tuning. ArXiv:1810.05934. Li, M.(2017).ScalingDistributedMachineLearningwithSystemandAlgorithmCo-design (Doctoral dissertation). PhD Thesis, CMU. Li, M., Andersen, D. G., Park, J. W., Smola, A. J., Ahmed, A., Josifovski, V., ‚Ä¶ Su, B.-Y.bubu(2014). Scaling distributed machine learning with the parameter server. 11th Symposium on Operating Systems Design and Implementation (OSDI 14) (pp. 583‚Äì598). REFERENCES
1099

Li, M., Zhang, T., Chen, Y., & Smola, A. J.bubu(2014). Efficient mini-batch training for stochastic optimization. Proceedings of the 20th ACM SIGKDD International Confer- ence on Knowledge Discovery and Data Mining (pp. 661‚Äì670).bubuLiaw, R., Liang, E., Nishihara, R., Moritz, P., Gonzalez, J., & Stoica, I.bubu(2018). Tune: a research platform for distributed model selection and training. ArXiv:1807.05118. Lin, M., Chen, Q., & Yan, S. (2013). Network in network. ArXiv:1312.4400. Lin, T.-Y., Goyal, P., Girshick, R., He, K., & Doll√°r, P.bubu(2017). Focal loss for dense ob- ject detection. Proceedings of the IEEE International Conference on Computer Vision (pp. 2980‚Äì2988). Lin, Y., Lv, F., Zhu, S., Yang, M., Cour, T., Yu, K., ‚Ä¶ others.bubu(2010). ImageNet classifi- cation: fast descriptor coding and large-scale SVM training. Large Scale Visual Recog- nition Challenge. Lin, Z., Feng, M., Santos, C.bubuN. d., Yu, M., Xiang, B., Zhou, B., & Bengio, Y.bubu(2017). A structured self-attentive sentence embedding. ArXiv:1703.03130.bubuLipton, Z. C., Berkowitz, J., & Elkan, C.bubu(2015). A critical review of recurrent neural networks for sequence learning. ArXiv:1506.00019.bubuLipton, Z. C., Kale, D. C., Elkan, C., & Wetzel, R.bubu(2016). Learning to diagnose with LSTM recurrent neural networks. International Conference on Learning Representa- tions (ICLR). Lipton, Z. C., & Steinhardt, J. (2018). Troubling trends in machine learning scholarship. Communications of the ACM, 17, 45‚Äì77. Liu, D. C., & Nocedal, J.bubu(1989). On the limited memory BFGS method for large scale optimization. Mathematical Programming, 45(1), 503‚Äì528. Liu, H., Simonyan, K., & Yang, Y.bubu(2018). DARTS: differentiable architecture search. ArXiv:1806.09055.bubuLiu, W., Anguelov, D., Erhan, D., Szegedy, C., Reed, S., Fu, C.-Y., & Berg, A. C.bubu(2016). SSD: single shot multibox detector. European Conference on Computer Vision (pp.bubu21‚Äì 37). Liu, Y., Ott, M., Goyal, N., Du, J., Joshi, M., Chen, D., ‚Ä¶ Stoyanov, V.bubu(2019). RoBERTa: a robustly optimized BERT pretraining approach. ArXiv:1907.11692.bubuLiu, Z., Lin, Y., Cao, Y., Hu, H., Wei, Y., Zhang, Z., ‚Ä¶ Guo, B.bubu(2021). Swin transformer: hierarchical vision transformer using shifted windows. Proceedings of the IEEE/CVF International Conference on Computer Vision (pp. 10012‚Äì10022).bubuLiu, Z., Mao, H., Wu, C.-Y., Feichtenhofer, C., Darrell, T., & Xie, S. (2022). A convNet for the 2020s. ArXiv:2201.03545. Long, J., Shelhamer, E., & Darrell, T.bubu(2015). Fully convolutional networks for semantic segmentation. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 3431‚Äì3440).bubuLoshchilov, I., & Hutter, F.bubu(2016). SGDR: stochastic gradient descent with warm restarts. ArXiv:1608.03983.bubuLowe, D. G.bubu(2004). Distinctive image features from scale-invariant keypoints. Interna- tional Journal of Computer Vision, 60(2), 91‚Äì110. Luo, P., Wang, X., Shao, W., & Peng, Z. (2018). Towards understanding regularization in batch normalization. ArXiv:1809.00846.bubuREFERENCES
1100

Maas, A. L., Daly, R. E., Pham, P. T., Huang, D., Ng, A. Y., & Potts, C.bubu(2011). Learn- ing word vectors for sentiment analysis. Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (pp. 142‚Äì150).bubuMack, Y.-P., & Silverman, B. W.bubu(1982). Weak and strong uniform consistency of kernel regression estimates. Zeitschrift f√ºr Wahrscheinlichkeitstheorie und verwandte Gebiete, 61(3), 405‚Äì415.bubuMacKay, D. J.bubu(2003). Information Theory, Inference and Learning Algorithms. Cambridge University Press.bubuMaclaurin, D., Duvenaud, D., & Adams, R.bubu(2015). Gradient-based hyperparameter opti- mization through reversible learning. Proceedings of the 32nd International Conference on Machine Learning (ICML‚Äô15). Mangasarian, O.bubuL.bubu(1965). Linear and nonlinear separation of patterns by linear program- ming. Oper.bubuRes., 13, 444-452. Mangram, M.E.(2013).AsimplifiedperspectiveoftheMarkowitzportfoliotheory.Global Journal of Business Research, 7(1), 59‚Äì70. Matthews, A.bubuG.bubud. G., Rowland, M., Hron, J., Turner, R. E., & Ghahramani, Z.bubu(2018). Gaussian process behaviour in wide deep neural networks. ArXiv:1804.11271.bubuMcCann, B., Bradbury, J., Xiong, C., & Socher, R.bubu(2017). Learned in translation: Contex- tualized word vectors. Advances in Neural Information Processing Systems (pp. 6294‚Äì 6305).bubuMcCulloch, W. S., & Pitts, W.bubu(1943). A logical calculus of the ideas immanent in nervous activity. Bulletin of Mathematical Biophysics, 5(4), 115‚Äì133. Mead, C. (1980). Introduction to VLSI systems. IEE Proceedings I-Solid-State and Elec- tron Devices, 128(1), 18. Merity, S., Xiong, C., Bradbury, J., & Socher, R.bubu(2016). Pointer sentinel mixture models. ArXiv:1609.07843. Micchelli, C.A.(1984).Interpolationofscattereddata: distancematricesandconditionally positive definite functions. Approximation Theory and Spline Functions (pp. 143‚Äì145).bubuSpringer. Mikolov, T., Chen, K., Corrado, G., & Dean, J.bubu(2013). Efficient estimation of word repre- sentations in vector space. ArXiv:1301.3781.bubuMikolov, T., Sutskever, I., Chen, K., Corrado, G. S., & Dean, J.bubu(2013). Distributed rep- resentations of words and phrases and their compositionality. Advances in Neural Infor- mation Processing Systems (pp. 3111‚Äì3119). Miller, G.A.(1995).WordNet: alexicaldatabaseforEnglish.CommunicationsoftheACM, 38(11), 39‚Äì41. Mirhoseini, A., Pham, H., Le, Q.bubuV., Steiner, B., Larsen, R., Zhou, Y., ‚Ä¶ Dean, J.bubu(2017). Device placement optimization with reinforcement learning. Proceedings of the 34th International Conference on Machine Learning (pp.bubu2430‚Äì2439).bubuMnih, V., Heess, N., Graves, A., & others.bubu(2014). Recurrent models of visual attention. Advances in Neural Information Processing Systems (pp. 2204‚Äì2212).bubuMnih, V., Kavukcuoglu, K., Silver, D., Graves, A., Antonoglou, I., Wierstra, D., & Ried- miller, M.bubu(2013). Playing Atari with deep reinforcement learning. ArXiv:1312.5602.bubuREFERENCES
1101

Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., ‚Ä¶ et al.bubu(2015). Human-level control through deep reinforcement learning. Nature, 518(7540), 529‚Äì533.bubuMoon, T., Smola, A., Chang, Y., & Zheng, Z.bubu(2010). Intervalrank: isotonic regression with listwise and pairwise constraints. Proceedings of the 3rd ACM International Conference on Web Search and Data Mining (pp. 151‚Äì160).bubuMorey, R. D., Hoekstra, R., Rouder, J. N., Lee, M. D., & Wagenmakers, E.-J.bubu(2016). The fallacy of placing confidence in confidence intervals. Psychonomic Bulletin & Review, 23(1), 103‚Äì123. Morozov, V. A.bubu(1984). Methods for Solving Incorrectly Posed Problems. Springer. Nadaraya, E.A.(1964).Onestimatingregression.TheoryofProbability&itsApplications, 9(1), 141‚Äì142. Nair, V., & Hinton, G. E.bubu(2010). Rectified linear units improve restricted Boltzmann ma- chines. ICML.bubuNakkiran, P., Kaplun, G., Bansal, Y., Yang, T., Barak, B., & Sutskever, I. (2021). Deep dou- ble descent: where bigger models and more data hurt. Journal of Statistical Mechanics: Theory and Experiment, 2021(12), 124003. Naor, M., & Reingold, O.bubu(1999). On the construction of pseudorandom permutations: Luby‚ÄìRackoff revisited. Journal of Cryptology, 12(1), 29‚Äì66. Neal, R. M.bubu(1996). Bayesian Learning for Neural Networks. Springer. Nesterov, Y. (2018). Lectures on Convex Optimization. Springer. Nesterov, Y., & Vial, J.-P.bubu(2000). Confidence level solutions for stochastic programming. Automatica, 44(6), 1559‚Äì1568.bubuNeyman, J.bubu(1937). Outline of a theory of statistical estimation based on the classical the- ory of probability. Philosophical Transactions of the Royal Society of London. Series A, Mathematical and Physical Sciences, 236(767), 333‚Äì380. Norelli, A., Fumero, M., Maiorca, V., Moschella, L., Rodol√†, E., & Locatello, F.bubu(2022). ASIF: coupled data turns unimodal models to multimodal without training. ArXiv:2210.01738.bubuNovak, R., Xiao, L., Lee, J., Bahri, Y., Yang, G., Hron, J., ‚Ä¶ Sohl-Dickstein, J.bubu(2018). Bayesian deep convolutional networks with many channels are Gaussian processes. ArXiv:1810.05148.bubuNovikoff, A. B.bubuJ.bubu(1962). On convergence proofs on perceptrons. Proceedings of the Sym- posium on the Mathematical Theory of Automata (pp. 615‚Äì622).bubuOlshausen, B. A., & Field, D. J.bubu(1996). Emergence of simple-cell receptive field properties by learning a sparse code for natural images. Nature, 381(6583), 607‚Äì609.bubuOng, C. S., Smola, A., & Williamson, R.bubu(2005). Learning the kernel with hyperkernels. Journal of Machine Learning Research, 6, 1043‚Äì1071. OpenAI. (2023). GPT-4 Technical Report. ArXiv:2303.08774. Ouyang, L., Wu, J., Jiang, X., Almeida, D., Wainwright, C. L., Mishkin, P., ‚Ä¶ et al.bubu(2022). Training language models to follow instructions with human feedback. ArXiv:2203.02155.bubuPapineni, K., Roukos, S., Ward, T., & Zhu, W.-J.bubu(2002). BLEU: a method for automatic evaluation of machine translation. Proceedings of the 40th Annual Meeting of the Asso- ciation for Computational Linguistics (pp. 311‚Äì318).bubuREFERENCES
1102

Parikh, A. P., T√§ckstr√∂m, O., Das, D., & Uszkoreit, J.bubu(2016). A decomposable attention model for natural language inference. ArXiv:1606.01933.bubuPark, T., Liu, M.-Y., Wang, T.-C., & Zhu, J.-Y.bubu(2019). Semantic image synthesis with spatially-adaptive normalization. Proceedings of the IEEE Conference on Computer Vi- sion and Pattern Recognition (pp. 2337‚Äì2346).bubuParzen, E.bubu(1957). On consistent estimates of the spectrum of a stationary time series. An- nals of Mathematical Statistics, 28, 329‚Äì348. Paszke, A., Gross, S., Massa, F., Lerer, A., Bradbury, J., Chanan, G., ‚Ä¶ et al.bubu(2019). Py- Torch: an imperative style, high-performance deep learning library. Advances in Neural Information Processing Systems, 32, 8026‚Äì8037. Paulus, R., Xiong, C., & Socher, R. (2017). A deep reinforced model for abstractive sum- marization. ArXiv:1705.04304.bubuPenedo, G., Malartic, Q., Hesslow, D., Cojocaru, R., Cappelli, A., Alobeidli, H., ‚Ä¶Launay, J.bubu(2023). The RefinedWeb dataset for Falcon LLM: outperforming curated corpora with web data, and web data only. ArXiv:2306.01116.bubuPennington, J., Schoenholz, S., & Ganguli, S.bubu(2017). Resurrecting the sigmoid in deep learning through dynamical isometry: theory and practice. Advances in Neural Informa- tion Processing Systems (pp.bubu4785‚Äì4795). Pennington, J., Socher, R., &Manning, C.(2014).GloVe: globalvectorsforwordrepresen- tation. Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP) (pp. 1532‚Äì1543).bubuPeters, J., Janzing, D., & Sch√∂lkopf, B.bubu(2017). Elements of Causal Inference: Foundations and Learning Algorithms. MIT Press. Peters, M., Ammar, W., Bhagavatula, C., & Power, R.bubu(2017). Semi-supervised sequence tagging with bidirectional language models. Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, Volume 1 (pp. 1756‚Äì1765). Peters, M., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee, K., & Zettlemoyer, L.bubu(2018). Deep contextualized word representations. Proceedings of the 2018 Conference oftheNorthAmericanChapteroftheAssociationforComputationalLinguistics: Human Language Technologies, Volume 1 (pp. 2227‚Äì2237).bubuPetersen, K. B., & Pedersen, M. S.bubu(2008). The Matrix Cookbook. Technical University of Denmark. Pleiss, G., Chen, D., Huang, G., Li, T., Van Der Maaten, L., & Weinberger, K. Q.bubu(2017). Memory-efficient implementation of densenets. ArXiv:1707.06990.bubuPolyak, B. T.bubu(1964). Some methods of speeding up the convergence of iteration methods. USSR Computational Mathematics and Mathematical Physics, 4(5), 1‚Äì17. Prakash, A., Hasan, S. A., Lee, K., Datla, V., Qadir, A., Liu, J., & Farri, O.bubu(2016). Neural paraphrase generation with stacked residual LSTM networks. ArXiv:1610.03098.bubuQin, C., Zhang, A., Zhang, Z., Chen, J., Yasunaga, M., & Yang, D.bubu(2023). Is ChatGPT a general-purpose natural language processing task solver? ArXiv:2302.06476.bubuQuadrana, M., Cremonesi, P., & Jannach, D.bubu(2018). Sequence-aware recommender sys- tems. ACM Computing Surveys, 51(4), 66.bubuQuinlan, J.bubuR.bubu(1993). C4.5: Programs for Machine Learning. Elsevier.bubuRabiner, L., & Juang, B.-H. (1993). Fundamentals of Speech Recognition. Prentice-Hall. REFERENCES
1103

Radford, A., Kim, J. W., Hallacy, C., Ramesh, A., Goh, G., Agarwal, S., ‚Ä¶ et al.bubu(2021). Learning transferable visual models from natural language supervision. International Conference on Machine Learning (pp.bubu8748‚Äì8763). Radford, A., Metz, L., & Chintala, S.bubu(2015). Unsupervised representation learning with deep convolutional generative adversarial networks. ArXiv:1511.06434.bubuRadford, A., Narasimhan, K., Salimans, T., & Sutskever, I.bubu(2018). Improving language understanding by generative pre-training. OpenAI.bubuRadford, A., Wu, J., Child, R., Luan, D., Amodei, D., & Sutskever, I.bubu(2019). Language models are unsupervised multitask learners. OpenAI Blog, 1(8), 9.bubuRadosavovic, I., Johnson, J., Xie, S., Lo, W.-Y., & Doll√°r, P.bubu(2019). On network design spaces for visual recognition. Proceedings of the IEEE/CVF International Conference on Computer Vision (pp. 1882‚Äì1890).bubuRadosavovic, I., Kosaraju, R. P., Girshick, R., He, K., & Doll√°r, P.bubu(2020). Designing net- work design spaces. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (pp. 10428‚Äì10436).bubuRae, J. W., Borgeaud, S., Cai, T., Millican, K., Hoffmann, J., Song, F., ‚Ä¶ et al.bubu(2021). Scaling language models: methods, analysis & insights from training gopher. ArXiv:2112.11446.bubuRaffel, C., Shazeer, N., Roberts, A., Lee, K., Narang, S., Matena, M., ‚Ä¶ Liu, P. J.bubu(2020). Exploring the limits of transfer learning with a unified text-to-text transformer. Journal of Machine Learning Research, 21, 1‚Äì67. Rajpurkar, P., Zhang, J., Lopyrev, K., & Liang, P.bubu(2016). SQuAD: 100,000+ questions for machine comprehension of text. ArXiv:1606.05250.bubuRamachandran, P., Parmar, N., Vaswani, A., Bello, I., Levskaya, A., & Shlens, J.bubu(2019). Stand-alone self-attention in vision models. Advances in Neural Information Processing Systems, 32. Ramachandran, P., Zoph, B., & Le, Q.bubuV.bubu(2017). Searching for activation functions. ArXiv:1710.05941. Ramesh, A., Dhariwal, P., Nichol, A., Chu, C., & Chen, M.bubu(2022). Hierarchical text- conditional image generation with clip latents. ArXiv:2204.06125.bubuRam√≥n y Cajal, Santiago, & Azoulay, L. (1894). Les Nouvelles Id√©es sur la Structure du Syst√®me Nerveux chez l‚ÄôHomme et chez les Vert√©br√©s. Paris, C.bubuReinwald & Cie. Ranzato, M.-A., Boureau, Y.-L., Chopra, S., & LeCun, Y.bubu(2007). A unified energy-based frameworkforunsupervisedlearning.ArtificialIntelligenceandStatistics(pp.371‚Äì379). Rasmussen, C.bubuE., & Williams, C. K.bubu(2006). Gaussian Processes for Machine Learning. MIT Press.bubuReddi, S. J., Kale, S., & Kumar, S.bubu(2019). On the convergence of Adam and beyond. ArXiv:1904.09237. Redmon, J., Divvala, S., Girshick, R., & Farhadi, A.bubu(2016). You only look once: unified, real-time object detection. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 779‚Äì788).bubuRedmon, J., & Farhadi, A.bubu(2018). YOLOv3: an incremental improvement. ArXiv:1804.02767.bubuReed, S., & De Freitas, N.bubu(2015). Neural programmer-interpreters. ArXiv:1511.06279. REFERENCES
1104

Reed, S., Zolna, K., Parisotto, E., Colmenarejo, S. G., Novikov, A., Barth-Maron, G., ‚Ä¶ et al.bubu(2022). A generalist agent. ArXiv:2205.06175. Ren, S., He, K., Girshick, R., & Sun, J.bubu(2015). Faster R-CNN: towards real-time object detection with region proposal networks. Advances in Neural Information Processing Systems (pp. 91‚Äì99).bubuRevels, J., Lubin, M., & Papamarkou, T.bubu(2016). Forward-mode automatic differentiation in Julia. ArXiv:1607.07892.bubuRezende, D. J., Mohamed, S., & Wierstra, D.bubu(2014). Stochastic backpropagation and ap- proximate inference in deep generative models. International Conference on Machine Learning (pp. 1278‚Äì1286).bubuRiesenhuber, M., & Poggio, T.bubu(1999). Hierarchical models of object recognition in cortex. Nature Neuroscience, 2(11), 1019‚Äì1025. Rockafellar, R. T.bubu(1970). Convex Analysis. Princeton University Press. Rolnick, D., Veit, A., Belongie, S., & Shavit, N.bubu(2017). Deep learning is robust to massive label noise. ArXiv:1705.10694.bubuRudin, W. (1973). Functional Analysis. McGraw-Hill.bubuRumelhart, D. E., Hinton, G. E., & Williams, R. J.bubu(1988). Learning representations by back-propagating errors. Cognitive Modeling, 5(3), 1. Russakovsky, O., Deng, J., Huang, Z., Berg, A. C., & Fei-Fei, L.bubu(2013). Detecting avoca- dos to zucchinis: what have we done, and where are we going? International Conference on Computer Vision (ICCV). Russakovsky, O., Deng, J., Su, H., Krause, J., Satheesh, S., Ma, S., ‚Ä¶ et al.bubu(2015). Ima- geNetlargescalevisualrecognitionchallenge.InternationalJournalofComputerVision, 115(3), 211‚Äì252. Russell, S.bubuJ., & Norvig, P.bubu(2016). Artificial Intelligence: A Modern Approach. Pearson Education Limited. Saharia, C., Chan, W., Saxena, S., Li, L., Whang, J., Denton, E., ‚Ä¶ et al.bubu(2022). Photorealistic text-to-image diffusion models with deep language understanding. ArXiv:2205.11487.bubuSalinas, D., Seeger, M., Klein, A., Perrone, V., Wistuba, M., & Archambeau, C.bubu(2022). Syne Tune: a library for large scale hyperparameter tuning and reproducible research. First Conference on Automated Machine Learning. Sanh, V., Debut, L., Chaumond, J., & Wolf, T.bubu(2019). DistilBERT, a distilled version of BERT: smaller, faster, cheaper and lighter. ArXiv:1910.01108.bubuSanh, V., Webson, A., Raffel, C., Bach, S. H., Sutawika, L., Alyafeai, Z., ‚Ä¶ et al.bubu(2021). Multitask prompted training enables zero-shot task generalization. ArXiv:2110.08207.bubuSanturkar, S., Tsipras, D., Ilyas, A., & Madry, A.bubu(2018). How does batch normaliza- tion help optimization? Advances in Neural Information Processing Systems (pp. 2483‚Äì 2493).bubuSarwar, B. M., Karypis, G., Konstan, J. A., & Riedl, J.bubu(2001). Item-based collaborative filtering recommendation algorithms. Proceedings of 10th International Conference on World Wide Web (pp.bubu285‚Äì295).bubuScao, T. L., Fan, A., Akiki, C., Pavlick, E., Iliƒá, S., Hesslow, D., ‚Ä¶ et al.bubu(2022). BLOOM: a 176B-parameter open-access multilingual language model. ArXiv:2211.05100.bubuREFERENCES
1105

Schein, A.I., Popescul, A., Ungar, L.H., &Pennock, D.M.(2002).Methodsandmetricsfor cold-start recommendations. Proceedings of the 25th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval (pp. 253‚Äì260). Schuhmann, C., Beaumont, R., Vencu, R., Gordon, C., Wightman, R., Cherti, M., ‚Ä¶ et al.bubu(2022). LAION-5B: an open large-scale dataset for training next generation image-text models. ArXiv:2210.08402. Schuster,M., &Paliwal,K.K.(1997).Bidirectionalrecurrentneuralnetworks.IEEETrans- actions on Signal Processing, 45(11), 2673‚Äì2681. Sch√∂lkopf, B., Herbrich, R., & Smola, A.bubuJ. (2001). Helmbold, D. P., & Williamson, B.bubu(Eds.). A generalized representer theorem. Proceedings of the Annual Conference on Computational Learning Theory (pp. 416‚Äì426).bubuSpringer-Verlag. Sch√∂lkopf, B., Burges, C., & Vapnik, V.bubu(1996). Incorporating invariancesin support vector learning machines. International Conference on Artificial Neural Networks (pp. 47‚Äì52).bubuSch√∂lkopf, B., & Smola, A. J.bubu(2002). Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond. MIT Press.bubuSennrich, R., Haddow, B., & Birch, A.bubu(2015). Neural machine translation of rare words with subword units. ArXiv:1508.07909.bubuSergeev, A., & Del Balso, M.bubu(2018). Horovod: fast and easy distributed deep learning in TensorFlow. ArXiv:1802.05799.bubuShannon, C. E.bubu(1948). A mathematical theory of communication. The Bell System Techni- cal Journal, 27(3), 379‚Äì423. Shao, H., Yao, S., Sun, D., Zhang, A., Liu, S., Liu, D., ‚Ä¶ Abdelzaher, T.bubu(2020). Con- trolVAE: controllable variational autoencoder. Proceedings of the 37th International Conference on Machine Learning. Shaw, P., Uszkoreit, J., & Vaswani, A.bubu(2018). Self-attention with relative position repre- sentations. ArXiv:1803.02155.bubuShoeybi, M., Patwary, M., Puri, R., LeGresley, P., Casper, J., & Catanzaro, B.bubu(2019). Megatron-LM: training multi-billion parameter language models using model paral- lelism. ArXiv:1909.08053.bubuSilver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L., Van Den Driessche, G., ‚Ä¶ et al.bubu(2016). Mastering the game of Go with deep neural networks and tree search. Nature, 529(7587), 484.bubuSilverman, B.bubuW.bubu(1986). Density Estimation for Statistical and Data Analysis. Chapman and Hall.bubuSimard, P. Y., LeCun, Y. A., Denker, J. S., & Victorri, B.bubu(1998). Transformation invari- ance in pattern recognition ‚Äì tangent distance and tangent propagation. Neural Networks: Tricks of the Trade (pp. 239‚Äì274).bubuSpringer. Simonyan, K., & Zisserman, A.bubu(2014). Very deep convolutional networks for large-scale image recognition. ArXiv:1409.1556.bubuSindhwani, V., Sainath, T. N., & Kumar, S.bubu(2015). Structured transforms for small- footprint deep learning. ArXiv:1510.01722.bubuSivic, J., & Zisserman, A.bubu(2003). Video Google: a text retrieval approach to object match- ing in videos. Proceedings of the IEEE International Conference on Computer Vision (pp.bubu1470‚Äì1470).bubuREFERENCES
1106

Smith, S., Patwary, M., Norick, B., LeGresley, P., Rajbhandari, S., Casper, J., ‚Ä¶ et al.bubu(2022). Using DeepSpeed and Megatron to train Megatron-Turing NLG 530B, a large- scale generative language model. ArXiv:2201.11990.bubuSmola, A., & Narayanamurthy, S.bubu(2010). An architecture for parallel topic models. Pro- ceedings of the VLDB Endowment, 3(1-2), 703‚Äì710.bubuSnoek, J., Larochelle, H., & Adams, R.bubu(2012). Practical Bayesian optimization of machine learning algorithms. Advances in Neural Information Processing Systems 25 (pp. 2951‚Äì 2959). Sohl-Dickstein, J., Weiss, E., Maheswaranathan, N., & Ganguli, S.bubu(2015). Deep unsu- pervised learning using nonequilibrium thermodynamics. International Conference on Machine Learning (pp. 2256‚Äì2265).bubuSong, Y., & Ermon, S.bubu(2019). Generative modeling by estimating gradients of the data distribution. Advances in Neural Information Processing Systems, 32. Song, Y., Sohl-Dickstein, J., Kingma, D. P., Kumar, A., Ermon, S., & Poole, B.bubu(2021). Score-based generative modeling through stochastic differential equations. International Conference on Learning Representations. Speelpenning, B.bubu(1980). Compiling fast partial derivatives of functions given by algo- rithms (Doctoral dissertation). University of Illinois at Urbana-Champaign.bubuSrivastava, A., Rastogi, A., Rao, A., Shoeb, A. A. M., Abid, A., Fisch, A., ‚Ä¶ et al.bubu(2022). Beyond the imitation game: quantifying and extrapolating the capabilities of language models. ArXiv:2206.04615.bubuSrivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., & Salakhutdinov, R.bubu(2014). Dropout: a simple way to prevent neural networks from overfitting. Journal of Machine Learning Research, 15(1), 1929‚Äì1958. Srivastava, R. K., Greff, K., & Schmidhuber, J. (2015). Highway networks. ArXiv:1505.00387. Strang, G. (1993). Introduction to Linear Algebra. Wellesley‚ÄìCambridge Press.bubuSu, X., & Khoshgoftaar, T.bubuM.bubu(2009). A survey of collaborative filtering techniques. Ad- vances in Artificial Intelligence, 2009. Sukhbaatar, S., Weston, J., & Fergus, R.bubu(2015). End-to-end memory networks. Advances in Neural Information Processing Systems (pp. 2440‚Äì2448).bubuSutskever, I., Martens, J., Dahl, G., & Hinton, G.bubu(2013). On the importance of initializa- tion and momentum in deep learning. International Conference on Machine Learning (pp. 1139‚Äì1147).bubuSutskever, I., Vinyals, O., & Le, Q. V.bubu(2014). Sequence to sequence learning with neural networks. Advances in Neural Information Processing Systems (pp. 3104‚Äì3112).bubuSzegedy, C., Ioffe, S., Vanhoucke, V., & Alemi, A. A.bubu(2017). Inception-v4, Inception- ResNet and the impact of residual connections on learning. 31st AAAI Conference on Artificial Intelligence. Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S., Anguelov, D., ‚Ä¶ Rabinovich, A.bubu(2015). Going deeper with convolutions. Proceedings of the IEEE Conference on Com- puter Vision and Pattern Recognition (pp. 1‚Äì9).bubuSzegedy, C., Vanhoucke, V., Ioffe, S., Shlens, J., & Wojna, Z.bubu(2016). Rethinking the Incep- tion architecture for computer vision. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 2818‚Äì2826). REFERENCES
1107

Tallec, C., & Ollivier, Y.bubu(2017). Unbiasing truncated backpropagation through time. ArXiv:1705.08209.bubuTan, M., & Le, Q.bubu(2019). EfficientNet: rethinking model scaling for convolutional neural networks. International Conference on Machine Learning (pp. 6105‚Äì6114). Taskar, B., Guestrin, C., & Koller, D.bubu(2004). Max-margin Markov networks. Advances in Neural Information Processing Systems, 16, 25. Tay, Y., Dehghani, M., Bahri, D., & Metzler, D.bubu(2020). Efficient transformers: a survey. ArXiv:2009.06732.bubuTaylor, R., Kardas, M., Cucurull, G., Scialom, T., Hartshorn, A., Saravia, E., ‚Ä¶ Stojnic, R. (2022). Galactica: a large language model for science. ArXiv:2211.09085.bubuTeye, M., Azizpour, H., & Smith, K.bubu(2018). Bayesian uncertainty estimation for batch normalized deep networks. ArXiv:1802.06455.bubuThomee, B., Shamma, D. A., Friedland, G., Elizalde, B., Ni, K., Poland, D., ‚Ä¶ Li, L.-J.bubu(2016). Yfcc100m: the new data in multimedia research. Communications of the ACM, 59(2), 64‚Äì73. Tieleman, T., & Hinton, G.bubu(2012). Divide the gradient by a running average of its recent magnitude. COURSERA: Neural Networks for Machine Learning, Lecture 6.5-rmsprop. Tikhonov, A.bubuN., & Arsenin, V. Y.bubu(1977). Solutions of Ill-Posed Problems. W.H.bubuWinston. Tolstikhin, I. O., Houlsby, N., Kolesnikov, A., Beyer, L., Zhai, X., Unterthiner, T., ‚Ä¶ et al.bubu(2021). MLP-mixer: an all-MLP architecture for vision. Advances in Neural Information Processing Systems, 34. Torralba, A., Fergus, R., & Freeman, W. T.bubu(2008). 80 million tiny images: a large data set for nonparametric object and scene recognition. IEEE Transactions on Pattern Analysis and Machine Intelligence, 30(11), 1958‚Äì1970. Touvron, H., Cord, M., Douze, M., Massa, F., Sablayrolles, A., & J√©gou, H.bubu(2021). Train- ing data-efficient image transformers & distillation through attention. International Con- ference on Machine Learning (pp. 10347‚Äì10357).bubuTouvron, H., Lavril, T., Izacard, G., Martinet, X., Lachaux, M.-A., Lacroix, T., ‚Ä¶ et al.bubu(2023a). LLaMA: open and efficient foundation language models. ArXiv:2302.13971.bubuTouvron, H., Martin, L., Stone, K., Albert, P., Almahairi, A., Babaei, Y., ‚Ä¶ et al. (2023b). LLaMA 2: open foundation and fine-tuned chat models. ArXiv:2307.09288.bubuTsoumakas, G., & Katakis, I.bubu(2007). Multi-label classification: an overview. International Journal of Data Warehousing and Mining, 3(3), 1‚Äì13.bubuTuring, A. (1950). Computing machinery and intelligence. Mind, 59(236), 433. Uijlings, J. R., Van De Sande, K. E., Gevers, T., & Smeulders, A. W.bubu(2013). Selective search for object recognition. International Journal of Computer Vision, 104(2), 154‚Äì 171. Vapnik, V. (1995). The Nature of Statistical Learning Theory. New York: Springer.bubuVapnik, V.bubu(1998). Statistical Learning Theory. New York: John Wiley and Sons. Vapnik, V., & Chervonenkis, A.bubu(1964). A note on one class of perceptrons. Automation and Remote Control, 25. Vapnik, V., & Chervonenkis, A.bubu(1968). Uniform convergence of frequencies of occurence of events to their probabilities. Dokl.bubuAkad.bubuNauk SSSR, 181, 915-918. Vapnik, V., &Chervonenkis, A.(1971).Ontheuniformconvergenceofrelativefrequencies of events to their probabilities. Theory Probab. Appl., 16(2), 264-281. REFERENCES
1108

Vapnik, V., & Chervonenkis, A. (1981). The necessary and sufficient conditions for the uniform convergence of averages to their expected values. Teoriya Veroyatnostei i Ee Primeneniya, 26(3), 543-564. Vapnik, V., & Chervonenkis, A. (1991). The necessary and sufficient conditions for consis- tency in the empirical risk minimization method. Pattern Recognition and Image Anal- ysis, 1(3), 283-305. Vapnik, V.bubuN., & Chervonenkis, A. Y.bubu(1974). Ordered risk minimization. Automation and Remote Control, 35, 1226‚Äì1235, 1403‚Äì1412. Vapnik, V.bubu(1992). Principles of risk minimization for learning theory. Advances in Neural Information Processing Systems (pp. 831‚Äì838).bubuVapnik, V., Levin, E., & Le Cun, Y.bubu(1994). Measuring the VC-dimension of a learning machine. Neural Computation, 6(5), 851‚Äì876. Vaswani,A.,Shazeer,N.,Parmar,N.,Uszkoreit,J.,Jones,L.,Gomez,A.N.,‚Ä¶Polosukhin, I. (2017). Attention is all you need. Advances in Neural Information Processing Systems (pp. 5998‚Äì6008).bubuWahba, G.bubu(1990). Spline Models for Observational Data. SIAM.bubuWaibel, A., Hanazawa, T., Hinton, G., Shikano, K., & Lang, K. J.bubu(1989). Phoneme recog- nition using time-delay neural networks. IEEE Transactions on Acoustics, Speech, and Signal Processing, 37(3), 328‚Äì339. Wang, H., Zhang, A., Zheng, S., Shi, X., Li, M., & Wang, Z.bubu(2022). Removing batch nor- malization boosts adversarial training. International Conference on Machine Learning (pp.bubu23433‚Äì23445). Wang, L., Li, M., Liberty, E., & Smola, A. J.bubu(2018). Optimal message scheduling for aggregation. Networks, 2(3), 2‚Äì3. Wang, Q., Li, B., Xiao, T., Zhu, J., Li, C., Wong, D. F., & Chao, L. S.bubu(2019). Learning deep transformer models for machine translation. Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics (pp. 1810‚Äì1822).bubuWang, X., Wei, J., Schuurmans, D., Le, Q., Chi, E., & Zhou, D.bubu(2023). Self-consistency improves chain of thought reasoning in language models. International Conference on Learning Representations. Wang, Y., Davidson, A., Pan, Y., Wu, Y., Riffel, A., & Owens, J. D.bubu(2016). Gunrock: a high-performance graph processing library on the GPU. ACM SIGPLAN Notices (p.bubu11). Warstadt, A., Singh, A., & Bowman, S. R.bubu(2019). Neural network acceptability judgments. Transactions of the Association for Computational Linguistics, 7, 625‚Äì641. Wasserman, L.(2013).AllofStatistics: AConciseCoursein StatisticalInference.Springer. Watkins, C.bubuJ., & Dayan, P.bubu(1992). Q-learning. Machine Learning, 8(3‚Äì4), 279‚Äì292. Watson, G.bubuS.bubu(1964). Smooth regression analysis. SankhyƒÅ: The Indian Journal of Statis- tics, Series A, pp. 359‚Äì372. Wei, J., Bosma, M., Zhao, V. Y., Guu, K., Yu, A. W., Lester, B., ‚Ä¶ Le, Q. V.bubu(2021). Finetuned language models are zero-shot learners. ArXiv:2109.01652.bubuWei, J., Tay, Y., Bommasani, R., Raffel, C., Zoph, B., Borgeaud, S., ‚Ä¶ et al. (2022). Emer- gent abilities of large language models. ArXiv:2206.07682.bubuWei, J., Wang, X., Schuurmans, D., Bosma, M., Chi, E., Le, Q., & Zhou, D.bubu(2022). Chain of thought prompting elicits reasoning in large language models. ArXiv:2201.11903.bubuREFERENCES
1109

Welling, M., & Teh, Y. W.bubu(2011). Bayesian learning via stochastic gradient Langevin dy- namics. Proceedings of the 28th International Conference on Machine Learning (ICML- 11) (pp.bubu681‚Äì688). Wengert, R.E.(1964).Asimpleautomaticderivativeevaluationprogram.Communications of the ACM, 7(8), 463‚Äì464. Werbos, P.bubuJ.bubu(1990). Backpropagation through time: what it does and how to do it. Pro- ceedings of the IEEE, 78(10), 1550‚Äì1560.bubuWigner, E. P.bubu(1958). On the distribution of the roots of certain symmetric matrices. Ann.bubuMath. (pp.bubu325‚Äì327). Wilson, A.G., &Izmailov, P.(2020).Bayesiandeeplearningandaprobabilisticperspective of generalization. Advances in Neural Information Processing Systems, 33, 4697‚Äì4708. Wistuba, M., Rawat, A., & Pedapati, T. (2019). A survey on neural architecture search. ArXiv:1905.01392 [cs.LG].bubuWistuba, M., Schilling, N., & Schmidt-Thieme, L.bubu(2018). Scalable Gaussian process- based transfer surrogates for hyperparameter optimization. Machine Learning, 108, 43‚Äì 78.bubuWolpert, D. H., & Macready, W. G.bubu(1995). No free lunch theorems for search. Technical Report SFI-TR-95-02-010, Santa Fe Institute. Wood, F., Gasthaus, J., Archambeau, C., James, L., & Teh, Y. W.bubu(2011). The sequence memoizer. Communications of the ACM, 54(2), 91‚Äì98. Wu, B., Wan, A., Yue, X., Jin, P., Zhao, S., Golmant, N., ‚Ä¶ Keutzer, K.bubu(2018). Shift: a zero flop, zero parameter alternative to spatial convolutions. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 9127‚Äì9135).bubuWu, Y., Schuster, M., Chen, Z., Le, Q. V., Norouzi, M., Macherey, W., ‚Ä¶ et al.bubu(2016). Google‚Äôs neural machine translation system: bridging the gap between human and ma- chine translation. ArXiv:1609.08144.bubuXiao, H., Rasul, K., & Vollgraf, R.bubu(2017). Fashion-MNIST: a novel image dataset for benchmarking machine learning algorithms. ArXiv:1708.07747.bubuXiao, L., Bahri, Y., Sohl-Dickstein, J., Schoenholz, S., & Pennington, J. (2018). Dynamical isometry and a mean field theory of CNNs: how to train 10,000-layer vanilla convolu- tionalneuralnetworks.InternationalConferenceonMachineLearning(pp.5393‚Äì5402). Xie, S., Girshick, R., Doll√°r, P., Tu, Z., & He, K. (2017). Aggregated residual transforma- tions for deep neural networks. Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (pp. 1492‚Äì1500). Xiong, R., Yang, Y., He, D., Zheng, K., Zheng, S., Xing, C., ‚Ä¶Liu, T.(2020).Onlayernor- malization in the transformer architecture. International Conference on Machine Learn- ing (pp. 10524‚Äì10533). Xiong, W., Wu, L., Alleva, F., Droppo, J., Huang, X., & Stolcke, A.bubu(2018). The Microsoft 2017 conversational speech recognition system. 2018 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP) (pp. 5934‚Äì5938).bubuYamaguchi, K., Sakamoto, K., Akabane, T., & Fujimoto, Y.bubu(1990). A neural network for speaker-independent isolated word recognition. First International Conference on Spoken Language Processing. Yang, Z., Hu, Z., Deng, Y., Dyer, C., & Smola, A. (2016). Neural machine translation with recurrent attention modeling. ArXiv:1607.05108. REFERENCES
1110

Yang, Z., Moczulski, M., Denil, M., De Freitas, N., Smola, A., Song, L., & Wang, Z. (2015).Deepfriedconvnets.ProceedingsoftheIEEEInternationalConferenceonCom- puter Vision (pp. 1476‚Äì1483).bubuYe, M., Yin, P., Lee, W.-C., & Lee, D.-L.bubu(2011). Exploiting geographical influence for col- laborativepoint-of-interestrecommendation.Proceedingsofthe34thInternationalACM SIGIR Conference on Research and Development in Information Retrieval (pp. 325‚Äì 334).bubuYou, Y., Gitman, I., & Ginsburg, B.bubu(2017). Large batch training of convolutional networks. ArXiv:1708.03888.bubuYu, J., Xu, Y., Koh, J. Y., Luong, T., Baid, G., Wang, Z., ‚Ä¶ Wu, Y.bubu(2022). Scaling au- toregressive models for content-rich text-to-image generation. ArXiv:2206.10789.bubuZaheer, M., Reddi, S., Sachan, D., Kale, S., & Kumar, S.bubu(2018). Adaptive methods for nonconvexoptimization.AdvancesinNeuralInformationProcessingSystems(pp.9793‚Äì 9803). Zeiler, M.bubuD.bubu(2012). ADADELTA: an adaptive learning rate method. ArXiv:1212.5701.bubuZeiler, M. D., & Fergus, R.bubu(2013). Stochastic pooling for regularization of deep convolu- tional neural networks. ArXiv:1301.3557.bubuZhang, A., Tay, Y., Zhang, S., Chan, A., Luu, A. T., Hui, S. C., & Fu, J.bubu(2021). Beyond fully-connected layers with quaternions: parameterization of hypercomplex multiplica- tions with 1/n parameters. International Conference on Learning Representations.bubuZhang, C., Bengio, S., Hardt, M., Recht, B., & Vinyals, O. (2021). Understanding deep learning (still) requires rethinking generalization. Communications of the ACM, 64(3), 107‚Äì115. Zhang, S., Yao, L., Sun, A., & Tay, Y.bubu(2019). Deep learning based recommender system: a survey and new perspectives. ACM Computing Surveys, 52(1), 5.bubuZhang, S., Roller, S., Goyal, N., Artetxe, M., Chen, M., Chen, S., ‚Ä¶ et al.bubu(2022). OPT: open pre-trained transformer language models. ArXiv:2205.01068.bubuZhang, W., Tanida, J., Itoh, K., & Ichioka, Y.bubu(1988). Shift-invariant pattern recognition neural network and its optical architecture. Proceedings of Annual Conference of the Japan Society of Applied Physics.bubuZhang, Y., Sun, P., Jiang, Y., Yu, D., Yuan, Z., Luo, P., ‚Ä¶ Wang, X.bubu(2021). ByteTrack: multi-object tracking by associating every detection box. ArXiv:2110.06864.bubuZhang, Z., Zhang, A., Li, M., & Smola, A.bubu(2023). Automatic chain of thought prompting in large language models. International Conference on Learning Representations. Zhang, Z., Zhang, A., Li, M., Zhao, H., Karypis, G., & Smola, A. (2023). Multimodal chain-of-thought reasoning in language models. ArXiv:2302.00923.bubuZhao, Z.-Q., Zheng, P., Xu, S.-t., & Wu, X.bubu(2019). Object detection with deep learning: a review. IEEE Transactions on Neural Networks and Learning Systems, 30(11), 3212‚Äì 3232. Zhou, D., Sch√§rli, N., Hou, L., Wei, J., Scales, N., Wang, X., ‚Ä¶ Chi, E.bubu(2023). Least- to-most prompting enables complex reasoning in large language models. International Conference on Learning Representations. Zhu, J.-Y., Park, T., Isola, P., & Efros, A. A.bubu(2017). Unpaired image-to-image transla- tion using cycle-consistent adversarial networks. Proceedings of the IEEE International Conference on Computer Vision (pp. 2223‚Äì2232).bubuREFERENCES
1111

Zhu, Y., Kiros, R., Zemel, R., Salakhutdinov, R., Urtasun, R., Torralba, A., & Fidler, S.bubu(2015). Aligning books and movies: towards story-like visual explanations by watch- ing movies and reading books. Proceedings of the IEEE International Conference on Computer Vision (pp.bubu19‚Äì27).bubuZoph, B., & Le, Q. V.bubu(2016). Neural architecture search with reinforcement learning. ArXiv:1611.01578.bubu